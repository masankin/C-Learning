容器
====
容器有三类：顺序容器，关联容器，容器适配器
----
准确来说，容器适配器不属于容器。。
##分类
|顺序容器|关联容器|无序容器<kbd>c++11</kdb>
|:------:|:------:|:--------:
|vector  |set     |*unordered_map*
|deque   |mutiset |*unordered_set*
|list    |map     |
|*forward_list* <kbd>c++11</kdb>|mutimap ||
|array <kbd>c++11</kdb>|||
>无序容器是C++11新增的，此处无序是unordered而不是unsorted。也可以看作是关联容器

map对应Java中的TreeMap，*unordered_map*对应Java中的HashMap。

##顺序容器
容器无序，元素插入位置同元素的值无关。
##关联容器
* 元素是排序的
* 插入任何元素，都按照相应的排序规则来确定其位置
* 在查找时具有良好的性能
* 通常以AVL树（平衡二叉树）实现，插入和检索时间皆为`O(logN)`

map/mutimap的每个元素实际上是`pair<const key,value>`类型，键不能改变。
>>在C++11之前，mutiset和mutimap中插入相同（值或键）元素，相同元素间的顺序是不确定的，
C++11规定，新插入的元素在相同元素的后面。也就保证了insert()、emplace()、erase()操作
的稳定性。

##无序容器 
无序容器是利用了hash表原理。hash数组的每个元素是一个链表，即所有经过hash函数运算得到相同值的元素都在同一链表上。同样的两个无序容器插入同样的元素，其遍历结果也是不确定的。  

无序容器比关联容器有更高的访问效率。但是耗费内存。

##顺序容器和关联容器共有的成员函数
|成员函数|描述|
|:------:|-----|
|begin|返回指向容器中第一个元素的迭代器|
|end|返回指向容器中最后一个元素后面位置的迭代器|
|rbegin|返回指向容器中最后一个元素的迭代器|
|rend|返回指向容器中第一个元素前面位置的迭代器|
|erase|从容器中删除一个或几个元素，返回被删除元素后面的迭代器|
|clear|清除容器中所有元素|
>>此外

##顺序容器共有的成员函数
不全，表中仅为常用成员函数

|成员函数|描述|
|:------:|-----|
|front|返回容器中第一个元素的引用|
|back|返回容器中最后一个元素的引用|
|_push_back_|在容器末尾添加新元素|
|_pop_back_|删除容器末尾的元素|
