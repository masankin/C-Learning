// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Activity.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Activity.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace fgame {

void protobuf_ShutdownFile_Activity_2eproto() {
  delete CSGetOpenActivityReq::default_instance_;
  delete CSOpenActivityInfo::default_instance_;
  delete CSGetOpenActivityResp::default_instance_;
  delete CSGetActivityDataReq::default_instance_;
  delete CSActivityInfo::default_instance_;
  delete CSGetActivityDataResp::default_instance_;
  delete CSReceiveActivityRewardReq::default_instance_;
  delete CSReceiveActivityRewardResp::default_instance_;
  delete CSGetPowerEnergyActivityDataReq::default_instance_;
  delete CSGetPowerEnergyActivityResp::default_instance_;
  delete CSReceivePowerEnergyReq::default_instance_;
  delete CSReceivePowerEnergyResp::default_instance_;
  delete CSSubActivity::default_instance_;
  delete CSActivityData::default_instance_;
  delete CSActivityListReq::default_instance_;
  delete CSActivityListResp::default_instance_;
  delete CSActivitySubmitReq::default_instance_;
  delete CSActivitySubmitResp::default_instance_;
  delete CSActivityUpdateResp::default_instance_;
  delete CSNewYearGetInfoReq::default_instance_;
  delete CSNewYearGetInfoResp::default_instance_;
  delete CSNewYearRewardReq::default_instance_;
  delete CSNewYearRewardResp::default_instance_;
  delete CSNewYearCmpReq::default_instance_;
  delete CSNewYearCmpResp::default_instance_;
  delete CSActivityCrazyDtlsReq::default_instance_;
  delete CSActivityCrazyDtlsResp::default_instance_;
  delete CSActivityCrazyUsageReq::default_instance_;
  delete CSActivityCrazyUsageResp::default_instance_;
  delete CSActivityCrazyUsableResp::default_instance_;
  delete CSOpenChestReq::default_instance_;
  delete CSRedPacketsGetInfoReq::default_instance_;
  delete CSRedPacketsGetInfoResp::default_instance_;
  delete CSRedPacketsGrebReq::default_instance_;
  delete CSRedPacketsGrebResp::default_instance_;
  delete CSRedPacketsOpenedReq::default_instance_;
  delete CSRedPacketsOpenedResp::default_instance_;
  delete CSChristmasDecorateReq::default_instance_;
  delete CSChristmasDecorateResp::default_instance_;
  delete CSChristmasTakeBonusReq::default_instance_;
  delete CSChristmasTakeBonusResp::default_instance_;
  delete CSChristmasGetDataReq::default_instance_;
  delete ChristmasTakeRecord::default_instance_;
  delete CSChristmasGetDataResp::default_instance_;
  delete CSChristmasGetRankReq::default_instance_;
  delete ChristmasRankItem::default_instance_;
  delete CSChristmasGetRankResp::default_instance_;
  delete CSValentineDataReq::default_instance_;
  delete CSValentineDataResp::default_instance_;
  delete CSValentineExchangeReq::default_instance_;
  delete CSValentineExchangeResp::default_instance_;
  delete CSDailyTaskStatusReq::default_instance_;
  delete CSDailyTaskStatusResp::default_instance_;
  delete CSRequestDailyTaskReq::default_instance_;
  delete DailyTaskInfo::default_instance_;
  delete CSRequestDailyTaskResp::default_instance_;
  delete CSUpdateTaskStatusReq::default_instance_;
  delete CSUpdateTaskStatusResp::default_instance_;
  delete CSChangeDailyTaskReq::default_instance_;
  delete CSChangeDailyTaskResp::default_instance_;
  delete CSOpenDailyTaskAwardReq::default_instance_;
  delete CSOpenDailyTaskAwardResp::default_instance_;
  delete CSUpdateDailyTaskProgressReq::default_instance_;
  delete CSUpdateDailyTaskProgressResp::default_instance_;
  delete CSRankWeekRewardInfoReq::default_instance_;
  delete CSRankWeekRewardInfoResp::default_instance_;
  delete CSRankWeekRewardRewardReq::default_instance_;
  delete CSRankWeekRewardRewardResp::default_instance_;
  delete CSNewDailyTaskResp::default_instance_;
  delete CSOpActAddResp::default_instance_;
  delete CSOpActStateChangedResp::default_instance_;
  delete CSActSelfDataChangedResp::default_instance_;
  delete CSActGlobalDataChangedResp::default_instance_;
  delete CSOpActConfigListReq::default_instance_;
  delete CSOpActConfigListResp::default_instance_;
  delete CSOpActSelfDataListReq::default_instance_;
  delete CSOpActSelfDataListResp::default_instance_;
  delete CSOpActGlobalDataListReq::default_instance_;
  delete CSOpActGlobalDataListResp::default_instance_;
  delete CSOpActDemoTakeReq::default_instance_;
  delete CSOpActDemoTakeResp::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_Activity_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_Activity_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::fgame::protobuf_AddDesc_Player_2eproto();
  CSGetOpenActivityReq::default_instance_ = new CSGetOpenActivityReq();
  CSOpenActivityInfo::default_instance_ = new CSOpenActivityInfo();
  CSGetOpenActivityResp::default_instance_ = new CSGetOpenActivityResp();
  CSGetActivityDataReq::default_instance_ = new CSGetActivityDataReq();
  CSActivityInfo::default_instance_ = new CSActivityInfo();
  CSGetActivityDataResp::default_instance_ = new CSGetActivityDataResp();
  CSReceiveActivityRewardReq::default_instance_ = new CSReceiveActivityRewardReq();
  CSReceiveActivityRewardResp::default_instance_ = new CSReceiveActivityRewardResp();
  CSGetPowerEnergyActivityDataReq::default_instance_ = new CSGetPowerEnergyActivityDataReq();
  CSGetPowerEnergyActivityResp::default_instance_ = new CSGetPowerEnergyActivityResp();
  CSReceivePowerEnergyReq::default_instance_ = new CSReceivePowerEnergyReq();
  CSReceivePowerEnergyResp::default_instance_ = new CSReceivePowerEnergyResp();
  CSSubActivity::default_instance_ = new CSSubActivity();
  CSActivityData::default_instance_ = new CSActivityData();
  CSActivityListReq::default_instance_ = new CSActivityListReq();
  CSActivityListResp::default_instance_ = new CSActivityListResp();
  CSActivitySubmitReq::default_instance_ = new CSActivitySubmitReq();
  CSActivitySubmitResp::default_instance_ = new CSActivitySubmitResp();
  CSActivityUpdateResp::default_instance_ = new CSActivityUpdateResp();
  CSNewYearGetInfoReq::default_instance_ = new CSNewYearGetInfoReq();
  CSNewYearGetInfoResp::default_instance_ = new CSNewYearGetInfoResp();
  CSNewYearRewardReq::default_instance_ = new CSNewYearRewardReq();
  CSNewYearRewardResp::default_instance_ = new CSNewYearRewardResp();
  CSNewYearCmpReq::default_instance_ = new CSNewYearCmpReq();
  CSNewYearCmpResp::default_instance_ = new CSNewYearCmpResp();
  CSActivityCrazyDtlsReq::default_instance_ = new CSActivityCrazyDtlsReq();
  CSActivityCrazyDtlsResp::default_instance_ = new CSActivityCrazyDtlsResp();
  CSActivityCrazyUsageReq::default_instance_ = new CSActivityCrazyUsageReq();
  CSActivityCrazyUsageResp::default_instance_ = new CSActivityCrazyUsageResp();
  CSActivityCrazyUsableResp::default_instance_ = new CSActivityCrazyUsableResp();
  CSOpenChestReq::default_instance_ = new CSOpenChestReq();
  CSRedPacketsGetInfoReq::default_instance_ = new CSRedPacketsGetInfoReq();
  CSRedPacketsGetInfoResp::default_instance_ = new CSRedPacketsGetInfoResp();
  CSRedPacketsGrebReq::default_instance_ = new CSRedPacketsGrebReq();
  CSRedPacketsGrebResp::default_instance_ = new CSRedPacketsGrebResp();
  CSRedPacketsOpenedReq::default_instance_ = new CSRedPacketsOpenedReq();
  CSRedPacketsOpenedResp::default_instance_ = new CSRedPacketsOpenedResp();
  CSChristmasDecorateReq::default_instance_ = new CSChristmasDecorateReq();
  CSChristmasDecorateResp::default_instance_ = new CSChristmasDecorateResp();
  CSChristmasTakeBonusReq::default_instance_ = new CSChristmasTakeBonusReq();
  CSChristmasTakeBonusResp::default_instance_ = new CSChristmasTakeBonusResp();
  CSChristmasGetDataReq::default_instance_ = new CSChristmasGetDataReq();
  ChristmasTakeRecord::default_instance_ = new ChristmasTakeRecord();
  CSChristmasGetDataResp::default_instance_ = new CSChristmasGetDataResp();
  CSChristmasGetRankReq::default_instance_ = new CSChristmasGetRankReq();
  ChristmasRankItem::default_instance_ = new ChristmasRankItem();
  CSChristmasGetRankResp::default_instance_ = new CSChristmasGetRankResp();
  CSValentineDataReq::default_instance_ = new CSValentineDataReq();
  CSValentineDataResp::default_instance_ = new CSValentineDataResp();
  CSValentineExchangeReq::default_instance_ = new CSValentineExchangeReq();
  CSValentineExchangeResp::default_instance_ = new CSValentineExchangeResp();
  CSDailyTaskStatusReq::default_instance_ = new CSDailyTaskStatusReq();
  CSDailyTaskStatusResp::default_instance_ = new CSDailyTaskStatusResp();
  CSRequestDailyTaskReq::default_instance_ = new CSRequestDailyTaskReq();
  DailyTaskInfo::default_instance_ = new DailyTaskInfo();
  CSRequestDailyTaskResp::default_instance_ = new CSRequestDailyTaskResp();
  CSUpdateTaskStatusReq::default_instance_ = new CSUpdateTaskStatusReq();
  CSUpdateTaskStatusResp::default_instance_ = new CSUpdateTaskStatusResp();
  CSChangeDailyTaskReq::default_instance_ = new CSChangeDailyTaskReq();
  CSChangeDailyTaskResp::default_instance_ = new CSChangeDailyTaskResp();
  CSOpenDailyTaskAwardReq::default_instance_ = new CSOpenDailyTaskAwardReq();
  CSOpenDailyTaskAwardResp::default_instance_ = new CSOpenDailyTaskAwardResp();
  CSUpdateDailyTaskProgressReq::default_instance_ = new CSUpdateDailyTaskProgressReq();
  CSUpdateDailyTaskProgressResp::default_instance_ = new CSUpdateDailyTaskProgressResp();
  CSRankWeekRewardInfoReq::default_instance_ = new CSRankWeekRewardInfoReq();
  CSRankWeekRewardInfoResp::default_instance_ = new CSRankWeekRewardInfoResp();
  CSRankWeekRewardRewardReq::default_instance_ = new CSRankWeekRewardRewardReq();
  CSRankWeekRewardRewardResp::default_instance_ = new CSRankWeekRewardRewardResp();
  CSNewDailyTaskResp::default_instance_ = new CSNewDailyTaskResp();
  CSOpActAddResp::default_instance_ = new CSOpActAddResp();
  CSOpActStateChangedResp::default_instance_ = new CSOpActStateChangedResp();
  CSActSelfDataChangedResp::default_instance_ = new CSActSelfDataChangedResp();
  CSActGlobalDataChangedResp::default_instance_ = new CSActGlobalDataChangedResp();
  CSOpActConfigListReq::default_instance_ = new CSOpActConfigListReq();
  CSOpActConfigListResp::default_instance_ = new CSOpActConfigListResp();
  CSOpActSelfDataListReq::default_instance_ = new CSOpActSelfDataListReq();
  CSOpActSelfDataListResp::default_instance_ = new CSOpActSelfDataListResp();
  CSOpActGlobalDataListReq::default_instance_ = new CSOpActGlobalDataListReq();
  CSOpActGlobalDataListResp::default_instance_ = new CSOpActGlobalDataListResp();
  CSOpActDemoTakeReq::default_instance_ = new CSOpActDemoTakeReq();
  CSOpActDemoTakeResp::default_instance_ = new CSOpActDemoTakeResp();
  CSGetOpenActivityReq::default_instance_->InitAsDefaultInstance();
  CSOpenActivityInfo::default_instance_->InitAsDefaultInstance();
  CSGetOpenActivityResp::default_instance_->InitAsDefaultInstance();
  CSGetActivityDataReq::default_instance_->InitAsDefaultInstance();
  CSActivityInfo::default_instance_->InitAsDefaultInstance();
  CSGetActivityDataResp::default_instance_->InitAsDefaultInstance();
  CSReceiveActivityRewardReq::default_instance_->InitAsDefaultInstance();
  CSReceiveActivityRewardResp::default_instance_->InitAsDefaultInstance();
  CSGetPowerEnergyActivityDataReq::default_instance_->InitAsDefaultInstance();
  CSGetPowerEnergyActivityResp::default_instance_->InitAsDefaultInstance();
  CSReceivePowerEnergyReq::default_instance_->InitAsDefaultInstance();
  CSReceivePowerEnergyResp::default_instance_->InitAsDefaultInstance();
  CSSubActivity::default_instance_->InitAsDefaultInstance();
  CSActivityData::default_instance_->InitAsDefaultInstance();
  CSActivityListReq::default_instance_->InitAsDefaultInstance();
  CSActivityListResp::default_instance_->InitAsDefaultInstance();
  CSActivitySubmitReq::default_instance_->InitAsDefaultInstance();
  CSActivitySubmitResp::default_instance_->InitAsDefaultInstance();
  CSActivityUpdateResp::default_instance_->InitAsDefaultInstance();
  CSNewYearGetInfoReq::default_instance_->InitAsDefaultInstance();
  CSNewYearGetInfoResp::default_instance_->InitAsDefaultInstance();
  CSNewYearRewardReq::default_instance_->InitAsDefaultInstance();
  CSNewYearRewardResp::default_instance_->InitAsDefaultInstance();
  CSNewYearCmpReq::default_instance_->InitAsDefaultInstance();
  CSNewYearCmpResp::default_instance_->InitAsDefaultInstance();
  CSActivityCrazyDtlsReq::default_instance_->InitAsDefaultInstance();
  CSActivityCrazyDtlsResp::default_instance_->InitAsDefaultInstance();
  CSActivityCrazyUsageReq::default_instance_->InitAsDefaultInstance();
  CSActivityCrazyUsageResp::default_instance_->InitAsDefaultInstance();
  CSActivityCrazyUsableResp::default_instance_->InitAsDefaultInstance();
  CSOpenChestReq::default_instance_->InitAsDefaultInstance();
  CSRedPacketsGetInfoReq::default_instance_->InitAsDefaultInstance();
  CSRedPacketsGetInfoResp::default_instance_->InitAsDefaultInstance();
  CSRedPacketsGrebReq::default_instance_->InitAsDefaultInstance();
  CSRedPacketsGrebResp::default_instance_->InitAsDefaultInstance();
  CSRedPacketsOpenedReq::default_instance_->InitAsDefaultInstance();
  CSRedPacketsOpenedResp::default_instance_->InitAsDefaultInstance();
  CSChristmasDecorateReq::default_instance_->InitAsDefaultInstance();
  CSChristmasDecorateResp::default_instance_->InitAsDefaultInstance();
  CSChristmasTakeBonusReq::default_instance_->InitAsDefaultInstance();
  CSChristmasTakeBonusResp::default_instance_->InitAsDefaultInstance();
  CSChristmasGetDataReq::default_instance_->InitAsDefaultInstance();
  ChristmasTakeRecord::default_instance_->InitAsDefaultInstance();
  CSChristmasGetDataResp::default_instance_->InitAsDefaultInstance();
  CSChristmasGetRankReq::default_instance_->InitAsDefaultInstance();
  ChristmasRankItem::default_instance_->InitAsDefaultInstance();
  CSChristmasGetRankResp::default_instance_->InitAsDefaultInstance();
  CSValentineDataReq::default_instance_->InitAsDefaultInstance();
  CSValentineDataResp::default_instance_->InitAsDefaultInstance();
  CSValentineExchangeReq::default_instance_->InitAsDefaultInstance();
  CSValentineExchangeResp::default_instance_->InitAsDefaultInstance();
  CSDailyTaskStatusReq::default_instance_->InitAsDefaultInstance();
  CSDailyTaskStatusResp::default_instance_->InitAsDefaultInstance();
  CSRequestDailyTaskReq::default_instance_->InitAsDefaultInstance();
  DailyTaskInfo::default_instance_->InitAsDefaultInstance();
  CSRequestDailyTaskResp::default_instance_->InitAsDefaultInstance();
  CSUpdateTaskStatusReq::default_instance_->InitAsDefaultInstance();
  CSUpdateTaskStatusResp::default_instance_->InitAsDefaultInstance();
  CSChangeDailyTaskReq::default_instance_->InitAsDefaultInstance();
  CSChangeDailyTaskResp::default_instance_->InitAsDefaultInstance();
  CSOpenDailyTaskAwardReq::default_instance_->InitAsDefaultInstance();
  CSOpenDailyTaskAwardResp::default_instance_->InitAsDefaultInstance();
  CSUpdateDailyTaskProgressReq::default_instance_->InitAsDefaultInstance();
  CSUpdateDailyTaskProgressResp::default_instance_->InitAsDefaultInstance();
  CSRankWeekRewardInfoReq::default_instance_->InitAsDefaultInstance();
  CSRankWeekRewardInfoResp::default_instance_->InitAsDefaultInstance();
  CSRankWeekRewardRewardReq::default_instance_->InitAsDefaultInstance();
  CSRankWeekRewardRewardResp::default_instance_->InitAsDefaultInstance();
  CSNewDailyTaskResp::default_instance_->InitAsDefaultInstance();
  CSOpActAddResp::default_instance_->InitAsDefaultInstance();
  CSOpActStateChangedResp::default_instance_->InitAsDefaultInstance();
  CSActSelfDataChangedResp::default_instance_->InitAsDefaultInstance();
  CSActGlobalDataChangedResp::default_instance_->InitAsDefaultInstance();
  CSOpActConfigListReq::default_instance_->InitAsDefaultInstance();
  CSOpActConfigListResp::default_instance_->InitAsDefaultInstance();
  CSOpActSelfDataListReq::default_instance_->InitAsDefaultInstance();
  CSOpActSelfDataListResp::default_instance_->InitAsDefaultInstance();
  CSOpActGlobalDataListReq::default_instance_->InitAsDefaultInstance();
  CSOpActGlobalDataListResp::default_instance_->InitAsDefaultInstance();
  CSOpActDemoTakeReq::default_instance_->InitAsDefaultInstance();
  CSOpActDemoTakeResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Activity_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_Activity_2eproto_once_);
void protobuf_AddDesc_Activity_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_Activity_2eproto_once_,
                 &protobuf_AddDesc_Activity_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Activity_2eproto {
  StaticDescriptorInitializer_Activity_2eproto() {
    protobuf_AddDesc_Activity_2eproto();
  }
} static_descriptor_initializer_Activity_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSGetOpenActivityReq::CSGetOpenActivityReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetOpenActivityReq)
}

void CSGetOpenActivityReq::InitAsDefaultInstance() {
}

CSGetOpenActivityReq::CSGetOpenActivityReq(const CSGetOpenActivityReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetOpenActivityReq)
}

void CSGetOpenActivityReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetOpenActivityReq::~CSGetOpenActivityReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGetOpenActivityReq)
  SharedDtor();
}

void CSGetOpenActivityReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetOpenActivityReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetOpenActivityReq& CSGetOpenActivityReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSGetOpenActivityReq* CSGetOpenActivityReq::default_instance_ = NULL;

CSGetOpenActivityReq* CSGetOpenActivityReq::New() const {
  return new CSGetOpenActivityReq;
}

void CSGetOpenActivityReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetOpenActivityReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetOpenActivityReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetOpenActivityReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetOpenActivityReq)
  return false;
#undef DO_
}

void CSGetOpenActivityReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetOpenActivityReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetOpenActivityReq)
}

int CSGetOpenActivityReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetOpenActivityReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetOpenActivityReq*>(&from));
}

void CSGetOpenActivityReq::MergeFrom(const CSGetOpenActivityReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetOpenActivityReq::CopyFrom(const CSGetOpenActivityReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetOpenActivityReq::IsInitialized() const {

  return true;
}

void CSGetOpenActivityReq::Swap(CSGetOpenActivityReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetOpenActivityReq::GetTypeName() const {
  return "fgame.CSGetOpenActivityReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSOpenActivityInfo::kTypeFieldNumber;
#endif  // !_MSC_VER

CSOpenActivityInfo::CSOpenActivityInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSOpenActivityInfo)
}

void CSOpenActivityInfo::InitAsDefaultInstance() {
}

CSOpenActivityInfo::CSOpenActivityInfo(const CSOpenActivityInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSOpenActivityInfo)
}

void CSOpenActivityInfo::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSOpenActivityInfo::~CSOpenActivityInfo() {
  // @@protoc_insertion_point(destructor:fgame.CSOpenActivityInfo)
  SharedDtor();
}

void CSOpenActivityInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSOpenActivityInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSOpenActivityInfo& CSOpenActivityInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSOpenActivityInfo* CSOpenActivityInfo::default_instance_ = NULL;

CSOpenActivityInfo* CSOpenActivityInfo::New() const {
  return new CSOpenActivityInfo;
}

void CSOpenActivityInfo::Clear() {
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSOpenActivityInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSOpenActivityInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSOpenActivityInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSOpenActivityInfo)
  return false;
#undef DO_
}

void CSOpenActivityInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSOpenActivityInfo)
  // required uint32 Type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSOpenActivityInfo)
}

int CSOpenActivityInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSOpenActivityInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSOpenActivityInfo*>(&from));
}

void CSOpenActivityInfo::MergeFrom(const CSOpenActivityInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSOpenActivityInfo::CopyFrom(const CSOpenActivityInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOpenActivityInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSOpenActivityInfo::Swap(CSOpenActivityInfo* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSOpenActivityInfo::GetTypeName() const {
  return "fgame.CSOpenActivityInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGetOpenActivityResp::kOpenActivityInfoFieldNumber;
#endif  // !_MSC_VER

CSGetOpenActivityResp::CSGetOpenActivityResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetOpenActivityResp)
}

void CSGetOpenActivityResp::InitAsDefaultInstance() {
}

CSGetOpenActivityResp::CSGetOpenActivityResp(const CSGetOpenActivityResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetOpenActivityResp)
}

void CSGetOpenActivityResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetOpenActivityResp::~CSGetOpenActivityResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGetOpenActivityResp)
  SharedDtor();
}

void CSGetOpenActivityResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetOpenActivityResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetOpenActivityResp& CSGetOpenActivityResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSGetOpenActivityResp* CSGetOpenActivityResp::default_instance_ = NULL;

CSGetOpenActivityResp* CSGetOpenActivityResp::New() const {
  return new CSGetOpenActivityResp;
}

void CSGetOpenActivityResp::Clear() {
  openactivityinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetOpenActivityResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetOpenActivityResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.CSOpenActivityInfo OpenActivityInfo = 1;
      case 1: {
        if (tag == 10) {
         parse_OpenActivityInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_openactivityinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_OpenActivityInfo;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetOpenActivityResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetOpenActivityResp)
  return false;
#undef DO_
}

void CSGetOpenActivityResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetOpenActivityResp)
  // repeated .fgame.CSOpenActivityInfo OpenActivityInfo = 1;
  for (int i = 0; i < this->openactivityinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->openactivityinfo(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetOpenActivityResp)
}

int CSGetOpenActivityResp::ByteSize() const {
  int total_size = 0;

  // repeated .fgame.CSOpenActivityInfo OpenActivityInfo = 1;
  total_size += 1 * this->openactivityinfo_size();
  for (int i = 0; i < this->openactivityinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->openactivityinfo(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetOpenActivityResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetOpenActivityResp*>(&from));
}

void CSGetOpenActivityResp::MergeFrom(const CSGetOpenActivityResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  openactivityinfo_.MergeFrom(from.openactivityinfo_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetOpenActivityResp::CopyFrom(const CSGetOpenActivityResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetOpenActivityResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->openactivityinfo())) return false;
  return true;
}

void CSGetOpenActivityResp::Swap(CSGetOpenActivityResp* other) {
  if (other != this) {
    openactivityinfo_.Swap(&other->openactivityinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetOpenActivityResp::GetTypeName() const {
  return "fgame.CSGetOpenActivityResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSGetActivityDataReq::CSGetActivityDataReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetActivityDataReq)
}

void CSGetActivityDataReq::InitAsDefaultInstance() {
}

CSGetActivityDataReq::CSGetActivityDataReq(const CSGetActivityDataReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetActivityDataReq)
}

void CSGetActivityDataReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetActivityDataReq::~CSGetActivityDataReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGetActivityDataReq)
  SharedDtor();
}

void CSGetActivityDataReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetActivityDataReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetActivityDataReq& CSGetActivityDataReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSGetActivityDataReq* CSGetActivityDataReq::default_instance_ = NULL;

CSGetActivityDataReq* CSGetActivityDataReq::New() const {
  return new CSGetActivityDataReq;
}

void CSGetActivityDataReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetActivityDataReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetActivityDataReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetActivityDataReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetActivityDataReq)
  return false;
#undef DO_
}

void CSGetActivityDataReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetActivityDataReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetActivityDataReq)
}

int CSGetActivityDataReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetActivityDataReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetActivityDataReq*>(&from));
}

void CSGetActivityDataReq::MergeFrom(const CSGetActivityDataReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetActivityDataReq::CopyFrom(const CSGetActivityDataReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetActivityDataReq::IsInitialized() const {

  return true;
}

void CSGetActivityDataReq::Swap(CSGetActivityDataReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetActivityDataReq::GetTypeName() const {
  return "fgame.CSGetActivityDataReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSActivityInfo::kIdFieldNumber;
const int CSActivityInfo::kStageFieldNumber;
const int CSActivityInfo::kTypeFieldNumber;
const int CSActivityInfo::kStatusFieldNumber;
const int CSActivityInfo::kGiftFieldNumber;
const int CSActivityInfo::kStartTimeFieldNumber;
const int CSActivityInfo::kEndTimeFieldNumber;
const int CSActivityInfo::kRechargeNumFieldNumber;
#endif  // !_MSC_VER

CSActivityInfo::CSActivityInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSActivityInfo)
}

void CSActivityInfo::InitAsDefaultInstance() {
}

CSActivityInfo::CSActivityInfo(const CSActivityInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSActivityInfo)
}

void CSActivityInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_ = 0u;
  stage_ = 0u;
  type_ = 0u;
  status_ = 0u;
  gift_ = 0u;
  starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  recharge_num_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSActivityInfo::~CSActivityInfo() {
  // @@protoc_insertion_point(destructor:fgame.CSActivityInfo)
  SharedDtor();
}

void CSActivityInfo::SharedDtor() {
  if (starttime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete starttime_;
  }
  if (endtime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete endtime_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSActivityInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSActivityInfo& CSActivityInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSActivityInfo* CSActivityInfo::default_instance_ = NULL;

CSActivityInfo* CSActivityInfo::New() const {
  return new CSActivityInfo;
}

void CSActivityInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSActivityInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(id_, status_);
    ZR_(gift_, recharge_num_);
    if (has_starttime()) {
      if (starttime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        starttime_->clear();
      }
    }
    if (has_endtime()) {
      if (endtime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        endtime_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSActivityInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSActivityInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Stage;
        break;
      }

      // required uint32 Stage = 2;
      case 2: {
        if (tag == 16) {
         parse_Stage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &stage_)));
          set_has_stage();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Type;
        break;
      }

      // required uint32 Type = 3;
      case 3: {
        if (tag == 24) {
         parse_Type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Status;
        break;
      }

      // optional uint32 Status = 4;
      case 4: {
        if (tag == 32) {
         parse_Status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_Gift;
        break;
      }

      // optional uint32 Gift = 5;
      case 5: {
        if (tag == 40) {
         parse_Gift:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gift_)));
          set_has_gift();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_StartTime;
        break;
      }

      // optional string StartTime = 6;
      case 6: {
        if (tag == 50) {
         parse_StartTime:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_starttime()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_EndTime;
        break;
      }

      // optional string EndTime = 7;
      case 7: {
        if (tag == 58) {
         parse_EndTime:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_endtime()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_Recharge_num;
        break;
      }

      // optional uint32 Recharge_num = 8;
      case 8: {
        if (tag == 64) {
         parse_Recharge_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &recharge_num_)));
          set_has_recharge_num();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSActivityInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSActivityInfo)
  return false;
#undef DO_
}

void CSActivityInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSActivityInfo)
  // required uint32 Id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 Stage = 2;
  if (has_stage()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->stage(), output);
  }

  // required uint32 Type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->type(), output);
  }

  // optional uint32 Status = 4;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->status(), output);
  }

  // optional uint32 Gift = 5;
  if (has_gift()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->gift(), output);
  }

  // optional string StartTime = 6;
  if (has_starttime()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->starttime(), output);
  }

  // optional string EndTime = 7;
  if (has_endtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->endtime(), output);
  }

  // optional uint32 Recharge_num = 8;
  if (has_recharge_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->recharge_num(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSActivityInfo)
}

int CSActivityInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 Stage = 2;
    if (has_stage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->stage());
    }

    // required uint32 Type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // optional uint32 Status = 4;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->status());
    }

    // optional uint32 Gift = 5;
    if (has_gift()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gift());
    }

    // optional string StartTime = 6;
    if (has_starttime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->starttime());
    }

    // optional string EndTime = 7;
    if (has_endtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->endtime());
    }

    // optional uint32 Recharge_num = 8;
    if (has_recharge_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->recharge_num());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSActivityInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSActivityInfo*>(&from));
}

void CSActivityInfo::MergeFrom(const CSActivityInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_stage()) {
      set_stage(from.stage());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_gift()) {
      set_gift(from.gift());
    }
    if (from.has_starttime()) {
      set_starttime(from.starttime());
    }
    if (from.has_endtime()) {
      set_endtime(from.endtime());
    }
    if (from.has_recharge_num()) {
      set_recharge_num(from.recharge_num());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSActivityInfo::CopyFrom(const CSActivityInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSActivityInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSActivityInfo::Swap(CSActivityInfo* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(stage_, other->stage_);
    std::swap(type_, other->type_);
    std::swap(status_, other->status_);
    std::swap(gift_, other->gift_);
    std::swap(starttime_, other->starttime_);
    std::swap(endtime_, other->endtime_);
    std::swap(recharge_num_, other->recharge_num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSActivityInfo::GetTypeName() const {
  return "fgame.CSActivityInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGetActivityDataResp::kDayCountFieldNumber;
const int CSGetActivityDataResp::kRechargeCountFieldNumber;
const int CSGetActivityDataResp::kActivityInfoFieldNumber;
#endif  // !_MSC_VER

CSGetActivityDataResp::CSGetActivityDataResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetActivityDataResp)
}

void CSGetActivityDataResp::InitAsDefaultInstance() {
}

CSGetActivityDataResp::CSGetActivityDataResp(const CSGetActivityDataResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetActivityDataResp)
}

void CSGetActivityDataResp::SharedCtor() {
  _cached_size_ = 0;
  daycount_ = 0u;
  rechargecount_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetActivityDataResp::~CSGetActivityDataResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGetActivityDataResp)
  SharedDtor();
}

void CSGetActivityDataResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetActivityDataResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetActivityDataResp& CSGetActivityDataResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSGetActivityDataResp* CSGetActivityDataResp::default_instance_ = NULL;

CSGetActivityDataResp* CSGetActivityDataResp::New() const {
  return new CSGetActivityDataResp;
}

void CSGetActivityDataResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSGetActivityDataResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(daycount_, rechargecount_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  activityinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetActivityDataResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetActivityDataResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 DayCount = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &daycount_)));
          set_has_daycount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_RechargeCount;
        break;
      }

      // required uint32 RechargeCount = 2;
      case 2: {
        if (tag == 16) {
         parse_RechargeCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rechargecount_)));
          set_has_rechargecount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_ActivityInfo;
        break;
      }

      // repeated .fgame.CSActivityInfo ActivityInfo = 3;
      case 3: {
        if (tag == 26) {
         parse_ActivityInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_activityinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_ActivityInfo;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetActivityDataResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetActivityDataResp)
  return false;
#undef DO_
}

void CSGetActivityDataResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetActivityDataResp)
  // required uint32 DayCount = 1;
  if (has_daycount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->daycount(), output);
  }

  // required uint32 RechargeCount = 2;
  if (has_rechargecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->rechargecount(), output);
  }

  // repeated .fgame.CSActivityInfo ActivityInfo = 3;
  for (int i = 0; i < this->activityinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->activityinfo(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetActivityDataResp)
}

int CSGetActivityDataResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 DayCount = 1;
    if (has_daycount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->daycount());
    }

    // required uint32 RechargeCount = 2;
    if (has_rechargecount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rechargecount());
    }

  }
  // repeated .fgame.CSActivityInfo ActivityInfo = 3;
  total_size += 1 * this->activityinfo_size();
  for (int i = 0; i < this->activityinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->activityinfo(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetActivityDataResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetActivityDataResp*>(&from));
}

void CSGetActivityDataResp::MergeFrom(const CSGetActivityDataResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  activityinfo_.MergeFrom(from.activityinfo_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_daycount()) {
      set_daycount(from.daycount());
    }
    if (from.has_rechargecount()) {
      set_rechargecount(from.rechargecount());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetActivityDataResp::CopyFrom(const CSGetActivityDataResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetActivityDataResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->activityinfo())) return false;
  return true;
}

void CSGetActivityDataResp::Swap(CSGetActivityDataResp* other) {
  if (other != this) {
    std::swap(daycount_, other->daycount_);
    std::swap(rechargecount_, other->rechargecount_);
    activityinfo_.Swap(&other->activityinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetActivityDataResp::GetTypeName() const {
  return "fgame.CSGetActivityDataResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSReceiveActivityRewardReq::kIdFieldNumber;
const int CSReceiveActivityRewardReq::kStageFieldNumber;
const int CSReceiveActivityRewardReq::kTypeFieldNumber;
#endif  // !_MSC_VER

CSReceiveActivityRewardReq::CSReceiveActivityRewardReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSReceiveActivityRewardReq)
}

void CSReceiveActivityRewardReq::InitAsDefaultInstance() {
}

CSReceiveActivityRewardReq::CSReceiveActivityRewardReq(const CSReceiveActivityRewardReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSReceiveActivityRewardReq)
}

void CSReceiveActivityRewardReq::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  stage_ = 0u;
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSReceiveActivityRewardReq::~CSReceiveActivityRewardReq() {
  // @@protoc_insertion_point(destructor:fgame.CSReceiveActivityRewardReq)
  SharedDtor();
}

void CSReceiveActivityRewardReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSReceiveActivityRewardReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSReceiveActivityRewardReq& CSReceiveActivityRewardReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSReceiveActivityRewardReq* CSReceiveActivityRewardReq::default_instance_ = NULL;

CSReceiveActivityRewardReq* CSReceiveActivityRewardReq::New() const {
  return new CSReceiveActivityRewardReq;
}

void CSReceiveActivityRewardReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSReceiveActivityRewardReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, type_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSReceiveActivityRewardReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSReceiveActivityRewardReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Stage;
        break;
      }

      // required uint32 Stage = 2;
      case 2: {
        if (tag == 16) {
         parse_Stage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &stage_)));
          set_has_stage();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Type;
        break;
      }

      // required uint32 Type = 3;
      case 3: {
        if (tag == 24) {
         parse_Type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSReceiveActivityRewardReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSReceiveActivityRewardReq)
  return false;
#undef DO_
}

void CSReceiveActivityRewardReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSReceiveActivityRewardReq)
  // required uint32 Id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 Stage = 2;
  if (has_stage()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->stage(), output);
  }

  // required uint32 Type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSReceiveActivityRewardReq)
}

int CSReceiveActivityRewardReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 Stage = 2;
    if (has_stage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->stage());
    }

    // required uint32 Type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSReceiveActivityRewardReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSReceiveActivityRewardReq*>(&from));
}

void CSReceiveActivityRewardReq::MergeFrom(const CSReceiveActivityRewardReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_stage()) {
      set_stage(from.stage());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSReceiveActivityRewardReq::CopyFrom(const CSReceiveActivityRewardReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSReceiveActivityRewardReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSReceiveActivityRewardReq::Swap(CSReceiveActivityRewardReq* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(stage_, other->stage_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSReceiveActivityRewardReq::GetTypeName() const {
  return "fgame.CSReceiveActivityRewardReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSReceiveActivityRewardResp::kRetFieldNumber;
const int CSReceiveActivityRewardResp::kTypeFieldNumber;
const int CSReceiveActivityRewardResp::kIdFieldNumber;
#endif  // !_MSC_VER

CSReceiveActivityRewardResp::CSReceiveActivityRewardResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSReceiveActivityRewardResp)
}

void CSReceiveActivityRewardResp::InitAsDefaultInstance() {
}

CSReceiveActivityRewardResp::CSReceiveActivityRewardResp(const CSReceiveActivityRewardResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSReceiveActivityRewardResp)
}

void CSReceiveActivityRewardResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  type_ = 0u;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSReceiveActivityRewardResp::~CSReceiveActivityRewardResp() {
  // @@protoc_insertion_point(destructor:fgame.CSReceiveActivityRewardResp)
  SharedDtor();
}

void CSReceiveActivityRewardResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSReceiveActivityRewardResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSReceiveActivityRewardResp& CSReceiveActivityRewardResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSReceiveActivityRewardResp* CSReceiveActivityRewardResp::default_instance_ = NULL;

CSReceiveActivityRewardResp* CSReceiveActivityRewardResp::New() const {
  return new CSReceiveActivityRewardResp;
}

void CSReceiveActivityRewardResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSReceiveActivityRewardResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ret_, id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSReceiveActivityRewardResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSReceiveActivityRewardResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Type;
        break;
      }

      // required uint32 Type = 2;
      case 2: {
        if (tag == 16) {
         parse_Type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Id;
        break;
      }

      // required uint32 Id = 3;
      case 3: {
        if (tag == 24) {
         parse_Id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSReceiveActivityRewardResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSReceiveActivityRewardResp)
  return false;
#undef DO_
}

void CSReceiveActivityRewardResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSReceiveActivityRewardResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // required uint32 Type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->type(), output);
  }

  // required uint32 Id = 3;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSReceiveActivityRewardResp)
}

int CSReceiveActivityRewardResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // required uint32 Type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required uint32 Id = 3;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSReceiveActivityRewardResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSReceiveActivityRewardResp*>(&from));
}

void CSReceiveActivityRewardResp::MergeFrom(const CSReceiveActivityRewardResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSReceiveActivityRewardResp::CopyFrom(const CSReceiveActivityRewardResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSReceiveActivityRewardResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSReceiveActivityRewardResp::Swap(CSReceiveActivityRewardResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(type_, other->type_);
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSReceiveActivityRewardResp::GetTypeName() const {
  return "fgame.CSReceiveActivityRewardResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSGetPowerEnergyActivityDataReq::CSGetPowerEnergyActivityDataReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetPowerEnergyActivityDataReq)
}

void CSGetPowerEnergyActivityDataReq::InitAsDefaultInstance() {
}

CSGetPowerEnergyActivityDataReq::CSGetPowerEnergyActivityDataReq(const CSGetPowerEnergyActivityDataReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetPowerEnergyActivityDataReq)
}

void CSGetPowerEnergyActivityDataReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetPowerEnergyActivityDataReq::~CSGetPowerEnergyActivityDataReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGetPowerEnergyActivityDataReq)
  SharedDtor();
}

void CSGetPowerEnergyActivityDataReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetPowerEnergyActivityDataReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetPowerEnergyActivityDataReq& CSGetPowerEnergyActivityDataReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSGetPowerEnergyActivityDataReq* CSGetPowerEnergyActivityDataReq::default_instance_ = NULL;

CSGetPowerEnergyActivityDataReq* CSGetPowerEnergyActivityDataReq::New() const {
  return new CSGetPowerEnergyActivityDataReq;
}

void CSGetPowerEnergyActivityDataReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetPowerEnergyActivityDataReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetPowerEnergyActivityDataReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetPowerEnergyActivityDataReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetPowerEnergyActivityDataReq)
  return false;
#undef DO_
}

void CSGetPowerEnergyActivityDataReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetPowerEnergyActivityDataReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetPowerEnergyActivityDataReq)
}

int CSGetPowerEnergyActivityDataReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetPowerEnergyActivityDataReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetPowerEnergyActivityDataReq*>(&from));
}

void CSGetPowerEnergyActivityDataReq::MergeFrom(const CSGetPowerEnergyActivityDataReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetPowerEnergyActivityDataReq::CopyFrom(const CSGetPowerEnergyActivityDataReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetPowerEnergyActivityDataReq::IsInitialized() const {

  return true;
}

void CSGetPowerEnergyActivityDataReq::Swap(CSGetPowerEnergyActivityDataReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetPowerEnergyActivityDataReq::GetTypeName() const {
  return "fgame.CSGetPowerEnergyActivityDataReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGetPowerEnergyActivityResp::kIdFieldNumber;
const int CSGetPowerEnergyActivityResp::kIsOpenFieldNumber;
const int CSGetPowerEnergyActivityResp::kStatusFieldNumber;
const int CSGetPowerEnergyActivityResp::kStartTimeFieldNumber;
const int CSGetPowerEnergyActivityResp::kEndTimeFieldNumber;
#endif  // !_MSC_VER

CSGetPowerEnergyActivityResp::CSGetPowerEnergyActivityResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetPowerEnergyActivityResp)
}

void CSGetPowerEnergyActivityResp::InitAsDefaultInstance() {
}

CSGetPowerEnergyActivityResp::CSGetPowerEnergyActivityResp(const CSGetPowerEnergyActivityResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetPowerEnergyActivityResp)
}

void CSGetPowerEnergyActivityResp::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  isopen_ = 0u;
  status_ = 0u;
  starttime_ = 0u;
  endtime_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetPowerEnergyActivityResp::~CSGetPowerEnergyActivityResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGetPowerEnergyActivityResp)
  SharedDtor();
}

void CSGetPowerEnergyActivityResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetPowerEnergyActivityResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetPowerEnergyActivityResp& CSGetPowerEnergyActivityResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSGetPowerEnergyActivityResp* CSGetPowerEnergyActivityResp::default_instance_ = NULL;

CSGetPowerEnergyActivityResp* CSGetPowerEnergyActivityResp::New() const {
  return new CSGetPowerEnergyActivityResp;
}

void CSGetPowerEnergyActivityResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSGetPowerEnergyActivityResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(id_, endtime_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetPowerEnergyActivityResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetPowerEnergyActivityResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_IsOpen;
        break;
      }

      // required uint32 IsOpen = 2;
      case 2: {
        if (tag == 16) {
         parse_IsOpen:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &isopen_)));
          set_has_isopen();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Status;
        break;
      }

      // required uint32 Status = 3;
      case 3: {
        if (tag == 24) {
         parse_Status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_StartTime;
        break;
      }

      // required uint32 StartTime = 4;
      case 4: {
        if (tag == 32) {
         parse_StartTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &starttime_)));
          set_has_starttime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_EndTime;
        break;
      }

      // required uint32 EndTime = 5;
      case 5: {
        if (tag == 40) {
         parse_EndTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endtime_)));
          set_has_endtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetPowerEnergyActivityResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetPowerEnergyActivityResp)
  return false;
#undef DO_
}

void CSGetPowerEnergyActivityResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetPowerEnergyActivityResp)
  // required uint32 Id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 IsOpen = 2;
  if (has_isopen()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->isopen(), output);
  }

  // required uint32 Status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->status(), output);
  }

  // required uint32 StartTime = 4;
  if (has_starttime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->starttime(), output);
  }

  // required uint32 EndTime = 5;
  if (has_endtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->endtime(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetPowerEnergyActivityResp)
}

int CSGetPowerEnergyActivityResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 IsOpen = 2;
    if (has_isopen()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->isopen());
    }

    // required uint32 Status = 3;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->status());
    }

    // required uint32 StartTime = 4;
    if (has_starttime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->starttime());
    }

    // required uint32 EndTime = 5;
    if (has_endtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endtime());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetPowerEnergyActivityResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetPowerEnergyActivityResp*>(&from));
}

void CSGetPowerEnergyActivityResp::MergeFrom(const CSGetPowerEnergyActivityResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_isopen()) {
      set_isopen(from.isopen());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_starttime()) {
      set_starttime(from.starttime());
    }
    if (from.has_endtime()) {
      set_endtime(from.endtime());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetPowerEnergyActivityResp::CopyFrom(const CSGetPowerEnergyActivityResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetPowerEnergyActivityResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void CSGetPowerEnergyActivityResp::Swap(CSGetPowerEnergyActivityResp* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(isopen_, other->isopen_);
    std::swap(status_, other->status_);
    std::swap(starttime_, other->starttime_);
    std::swap(endtime_, other->endtime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetPowerEnergyActivityResp::GetTypeName() const {
  return "fgame.CSGetPowerEnergyActivityResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSReceivePowerEnergyReq::kIdFieldNumber;
const int CSReceivePowerEnergyReq::kTypeFieldNumber;
#endif  // !_MSC_VER

CSReceivePowerEnergyReq::CSReceivePowerEnergyReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSReceivePowerEnergyReq)
}

void CSReceivePowerEnergyReq::InitAsDefaultInstance() {
}

CSReceivePowerEnergyReq::CSReceivePowerEnergyReq(const CSReceivePowerEnergyReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSReceivePowerEnergyReq)
}

void CSReceivePowerEnergyReq::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSReceivePowerEnergyReq::~CSReceivePowerEnergyReq() {
  // @@protoc_insertion_point(destructor:fgame.CSReceivePowerEnergyReq)
  SharedDtor();
}

void CSReceivePowerEnergyReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSReceivePowerEnergyReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSReceivePowerEnergyReq& CSReceivePowerEnergyReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSReceivePowerEnergyReq* CSReceivePowerEnergyReq::default_instance_ = NULL;

CSReceivePowerEnergyReq* CSReceivePowerEnergyReq::New() const {
  return new CSReceivePowerEnergyReq;
}

void CSReceivePowerEnergyReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSReceivePowerEnergyReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, type_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSReceivePowerEnergyReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSReceivePowerEnergyReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Type;
        break;
      }

      // required uint32 Type = 2;
      case 2: {
        if (tag == 16) {
         parse_Type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSReceivePowerEnergyReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSReceivePowerEnergyReq)
  return false;
#undef DO_
}

void CSReceivePowerEnergyReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSReceivePowerEnergyReq)
  // required uint32 Id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 Type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSReceivePowerEnergyReq)
}

int CSReceivePowerEnergyReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 Type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSReceivePowerEnergyReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSReceivePowerEnergyReq*>(&from));
}

void CSReceivePowerEnergyReq::MergeFrom(const CSReceivePowerEnergyReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSReceivePowerEnergyReq::CopyFrom(const CSReceivePowerEnergyReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSReceivePowerEnergyReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSReceivePowerEnergyReq::Swap(CSReceivePowerEnergyReq* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSReceivePowerEnergyReq::GetTypeName() const {
  return "fgame.CSReceivePowerEnergyReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSReceivePowerEnergyResp::kRetFieldNumber;
const int CSReceivePowerEnergyResp::kTypeFieldNumber;
#endif  // !_MSC_VER

CSReceivePowerEnergyResp::CSReceivePowerEnergyResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSReceivePowerEnergyResp)
}

void CSReceivePowerEnergyResp::InitAsDefaultInstance() {
}

CSReceivePowerEnergyResp::CSReceivePowerEnergyResp(const CSReceivePowerEnergyResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSReceivePowerEnergyResp)
}

void CSReceivePowerEnergyResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSReceivePowerEnergyResp::~CSReceivePowerEnergyResp() {
  // @@protoc_insertion_point(destructor:fgame.CSReceivePowerEnergyResp)
  SharedDtor();
}

void CSReceivePowerEnergyResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSReceivePowerEnergyResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSReceivePowerEnergyResp& CSReceivePowerEnergyResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSReceivePowerEnergyResp* CSReceivePowerEnergyResp::default_instance_ = NULL;

CSReceivePowerEnergyResp* CSReceivePowerEnergyResp::New() const {
  return new CSReceivePowerEnergyResp;
}

void CSReceivePowerEnergyResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSReceivePowerEnergyResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ret_, type_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSReceivePowerEnergyResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSReceivePowerEnergyResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Type;
        break;
      }

      // required uint32 Type = 2;
      case 2: {
        if (tag == 16) {
         parse_Type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSReceivePowerEnergyResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSReceivePowerEnergyResp)
  return false;
#undef DO_
}

void CSReceivePowerEnergyResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSReceivePowerEnergyResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // required uint32 Type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSReceivePowerEnergyResp)
}

int CSReceivePowerEnergyResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // required uint32 Type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSReceivePowerEnergyResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSReceivePowerEnergyResp*>(&from));
}

void CSReceivePowerEnergyResp::MergeFrom(const CSReceivePowerEnergyResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSReceivePowerEnergyResp::CopyFrom(const CSReceivePowerEnergyResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSReceivePowerEnergyResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSReceivePowerEnergyResp::Swap(CSReceivePowerEnergyResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSReceivePowerEnergyResp::GetTypeName() const {
  return "fgame.CSReceivePowerEnergyResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSubActivity::kActIdFieldNumber;
const int CSSubActivity::kSubIdFieldNumber;
const int CSSubActivity::kGiftIdFieldNumber;
const int CSSubActivity::kRequestFieldNumber;
const int CSSubActivity::kValueFieldNumber;
const int CSSubActivity::kCompletedFieldNumber;
const int CSSubActivity::kSubmitFieldNumber;
#endif  // !_MSC_VER

CSSubActivity::CSSubActivity()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSubActivity)
}

void CSSubActivity::InitAsDefaultInstance() {
}

CSSubActivity::CSSubActivity(const CSSubActivity& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSubActivity)
}

void CSSubActivity::SharedCtor() {
  _cached_size_ = 0;
  act_id_ = 0u;
  sub_id_ = 0u;
  giftid_ = 0u;
  request_ = 0u;
  value_ = 0u;
  completed_ = false;
  submit_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSubActivity::~CSSubActivity() {
  // @@protoc_insertion_point(destructor:fgame.CSSubActivity)
  SharedDtor();
}

void CSSubActivity::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSubActivity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSubActivity& CSSubActivity::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSSubActivity* CSSubActivity::default_instance_ = NULL;

CSSubActivity* CSSubActivity::New() const {
  return new CSSubActivity;
}

void CSSubActivity::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSSubActivity*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(act_id_, submit_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSubActivity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSubActivity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Act_Id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &act_id_)));
          set_has_act_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Sub_Id;
        break;
      }

      // required uint32 Sub_Id = 2;
      case 2: {
        if (tag == 16) {
         parse_Sub_Id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sub_id_)));
          set_has_sub_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_GiftId;
        break;
      }

      // optional uint32 GiftId = 3;
      case 3: {
        if (tag == 24) {
         parse_GiftId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &giftid_)));
          set_has_giftid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Request;
        break;
      }

      // optional uint32 Request = 4;
      case 4: {
        if (tag == 32) {
         parse_Request:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &request_)));
          set_has_request();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_Value;
        break;
      }

      // optional uint32 Value = 5;
      case 5: {
        if (tag == 40) {
         parse_Value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_Completed;
        break;
      }

      // optional bool Completed = 6;
      case 6: {
        if (tag == 48) {
         parse_Completed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &completed_)));
          set_has_completed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_Submit;
        break;
      }

      // optional bool Submit = 7;
      case 7: {
        if (tag == 56) {
         parse_Submit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &submit_)));
          set_has_submit();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSubActivity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSubActivity)
  return false;
#undef DO_
}

void CSSubActivity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSubActivity)
  // required uint32 Act_Id = 1;
  if (has_act_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->act_id(), output);
  }

  // required uint32 Sub_Id = 2;
  if (has_sub_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->sub_id(), output);
  }

  // optional uint32 GiftId = 3;
  if (has_giftid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->giftid(), output);
  }

  // optional uint32 Request = 4;
  if (has_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->request(), output);
  }

  // optional uint32 Value = 5;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->value(), output);
  }

  // optional bool Completed = 6;
  if (has_completed()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->completed(), output);
  }

  // optional bool Submit = 7;
  if (has_submit()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->submit(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSubActivity)
}

int CSSubActivity::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Act_Id = 1;
    if (has_act_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->act_id());
    }

    // required uint32 Sub_Id = 2;
    if (has_sub_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sub_id());
    }

    // optional uint32 GiftId = 3;
    if (has_giftid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->giftid());
    }

    // optional uint32 Request = 4;
    if (has_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->request());
    }

    // optional uint32 Value = 5;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

    // optional bool Completed = 6;
    if (has_completed()) {
      total_size += 1 + 1;
    }

    // optional bool Submit = 7;
    if (has_submit()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSubActivity::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSubActivity*>(&from));
}

void CSSubActivity::MergeFrom(const CSSubActivity& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_act_id()) {
      set_act_id(from.act_id());
    }
    if (from.has_sub_id()) {
      set_sub_id(from.sub_id());
    }
    if (from.has_giftid()) {
      set_giftid(from.giftid());
    }
    if (from.has_request()) {
      set_request(from.request());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_completed()) {
      set_completed(from.completed());
    }
    if (from.has_submit()) {
      set_submit(from.submit());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSubActivity::CopyFrom(const CSSubActivity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSubActivity::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSSubActivity::Swap(CSSubActivity* other) {
  if (other != this) {
    std::swap(act_id_, other->act_id_);
    std::swap(sub_id_, other->sub_id_);
    std::swap(giftid_, other->giftid_);
    std::swap(request_, other->request_);
    std::swap(value_, other->value_);
    std::swap(completed_, other->completed_);
    std::swap(submit_, other->submit_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSubActivity::GetTypeName() const {
  return "fgame.CSSubActivity";
}


// ===================================================================

#ifndef _MSC_VER
const int CSActivityData::kActTypeFieldNumber;
const int CSActivityData::kCurSubIdFieldNumber;
const int CSActivityData::kDaysRemainFieldNumber;
const int CSActivityData::kSubListFieldNumber;
#endif  // !_MSC_VER

CSActivityData::CSActivityData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSActivityData)
}

void CSActivityData::InitAsDefaultInstance() {
}

CSActivityData::CSActivityData(const CSActivityData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSActivityData)
}

void CSActivityData::SharedCtor() {
  _cached_size_ = 0;
  act_type_ = 0u;
  cur_subid_ = 0u;
  daysremain_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSActivityData::~CSActivityData() {
  // @@protoc_insertion_point(destructor:fgame.CSActivityData)
  SharedDtor();
}

void CSActivityData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSActivityData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSActivityData& CSActivityData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSActivityData* CSActivityData::default_instance_ = NULL;

CSActivityData* CSActivityData::New() const {
  return new CSActivityData;
}

void CSActivityData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSActivityData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(act_type_, cur_subid_);
    daysremain_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  sublist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSActivityData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSActivityData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Act_type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &act_type_)));
          set_has_act_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Cur_SubId;
        break;
      }

      // required uint32 Cur_SubId = 2;
      case 2: {
        if (tag == 16) {
         parse_Cur_SubId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cur_subid_)));
          set_has_cur_subid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_DaysRemain;
        break;
      }

      // required uint32 DaysRemain = 3;
      case 3: {
        if (tag == 24) {
         parse_DaysRemain:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &daysremain_)));
          set_has_daysremain();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_SubList;
        break;
      }

      // repeated .fgame.CSSubActivity SubList = 4;
      case 4: {
        if (tag == 34) {
         parse_SubList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sublist()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_SubList;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSActivityData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSActivityData)
  return false;
#undef DO_
}

void CSActivityData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSActivityData)
  // required uint32 Act_type = 1;
  if (has_act_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->act_type(), output);
  }

  // required uint32 Cur_SubId = 2;
  if (has_cur_subid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->cur_subid(), output);
  }

  // required uint32 DaysRemain = 3;
  if (has_daysremain()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->daysremain(), output);
  }

  // repeated .fgame.CSSubActivity SubList = 4;
  for (int i = 0; i < this->sublist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->sublist(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSActivityData)
}

int CSActivityData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Act_type = 1;
    if (has_act_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->act_type());
    }

    // required uint32 Cur_SubId = 2;
    if (has_cur_subid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cur_subid());
    }

    // required uint32 DaysRemain = 3;
    if (has_daysremain()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->daysremain());
    }

  }
  // repeated .fgame.CSSubActivity SubList = 4;
  total_size += 1 * this->sublist_size();
  for (int i = 0; i < this->sublist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sublist(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSActivityData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSActivityData*>(&from));
}

void CSActivityData::MergeFrom(const CSActivityData& from) {
  GOOGLE_CHECK_NE(&from, this);
  sublist_.MergeFrom(from.sublist_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_act_type()) {
      set_act_type(from.act_type());
    }
    if (from.has_cur_subid()) {
      set_cur_subid(from.cur_subid());
    }
    if (from.has_daysremain()) {
      set_daysremain(from.daysremain());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSActivityData::CopyFrom(const CSActivityData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSActivityData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->sublist())) return false;
  return true;
}

void CSActivityData::Swap(CSActivityData* other) {
  if (other != this) {
    std::swap(act_type_, other->act_type_);
    std::swap(cur_subid_, other->cur_subid_);
    std::swap(daysremain_, other->daysremain_);
    sublist_.Swap(&other->sublist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSActivityData::GetTypeName() const {
  return "fgame.CSActivityData";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSActivityListReq::CSActivityListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSActivityListReq)
}

void CSActivityListReq::InitAsDefaultInstance() {
}

CSActivityListReq::CSActivityListReq(const CSActivityListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSActivityListReq)
}

void CSActivityListReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSActivityListReq::~CSActivityListReq() {
  // @@protoc_insertion_point(destructor:fgame.CSActivityListReq)
  SharedDtor();
}

void CSActivityListReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSActivityListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSActivityListReq& CSActivityListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSActivityListReq* CSActivityListReq::default_instance_ = NULL;

CSActivityListReq* CSActivityListReq::New() const {
  return new CSActivityListReq;
}

void CSActivityListReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSActivityListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSActivityListReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSActivityListReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSActivityListReq)
  return false;
#undef DO_
}

void CSActivityListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSActivityListReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSActivityListReq)
}

int CSActivityListReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSActivityListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSActivityListReq*>(&from));
}

void CSActivityListReq::MergeFrom(const CSActivityListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSActivityListReq::CopyFrom(const CSActivityListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSActivityListReq::IsInitialized() const {

  return true;
}

void CSActivityListReq::Swap(CSActivityListReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSActivityListReq::GetTypeName() const {
  return "fgame.CSActivityListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSActivityListResp::kActivityListFieldNumber;
#endif  // !_MSC_VER

CSActivityListResp::CSActivityListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSActivityListResp)
}

void CSActivityListResp::InitAsDefaultInstance() {
}

CSActivityListResp::CSActivityListResp(const CSActivityListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSActivityListResp)
}

void CSActivityListResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSActivityListResp::~CSActivityListResp() {
  // @@protoc_insertion_point(destructor:fgame.CSActivityListResp)
  SharedDtor();
}

void CSActivityListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSActivityListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSActivityListResp& CSActivityListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSActivityListResp* CSActivityListResp::default_instance_ = NULL;

CSActivityListResp* CSActivityListResp::New() const {
  return new CSActivityListResp;
}

void CSActivityListResp::Clear() {
  activitylist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSActivityListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSActivityListResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.CSActivityData ActivityList = 1;
      case 1: {
        if (tag == 10) {
         parse_ActivityList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_activitylist()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_ActivityList;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSActivityListResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSActivityListResp)
  return false;
#undef DO_
}

void CSActivityListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSActivityListResp)
  // repeated .fgame.CSActivityData ActivityList = 1;
  for (int i = 0; i < this->activitylist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->activitylist(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSActivityListResp)
}

int CSActivityListResp::ByteSize() const {
  int total_size = 0;

  // repeated .fgame.CSActivityData ActivityList = 1;
  total_size += 1 * this->activitylist_size();
  for (int i = 0; i < this->activitylist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->activitylist(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSActivityListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSActivityListResp*>(&from));
}

void CSActivityListResp::MergeFrom(const CSActivityListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  activitylist_.MergeFrom(from.activitylist_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSActivityListResp::CopyFrom(const CSActivityListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSActivityListResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->activitylist())) return false;
  return true;
}

void CSActivityListResp::Swap(CSActivityListResp* other) {
  if (other != this) {
    activitylist_.Swap(&other->activitylist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSActivityListResp::GetTypeName() const {
  return "fgame.CSActivityListResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSActivitySubmitReq::kActIdFieldNumber;
const int CSActivitySubmitReq::kSubIdFieldNumber;
#endif  // !_MSC_VER

CSActivitySubmitReq::CSActivitySubmitReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSActivitySubmitReq)
}

void CSActivitySubmitReq::InitAsDefaultInstance() {
}

CSActivitySubmitReq::CSActivitySubmitReq(const CSActivitySubmitReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSActivitySubmitReq)
}

void CSActivitySubmitReq::SharedCtor() {
  _cached_size_ = 0;
  act_id_ = 0u;
  sub_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSActivitySubmitReq::~CSActivitySubmitReq() {
  // @@protoc_insertion_point(destructor:fgame.CSActivitySubmitReq)
  SharedDtor();
}

void CSActivitySubmitReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSActivitySubmitReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSActivitySubmitReq& CSActivitySubmitReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSActivitySubmitReq* CSActivitySubmitReq::default_instance_ = NULL;

CSActivitySubmitReq* CSActivitySubmitReq::New() const {
  return new CSActivitySubmitReq;
}

void CSActivitySubmitReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSActivitySubmitReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(act_id_, sub_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSActivitySubmitReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSActivitySubmitReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Act_Id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &act_id_)));
          set_has_act_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Sub_Id;
        break;
      }

      // required uint32 Sub_Id = 2;
      case 2: {
        if (tag == 16) {
         parse_Sub_Id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sub_id_)));
          set_has_sub_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSActivitySubmitReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSActivitySubmitReq)
  return false;
#undef DO_
}

void CSActivitySubmitReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSActivitySubmitReq)
  // required uint32 Act_Id = 1;
  if (has_act_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->act_id(), output);
  }

  // required uint32 Sub_Id = 2;
  if (has_sub_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->sub_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSActivitySubmitReq)
}

int CSActivitySubmitReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Act_Id = 1;
    if (has_act_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->act_id());
    }

    // required uint32 Sub_Id = 2;
    if (has_sub_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sub_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSActivitySubmitReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSActivitySubmitReq*>(&from));
}

void CSActivitySubmitReq::MergeFrom(const CSActivitySubmitReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_act_id()) {
      set_act_id(from.act_id());
    }
    if (from.has_sub_id()) {
      set_sub_id(from.sub_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSActivitySubmitReq::CopyFrom(const CSActivitySubmitReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSActivitySubmitReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSActivitySubmitReq::Swap(CSActivitySubmitReq* other) {
  if (other != this) {
    std::swap(act_id_, other->act_id_);
    std::swap(sub_id_, other->sub_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSActivitySubmitReq::GetTypeName() const {
  return "fgame.CSActivitySubmitReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSActivitySubmitResp::kActIdFieldNumber;
const int CSActivitySubmitResp::kSubIdFieldNumber;
#endif  // !_MSC_VER

CSActivitySubmitResp::CSActivitySubmitResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSActivitySubmitResp)
}

void CSActivitySubmitResp::InitAsDefaultInstance() {
}

CSActivitySubmitResp::CSActivitySubmitResp(const CSActivitySubmitResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSActivitySubmitResp)
}

void CSActivitySubmitResp::SharedCtor() {
  _cached_size_ = 0;
  act_id_ = 0u;
  sub_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSActivitySubmitResp::~CSActivitySubmitResp() {
  // @@protoc_insertion_point(destructor:fgame.CSActivitySubmitResp)
  SharedDtor();
}

void CSActivitySubmitResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSActivitySubmitResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSActivitySubmitResp& CSActivitySubmitResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSActivitySubmitResp* CSActivitySubmitResp::default_instance_ = NULL;

CSActivitySubmitResp* CSActivitySubmitResp::New() const {
  return new CSActivitySubmitResp;
}

void CSActivitySubmitResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSActivitySubmitResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(act_id_, sub_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSActivitySubmitResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSActivitySubmitResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Act_Id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &act_id_)));
          set_has_act_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Sub_Id;
        break;
      }

      // required uint32 Sub_Id = 2;
      case 2: {
        if (tag == 16) {
         parse_Sub_Id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sub_id_)));
          set_has_sub_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSActivitySubmitResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSActivitySubmitResp)
  return false;
#undef DO_
}

void CSActivitySubmitResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSActivitySubmitResp)
  // required uint32 Act_Id = 1;
  if (has_act_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->act_id(), output);
  }

  // required uint32 Sub_Id = 2;
  if (has_sub_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->sub_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSActivitySubmitResp)
}

int CSActivitySubmitResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Act_Id = 1;
    if (has_act_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->act_id());
    }

    // required uint32 Sub_Id = 2;
    if (has_sub_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sub_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSActivitySubmitResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSActivitySubmitResp*>(&from));
}

void CSActivitySubmitResp::MergeFrom(const CSActivitySubmitResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_act_id()) {
      set_act_id(from.act_id());
    }
    if (from.has_sub_id()) {
      set_sub_id(from.sub_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSActivitySubmitResp::CopyFrom(const CSActivitySubmitResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSActivitySubmitResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSActivitySubmitResp::Swap(CSActivitySubmitResp* other) {
  if (other != this) {
    std::swap(act_id_, other->act_id_);
    std::swap(sub_id_, other->sub_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSActivitySubmitResp::GetTypeName() const {
  return "fgame.CSActivitySubmitResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSActivityUpdateResp::kActivityFieldNumber;
#endif  // !_MSC_VER

CSActivityUpdateResp::CSActivityUpdateResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSActivityUpdateResp)
}

void CSActivityUpdateResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  activity_ = const_cast< ::fgame::CSSubActivity*>(
      ::fgame::CSSubActivity::internal_default_instance());
#else
  activity_ = const_cast< ::fgame::CSSubActivity*>(&::fgame::CSSubActivity::default_instance());
#endif
}

CSActivityUpdateResp::CSActivityUpdateResp(const CSActivityUpdateResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSActivityUpdateResp)
}

void CSActivityUpdateResp::SharedCtor() {
  _cached_size_ = 0;
  activity_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSActivityUpdateResp::~CSActivityUpdateResp() {
  // @@protoc_insertion_point(destructor:fgame.CSActivityUpdateResp)
  SharedDtor();
}

void CSActivityUpdateResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete activity_;
  }
}

void CSActivityUpdateResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSActivityUpdateResp& CSActivityUpdateResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSActivityUpdateResp* CSActivityUpdateResp::default_instance_ = NULL;

CSActivityUpdateResp* CSActivityUpdateResp::New() const {
  return new CSActivityUpdateResp;
}

void CSActivityUpdateResp::Clear() {
  if (has_activity()) {
    if (activity_ != NULL) activity_->::fgame::CSSubActivity::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSActivityUpdateResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSActivityUpdateResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .fgame.CSSubActivity Activity = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_activity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSActivityUpdateResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSActivityUpdateResp)
  return false;
#undef DO_
}

void CSActivityUpdateResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSActivityUpdateResp)
  // required .fgame.CSSubActivity Activity = 1;
  if (has_activity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->activity(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSActivityUpdateResp)
}

int CSActivityUpdateResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .fgame.CSSubActivity Activity = 1;
    if (has_activity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->activity());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSActivityUpdateResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSActivityUpdateResp*>(&from));
}

void CSActivityUpdateResp::MergeFrom(const CSActivityUpdateResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_activity()) {
      mutable_activity()->::fgame::CSSubActivity::MergeFrom(from.activity());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSActivityUpdateResp::CopyFrom(const CSActivityUpdateResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSActivityUpdateResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_activity()) {
    if (!this->activity().IsInitialized()) return false;
  }
  return true;
}

void CSActivityUpdateResp::Swap(CSActivityUpdateResp* other) {
  if (other != this) {
    std::swap(activity_, other->activity_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSActivityUpdateResp::GetTypeName() const {
  return "fgame.CSActivityUpdateResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSNewYearGetInfoReq::CSNewYearGetInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSNewYearGetInfoReq)
}

void CSNewYearGetInfoReq::InitAsDefaultInstance() {
}

CSNewYearGetInfoReq::CSNewYearGetInfoReq(const CSNewYearGetInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSNewYearGetInfoReq)
}

void CSNewYearGetInfoReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSNewYearGetInfoReq::~CSNewYearGetInfoReq() {
  // @@protoc_insertion_point(destructor:fgame.CSNewYearGetInfoReq)
  SharedDtor();
}

void CSNewYearGetInfoReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSNewYearGetInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSNewYearGetInfoReq& CSNewYearGetInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSNewYearGetInfoReq* CSNewYearGetInfoReq::default_instance_ = NULL;

CSNewYearGetInfoReq* CSNewYearGetInfoReq::New() const {
  return new CSNewYearGetInfoReq;
}

void CSNewYearGetInfoReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSNewYearGetInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSNewYearGetInfoReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSNewYearGetInfoReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSNewYearGetInfoReq)
  return false;
#undef DO_
}

void CSNewYearGetInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSNewYearGetInfoReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSNewYearGetInfoReq)
}

int CSNewYearGetInfoReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSNewYearGetInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSNewYearGetInfoReq*>(&from));
}

void CSNewYearGetInfoReq::MergeFrom(const CSNewYearGetInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSNewYearGetInfoReq::CopyFrom(const CSNewYearGetInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSNewYearGetInfoReq::IsInitialized() const {

  return true;
}

void CSNewYearGetInfoReq::Swap(CSNewYearGetInfoReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSNewYearGetInfoReq::GetTypeName() const {
  return "fgame.CSNewYearGetInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSNewYearGetInfoResp::kStartTimeFieldNumber;
const int CSNewYearGetInfoResp::kEndTimeFieldNumber;
const int CSNewYearGetInfoResp::kConditionIdFieldNumber;
const int CSNewYearGetInfoResp::kCompleteCountFieldNumber;
const int CSNewYearGetInfoResp::kCurCountFieldNumber;
const int CSNewYearGetInfoResp::kNextPacketTagFieldNumber;
const int CSNewYearGetInfoResp::kAwardIdFieldNumber;
#endif  // !_MSC_VER

CSNewYearGetInfoResp::CSNewYearGetInfoResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSNewYearGetInfoResp)
}

void CSNewYearGetInfoResp::InitAsDefaultInstance() {
}

CSNewYearGetInfoResp::CSNewYearGetInfoResp(const CSNewYearGetInfoResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSNewYearGetInfoResp)
}

void CSNewYearGetInfoResp::SharedCtor() {
  _cached_size_ = 0;
  starttime_ = 0u;
  endtime_ = 0u;
  conditionid_ = 0u;
  completecount_ = 0u;
  curcount_ = 0u;
  nextpackettag_ = false;
  awardid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSNewYearGetInfoResp::~CSNewYearGetInfoResp() {
  // @@protoc_insertion_point(destructor:fgame.CSNewYearGetInfoResp)
  SharedDtor();
}

void CSNewYearGetInfoResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSNewYearGetInfoResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSNewYearGetInfoResp& CSNewYearGetInfoResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSNewYearGetInfoResp* CSNewYearGetInfoResp::default_instance_ = NULL;

CSNewYearGetInfoResp* CSNewYearGetInfoResp::New() const {
  return new CSNewYearGetInfoResp;
}

void CSNewYearGetInfoResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSNewYearGetInfoResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(starttime_, awardid_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSNewYearGetInfoResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSNewYearGetInfoResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 startTime = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &starttime_)));
          set_has_starttime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_endTime;
        break;
      }

      // optional uint32 endTime = 2;
      case 2: {
        if (tag == 16) {
         parse_endTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endtime_)));
          set_has_endtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_conditionId;
        break;
      }

      // optional uint32 conditionId = 3;
      case 3: {
        if (tag == 24) {
         parse_conditionId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &conditionid_)));
          set_has_conditionid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_completeCount;
        break;
      }

      // optional uint32 completeCount = 4;
      case 4: {
        if (tag == 32) {
         parse_completeCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &completecount_)));
          set_has_completecount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_curCount;
        break;
      }

      // optional uint32 curCount = 5;
      case 5: {
        if (tag == 40) {
         parse_curCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &curcount_)));
          set_has_curcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_nextPacketTag;
        break;
      }

      // optional bool nextPacketTag = 6;
      case 6: {
        if (tag == 48) {
         parse_nextPacketTag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &nextpackettag_)));
          set_has_nextpackettag();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_awardId;
        break;
      }

      // optional uint32 awardId = 7;
      case 7: {
        if (tag == 56) {
         parse_awardId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &awardid_)));
          set_has_awardid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSNewYearGetInfoResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSNewYearGetInfoResp)
  return false;
#undef DO_
}

void CSNewYearGetInfoResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSNewYearGetInfoResp)
  // optional uint32 startTime = 1;
  if (has_starttime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->starttime(), output);
  }

  // optional uint32 endTime = 2;
  if (has_endtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->endtime(), output);
  }

  // optional uint32 conditionId = 3;
  if (has_conditionid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->conditionid(), output);
  }

  // optional uint32 completeCount = 4;
  if (has_completecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->completecount(), output);
  }

  // optional uint32 curCount = 5;
  if (has_curcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->curcount(), output);
  }

  // optional bool nextPacketTag = 6;
  if (has_nextpackettag()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->nextpackettag(), output);
  }

  // optional uint32 awardId = 7;
  if (has_awardid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->awardid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSNewYearGetInfoResp)
}

int CSNewYearGetInfoResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 startTime = 1;
    if (has_starttime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->starttime());
    }

    // optional uint32 endTime = 2;
    if (has_endtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endtime());
    }

    // optional uint32 conditionId = 3;
    if (has_conditionid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->conditionid());
    }

    // optional uint32 completeCount = 4;
    if (has_completecount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->completecount());
    }

    // optional uint32 curCount = 5;
    if (has_curcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->curcount());
    }

    // optional bool nextPacketTag = 6;
    if (has_nextpackettag()) {
      total_size += 1 + 1;
    }

    // optional uint32 awardId = 7;
    if (has_awardid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->awardid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSNewYearGetInfoResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSNewYearGetInfoResp*>(&from));
}

void CSNewYearGetInfoResp::MergeFrom(const CSNewYearGetInfoResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_starttime()) {
      set_starttime(from.starttime());
    }
    if (from.has_endtime()) {
      set_endtime(from.endtime());
    }
    if (from.has_conditionid()) {
      set_conditionid(from.conditionid());
    }
    if (from.has_completecount()) {
      set_completecount(from.completecount());
    }
    if (from.has_curcount()) {
      set_curcount(from.curcount());
    }
    if (from.has_nextpackettag()) {
      set_nextpackettag(from.nextpackettag());
    }
    if (from.has_awardid()) {
      set_awardid(from.awardid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSNewYearGetInfoResp::CopyFrom(const CSNewYearGetInfoResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSNewYearGetInfoResp::IsInitialized() const {

  return true;
}

void CSNewYearGetInfoResp::Swap(CSNewYearGetInfoResp* other) {
  if (other != this) {
    std::swap(starttime_, other->starttime_);
    std::swap(endtime_, other->endtime_);
    std::swap(conditionid_, other->conditionid_);
    std::swap(completecount_, other->completecount_);
    std::swap(curcount_, other->curcount_);
    std::swap(nextpackettag_, other->nextpackettag_);
    std::swap(awardid_, other->awardid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSNewYearGetInfoResp::GetTypeName() const {
  return "fgame.CSNewYearGetInfoResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSNewYearRewardReq::CSNewYearRewardReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSNewYearRewardReq)
}

void CSNewYearRewardReq::InitAsDefaultInstance() {
}

CSNewYearRewardReq::CSNewYearRewardReq(const CSNewYearRewardReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSNewYearRewardReq)
}

void CSNewYearRewardReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSNewYearRewardReq::~CSNewYearRewardReq() {
  // @@protoc_insertion_point(destructor:fgame.CSNewYearRewardReq)
  SharedDtor();
}

void CSNewYearRewardReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSNewYearRewardReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSNewYearRewardReq& CSNewYearRewardReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSNewYearRewardReq* CSNewYearRewardReq::default_instance_ = NULL;

CSNewYearRewardReq* CSNewYearRewardReq::New() const {
  return new CSNewYearRewardReq;
}

void CSNewYearRewardReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSNewYearRewardReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSNewYearRewardReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSNewYearRewardReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSNewYearRewardReq)
  return false;
#undef DO_
}

void CSNewYearRewardReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSNewYearRewardReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSNewYearRewardReq)
}

int CSNewYearRewardReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSNewYearRewardReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSNewYearRewardReq*>(&from));
}

void CSNewYearRewardReq::MergeFrom(const CSNewYearRewardReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSNewYearRewardReq::CopyFrom(const CSNewYearRewardReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSNewYearRewardReq::IsInitialized() const {

  return true;
}

void CSNewYearRewardReq::Swap(CSNewYearRewardReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSNewYearRewardReq::GetTypeName() const {
  return "fgame.CSNewYearRewardReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSNewYearRewardResp::kRetFieldNumber;
const int CSNewYearRewardResp::kNextTaskFieldNumber;
#endif  // !_MSC_VER

CSNewYearRewardResp::CSNewYearRewardResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSNewYearRewardResp)
}

void CSNewYearRewardResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  nexttask_ = const_cast< ::fgame::CSNewYearGetInfoResp*>(
      ::fgame::CSNewYearGetInfoResp::internal_default_instance());
#else
  nexttask_ = const_cast< ::fgame::CSNewYearGetInfoResp*>(&::fgame::CSNewYearGetInfoResp::default_instance());
#endif
}

CSNewYearRewardResp::CSNewYearRewardResp(const CSNewYearRewardResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSNewYearRewardResp)
}

void CSNewYearRewardResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  nexttask_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSNewYearRewardResp::~CSNewYearRewardResp() {
  // @@protoc_insertion_point(destructor:fgame.CSNewYearRewardResp)
  SharedDtor();
}

void CSNewYearRewardResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete nexttask_;
  }
}

void CSNewYearRewardResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSNewYearRewardResp& CSNewYearRewardResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSNewYearRewardResp* CSNewYearRewardResp::default_instance_ = NULL;

CSNewYearRewardResp* CSNewYearRewardResp::New() const {
  return new CSNewYearRewardResp;
}

void CSNewYearRewardResp::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    ret_ = 0u;
    if (has_nexttask()) {
      if (nexttask_ != NULL) nexttask_->::fgame::CSNewYearGetInfoResp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSNewYearRewardResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSNewYearRewardResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_nextTask;
        break;
      }

      // optional .fgame.CSNewYearGetInfoResp nextTask = 2;
      case 2: {
        if (tag == 18) {
         parse_nextTask:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_nexttask()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSNewYearRewardResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSNewYearRewardResp)
  return false;
#undef DO_
}

void CSNewYearRewardResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSNewYearRewardResp)
  // optional uint32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // optional .fgame.CSNewYearGetInfoResp nextTask = 2;
  if (has_nexttask()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->nexttask(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSNewYearRewardResp)
}

int CSNewYearRewardResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // optional .fgame.CSNewYearGetInfoResp nextTask = 2;
    if (has_nexttask()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->nexttask());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSNewYearRewardResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSNewYearRewardResp*>(&from));
}

void CSNewYearRewardResp::MergeFrom(const CSNewYearRewardResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_nexttask()) {
      mutable_nexttask()->::fgame::CSNewYearGetInfoResp::MergeFrom(from.nexttask());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSNewYearRewardResp::CopyFrom(const CSNewYearRewardResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSNewYearRewardResp::IsInitialized() const {

  return true;
}

void CSNewYearRewardResp::Swap(CSNewYearRewardResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(nexttask_, other->nexttask_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSNewYearRewardResp::GetTypeName() const {
  return "fgame.CSNewYearRewardResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSNewYearCmpReq::CSNewYearCmpReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSNewYearCmpReq)
}

void CSNewYearCmpReq::InitAsDefaultInstance() {
}

CSNewYearCmpReq::CSNewYearCmpReq(const CSNewYearCmpReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSNewYearCmpReq)
}

void CSNewYearCmpReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSNewYearCmpReq::~CSNewYearCmpReq() {
  // @@protoc_insertion_point(destructor:fgame.CSNewYearCmpReq)
  SharedDtor();
}

void CSNewYearCmpReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSNewYearCmpReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSNewYearCmpReq& CSNewYearCmpReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSNewYearCmpReq* CSNewYearCmpReq::default_instance_ = NULL;

CSNewYearCmpReq* CSNewYearCmpReq::New() const {
  return new CSNewYearCmpReq;
}

void CSNewYearCmpReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSNewYearCmpReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSNewYearCmpReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSNewYearCmpReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSNewYearCmpReq)
  return false;
#undef DO_
}

void CSNewYearCmpReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSNewYearCmpReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSNewYearCmpReq)
}

int CSNewYearCmpReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSNewYearCmpReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSNewYearCmpReq*>(&from));
}

void CSNewYearCmpReq::MergeFrom(const CSNewYearCmpReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSNewYearCmpReq::CopyFrom(const CSNewYearCmpReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSNewYearCmpReq::IsInitialized() const {

  return true;
}

void CSNewYearCmpReq::Swap(CSNewYearCmpReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSNewYearCmpReq::GetTypeName() const {
  return "fgame.CSNewYearCmpReq";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSNewYearCmpResp::CSNewYearCmpResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSNewYearCmpResp)
}

void CSNewYearCmpResp::InitAsDefaultInstance() {
}

CSNewYearCmpResp::CSNewYearCmpResp(const CSNewYearCmpResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSNewYearCmpResp)
}

void CSNewYearCmpResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSNewYearCmpResp::~CSNewYearCmpResp() {
  // @@protoc_insertion_point(destructor:fgame.CSNewYearCmpResp)
  SharedDtor();
}

void CSNewYearCmpResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSNewYearCmpResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSNewYearCmpResp& CSNewYearCmpResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSNewYearCmpResp* CSNewYearCmpResp::default_instance_ = NULL;

CSNewYearCmpResp* CSNewYearCmpResp::New() const {
  return new CSNewYearCmpResp;
}

void CSNewYearCmpResp::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSNewYearCmpResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSNewYearCmpResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSNewYearCmpResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSNewYearCmpResp)
  return false;
#undef DO_
}

void CSNewYearCmpResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSNewYearCmpResp)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSNewYearCmpResp)
}

int CSNewYearCmpResp::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSNewYearCmpResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSNewYearCmpResp*>(&from));
}

void CSNewYearCmpResp::MergeFrom(const CSNewYearCmpResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSNewYearCmpResp::CopyFrom(const CSNewYearCmpResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSNewYearCmpResp::IsInitialized() const {

  return true;
}

void CSNewYearCmpResp::Swap(CSNewYearCmpResp* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSNewYearCmpResp::GetTypeName() const {
  return "fgame.CSNewYearCmpResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSActivityCrazyDtlsReq::CSActivityCrazyDtlsReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSActivityCrazyDtlsReq)
}

void CSActivityCrazyDtlsReq::InitAsDefaultInstance() {
}

CSActivityCrazyDtlsReq::CSActivityCrazyDtlsReq(const CSActivityCrazyDtlsReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSActivityCrazyDtlsReq)
}

void CSActivityCrazyDtlsReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSActivityCrazyDtlsReq::~CSActivityCrazyDtlsReq() {
  // @@protoc_insertion_point(destructor:fgame.CSActivityCrazyDtlsReq)
  SharedDtor();
}

void CSActivityCrazyDtlsReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSActivityCrazyDtlsReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSActivityCrazyDtlsReq& CSActivityCrazyDtlsReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSActivityCrazyDtlsReq* CSActivityCrazyDtlsReq::default_instance_ = NULL;

CSActivityCrazyDtlsReq* CSActivityCrazyDtlsReq::New() const {
  return new CSActivityCrazyDtlsReq;
}

void CSActivityCrazyDtlsReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSActivityCrazyDtlsReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSActivityCrazyDtlsReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSActivityCrazyDtlsReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSActivityCrazyDtlsReq)
  return false;
#undef DO_
}

void CSActivityCrazyDtlsReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSActivityCrazyDtlsReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSActivityCrazyDtlsReq)
}

int CSActivityCrazyDtlsReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSActivityCrazyDtlsReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSActivityCrazyDtlsReq*>(&from));
}

void CSActivityCrazyDtlsReq::MergeFrom(const CSActivityCrazyDtlsReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSActivityCrazyDtlsReq::CopyFrom(const CSActivityCrazyDtlsReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSActivityCrazyDtlsReq::IsInitialized() const {

  return true;
}

void CSActivityCrazyDtlsReq::Swap(CSActivityCrazyDtlsReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSActivityCrazyDtlsReq::GetTypeName() const {
  return "fgame.CSActivityCrazyDtlsReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSActivityCrazyDtlsResp::kPointsFieldNumber;
const int CSActivityCrazyDtlsResp::kScoreFieldNumber;
const int CSActivityCrazyDtlsResp::kDayFieldNumber;
const int CSActivityCrazyDtlsResp::kRewardIdFieldNumber;
const int CSActivityCrazyDtlsResp::kUsableFieldNumber;
const int CSActivityCrazyDtlsResp::kConditionStateFieldNumber;
const int CSActivityCrazyDtlsResp::kSubConditionStateFieldNumber;
const int CSActivityCrazyDtlsResp::kCrazyTimeFieldNumber;
#endif  // !_MSC_VER

CSActivityCrazyDtlsResp::CSActivityCrazyDtlsResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSActivityCrazyDtlsResp)
}

void CSActivityCrazyDtlsResp::InitAsDefaultInstance() {
}

CSActivityCrazyDtlsResp::CSActivityCrazyDtlsResp(const CSActivityCrazyDtlsResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSActivityCrazyDtlsResp)
}

void CSActivityCrazyDtlsResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  points_ = 0u;
  score_ = 0u;
  day_ = 0u;
  rewardid_ = 0u;
  usable_ = 0u;
  conditionstate_ = 0u;
  subconditionstate_ = 0u;
  crazytime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSActivityCrazyDtlsResp::~CSActivityCrazyDtlsResp() {
  // @@protoc_insertion_point(destructor:fgame.CSActivityCrazyDtlsResp)
  SharedDtor();
}

void CSActivityCrazyDtlsResp::SharedDtor() {
  if (crazytime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete crazytime_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSActivityCrazyDtlsResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSActivityCrazyDtlsResp& CSActivityCrazyDtlsResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSActivityCrazyDtlsResp* CSActivityCrazyDtlsResp::default_instance_ = NULL;

CSActivityCrazyDtlsResp* CSActivityCrazyDtlsResp::New() const {
  return new CSActivityCrazyDtlsResp;
}

void CSActivityCrazyDtlsResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSActivityCrazyDtlsResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(points_, conditionstate_);
    subconditionstate_ = 0u;
    if (has_crazytime()) {
      if (crazytime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        crazytime_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSActivityCrazyDtlsResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSActivityCrazyDtlsResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 Points = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &points_)));
          set_has_points();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Score;
        break;
      }

      // optional uint32 Score = 2;
      case 2: {
        if (tag == 16) {
         parse_Score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Day;
        break;
      }

      // optional uint32 Day = 3;
      case 3: {
        if (tag == 24) {
         parse_Day:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &day_)));
          set_has_day();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_RewardId;
        break;
      }

      // optional uint32 RewardId = 4;
      case 4: {
        if (tag == 32) {
         parse_RewardId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rewardid_)));
          set_has_rewardid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_Usable;
        break;
      }

      // optional uint32 Usable = 5;
      case 5: {
        if (tag == 40) {
         parse_Usable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &usable_)));
          set_has_usable();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_ConditionState;
        break;
      }

      // optional uint32 ConditionState = 6;
      case 6: {
        if (tag == 48) {
         parse_ConditionState:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &conditionstate_)));
          set_has_conditionstate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_SubConditionState;
        break;
      }

      // optional uint32 SubConditionState = 7;
      case 7: {
        if (tag == 56) {
         parse_SubConditionState:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &subconditionstate_)));
          set_has_subconditionstate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_CrazyTime;
        break;
      }

      // optional string CrazyTime = 8;
      case 8: {
        if (tag == 66) {
         parse_CrazyTime:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_crazytime()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSActivityCrazyDtlsResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSActivityCrazyDtlsResp)
  return false;
#undef DO_
}

void CSActivityCrazyDtlsResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSActivityCrazyDtlsResp)
  // optional uint32 Points = 1;
  if (has_points()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->points(), output);
  }

  // optional uint32 Score = 2;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->score(), output);
  }

  // optional uint32 Day = 3;
  if (has_day()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->day(), output);
  }

  // optional uint32 RewardId = 4;
  if (has_rewardid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->rewardid(), output);
  }

  // optional uint32 Usable = 5;
  if (has_usable()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->usable(), output);
  }

  // optional uint32 ConditionState = 6;
  if (has_conditionstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->conditionstate(), output);
  }

  // optional uint32 SubConditionState = 7;
  if (has_subconditionstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->subconditionstate(), output);
  }

  // optional string CrazyTime = 8;
  if (has_crazytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->crazytime(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSActivityCrazyDtlsResp)
}

int CSActivityCrazyDtlsResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 Points = 1;
    if (has_points()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->points());
    }

    // optional uint32 Score = 2;
    if (has_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->score());
    }

    // optional uint32 Day = 3;
    if (has_day()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->day());
    }

    // optional uint32 RewardId = 4;
    if (has_rewardid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rewardid());
    }

    // optional uint32 Usable = 5;
    if (has_usable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->usable());
    }

    // optional uint32 ConditionState = 6;
    if (has_conditionstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->conditionstate());
    }

    // optional uint32 SubConditionState = 7;
    if (has_subconditionstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->subconditionstate());
    }

    // optional string CrazyTime = 8;
    if (has_crazytime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->crazytime());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSActivityCrazyDtlsResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSActivityCrazyDtlsResp*>(&from));
}

void CSActivityCrazyDtlsResp::MergeFrom(const CSActivityCrazyDtlsResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_points()) {
      set_points(from.points());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
    if (from.has_day()) {
      set_day(from.day());
    }
    if (from.has_rewardid()) {
      set_rewardid(from.rewardid());
    }
    if (from.has_usable()) {
      set_usable(from.usable());
    }
    if (from.has_conditionstate()) {
      set_conditionstate(from.conditionstate());
    }
    if (from.has_subconditionstate()) {
      set_subconditionstate(from.subconditionstate());
    }
    if (from.has_crazytime()) {
      set_crazytime(from.crazytime());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSActivityCrazyDtlsResp::CopyFrom(const CSActivityCrazyDtlsResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSActivityCrazyDtlsResp::IsInitialized() const {

  return true;
}

void CSActivityCrazyDtlsResp::Swap(CSActivityCrazyDtlsResp* other) {
  if (other != this) {
    std::swap(points_, other->points_);
    std::swap(score_, other->score_);
    std::swap(day_, other->day_);
    std::swap(rewardid_, other->rewardid_);
    std::swap(usable_, other->usable_);
    std::swap(conditionstate_, other->conditionstate_);
    std::swap(subconditionstate_, other->subconditionstate_);
    std::swap(crazytime_, other->crazytime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSActivityCrazyDtlsResp::GetTypeName() const {
  return "fgame.CSActivityCrazyDtlsResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSActivityCrazyUsageReq::kRewardIdFieldNumber;
#endif  // !_MSC_VER

CSActivityCrazyUsageReq::CSActivityCrazyUsageReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSActivityCrazyUsageReq)
}

void CSActivityCrazyUsageReq::InitAsDefaultInstance() {
}

CSActivityCrazyUsageReq::CSActivityCrazyUsageReq(const CSActivityCrazyUsageReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSActivityCrazyUsageReq)
}

void CSActivityCrazyUsageReq::SharedCtor() {
  _cached_size_ = 0;
  rewardid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSActivityCrazyUsageReq::~CSActivityCrazyUsageReq() {
  // @@protoc_insertion_point(destructor:fgame.CSActivityCrazyUsageReq)
  SharedDtor();
}

void CSActivityCrazyUsageReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSActivityCrazyUsageReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSActivityCrazyUsageReq& CSActivityCrazyUsageReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSActivityCrazyUsageReq* CSActivityCrazyUsageReq::default_instance_ = NULL;

CSActivityCrazyUsageReq* CSActivityCrazyUsageReq::New() const {
  return new CSActivityCrazyUsageReq;
}

void CSActivityCrazyUsageReq::Clear() {
  rewardid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSActivityCrazyUsageReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSActivityCrazyUsageReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 RewardId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rewardid_)));
          set_has_rewardid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSActivityCrazyUsageReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSActivityCrazyUsageReq)
  return false;
#undef DO_
}

void CSActivityCrazyUsageReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSActivityCrazyUsageReq)
  // optional uint32 RewardId = 1;
  if (has_rewardid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->rewardid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSActivityCrazyUsageReq)
}

int CSActivityCrazyUsageReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 RewardId = 1;
    if (has_rewardid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rewardid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSActivityCrazyUsageReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSActivityCrazyUsageReq*>(&from));
}

void CSActivityCrazyUsageReq::MergeFrom(const CSActivityCrazyUsageReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rewardid()) {
      set_rewardid(from.rewardid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSActivityCrazyUsageReq::CopyFrom(const CSActivityCrazyUsageReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSActivityCrazyUsageReq::IsInitialized() const {

  return true;
}

void CSActivityCrazyUsageReq::Swap(CSActivityCrazyUsageReq* other) {
  if (other != this) {
    std::swap(rewardid_, other->rewardid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSActivityCrazyUsageReq::GetTypeName() const {
  return "fgame.CSActivityCrazyUsageReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSActivityCrazyUsageResp::kPointsFieldNumber;
const int CSActivityCrazyUsageResp::kGiftIdFieldNumber;
#endif  // !_MSC_VER

CSActivityCrazyUsageResp::CSActivityCrazyUsageResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSActivityCrazyUsageResp)
}

void CSActivityCrazyUsageResp::InitAsDefaultInstance() {
}

CSActivityCrazyUsageResp::CSActivityCrazyUsageResp(const CSActivityCrazyUsageResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSActivityCrazyUsageResp)
}

void CSActivityCrazyUsageResp::SharedCtor() {
  _cached_size_ = 0;
  points_ = 0u;
  giftid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSActivityCrazyUsageResp::~CSActivityCrazyUsageResp() {
  // @@protoc_insertion_point(destructor:fgame.CSActivityCrazyUsageResp)
  SharedDtor();
}

void CSActivityCrazyUsageResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSActivityCrazyUsageResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSActivityCrazyUsageResp& CSActivityCrazyUsageResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSActivityCrazyUsageResp* CSActivityCrazyUsageResp::default_instance_ = NULL;

CSActivityCrazyUsageResp* CSActivityCrazyUsageResp::New() const {
  return new CSActivityCrazyUsageResp;
}

void CSActivityCrazyUsageResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSActivityCrazyUsageResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(points_, giftid_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSActivityCrazyUsageResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSActivityCrazyUsageResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 Points = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &points_)));
          set_has_points();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_GiftId;
        break;
      }

      // optional uint32 GiftId = 2;
      case 2: {
        if (tag == 16) {
         parse_GiftId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &giftid_)));
          set_has_giftid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSActivityCrazyUsageResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSActivityCrazyUsageResp)
  return false;
#undef DO_
}

void CSActivityCrazyUsageResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSActivityCrazyUsageResp)
  // optional uint32 Points = 1;
  if (has_points()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->points(), output);
  }

  // optional uint32 GiftId = 2;
  if (has_giftid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->giftid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSActivityCrazyUsageResp)
}

int CSActivityCrazyUsageResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 Points = 1;
    if (has_points()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->points());
    }

    // optional uint32 GiftId = 2;
    if (has_giftid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->giftid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSActivityCrazyUsageResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSActivityCrazyUsageResp*>(&from));
}

void CSActivityCrazyUsageResp::MergeFrom(const CSActivityCrazyUsageResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_points()) {
      set_points(from.points());
    }
    if (from.has_giftid()) {
      set_giftid(from.giftid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSActivityCrazyUsageResp::CopyFrom(const CSActivityCrazyUsageResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSActivityCrazyUsageResp::IsInitialized() const {

  return true;
}

void CSActivityCrazyUsageResp::Swap(CSActivityCrazyUsageResp* other) {
  if (other != this) {
    std::swap(points_, other->points_);
    std::swap(giftid_, other->giftid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSActivityCrazyUsageResp::GetTypeName() const {
  return "fgame.CSActivityCrazyUsageResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSActivityCrazyUsableResp::kConditionStateFieldNumber;
const int CSActivityCrazyUsableResp::kSubConditionStateFieldNumber;
const int CSActivityCrazyUsableResp::kUsableFieldNumber;
const int CSActivityCrazyUsableResp::kExtraScoreFieldNumber;
#endif  // !_MSC_VER

CSActivityCrazyUsableResp::CSActivityCrazyUsableResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSActivityCrazyUsableResp)
}

void CSActivityCrazyUsableResp::InitAsDefaultInstance() {
}

CSActivityCrazyUsableResp::CSActivityCrazyUsableResp(const CSActivityCrazyUsableResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSActivityCrazyUsableResp)
}

void CSActivityCrazyUsableResp::SharedCtor() {
  _cached_size_ = 0;
  conditionstate_ = 0u;
  subconditionstate_ = 0u;
  usable_ = 0u;
  extrascore_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSActivityCrazyUsableResp::~CSActivityCrazyUsableResp() {
  // @@protoc_insertion_point(destructor:fgame.CSActivityCrazyUsableResp)
  SharedDtor();
}

void CSActivityCrazyUsableResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSActivityCrazyUsableResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSActivityCrazyUsableResp& CSActivityCrazyUsableResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSActivityCrazyUsableResp* CSActivityCrazyUsableResp::default_instance_ = NULL;

CSActivityCrazyUsableResp* CSActivityCrazyUsableResp::New() const {
  return new CSActivityCrazyUsableResp;
}

void CSActivityCrazyUsableResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSActivityCrazyUsableResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(conditionstate_, extrascore_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSActivityCrazyUsableResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSActivityCrazyUsableResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 ConditionState = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &conditionstate_)));
          set_has_conditionstate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_SubConditionState;
        break;
      }

      // optional uint32 SubConditionState = 2;
      case 2: {
        if (tag == 16) {
         parse_SubConditionState:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &subconditionstate_)));
          set_has_subconditionstate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Usable;
        break;
      }

      // optional uint32 Usable = 3;
      case 3: {
        if (tag == 24) {
         parse_Usable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &usable_)));
          set_has_usable();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_ExtraScore;
        break;
      }

      // optional uint32 ExtraScore = 4;
      case 4: {
        if (tag == 32) {
         parse_ExtraScore:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &extrascore_)));
          set_has_extrascore();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSActivityCrazyUsableResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSActivityCrazyUsableResp)
  return false;
#undef DO_
}

void CSActivityCrazyUsableResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSActivityCrazyUsableResp)
  // optional uint32 ConditionState = 1;
  if (has_conditionstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->conditionstate(), output);
  }

  // optional uint32 SubConditionState = 2;
  if (has_subconditionstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->subconditionstate(), output);
  }

  // optional uint32 Usable = 3;
  if (has_usable()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->usable(), output);
  }

  // optional uint32 ExtraScore = 4;
  if (has_extrascore()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->extrascore(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSActivityCrazyUsableResp)
}

int CSActivityCrazyUsableResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 ConditionState = 1;
    if (has_conditionstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->conditionstate());
    }

    // optional uint32 SubConditionState = 2;
    if (has_subconditionstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->subconditionstate());
    }

    // optional uint32 Usable = 3;
    if (has_usable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->usable());
    }

    // optional uint32 ExtraScore = 4;
    if (has_extrascore()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->extrascore());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSActivityCrazyUsableResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSActivityCrazyUsableResp*>(&from));
}

void CSActivityCrazyUsableResp::MergeFrom(const CSActivityCrazyUsableResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_conditionstate()) {
      set_conditionstate(from.conditionstate());
    }
    if (from.has_subconditionstate()) {
      set_subconditionstate(from.subconditionstate());
    }
    if (from.has_usable()) {
      set_usable(from.usable());
    }
    if (from.has_extrascore()) {
      set_extrascore(from.extrascore());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSActivityCrazyUsableResp::CopyFrom(const CSActivityCrazyUsableResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSActivityCrazyUsableResp::IsInitialized() const {

  return true;
}

void CSActivityCrazyUsableResp::Swap(CSActivityCrazyUsableResp* other) {
  if (other != this) {
    std::swap(conditionstate_, other->conditionstate_);
    std::swap(subconditionstate_, other->subconditionstate_);
    std::swap(usable_, other->usable_);
    std::swap(extrascore_, other->extrascore_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSActivityCrazyUsableResp::GetTypeName() const {
  return "fgame.CSActivityCrazyUsableResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSOpenChestReq::kItemIdFieldNumber;
const int CSOpenChestReq::kCountFieldNumber;
#endif  // !_MSC_VER

CSOpenChestReq::CSOpenChestReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSOpenChestReq)
}

void CSOpenChestReq::InitAsDefaultInstance() {
}

CSOpenChestReq::CSOpenChestReq(const CSOpenChestReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSOpenChestReq)
}

void CSOpenChestReq::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0;
  count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSOpenChestReq::~CSOpenChestReq() {
  // @@protoc_insertion_point(destructor:fgame.CSOpenChestReq)
  SharedDtor();
}

void CSOpenChestReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSOpenChestReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSOpenChestReq& CSOpenChestReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSOpenChestReq* CSOpenChestReq::default_instance_ = NULL;

CSOpenChestReq* CSOpenChestReq::New() const {
  return new CSOpenChestReq;
}

void CSOpenChestReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSOpenChestReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(itemid_, count_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSOpenChestReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSOpenChestReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ItemId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Count;
        break;
      }

      // optional int32 Count = 2;
      case 2: {
        if (tag == 16) {
         parse_Count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSOpenChestReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSOpenChestReq)
  return false;
#undef DO_
}

void CSOpenChestReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSOpenChestReq)
  // required int32 ItemId = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->itemid(), output);
  }

  // optional int32 Count = 2;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->count(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSOpenChestReq)
}

int CSOpenChestReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ItemId = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // optional int32 Count = 2;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSOpenChestReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSOpenChestReq*>(&from));
}

void CSOpenChestReq::MergeFrom(const CSOpenChestReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSOpenChestReq::CopyFrom(const CSOpenChestReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOpenChestReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSOpenChestReq::Swap(CSOpenChestReq* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSOpenChestReq::GetTypeName() const {
  return "fgame.CSOpenChestReq";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSRedPacketsGetInfoReq::CSRedPacketsGetInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRedPacketsGetInfoReq)
}

void CSRedPacketsGetInfoReq::InitAsDefaultInstance() {
}

CSRedPacketsGetInfoReq::CSRedPacketsGetInfoReq(const CSRedPacketsGetInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRedPacketsGetInfoReq)
}

void CSRedPacketsGetInfoReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRedPacketsGetInfoReq::~CSRedPacketsGetInfoReq() {
  // @@protoc_insertion_point(destructor:fgame.CSRedPacketsGetInfoReq)
  SharedDtor();
}

void CSRedPacketsGetInfoReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRedPacketsGetInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRedPacketsGetInfoReq& CSRedPacketsGetInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSRedPacketsGetInfoReq* CSRedPacketsGetInfoReq::default_instance_ = NULL;

CSRedPacketsGetInfoReq* CSRedPacketsGetInfoReq::New() const {
  return new CSRedPacketsGetInfoReq;
}

void CSRedPacketsGetInfoReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRedPacketsGetInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRedPacketsGetInfoReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRedPacketsGetInfoReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRedPacketsGetInfoReq)
  return false;
#undef DO_
}

void CSRedPacketsGetInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRedPacketsGetInfoReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRedPacketsGetInfoReq)
}

int CSRedPacketsGetInfoReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRedPacketsGetInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRedPacketsGetInfoReq*>(&from));
}

void CSRedPacketsGetInfoReq::MergeFrom(const CSRedPacketsGetInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRedPacketsGetInfoReq::CopyFrom(const CSRedPacketsGetInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRedPacketsGetInfoReq::IsInitialized() const {

  return true;
}

void CSRedPacketsGetInfoReq::Swap(CSRedPacketsGetInfoReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRedPacketsGetInfoReq::GetTypeName() const {
  return "fgame.CSRedPacketsGetInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSRedPacketsGetInfoResp::kStatusFieldNumber;
const int CSRedPacketsGetInfoResp::kValueFieldNumber;
const int CSRedPacketsGetInfoResp::kTimeFieldNumber;
#endif  // !_MSC_VER

CSRedPacketsGetInfoResp::CSRedPacketsGetInfoResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRedPacketsGetInfoResp)
}

void CSRedPacketsGetInfoResp::InitAsDefaultInstance() {
}

CSRedPacketsGetInfoResp::CSRedPacketsGetInfoResp(const CSRedPacketsGetInfoResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRedPacketsGetInfoResp)
}

void CSRedPacketsGetInfoResp::SharedCtor() {
  _cached_size_ = 0;
  status_ = 0u;
  value_ = 0u;
  time_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRedPacketsGetInfoResp::~CSRedPacketsGetInfoResp() {
  // @@protoc_insertion_point(destructor:fgame.CSRedPacketsGetInfoResp)
  SharedDtor();
}

void CSRedPacketsGetInfoResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRedPacketsGetInfoResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRedPacketsGetInfoResp& CSRedPacketsGetInfoResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSRedPacketsGetInfoResp* CSRedPacketsGetInfoResp::default_instance_ = NULL;

CSRedPacketsGetInfoResp* CSRedPacketsGetInfoResp::New() const {
  return new CSRedPacketsGetInfoResp;
}

void CSRedPacketsGetInfoResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSRedPacketsGetInfoResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(status_, time_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRedPacketsGetInfoResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRedPacketsGetInfoResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 status = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_value;
        break;
      }

      // optional uint32 value = 2;
      case 2: {
        if (tag == 16) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_time;
        break;
      }

      // optional uint32 time = 3;
      case 3: {
        if (tag == 24) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRedPacketsGetInfoResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRedPacketsGetInfoResp)
  return false;
#undef DO_
}

void CSRedPacketsGetInfoResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRedPacketsGetInfoResp)
  // optional uint32 status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->status(), output);
  }

  // optional uint32 value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->value(), output);
  }

  // optional uint32 time = 3;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->time(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRedPacketsGetInfoResp)
}

int CSRedPacketsGetInfoResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->status());
    }

    // optional uint32 value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

    // optional uint32 time = 3;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRedPacketsGetInfoResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRedPacketsGetInfoResp*>(&from));
}

void CSRedPacketsGetInfoResp::MergeFrom(const CSRedPacketsGetInfoResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRedPacketsGetInfoResp::CopyFrom(const CSRedPacketsGetInfoResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRedPacketsGetInfoResp::IsInitialized() const {

  return true;
}

void CSRedPacketsGetInfoResp::Swap(CSRedPacketsGetInfoResp* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(value_, other->value_);
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRedPacketsGetInfoResp::GetTypeName() const {
  return "fgame.CSRedPacketsGetInfoResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSRedPacketsGrebReq::CSRedPacketsGrebReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRedPacketsGrebReq)
}

void CSRedPacketsGrebReq::InitAsDefaultInstance() {
}

CSRedPacketsGrebReq::CSRedPacketsGrebReq(const CSRedPacketsGrebReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRedPacketsGrebReq)
}

void CSRedPacketsGrebReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRedPacketsGrebReq::~CSRedPacketsGrebReq() {
  // @@protoc_insertion_point(destructor:fgame.CSRedPacketsGrebReq)
  SharedDtor();
}

void CSRedPacketsGrebReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRedPacketsGrebReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRedPacketsGrebReq& CSRedPacketsGrebReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSRedPacketsGrebReq* CSRedPacketsGrebReq::default_instance_ = NULL;

CSRedPacketsGrebReq* CSRedPacketsGrebReq::New() const {
  return new CSRedPacketsGrebReq;
}

void CSRedPacketsGrebReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRedPacketsGrebReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRedPacketsGrebReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRedPacketsGrebReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRedPacketsGrebReq)
  return false;
#undef DO_
}

void CSRedPacketsGrebReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRedPacketsGrebReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRedPacketsGrebReq)
}

int CSRedPacketsGrebReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRedPacketsGrebReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRedPacketsGrebReq*>(&from));
}

void CSRedPacketsGrebReq::MergeFrom(const CSRedPacketsGrebReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRedPacketsGrebReq::CopyFrom(const CSRedPacketsGrebReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRedPacketsGrebReq::IsInitialized() const {

  return true;
}

void CSRedPacketsGrebReq::Swap(CSRedPacketsGrebReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRedPacketsGrebReq::GetTypeName() const {
  return "fgame.CSRedPacketsGrebReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSRedPacketsGrebResp::kRetFieldNumber;
const int CSRedPacketsGrebResp::kValueFieldNumber;
#endif  // !_MSC_VER

CSRedPacketsGrebResp::CSRedPacketsGrebResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRedPacketsGrebResp)
}

void CSRedPacketsGrebResp::InitAsDefaultInstance() {
}

CSRedPacketsGrebResp::CSRedPacketsGrebResp(const CSRedPacketsGrebResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRedPacketsGrebResp)
}

void CSRedPacketsGrebResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRedPacketsGrebResp::~CSRedPacketsGrebResp() {
  // @@protoc_insertion_point(destructor:fgame.CSRedPacketsGrebResp)
  SharedDtor();
}

void CSRedPacketsGrebResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRedPacketsGrebResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRedPacketsGrebResp& CSRedPacketsGrebResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSRedPacketsGrebResp* CSRedPacketsGrebResp::default_instance_ = NULL;

CSRedPacketsGrebResp* CSRedPacketsGrebResp::New() const {
  return new CSRedPacketsGrebResp;
}

void CSRedPacketsGrebResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSRedPacketsGrebResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ret_, value_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRedPacketsGrebResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRedPacketsGrebResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_value;
        break;
      }

      // optional uint32 value = 2;
      case 2: {
        if (tag == 16) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRedPacketsGrebResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRedPacketsGrebResp)
  return false;
#undef DO_
}

void CSRedPacketsGrebResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRedPacketsGrebResp)
  // optional uint32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // optional uint32 value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->value(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRedPacketsGrebResp)
}

int CSRedPacketsGrebResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // optional uint32 value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRedPacketsGrebResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRedPacketsGrebResp*>(&from));
}

void CSRedPacketsGrebResp::MergeFrom(const CSRedPacketsGrebResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRedPacketsGrebResp::CopyFrom(const CSRedPacketsGrebResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRedPacketsGrebResp::IsInitialized() const {

  return true;
}

void CSRedPacketsGrebResp::Swap(CSRedPacketsGrebResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRedPacketsGrebResp::GetTypeName() const {
  return "fgame.CSRedPacketsGrebResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSRedPacketsOpenedReq::CSRedPacketsOpenedReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRedPacketsOpenedReq)
}

void CSRedPacketsOpenedReq::InitAsDefaultInstance() {
}

CSRedPacketsOpenedReq::CSRedPacketsOpenedReq(const CSRedPacketsOpenedReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRedPacketsOpenedReq)
}

void CSRedPacketsOpenedReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRedPacketsOpenedReq::~CSRedPacketsOpenedReq() {
  // @@protoc_insertion_point(destructor:fgame.CSRedPacketsOpenedReq)
  SharedDtor();
}

void CSRedPacketsOpenedReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRedPacketsOpenedReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRedPacketsOpenedReq& CSRedPacketsOpenedReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSRedPacketsOpenedReq* CSRedPacketsOpenedReq::default_instance_ = NULL;

CSRedPacketsOpenedReq* CSRedPacketsOpenedReq::New() const {
  return new CSRedPacketsOpenedReq;
}

void CSRedPacketsOpenedReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRedPacketsOpenedReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRedPacketsOpenedReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRedPacketsOpenedReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRedPacketsOpenedReq)
  return false;
#undef DO_
}

void CSRedPacketsOpenedReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRedPacketsOpenedReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRedPacketsOpenedReq)
}

int CSRedPacketsOpenedReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRedPacketsOpenedReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRedPacketsOpenedReq*>(&from));
}

void CSRedPacketsOpenedReq::MergeFrom(const CSRedPacketsOpenedReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRedPacketsOpenedReq::CopyFrom(const CSRedPacketsOpenedReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRedPacketsOpenedReq::IsInitialized() const {

  return true;
}

void CSRedPacketsOpenedReq::Swap(CSRedPacketsOpenedReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRedPacketsOpenedReq::GetTypeName() const {
  return "fgame.CSRedPacketsOpenedReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSRedPacketsOpenedResp::kStartTimeFieldNumber;
const int CSRedPacketsOpenedResp::kEndTimeFieldNumber;
#endif  // !_MSC_VER

CSRedPacketsOpenedResp::CSRedPacketsOpenedResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRedPacketsOpenedResp)
}

void CSRedPacketsOpenedResp::InitAsDefaultInstance() {
}

CSRedPacketsOpenedResp::CSRedPacketsOpenedResp(const CSRedPacketsOpenedResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRedPacketsOpenedResp)
}

void CSRedPacketsOpenedResp::SharedCtor() {
  _cached_size_ = 0;
  starttime_ = 0u;
  endtime_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRedPacketsOpenedResp::~CSRedPacketsOpenedResp() {
  // @@protoc_insertion_point(destructor:fgame.CSRedPacketsOpenedResp)
  SharedDtor();
}

void CSRedPacketsOpenedResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRedPacketsOpenedResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRedPacketsOpenedResp& CSRedPacketsOpenedResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSRedPacketsOpenedResp* CSRedPacketsOpenedResp::default_instance_ = NULL;

CSRedPacketsOpenedResp* CSRedPacketsOpenedResp::New() const {
  return new CSRedPacketsOpenedResp;
}

void CSRedPacketsOpenedResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSRedPacketsOpenedResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(starttime_, endtime_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRedPacketsOpenedResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRedPacketsOpenedResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 startTime = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &starttime_)));
          set_has_starttime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_endTime;
        break;
      }

      // optional uint32 endTime = 2;
      case 2: {
        if (tag == 16) {
         parse_endTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endtime_)));
          set_has_endtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRedPacketsOpenedResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRedPacketsOpenedResp)
  return false;
#undef DO_
}

void CSRedPacketsOpenedResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRedPacketsOpenedResp)
  // optional uint32 startTime = 1;
  if (has_starttime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->starttime(), output);
  }

  // optional uint32 endTime = 2;
  if (has_endtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->endtime(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRedPacketsOpenedResp)
}

int CSRedPacketsOpenedResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 startTime = 1;
    if (has_starttime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->starttime());
    }

    // optional uint32 endTime = 2;
    if (has_endtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endtime());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRedPacketsOpenedResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRedPacketsOpenedResp*>(&from));
}

void CSRedPacketsOpenedResp::MergeFrom(const CSRedPacketsOpenedResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_starttime()) {
      set_starttime(from.starttime());
    }
    if (from.has_endtime()) {
      set_endtime(from.endtime());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRedPacketsOpenedResp::CopyFrom(const CSRedPacketsOpenedResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRedPacketsOpenedResp::IsInitialized() const {

  return true;
}

void CSRedPacketsOpenedResp::Swap(CSRedPacketsOpenedResp* other) {
  if (other != this) {
    std::swap(starttime_, other->starttime_);
    std::swap(endtime_, other->endtime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRedPacketsOpenedResp::GetTypeName() const {
  return "fgame.CSRedPacketsOpenedResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSChristmasDecorateReq::kTypeFieldNumber;
const int CSChristmasDecorateReq::kCountFieldNumber;
#endif  // !_MSC_VER

CSChristmasDecorateReq::CSChristmasDecorateReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSChristmasDecorateReq)
}

void CSChristmasDecorateReq::InitAsDefaultInstance() {
}

CSChristmasDecorateReq::CSChristmasDecorateReq(const CSChristmasDecorateReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSChristmasDecorateReq)
}

void CSChristmasDecorateReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSChristmasDecorateReq::~CSChristmasDecorateReq() {
  // @@protoc_insertion_point(destructor:fgame.CSChristmasDecorateReq)
  SharedDtor();
}

void CSChristmasDecorateReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSChristmasDecorateReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSChristmasDecorateReq& CSChristmasDecorateReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSChristmasDecorateReq* CSChristmasDecorateReq::default_instance_ = NULL;

CSChristmasDecorateReq* CSChristmasDecorateReq::New() const {
  return new CSChristmasDecorateReq;
}

void CSChristmasDecorateReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSChristmasDecorateReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(type_, count_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSChristmasDecorateReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSChristmasDecorateReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 Type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Count;
        break;
      }

      // optional int32 Count = 2;
      case 2: {
        if (tag == 16) {
         parse_Count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSChristmasDecorateReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSChristmasDecorateReq)
  return false;
#undef DO_
}

void CSChristmasDecorateReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSChristmasDecorateReq)
  // required int32 Type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // optional int32 Count = 2;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->count(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSChristmasDecorateReq)
}

int CSChristmasDecorateReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 Type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int32 Count = 2;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSChristmasDecorateReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSChristmasDecorateReq*>(&from));
}

void CSChristmasDecorateReq::MergeFrom(const CSChristmasDecorateReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSChristmasDecorateReq::CopyFrom(const CSChristmasDecorateReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSChristmasDecorateReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSChristmasDecorateReq::Swap(CSChristmasDecorateReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSChristmasDecorateReq::GetTypeName() const {
  return "fgame.CSChristmasDecorateReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSChristmasDecorateResp::kScoreFieldNumber;
const int CSChristmasDecorateResp::kUpdateDataFieldNumber;
#endif  // !_MSC_VER

CSChristmasDecorateResp::CSChristmasDecorateResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSChristmasDecorateResp)
}

void CSChristmasDecorateResp::InitAsDefaultInstance() {
}

CSChristmasDecorateResp::CSChristmasDecorateResp(const CSChristmasDecorateResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSChristmasDecorateResp)
}

void CSChristmasDecorateResp::SharedCtor() {
  _cached_size_ = 0;
  score_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSChristmasDecorateResp::~CSChristmasDecorateResp() {
  // @@protoc_insertion_point(destructor:fgame.CSChristmasDecorateResp)
  SharedDtor();
}

void CSChristmasDecorateResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSChristmasDecorateResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSChristmasDecorateResp& CSChristmasDecorateResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSChristmasDecorateResp* CSChristmasDecorateResp::default_instance_ = NULL;

CSChristmasDecorateResp* CSChristmasDecorateResp::New() const {
  return new CSChristmasDecorateResp;
}

void CSChristmasDecorateResp::Clear() {
  score_ = 0;
  updatedata_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSChristmasDecorateResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSChristmasDecorateResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 Score = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_UpdateData;
        break;
      }

      // repeated .fgame.PropertyUpdateData UpdateData = 2;
      case 2: {
        if (tag == 18) {
         parse_UpdateData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_updatedata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_UpdateData;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSChristmasDecorateResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSChristmasDecorateResp)
  return false;
#undef DO_
}

void CSChristmasDecorateResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSChristmasDecorateResp)
  // required int32 Score = 1;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->score(), output);
  }

  // repeated .fgame.PropertyUpdateData UpdateData = 2;
  for (int i = 0; i < this->updatedata_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->updatedata(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSChristmasDecorateResp)
}

int CSChristmasDecorateResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 Score = 1;
    if (has_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->score());
    }

  }
  // repeated .fgame.PropertyUpdateData UpdateData = 2;
  total_size += 1 * this->updatedata_size();
  for (int i = 0; i < this->updatedata_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->updatedata(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSChristmasDecorateResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSChristmasDecorateResp*>(&from));
}

void CSChristmasDecorateResp::MergeFrom(const CSChristmasDecorateResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  updatedata_.MergeFrom(from.updatedata_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_score()) {
      set_score(from.score());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSChristmasDecorateResp::CopyFrom(const CSChristmasDecorateResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSChristmasDecorateResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->updatedata())) return false;
  return true;
}

void CSChristmasDecorateResp::Swap(CSChristmasDecorateResp* other) {
  if (other != this) {
    std::swap(score_, other->score_);
    updatedata_.Swap(&other->updatedata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSChristmasDecorateResp::GetTypeName() const {
  return "fgame.CSChristmasDecorateResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSChristmasTakeBonusReq::kLevelFieldNumber;
#endif  // !_MSC_VER

CSChristmasTakeBonusReq::CSChristmasTakeBonusReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSChristmasTakeBonusReq)
}

void CSChristmasTakeBonusReq::InitAsDefaultInstance() {
}

CSChristmasTakeBonusReq::CSChristmasTakeBonusReq(const CSChristmasTakeBonusReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSChristmasTakeBonusReq)
}

void CSChristmasTakeBonusReq::SharedCtor() {
  _cached_size_ = 0;
  level_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSChristmasTakeBonusReq::~CSChristmasTakeBonusReq() {
  // @@protoc_insertion_point(destructor:fgame.CSChristmasTakeBonusReq)
  SharedDtor();
}

void CSChristmasTakeBonusReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSChristmasTakeBonusReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSChristmasTakeBonusReq& CSChristmasTakeBonusReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSChristmasTakeBonusReq* CSChristmasTakeBonusReq::default_instance_ = NULL;

CSChristmasTakeBonusReq* CSChristmasTakeBonusReq::New() const {
  return new CSChristmasTakeBonusReq;
}

void CSChristmasTakeBonusReq::Clear() {
  level_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSChristmasTakeBonusReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSChristmasTakeBonusReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 Level = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSChristmasTakeBonusReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSChristmasTakeBonusReq)
  return false;
#undef DO_
}

void CSChristmasTakeBonusReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSChristmasTakeBonusReq)
  // required int32 Level = 1;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->level(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSChristmasTakeBonusReq)
}

int CSChristmasTakeBonusReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 Level = 1;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->level());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSChristmasTakeBonusReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSChristmasTakeBonusReq*>(&from));
}

void CSChristmasTakeBonusReq::MergeFrom(const CSChristmasTakeBonusReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_level()) {
      set_level(from.level());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSChristmasTakeBonusReq::CopyFrom(const CSChristmasTakeBonusReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSChristmasTakeBonusReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSChristmasTakeBonusReq::Swap(CSChristmasTakeBonusReq* other) {
  if (other != this) {
    std::swap(level_, other->level_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSChristmasTakeBonusReq::GetTypeName() const {
  return "fgame.CSChristmasTakeBonusReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSChristmasTakeBonusResp::kUpdateDataFieldNumber;
#endif  // !_MSC_VER

CSChristmasTakeBonusResp::CSChristmasTakeBonusResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSChristmasTakeBonusResp)
}

void CSChristmasTakeBonusResp::InitAsDefaultInstance() {
}

CSChristmasTakeBonusResp::CSChristmasTakeBonusResp(const CSChristmasTakeBonusResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSChristmasTakeBonusResp)
}

void CSChristmasTakeBonusResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSChristmasTakeBonusResp::~CSChristmasTakeBonusResp() {
  // @@protoc_insertion_point(destructor:fgame.CSChristmasTakeBonusResp)
  SharedDtor();
}

void CSChristmasTakeBonusResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSChristmasTakeBonusResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSChristmasTakeBonusResp& CSChristmasTakeBonusResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSChristmasTakeBonusResp* CSChristmasTakeBonusResp::default_instance_ = NULL;

CSChristmasTakeBonusResp* CSChristmasTakeBonusResp::New() const {
  return new CSChristmasTakeBonusResp;
}

void CSChristmasTakeBonusResp::Clear() {
  updatedata_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSChristmasTakeBonusResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSChristmasTakeBonusResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.PropertyUpdateData UpdateData = 1;
      case 1: {
        if (tag == 10) {
         parse_UpdateData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_updatedata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_UpdateData;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSChristmasTakeBonusResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSChristmasTakeBonusResp)
  return false;
#undef DO_
}

void CSChristmasTakeBonusResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSChristmasTakeBonusResp)
  // repeated .fgame.PropertyUpdateData UpdateData = 1;
  for (int i = 0; i < this->updatedata_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->updatedata(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSChristmasTakeBonusResp)
}

int CSChristmasTakeBonusResp::ByteSize() const {
  int total_size = 0;

  // repeated .fgame.PropertyUpdateData UpdateData = 1;
  total_size += 1 * this->updatedata_size();
  for (int i = 0; i < this->updatedata_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->updatedata(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSChristmasTakeBonusResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSChristmasTakeBonusResp*>(&from));
}

void CSChristmasTakeBonusResp::MergeFrom(const CSChristmasTakeBonusResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  updatedata_.MergeFrom(from.updatedata_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSChristmasTakeBonusResp::CopyFrom(const CSChristmasTakeBonusResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSChristmasTakeBonusResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->updatedata())) return false;
  return true;
}

void CSChristmasTakeBonusResp::Swap(CSChristmasTakeBonusResp* other) {
  if (other != this) {
    updatedata_.Swap(&other->updatedata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSChristmasTakeBonusResp::GetTypeName() const {
  return "fgame.CSChristmasTakeBonusResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSChristmasGetDataReq::CSChristmasGetDataReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSChristmasGetDataReq)
}

void CSChristmasGetDataReq::InitAsDefaultInstance() {
}

CSChristmasGetDataReq::CSChristmasGetDataReq(const CSChristmasGetDataReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSChristmasGetDataReq)
}

void CSChristmasGetDataReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSChristmasGetDataReq::~CSChristmasGetDataReq() {
  // @@protoc_insertion_point(destructor:fgame.CSChristmasGetDataReq)
  SharedDtor();
}

void CSChristmasGetDataReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSChristmasGetDataReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSChristmasGetDataReq& CSChristmasGetDataReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSChristmasGetDataReq* CSChristmasGetDataReq::default_instance_ = NULL;

CSChristmasGetDataReq* CSChristmasGetDataReq::New() const {
  return new CSChristmasGetDataReq;
}

void CSChristmasGetDataReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSChristmasGetDataReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSChristmasGetDataReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSChristmasGetDataReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSChristmasGetDataReq)
  return false;
#undef DO_
}

void CSChristmasGetDataReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSChristmasGetDataReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSChristmasGetDataReq)
}

int CSChristmasGetDataReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSChristmasGetDataReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSChristmasGetDataReq*>(&from));
}

void CSChristmasGetDataReq::MergeFrom(const CSChristmasGetDataReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSChristmasGetDataReq::CopyFrom(const CSChristmasGetDataReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSChristmasGetDataReq::IsInitialized() const {

  return true;
}

void CSChristmasGetDataReq::Swap(CSChristmasGetDataReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSChristmasGetDataReq::GetTypeName() const {
  return "fgame.CSChristmasGetDataReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ChristmasTakeRecord::kLevelFieldNumber;
const int ChristmasTakeRecord::kIsTakeFieldNumber;
#endif  // !_MSC_VER

ChristmasTakeRecord::ChristmasTakeRecord()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.ChristmasTakeRecord)
}

void ChristmasTakeRecord::InitAsDefaultInstance() {
}

ChristmasTakeRecord::ChristmasTakeRecord(const ChristmasTakeRecord& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.ChristmasTakeRecord)
}

void ChristmasTakeRecord::SharedCtor() {
  _cached_size_ = 0;
  level_ = 0;
  istake_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChristmasTakeRecord::~ChristmasTakeRecord() {
  // @@protoc_insertion_point(destructor:fgame.ChristmasTakeRecord)
  SharedDtor();
}

void ChristmasTakeRecord::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChristmasTakeRecord::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChristmasTakeRecord& ChristmasTakeRecord::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

ChristmasTakeRecord* ChristmasTakeRecord::default_instance_ = NULL;

ChristmasTakeRecord* ChristmasTakeRecord::New() const {
  return new ChristmasTakeRecord;
}

void ChristmasTakeRecord::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ChristmasTakeRecord*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(level_, istake_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ChristmasTakeRecord::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.ChristmasTakeRecord)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 Level = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_IsTake;
        break;
      }

      // required bool IsTake = 2;
      case 2: {
        if (tag == 16) {
         parse_IsTake:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &istake_)));
          set_has_istake();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.ChristmasTakeRecord)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.ChristmasTakeRecord)
  return false;
#undef DO_
}

void ChristmasTakeRecord::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.ChristmasTakeRecord)
  // required int32 Level = 1;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->level(), output);
  }

  // required bool IsTake = 2;
  if (has_istake()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->istake(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.ChristmasTakeRecord)
}

int ChristmasTakeRecord::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 Level = 1;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->level());
    }

    // required bool IsTake = 2;
    if (has_istake()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChristmasTakeRecord::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChristmasTakeRecord*>(&from));
}

void ChristmasTakeRecord::MergeFrom(const ChristmasTakeRecord& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_istake()) {
      set_istake(from.istake());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ChristmasTakeRecord::CopyFrom(const ChristmasTakeRecord& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChristmasTakeRecord::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ChristmasTakeRecord::Swap(ChristmasTakeRecord* other) {
  if (other != this) {
    std::swap(level_, other->level_);
    std::swap(istake_, other->istake_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChristmasTakeRecord::GetTypeName() const {
  return "fgame.ChristmasTakeRecord";
}


// ===================================================================

#ifndef _MSC_VER
const int CSChristmasGetDataResp::kStartTimeFieldNumber;
const int CSChristmasGetDataResp::kEndTimeFieldNumber;
const int CSChristmasGetDataResp::kGlobalScoreFieldNumber;
const int CSChristmasGetDataResp::kSelfScoreFieldNumber;
const int CSChristmasGetDataResp::kTakeRecordFieldNumber;
const int CSChristmasGetDataResp::kDropEndTimeFieldNumber;
#endif  // !_MSC_VER

CSChristmasGetDataResp::CSChristmasGetDataResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSChristmasGetDataResp)
}

void CSChristmasGetDataResp::InitAsDefaultInstance() {
}

CSChristmasGetDataResp::CSChristmasGetDataResp(const CSChristmasGetDataResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSChristmasGetDataResp)
}

void CSChristmasGetDataResp::SharedCtor() {
  _cached_size_ = 0;
  starttime_ = 0;
  endtime_ = 0;
  globalscore_ = 0;
  selfscore_ = 0;
  dropendtime_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSChristmasGetDataResp::~CSChristmasGetDataResp() {
  // @@protoc_insertion_point(destructor:fgame.CSChristmasGetDataResp)
  SharedDtor();
}

void CSChristmasGetDataResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSChristmasGetDataResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSChristmasGetDataResp& CSChristmasGetDataResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSChristmasGetDataResp* CSChristmasGetDataResp::default_instance_ = NULL;

CSChristmasGetDataResp* CSChristmasGetDataResp::New() const {
  return new CSChristmasGetDataResp;
}

void CSChristmasGetDataResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSChristmasGetDataResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 47) {
    ZR_(starttime_, selfscore_);
    dropendtime_ = 0;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  takerecord_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSChristmasGetDataResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSChristmasGetDataResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 StartTime = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &starttime_)));
          set_has_starttime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_EndTime;
        break;
      }

      // required int32 EndTime = 2;
      case 2: {
        if (tag == 16) {
         parse_EndTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &endtime_)));
          set_has_endtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_GlobalScore;
        break;
      }

      // optional int32 GlobalScore = 3;
      case 3: {
        if (tag == 24) {
         parse_GlobalScore:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &globalscore_)));
          set_has_globalscore();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_SelfScore;
        break;
      }

      // optional int32 SelfScore = 4;
      case 4: {
        if (tag == 32) {
         parse_SelfScore:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &selfscore_)));
          set_has_selfscore();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_TakeRecord;
        break;
      }

      // repeated .fgame.ChristmasTakeRecord TakeRecord = 5;
      case 5: {
        if (tag == 42) {
         parse_TakeRecord:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_takerecord()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_TakeRecord;
        if (input->ExpectTag(48)) goto parse_DropEndTime;
        break;
      }

      // optional int32 DropEndTime = 6;
      case 6: {
        if (tag == 48) {
         parse_DropEndTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &dropendtime_)));
          set_has_dropendtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSChristmasGetDataResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSChristmasGetDataResp)
  return false;
#undef DO_
}

void CSChristmasGetDataResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSChristmasGetDataResp)
  // required int32 StartTime = 1;
  if (has_starttime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->starttime(), output);
  }

  // required int32 EndTime = 2;
  if (has_endtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->endtime(), output);
  }

  // optional int32 GlobalScore = 3;
  if (has_globalscore()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->globalscore(), output);
  }

  // optional int32 SelfScore = 4;
  if (has_selfscore()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->selfscore(), output);
  }

  // repeated .fgame.ChristmasTakeRecord TakeRecord = 5;
  for (int i = 0; i < this->takerecord_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->takerecord(i), output);
  }

  // optional int32 DropEndTime = 6;
  if (has_dropendtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->dropendtime(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSChristmasGetDataResp)
}

int CSChristmasGetDataResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 StartTime = 1;
    if (has_starttime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->starttime());
    }

    // required int32 EndTime = 2;
    if (has_endtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->endtime());
    }

    // optional int32 GlobalScore = 3;
    if (has_globalscore()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->globalscore());
    }

    // optional int32 SelfScore = 4;
    if (has_selfscore()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->selfscore());
    }

    // optional int32 DropEndTime = 6;
    if (has_dropendtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->dropendtime());
    }

  }
  // repeated .fgame.ChristmasTakeRecord TakeRecord = 5;
  total_size += 1 * this->takerecord_size();
  for (int i = 0; i < this->takerecord_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->takerecord(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSChristmasGetDataResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSChristmasGetDataResp*>(&from));
}

void CSChristmasGetDataResp::MergeFrom(const CSChristmasGetDataResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  takerecord_.MergeFrom(from.takerecord_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_starttime()) {
      set_starttime(from.starttime());
    }
    if (from.has_endtime()) {
      set_endtime(from.endtime());
    }
    if (from.has_globalscore()) {
      set_globalscore(from.globalscore());
    }
    if (from.has_selfscore()) {
      set_selfscore(from.selfscore());
    }
    if (from.has_dropendtime()) {
      set_dropendtime(from.dropendtime());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSChristmasGetDataResp::CopyFrom(const CSChristmasGetDataResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSChristmasGetDataResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->takerecord())) return false;
  return true;
}

void CSChristmasGetDataResp::Swap(CSChristmasGetDataResp* other) {
  if (other != this) {
    std::swap(starttime_, other->starttime_);
    std::swap(endtime_, other->endtime_);
    std::swap(globalscore_, other->globalscore_);
    std::swap(selfscore_, other->selfscore_);
    takerecord_.Swap(&other->takerecord_);
    std::swap(dropendtime_, other->dropendtime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSChristmasGetDataResp::GetTypeName() const {
  return "fgame.CSChristmasGetDataResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSChristmasGetRankReq::CSChristmasGetRankReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSChristmasGetRankReq)
}

void CSChristmasGetRankReq::InitAsDefaultInstance() {
}

CSChristmasGetRankReq::CSChristmasGetRankReq(const CSChristmasGetRankReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSChristmasGetRankReq)
}

void CSChristmasGetRankReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSChristmasGetRankReq::~CSChristmasGetRankReq() {
  // @@protoc_insertion_point(destructor:fgame.CSChristmasGetRankReq)
  SharedDtor();
}

void CSChristmasGetRankReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSChristmasGetRankReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSChristmasGetRankReq& CSChristmasGetRankReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSChristmasGetRankReq* CSChristmasGetRankReq::default_instance_ = NULL;

CSChristmasGetRankReq* CSChristmasGetRankReq::New() const {
  return new CSChristmasGetRankReq;
}

void CSChristmasGetRankReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSChristmasGetRankReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSChristmasGetRankReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSChristmasGetRankReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSChristmasGetRankReq)
  return false;
#undef DO_
}

void CSChristmasGetRankReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSChristmasGetRankReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSChristmasGetRankReq)
}

int CSChristmasGetRankReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSChristmasGetRankReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSChristmasGetRankReq*>(&from));
}

void CSChristmasGetRankReq::MergeFrom(const CSChristmasGetRankReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSChristmasGetRankReq::CopyFrom(const CSChristmasGetRankReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSChristmasGetRankReq::IsInitialized() const {

  return true;
}

void CSChristmasGetRankReq::Swap(CSChristmasGetRankReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSChristmasGetRankReq::GetTypeName() const {
  return "fgame.CSChristmasGetRankReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ChristmasRankItem::kOrderFieldNumber;
const int ChristmasRankItem::kIdFieldNumber;
const int ChristmasRankItem::kNameFieldNumber;
const int ChristmasRankItem::kScoreFieldNumber;
const int ChristmasRankItem::kVipLevelFieldNumber;
#endif  // !_MSC_VER

ChristmasRankItem::ChristmasRankItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.ChristmasRankItem)
}

void ChristmasRankItem::InitAsDefaultInstance() {
}

ChristmasRankItem::ChristmasRankItem(const ChristmasRankItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.ChristmasRankItem)
}

void ChristmasRankItem::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  order_ = 0;
  id_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  score_ = 0;
  viplevel_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChristmasRankItem::~ChristmasRankItem() {
  // @@protoc_insertion_point(destructor:fgame.ChristmasRankItem)
  SharedDtor();
}

void ChristmasRankItem::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChristmasRankItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChristmasRankItem& ChristmasRankItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

ChristmasRankItem* ChristmasRankItem::default_instance_ = NULL;

ChristmasRankItem* ChristmasRankItem::New() const {
  return new ChristmasRankItem;
}

void ChristmasRankItem::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ChristmasRankItem*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(order_, id_);
    ZR_(score_, viplevel_);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ChristmasRankItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.ChristmasRankItem)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 Order = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &order_)));
          set_has_order();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Id;
        break;
      }

      // required int32 Id = 2;
      case 2: {
        if (tag == 16) {
         parse_Id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_Name;
        break;
      }

      // required string Name = 3;
      case 3: {
        if (tag == 26) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Score;
        break;
      }

      // required int32 Score = 4;
      case 4: {
        if (tag == 32) {
         parse_Score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_VipLevel;
        break;
      }

      // optional int32 VipLevel = 5;
      case 5: {
        if (tag == 40) {
         parse_VipLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &viplevel_)));
          set_has_viplevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.ChristmasRankItem)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.ChristmasRankItem)
  return false;
#undef DO_
}

void ChristmasRankItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.ChristmasRankItem)
  // required int32 Order = 1;
  if (has_order()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->order(), output);
  }

  // required int32 Id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->id(), output);
  }

  // required string Name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // required int32 Score = 4;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->score(), output);
  }

  // optional int32 VipLevel = 5;
  if (has_viplevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->viplevel(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.ChristmasRankItem)
}

int ChristmasRankItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 Order = 1;
    if (has_order()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->order());
    }

    // required int32 Id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // required string Name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required int32 Score = 4;
    if (has_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->score());
    }

    // optional int32 VipLevel = 5;
    if (has_viplevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->viplevel());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChristmasRankItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChristmasRankItem*>(&from));
}

void ChristmasRankItem::MergeFrom(const ChristmasRankItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_order()) {
      set_order(from.order());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
    if (from.has_viplevel()) {
      set_viplevel(from.viplevel());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ChristmasRankItem::CopyFrom(const ChristmasRankItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChristmasRankItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void ChristmasRankItem::Swap(ChristmasRankItem* other) {
  if (other != this) {
    std::swap(order_, other->order_);
    std::swap(id_, other->id_);
    std::swap(name_, other->name_);
    std::swap(score_, other->score_);
    std::swap(viplevel_, other->viplevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChristmasRankItem::GetTypeName() const {
  return "fgame.ChristmasRankItem";
}


// ===================================================================

#ifndef _MSC_VER
const int CSChristmasGetRankResp::kRankItemsFieldNumber;
#endif  // !_MSC_VER

CSChristmasGetRankResp::CSChristmasGetRankResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSChristmasGetRankResp)
}

void CSChristmasGetRankResp::InitAsDefaultInstance() {
}

CSChristmasGetRankResp::CSChristmasGetRankResp(const CSChristmasGetRankResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSChristmasGetRankResp)
}

void CSChristmasGetRankResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSChristmasGetRankResp::~CSChristmasGetRankResp() {
  // @@protoc_insertion_point(destructor:fgame.CSChristmasGetRankResp)
  SharedDtor();
}

void CSChristmasGetRankResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSChristmasGetRankResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSChristmasGetRankResp& CSChristmasGetRankResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSChristmasGetRankResp* CSChristmasGetRankResp::default_instance_ = NULL;

CSChristmasGetRankResp* CSChristmasGetRankResp::New() const {
  return new CSChristmasGetRankResp;
}

void CSChristmasGetRankResp::Clear() {
  rankitems_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSChristmasGetRankResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSChristmasGetRankResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.ChristmasRankItem RankItems = 1;
      case 1: {
        if (tag == 10) {
         parse_RankItems:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_rankitems()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_RankItems;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSChristmasGetRankResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSChristmasGetRankResp)
  return false;
#undef DO_
}

void CSChristmasGetRankResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSChristmasGetRankResp)
  // repeated .fgame.ChristmasRankItem RankItems = 1;
  for (int i = 0; i < this->rankitems_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->rankitems(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSChristmasGetRankResp)
}

int CSChristmasGetRankResp::ByteSize() const {
  int total_size = 0;

  // repeated .fgame.ChristmasRankItem RankItems = 1;
  total_size += 1 * this->rankitems_size();
  for (int i = 0; i < this->rankitems_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rankitems(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSChristmasGetRankResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSChristmasGetRankResp*>(&from));
}

void CSChristmasGetRankResp::MergeFrom(const CSChristmasGetRankResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  rankitems_.MergeFrom(from.rankitems_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSChristmasGetRankResp::CopyFrom(const CSChristmasGetRankResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSChristmasGetRankResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->rankitems())) return false;
  return true;
}

void CSChristmasGetRankResp::Swap(CSChristmasGetRankResp* other) {
  if (other != this) {
    rankitems_.Swap(&other->rankitems_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSChristmasGetRankResp::GetTypeName() const {
  return "fgame.CSChristmasGetRankResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSValentineDataReq::CSValentineDataReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSValentineDataReq)
}

void CSValentineDataReq::InitAsDefaultInstance() {
}

CSValentineDataReq::CSValentineDataReq(const CSValentineDataReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSValentineDataReq)
}

void CSValentineDataReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSValentineDataReq::~CSValentineDataReq() {
  // @@protoc_insertion_point(destructor:fgame.CSValentineDataReq)
  SharedDtor();
}

void CSValentineDataReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSValentineDataReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSValentineDataReq& CSValentineDataReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSValentineDataReq* CSValentineDataReq::default_instance_ = NULL;

CSValentineDataReq* CSValentineDataReq::New() const {
  return new CSValentineDataReq;
}

void CSValentineDataReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSValentineDataReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSValentineDataReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSValentineDataReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSValentineDataReq)
  return false;
#undef DO_
}

void CSValentineDataReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSValentineDataReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSValentineDataReq)
}

int CSValentineDataReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSValentineDataReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSValentineDataReq*>(&from));
}

void CSValentineDataReq::MergeFrom(const CSValentineDataReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSValentineDataReq::CopyFrom(const CSValentineDataReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSValentineDataReq::IsInitialized() const {

  return true;
}

void CSValentineDataReq::Swap(CSValentineDataReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSValentineDataReq::GetTypeName() const {
  return "fgame.CSValentineDataReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSValentineDataResp::kStartTimeFieldNumber;
const int CSValentineDataResp::kEndTimeFieldNumber;
const int CSValentineDataResp::kRedRoseFieldNumber;
const int CSValentineDataResp::kPinkRoseFieldNumber;
const int CSValentineDataResp::kBlueRoseFieldNumber;
#endif  // !_MSC_VER

CSValentineDataResp::CSValentineDataResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSValentineDataResp)
}

void CSValentineDataResp::InitAsDefaultInstance() {
}

CSValentineDataResp::CSValentineDataResp(const CSValentineDataResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSValentineDataResp)
}

void CSValentineDataResp::SharedCtor() {
  _cached_size_ = 0;
  starttime_ = 0;
  endtime_ = 0;
  redrose_ = 0;
  pinkrose_ = 0;
  bluerose_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSValentineDataResp::~CSValentineDataResp() {
  // @@protoc_insertion_point(destructor:fgame.CSValentineDataResp)
  SharedDtor();
}

void CSValentineDataResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSValentineDataResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSValentineDataResp& CSValentineDataResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSValentineDataResp* CSValentineDataResp::default_instance_ = NULL;

CSValentineDataResp* CSValentineDataResp::New() const {
  return new CSValentineDataResp;
}

void CSValentineDataResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSValentineDataResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(starttime_, bluerose_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSValentineDataResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSValentineDataResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 StartTime = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &starttime_)));
          set_has_starttime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_EndTime;
        break;
      }

      // required int32 EndTime = 2;
      case 2: {
        if (tag == 16) {
         parse_EndTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &endtime_)));
          set_has_endtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_RedRose;
        break;
      }

      // optional int32 RedRose = 3;
      case 3: {
        if (tag == 24) {
         parse_RedRose:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &redrose_)));
          set_has_redrose();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_PinkRose;
        break;
      }

      // optional int32 PinkRose = 4;
      case 4: {
        if (tag == 32) {
         parse_PinkRose:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pinkrose_)));
          set_has_pinkrose();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_BlueRose;
        break;
      }

      // optional int32 BlueRose = 5;
      case 5: {
        if (tag == 40) {
         parse_BlueRose:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bluerose_)));
          set_has_bluerose();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSValentineDataResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSValentineDataResp)
  return false;
#undef DO_
}

void CSValentineDataResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSValentineDataResp)
  // required int32 StartTime = 1;
  if (has_starttime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->starttime(), output);
  }

  // required int32 EndTime = 2;
  if (has_endtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->endtime(), output);
  }

  // optional int32 RedRose = 3;
  if (has_redrose()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->redrose(), output);
  }

  // optional int32 PinkRose = 4;
  if (has_pinkrose()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->pinkrose(), output);
  }

  // optional int32 BlueRose = 5;
  if (has_bluerose()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->bluerose(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSValentineDataResp)
}

int CSValentineDataResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 StartTime = 1;
    if (has_starttime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->starttime());
    }

    // required int32 EndTime = 2;
    if (has_endtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->endtime());
    }

    // optional int32 RedRose = 3;
    if (has_redrose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->redrose());
    }

    // optional int32 PinkRose = 4;
    if (has_pinkrose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pinkrose());
    }

    // optional int32 BlueRose = 5;
    if (has_bluerose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bluerose());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSValentineDataResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSValentineDataResp*>(&from));
}

void CSValentineDataResp::MergeFrom(const CSValentineDataResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_starttime()) {
      set_starttime(from.starttime());
    }
    if (from.has_endtime()) {
      set_endtime(from.endtime());
    }
    if (from.has_redrose()) {
      set_redrose(from.redrose());
    }
    if (from.has_pinkrose()) {
      set_pinkrose(from.pinkrose());
    }
    if (from.has_bluerose()) {
      set_bluerose(from.bluerose());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSValentineDataResp::CopyFrom(const CSValentineDataResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSValentineDataResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSValentineDataResp::Swap(CSValentineDataResp* other) {
  if (other != this) {
    std::swap(starttime_, other->starttime_);
    std::swap(endtime_, other->endtime_);
    std::swap(redrose_, other->redrose_);
    std::swap(pinkrose_, other->pinkrose_);
    std::swap(bluerose_, other->bluerose_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSValentineDataResp::GetTypeName() const {
  return "fgame.CSValentineDataResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSValentineExchangeReq::kItemIdFieldNumber;
#endif  // !_MSC_VER

CSValentineExchangeReq::CSValentineExchangeReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSValentineExchangeReq)
}

void CSValentineExchangeReq::InitAsDefaultInstance() {
}

CSValentineExchangeReq::CSValentineExchangeReq(const CSValentineExchangeReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSValentineExchangeReq)
}

void CSValentineExchangeReq::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSValentineExchangeReq::~CSValentineExchangeReq() {
  // @@protoc_insertion_point(destructor:fgame.CSValentineExchangeReq)
  SharedDtor();
}

void CSValentineExchangeReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSValentineExchangeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSValentineExchangeReq& CSValentineExchangeReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSValentineExchangeReq* CSValentineExchangeReq::default_instance_ = NULL;

CSValentineExchangeReq* CSValentineExchangeReq::New() const {
  return new CSValentineExchangeReq;
}

void CSValentineExchangeReq::Clear() {
  itemid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSValentineExchangeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSValentineExchangeReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ItemId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSValentineExchangeReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSValentineExchangeReq)
  return false;
#undef DO_
}

void CSValentineExchangeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSValentineExchangeReq)
  // required int32 ItemId = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->itemid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSValentineExchangeReq)
}

int CSValentineExchangeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ItemId = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSValentineExchangeReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSValentineExchangeReq*>(&from));
}

void CSValentineExchangeReq::MergeFrom(const CSValentineExchangeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSValentineExchangeReq::CopyFrom(const CSValentineExchangeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSValentineExchangeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSValentineExchangeReq::Swap(CSValentineExchangeReq* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSValentineExchangeReq::GetTypeName() const {
  return "fgame.CSValentineExchangeReq";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSValentineExchangeResp::CSValentineExchangeResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSValentineExchangeResp)
}

void CSValentineExchangeResp::InitAsDefaultInstance() {
}

CSValentineExchangeResp::CSValentineExchangeResp(const CSValentineExchangeResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSValentineExchangeResp)
}

void CSValentineExchangeResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSValentineExchangeResp::~CSValentineExchangeResp() {
  // @@protoc_insertion_point(destructor:fgame.CSValentineExchangeResp)
  SharedDtor();
}

void CSValentineExchangeResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSValentineExchangeResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSValentineExchangeResp& CSValentineExchangeResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSValentineExchangeResp* CSValentineExchangeResp::default_instance_ = NULL;

CSValentineExchangeResp* CSValentineExchangeResp::New() const {
  return new CSValentineExchangeResp;
}

void CSValentineExchangeResp::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSValentineExchangeResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSValentineExchangeResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSValentineExchangeResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSValentineExchangeResp)
  return false;
#undef DO_
}

void CSValentineExchangeResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSValentineExchangeResp)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSValentineExchangeResp)
}

int CSValentineExchangeResp::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSValentineExchangeResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSValentineExchangeResp*>(&from));
}

void CSValentineExchangeResp::MergeFrom(const CSValentineExchangeResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSValentineExchangeResp::CopyFrom(const CSValentineExchangeResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSValentineExchangeResp::IsInitialized() const {

  return true;
}

void CSValentineExchangeResp::Swap(CSValentineExchangeResp* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSValentineExchangeResp::GetTypeName() const {
  return "fgame.CSValentineExchangeResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSDailyTaskStatusReq::CSDailyTaskStatusReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSDailyTaskStatusReq)
}

void CSDailyTaskStatusReq::InitAsDefaultInstance() {
}

CSDailyTaskStatusReq::CSDailyTaskStatusReq(const CSDailyTaskStatusReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSDailyTaskStatusReq)
}

void CSDailyTaskStatusReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDailyTaskStatusReq::~CSDailyTaskStatusReq() {
  // @@protoc_insertion_point(destructor:fgame.CSDailyTaskStatusReq)
  SharedDtor();
}

void CSDailyTaskStatusReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSDailyTaskStatusReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDailyTaskStatusReq& CSDailyTaskStatusReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSDailyTaskStatusReq* CSDailyTaskStatusReq::default_instance_ = NULL;

CSDailyTaskStatusReq* CSDailyTaskStatusReq::New() const {
  return new CSDailyTaskStatusReq;
}

void CSDailyTaskStatusReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSDailyTaskStatusReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSDailyTaskStatusReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSDailyTaskStatusReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSDailyTaskStatusReq)
  return false;
#undef DO_
}

void CSDailyTaskStatusReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSDailyTaskStatusReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSDailyTaskStatusReq)
}

int CSDailyTaskStatusReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDailyTaskStatusReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDailyTaskStatusReq*>(&from));
}

void CSDailyTaskStatusReq::MergeFrom(const CSDailyTaskStatusReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSDailyTaskStatusReq::CopyFrom(const CSDailyTaskStatusReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDailyTaskStatusReq::IsInitialized() const {

  return true;
}

void CSDailyTaskStatusReq::Swap(CSDailyTaskStatusReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDailyTaskStatusReq::GetTypeName() const {
  return "fgame.CSDailyTaskStatusReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDailyTaskStatusResp::kShowDailyTaskFieldNumber;
#endif  // !_MSC_VER

CSDailyTaskStatusResp::CSDailyTaskStatusResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSDailyTaskStatusResp)
}

void CSDailyTaskStatusResp::InitAsDefaultInstance() {
}

CSDailyTaskStatusResp::CSDailyTaskStatusResp(const CSDailyTaskStatusResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSDailyTaskStatusResp)
}

void CSDailyTaskStatusResp::SharedCtor() {
  _cached_size_ = 0;
  showdailytask_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDailyTaskStatusResp::~CSDailyTaskStatusResp() {
  // @@protoc_insertion_point(destructor:fgame.CSDailyTaskStatusResp)
  SharedDtor();
}

void CSDailyTaskStatusResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSDailyTaskStatusResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDailyTaskStatusResp& CSDailyTaskStatusResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSDailyTaskStatusResp* CSDailyTaskStatusResp::default_instance_ = NULL;

CSDailyTaskStatusResp* CSDailyTaskStatusResp::New() const {
  return new CSDailyTaskStatusResp;
}

void CSDailyTaskStatusResp::Clear() {
  showdailytask_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSDailyTaskStatusResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSDailyTaskStatusResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool ShowDailyTask = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &showdailytask_)));
          set_has_showdailytask();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSDailyTaskStatusResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSDailyTaskStatusResp)
  return false;
#undef DO_
}

void CSDailyTaskStatusResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSDailyTaskStatusResp)
  // required bool ShowDailyTask = 1;
  if (has_showdailytask()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->showdailytask(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSDailyTaskStatusResp)
}

int CSDailyTaskStatusResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool ShowDailyTask = 1;
    if (has_showdailytask()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDailyTaskStatusResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDailyTaskStatusResp*>(&from));
}

void CSDailyTaskStatusResp::MergeFrom(const CSDailyTaskStatusResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_showdailytask()) {
      set_showdailytask(from.showdailytask());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSDailyTaskStatusResp::CopyFrom(const CSDailyTaskStatusResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDailyTaskStatusResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSDailyTaskStatusResp::Swap(CSDailyTaskStatusResp* other) {
  if (other != this) {
    std::swap(showdailytask_, other->showdailytask_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDailyTaskStatusResp::GetTypeName() const {
  return "fgame.CSDailyTaskStatusResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSRequestDailyTaskReq::CSRequestDailyTaskReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRequestDailyTaskReq)
}

void CSRequestDailyTaskReq::InitAsDefaultInstance() {
}

CSRequestDailyTaskReq::CSRequestDailyTaskReq(const CSRequestDailyTaskReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRequestDailyTaskReq)
}

void CSRequestDailyTaskReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRequestDailyTaskReq::~CSRequestDailyTaskReq() {
  // @@protoc_insertion_point(destructor:fgame.CSRequestDailyTaskReq)
  SharedDtor();
}

void CSRequestDailyTaskReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRequestDailyTaskReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRequestDailyTaskReq& CSRequestDailyTaskReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSRequestDailyTaskReq* CSRequestDailyTaskReq::default_instance_ = NULL;

CSRequestDailyTaskReq* CSRequestDailyTaskReq::New() const {
  return new CSRequestDailyTaskReq;
}

void CSRequestDailyTaskReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRequestDailyTaskReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRequestDailyTaskReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRequestDailyTaskReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRequestDailyTaskReq)
  return false;
#undef DO_
}

void CSRequestDailyTaskReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRequestDailyTaskReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRequestDailyTaskReq)
}

int CSRequestDailyTaskReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRequestDailyTaskReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRequestDailyTaskReq*>(&from));
}

void CSRequestDailyTaskReq::MergeFrom(const CSRequestDailyTaskReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRequestDailyTaskReq::CopyFrom(const CSRequestDailyTaskReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRequestDailyTaskReq::IsInitialized() const {

  return true;
}

void CSRequestDailyTaskReq::Swap(CSRequestDailyTaskReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRequestDailyTaskReq::GetTypeName() const {
  return "fgame.CSRequestDailyTaskReq";
}


// ===================================================================

#ifndef _MSC_VER
const int DailyTaskInfo::kTaskTypeFieldNumber;
const int DailyTaskInfo::kGiftIDFieldNumber;
const int DailyTaskInfo::kProgressFieldNumber;
const int DailyTaskInfo::kTotalProgressFieldNumber;
const int DailyTaskInfo::kIsOpenFieldNumber;
#endif  // !_MSC_VER

DailyTaskInfo::DailyTaskInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.DailyTaskInfo)
}

void DailyTaskInfo::InitAsDefaultInstance() {
}

DailyTaskInfo::DailyTaskInfo(const DailyTaskInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.DailyTaskInfo)
}

void DailyTaskInfo::SharedCtor() {
  _cached_size_ = 0;
  tasktype_ = 0u;
  giftid_ = 0u;
  progress_ = 0u;
  totalprogress_ = 0u;
  isopen_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DailyTaskInfo::~DailyTaskInfo() {
  // @@protoc_insertion_point(destructor:fgame.DailyTaskInfo)
  SharedDtor();
}

void DailyTaskInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DailyTaskInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DailyTaskInfo& DailyTaskInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

DailyTaskInfo* DailyTaskInfo::default_instance_ = NULL;

DailyTaskInfo* DailyTaskInfo::New() const {
  return new DailyTaskInfo;
}

void DailyTaskInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<DailyTaskInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(tasktype_, isopen_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool DailyTaskInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.DailyTaskInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 TaskType = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tasktype_)));
          set_has_tasktype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_GiftID;
        break;
      }

      // required uint32 GiftID = 2;
      case 2: {
        if (tag == 16) {
         parse_GiftID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &giftid_)));
          set_has_giftid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Progress;
        break;
      }

      // required uint32 Progress = 3;
      case 3: {
        if (tag == 24) {
         parse_Progress:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &progress_)));
          set_has_progress();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_TotalProgress;
        break;
      }

      // required uint32 TotalProgress = 4;
      case 4: {
        if (tag == 32) {
         parse_TotalProgress:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &totalprogress_)));
          set_has_totalprogress();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_IsOpen;
        break;
      }

      // required bool IsOpen = 5;
      case 5: {
        if (tag == 40) {
         parse_IsOpen:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isopen_)));
          set_has_isopen();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.DailyTaskInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.DailyTaskInfo)
  return false;
#undef DO_
}

void DailyTaskInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.DailyTaskInfo)
  // required uint32 TaskType = 1;
  if (has_tasktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->tasktype(), output);
  }

  // required uint32 GiftID = 2;
  if (has_giftid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->giftid(), output);
  }

  // required uint32 Progress = 3;
  if (has_progress()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->progress(), output);
  }

  // required uint32 TotalProgress = 4;
  if (has_totalprogress()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->totalprogress(), output);
  }

  // required bool IsOpen = 5;
  if (has_isopen()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->isopen(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.DailyTaskInfo)
}

int DailyTaskInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 TaskType = 1;
    if (has_tasktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tasktype());
    }

    // required uint32 GiftID = 2;
    if (has_giftid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->giftid());
    }

    // required uint32 Progress = 3;
    if (has_progress()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->progress());
    }

    // required uint32 TotalProgress = 4;
    if (has_totalprogress()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->totalprogress());
    }

    // required bool IsOpen = 5;
    if (has_isopen()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DailyTaskInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DailyTaskInfo*>(&from));
}

void DailyTaskInfo::MergeFrom(const DailyTaskInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tasktype()) {
      set_tasktype(from.tasktype());
    }
    if (from.has_giftid()) {
      set_giftid(from.giftid());
    }
    if (from.has_progress()) {
      set_progress(from.progress());
    }
    if (from.has_totalprogress()) {
      set_totalprogress(from.totalprogress());
    }
    if (from.has_isopen()) {
      set_isopen(from.isopen());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void DailyTaskInfo::CopyFrom(const DailyTaskInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DailyTaskInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void DailyTaskInfo::Swap(DailyTaskInfo* other) {
  if (other != this) {
    std::swap(tasktype_, other->tasktype_);
    std::swap(giftid_, other->giftid_);
    std::swap(progress_, other->progress_);
    std::swap(totalprogress_, other->totalprogress_);
    std::swap(isopen_, other->isopen_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DailyTaskInfo::GetTypeName() const {
  return "fgame.DailyTaskInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSRequestDailyTaskResp::kTaskInfoListFieldNumber;
const int CSRequestDailyTaskResp::kTaskProgressFieldNumber;
const int CSRequestDailyTaskResp::kCanChangeFieldNumber;
#endif  // !_MSC_VER

CSRequestDailyTaskResp::CSRequestDailyTaskResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRequestDailyTaskResp)
}

void CSRequestDailyTaskResp::InitAsDefaultInstance() {
}

CSRequestDailyTaskResp::CSRequestDailyTaskResp(const CSRequestDailyTaskResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRequestDailyTaskResp)
}

void CSRequestDailyTaskResp::SharedCtor() {
  _cached_size_ = 0;
  taskprogress_ = 0u;
  canchange_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRequestDailyTaskResp::~CSRequestDailyTaskResp() {
  // @@protoc_insertion_point(destructor:fgame.CSRequestDailyTaskResp)
  SharedDtor();
}

void CSRequestDailyTaskResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRequestDailyTaskResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRequestDailyTaskResp& CSRequestDailyTaskResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSRequestDailyTaskResp* CSRequestDailyTaskResp::default_instance_ = NULL;

CSRequestDailyTaskResp* CSRequestDailyTaskResp::New() const {
  return new CSRequestDailyTaskResp;
}

void CSRequestDailyTaskResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSRequestDailyTaskResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(taskprogress_, canchange_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  taskinfolist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRequestDailyTaskResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRequestDailyTaskResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.DailyTaskInfo TaskInfoList = 1;
      case 1: {
        if (tag == 10) {
         parse_TaskInfoList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_taskinfolist()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_TaskInfoList;
        if (input->ExpectTag(16)) goto parse_TaskProgress;
        break;
      }

      // required uint32 TaskProgress = 2;
      case 2: {
        if (tag == 16) {
         parse_TaskProgress:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &taskprogress_)));
          set_has_taskprogress();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_CanChange;
        break;
      }

      // required bool CanChange = 3;
      case 3: {
        if (tag == 24) {
         parse_CanChange:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &canchange_)));
          set_has_canchange();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRequestDailyTaskResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRequestDailyTaskResp)
  return false;
#undef DO_
}

void CSRequestDailyTaskResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRequestDailyTaskResp)
  // repeated .fgame.DailyTaskInfo TaskInfoList = 1;
  for (int i = 0; i < this->taskinfolist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->taskinfolist(i), output);
  }

  // required uint32 TaskProgress = 2;
  if (has_taskprogress()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->taskprogress(), output);
  }

  // required bool CanChange = 3;
  if (has_canchange()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->canchange(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRequestDailyTaskResp)
}

int CSRequestDailyTaskResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required uint32 TaskProgress = 2;
    if (has_taskprogress()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->taskprogress());
    }

    // required bool CanChange = 3;
    if (has_canchange()) {
      total_size += 1 + 1;
    }

  }
  // repeated .fgame.DailyTaskInfo TaskInfoList = 1;
  total_size += 1 * this->taskinfolist_size();
  for (int i = 0; i < this->taskinfolist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->taskinfolist(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRequestDailyTaskResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRequestDailyTaskResp*>(&from));
}

void CSRequestDailyTaskResp::MergeFrom(const CSRequestDailyTaskResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  taskinfolist_.MergeFrom(from.taskinfolist_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_taskprogress()) {
      set_taskprogress(from.taskprogress());
    }
    if (from.has_canchange()) {
      set_canchange(from.canchange());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRequestDailyTaskResp::CopyFrom(const CSRequestDailyTaskResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRequestDailyTaskResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->taskinfolist())) return false;
  return true;
}

void CSRequestDailyTaskResp::Swap(CSRequestDailyTaskResp* other) {
  if (other != this) {
    taskinfolist_.Swap(&other->taskinfolist_);
    std::swap(taskprogress_, other->taskprogress_);
    std::swap(canchange_, other->canchange_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRequestDailyTaskResp::GetTypeName() const {
  return "fgame.CSRequestDailyTaskResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSUpdateTaskStatusReq::CSUpdateTaskStatusReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSUpdateTaskStatusReq)
}

void CSUpdateTaskStatusReq::InitAsDefaultInstance() {
}

CSUpdateTaskStatusReq::CSUpdateTaskStatusReq(const CSUpdateTaskStatusReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSUpdateTaskStatusReq)
}

void CSUpdateTaskStatusReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSUpdateTaskStatusReq::~CSUpdateTaskStatusReq() {
  // @@protoc_insertion_point(destructor:fgame.CSUpdateTaskStatusReq)
  SharedDtor();
}

void CSUpdateTaskStatusReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSUpdateTaskStatusReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSUpdateTaskStatusReq& CSUpdateTaskStatusReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSUpdateTaskStatusReq* CSUpdateTaskStatusReq::default_instance_ = NULL;

CSUpdateTaskStatusReq* CSUpdateTaskStatusReq::New() const {
  return new CSUpdateTaskStatusReq;
}

void CSUpdateTaskStatusReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSUpdateTaskStatusReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSUpdateTaskStatusReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSUpdateTaskStatusReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSUpdateTaskStatusReq)
  return false;
#undef DO_
}

void CSUpdateTaskStatusReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSUpdateTaskStatusReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSUpdateTaskStatusReq)
}

int CSUpdateTaskStatusReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSUpdateTaskStatusReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSUpdateTaskStatusReq*>(&from));
}

void CSUpdateTaskStatusReq::MergeFrom(const CSUpdateTaskStatusReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSUpdateTaskStatusReq::CopyFrom(const CSUpdateTaskStatusReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSUpdateTaskStatusReq::IsInitialized() const {

  return true;
}

void CSUpdateTaskStatusReq::Swap(CSUpdateTaskStatusReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSUpdateTaskStatusReq::GetTypeName() const {
  return "fgame.CSUpdateTaskStatusReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSUpdateTaskStatusResp::kTaskTypeFieldNumber;
const int CSUpdateTaskStatusResp::kIsOpenFieldNumber;
#endif  // !_MSC_VER

CSUpdateTaskStatusResp::CSUpdateTaskStatusResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSUpdateTaskStatusResp)
}

void CSUpdateTaskStatusResp::InitAsDefaultInstance() {
}

CSUpdateTaskStatusResp::CSUpdateTaskStatusResp(const CSUpdateTaskStatusResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSUpdateTaskStatusResp)
}

void CSUpdateTaskStatusResp::SharedCtor() {
  _cached_size_ = 0;
  tasktype_ = 0u;
  isopen_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSUpdateTaskStatusResp::~CSUpdateTaskStatusResp() {
  // @@protoc_insertion_point(destructor:fgame.CSUpdateTaskStatusResp)
  SharedDtor();
}

void CSUpdateTaskStatusResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSUpdateTaskStatusResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSUpdateTaskStatusResp& CSUpdateTaskStatusResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSUpdateTaskStatusResp* CSUpdateTaskStatusResp::default_instance_ = NULL;

CSUpdateTaskStatusResp* CSUpdateTaskStatusResp::New() const {
  return new CSUpdateTaskStatusResp;
}

void CSUpdateTaskStatusResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSUpdateTaskStatusResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(tasktype_, isopen_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSUpdateTaskStatusResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSUpdateTaskStatusResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 TaskType = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tasktype_)));
          set_has_tasktype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_IsOpen;
        break;
      }

      // required bool IsOpen = 2;
      case 2: {
        if (tag == 16) {
         parse_IsOpen:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isopen_)));
          set_has_isopen();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSUpdateTaskStatusResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSUpdateTaskStatusResp)
  return false;
#undef DO_
}

void CSUpdateTaskStatusResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSUpdateTaskStatusResp)
  // required uint32 TaskType = 1;
  if (has_tasktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->tasktype(), output);
  }

  // required bool IsOpen = 2;
  if (has_isopen()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->isopen(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSUpdateTaskStatusResp)
}

int CSUpdateTaskStatusResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 TaskType = 1;
    if (has_tasktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tasktype());
    }

    // required bool IsOpen = 2;
    if (has_isopen()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSUpdateTaskStatusResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSUpdateTaskStatusResp*>(&from));
}

void CSUpdateTaskStatusResp::MergeFrom(const CSUpdateTaskStatusResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tasktype()) {
      set_tasktype(from.tasktype());
    }
    if (from.has_isopen()) {
      set_isopen(from.isopen());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSUpdateTaskStatusResp::CopyFrom(const CSUpdateTaskStatusResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSUpdateTaskStatusResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSUpdateTaskStatusResp::Swap(CSUpdateTaskStatusResp* other) {
  if (other != this) {
    std::swap(tasktype_, other->tasktype_);
    std::swap(isopen_, other->isopen_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSUpdateTaskStatusResp::GetTypeName() const {
  return "fgame.CSUpdateTaskStatusResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSChangeDailyTaskReq::kTaskTypeFieldNumber;
#endif  // !_MSC_VER

CSChangeDailyTaskReq::CSChangeDailyTaskReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSChangeDailyTaskReq)
}

void CSChangeDailyTaskReq::InitAsDefaultInstance() {
}

CSChangeDailyTaskReq::CSChangeDailyTaskReq(const CSChangeDailyTaskReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSChangeDailyTaskReq)
}

void CSChangeDailyTaskReq::SharedCtor() {
  _cached_size_ = 0;
  tasktype_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSChangeDailyTaskReq::~CSChangeDailyTaskReq() {
  // @@protoc_insertion_point(destructor:fgame.CSChangeDailyTaskReq)
  SharedDtor();
}

void CSChangeDailyTaskReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSChangeDailyTaskReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSChangeDailyTaskReq& CSChangeDailyTaskReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSChangeDailyTaskReq* CSChangeDailyTaskReq::default_instance_ = NULL;

CSChangeDailyTaskReq* CSChangeDailyTaskReq::New() const {
  return new CSChangeDailyTaskReq;
}

void CSChangeDailyTaskReq::Clear() {
  tasktype_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSChangeDailyTaskReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSChangeDailyTaskReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 TaskType = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tasktype_)));
          set_has_tasktype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSChangeDailyTaskReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSChangeDailyTaskReq)
  return false;
#undef DO_
}

void CSChangeDailyTaskReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSChangeDailyTaskReq)
  // required uint32 TaskType = 1;
  if (has_tasktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->tasktype(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSChangeDailyTaskReq)
}

int CSChangeDailyTaskReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 TaskType = 1;
    if (has_tasktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tasktype());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSChangeDailyTaskReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSChangeDailyTaskReq*>(&from));
}

void CSChangeDailyTaskReq::MergeFrom(const CSChangeDailyTaskReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tasktype()) {
      set_tasktype(from.tasktype());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSChangeDailyTaskReq::CopyFrom(const CSChangeDailyTaskReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSChangeDailyTaskReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSChangeDailyTaskReq::Swap(CSChangeDailyTaskReq* other) {
  if (other != this) {
    std::swap(tasktype_, other->tasktype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSChangeDailyTaskReq::GetTypeName() const {
  return "fgame.CSChangeDailyTaskReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSChangeDailyTaskResp::kResultFieldNumber;
const int CSChangeDailyTaskResp::kNewTaskFieldNumber;
#endif  // !_MSC_VER

CSChangeDailyTaskResp::CSChangeDailyTaskResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSChangeDailyTaskResp)
}

void CSChangeDailyTaskResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  newtask_ = const_cast< ::fgame::DailyTaskInfo*>(
      ::fgame::DailyTaskInfo::internal_default_instance());
#else
  newtask_ = const_cast< ::fgame::DailyTaskInfo*>(&::fgame::DailyTaskInfo::default_instance());
#endif
}

CSChangeDailyTaskResp::CSChangeDailyTaskResp(const CSChangeDailyTaskResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSChangeDailyTaskResp)
}

void CSChangeDailyTaskResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = false;
  newtask_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSChangeDailyTaskResp::~CSChangeDailyTaskResp() {
  // @@protoc_insertion_point(destructor:fgame.CSChangeDailyTaskResp)
  SharedDtor();
}

void CSChangeDailyTaskResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete newtask_;
  }
}

void CSChangeDailyTaskResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSChangeDailyTaskResp& CSChangeDailyTaskResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSChangeDailyTaskResp* CSChangeDailyTaskResp::default_instance_ = NULL;

CSChangeDailyTaskResp* CSChangeDailyTaskResp::New() const {
  return new CSChangeDailyTaskResp;
}

void CSChangeDailyTaskResp::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    result_ = false;
    if (has_newtask()) {
      if (newtask_ != NULL) newtask_->::fgame::DailyTaskInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSChangeDailyTaskResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSChangeDailyTaskResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool Result = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_NewTask;
        break;
      }

      // optional .fgame.DailyTaskInfo NewTask = 2;
      case 2: {
        if (tag == 18) {
         parse_NewTask:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_newtask()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSChangeDailyTaskResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSChangeDailyTaskResp)
  return false;
#undef DO_
}

void CSChangeDailyTaskResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSChangeDailyTaskResp)
  // required bool Result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->result(), output);
  }

  // optional .fgame.DailyTaskInfo NewTask = 2;
  if (has_newtask()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->newtask(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSChangeDailyTaskResp)
}

int CSChangeDailyTaskResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool Result = 1;
    if (has_result()) {
      total_size += 1 + 1;
    }

    // optional .fgame.DailyTaskInfo NewTask = 2;
    if (has_newtask()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->newtask());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSChangeDailyTaskResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSChangeDailyTaskResp*>(&from));
}

void CSChangeDailyTaskResp::MergeFrom(const CSChangeDailyTaskResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_newtask()) {
      mutable_newtask()->::fgame::DailyTaskInfo::MergeFrom(from.newtask());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSChangeDailyTaskResp::CopyFrom(const CSChangeDailyTaskResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSChangeDailyTaskResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_newtask()) {
    if (!this->newtask().IsInitialized()) return false;
  }
  return true;
}

void CSChangeDailyTaskResp::Swap(CSChangeDailyTaskResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(newtask_, other->newtask_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSChangeDailyTaskResp::GetTypeName() const {
  return "fgame.CSChangeDailyTaskResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSOpenDailyTaskAwardReq::CSOpenDailyTaskAwardReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSOpenDailyTaskAwardReq)
}

void CSOpenDailyTaskAwardReq::InitAsDefaultInstance() {
}

CSOpenDailyTaskAwardReq::CSOpenDailyTaskAwardReq(const CSOpenDailyTaskAwardReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSOpenDailyTaskAwardReq)
}

void CSOpenDailyTaskAwardReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSOpenDailyTaskAwardReq::~CSOpenDailyTaskAwardReq() {
  // @@protoc_insertion_point(destructor:fgame.CSOpenDailyTaskAwardReq)
  SharedDtor();
}

void CSOpenDailyTaskAwardReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSOpenDailyTaskAwardReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSOpenDailyTaskAwardReq& CSOpenDailyTaskAwardReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSOpenDailyTaskAwardReq* CSOpenDailyTaskAwardReq::default_instance_ = NULL;

CSOpenDailyTaskAwardReq* CSOpenDailyTaskAwardReq::New() const {
  return new CSOpenDailyTaskAwardReq;
}

void CSOpenDailyTaskAwardReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSOpenDailyTaskAwardReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSOpenDailyTaskAwardReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSOpenDailyTaskAwardReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSOpenDailyTaskAwardReq)
  return false;
#undef DO_
}

void CSOpenDailyTaskAwardReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSOpenDailyTaskAwardReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSOpenDailyTaskAwardReq)
}

int CSOpenDailyTaskAwardReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSOpenDailyTaskAwardReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSOpenDailyTaskAwardReq*>(&from));
}

void CSOpenDailyTaskAwardReq::MergeFrom(const CSOpenDailyTaskAwardReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSOpenDailyTaskAwardReq::CopyFrom(const CSOpenDailyTaskAwardReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOpenDailyTaskAwardReq::IsInitialized() const {

  return true;
}

void CSOpenDailyTaskAwardReq::Swap(CSOpenDailyTaskAwardReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSOpenDailyTaskAwardReq::GetTypeName() const {
  return "fgame.CSOpenDailyTaskAwardReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSOpenDailyTaskAwardResp::kOkFieldNumber;
const int CSOpenDailyTaskAwardResp::kGiftIDFieldNumber;
const int CSOpenDailyTaskAwardResp::kHaveNewTaskFieldNumber;
#endif  // !_MSC_VER

CSOpenDailyTaskAwardResp::CSOpenDailyTaskAwardResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSOpenDailyTaskAwardResp)
}

void CSOpenDailyTaskAwardResp::InitAsDefaultInstance() {
}

CSOpenDailyTaskAwardResp::CSOpenDailyTaskAwardResp(const CSOpenDailyTaskAwardResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSOpenDailyTaskAwardResp)
}

void CSOpenDailyTaskAwardResp::SharedCtor() {
  _cached_size_ = 0;
  ok_ = false;
  giftid_ = 0u;
  havenewtask_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSOpenDailyTaskAwardResp::~CSOpenDailyTaskAwardResp() {
  // @@protoc_insertion_point(destructor:fgame.CSOpenDailyTaskAwardResp)
  SharedDtor();
}

void CSOpenDailyTaskAwardResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSOpenDailyTaskAwardResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSOpenDailyTaskAwardResp& CSOpenDailyTaskAwardResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSOpenDailyTaskAwardResp* CSOpenDailyTaskAwardResp::default_instance_ = NULL;

CSOpenDailyTaskAwardResp* CSOpenDailyTaskAwardResp::New() const {
  return new CSOpenDailyTaskAwardResp;
}

void CSOpenDailyTaskAwardResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSOpenDailyTaskAwardResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(giftid_, havenewtask_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSOpenDailyTaskAwardResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSOpenDailyTaskAwardResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool Ok = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ok_)));
          set_has_ok();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_GiftID;
        break;
      }

      // optional uint32 GiftID = 2;
      case 2: {
        if (tag == 16) {
         parse_GiftID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &giftid_)));
          set_has_giftid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_HaveNewTask;
        break;
      }

      // optional bool HaveNewTask = 3;
      case 3: {
        if (tag == 24) {
         parse_HaveNewTask:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &havenewtask_)));
          set_has_havenewtask();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSOpenDailyTaskAwardResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSOpenDailyTaskAwardResp)
  return false;
#undef DO_
}

void CSOpenDailyTaskAwardResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSOpenDailyTaskAwardResp)
  // required bool Ok = 1;
  if (has_ok()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->ok(), output);
  }

  // optional uint32 GiftID = 2;
  if (has_giftid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->giftid(), output);
  }

  // optional bool HaveNewTask = 3;
  if (has_havenewtask()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->havenewtask(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSOpenDailyTaskAwardResp)
}

int CSOpenDailyTaskAwardResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool Ok = 1;
    if (has_ok()) {
      total_size += 1 + 1;
    }

    // optional uint32 GiftID = 2;
    if (has_giftid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->giftid());
    }

    // optional bool HaveNewTask = 3;
    if (has_havenewtask()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSOpenDailyTaskAwardResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSOpenDailyTaskAwardResp*>(&from));
}

void CSOpenDailyTaskAwardResp::MergeFrom(const CSOpenDailyTaskAwardResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ok()) {
      set_ok(from.ok());
    }
    if (from.has_giftid()) {
      set_giftid(from.giftid());
    }
    if (from.has_havenewtask()) {
      set_havenewtask(from.havenewtask());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSOpenDailyTaskAwardResp::CopyFrom(const CSOpenDailyTaskAwardResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOpenDailyTaskAwardResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSOpenDailyTaskAwardResp::Swap(CSOpenDailyTaskAwardResp* other) {
  if (other != this) {
    std::swap(ok_, other->ok_);
    std::swap(giftid_, other->giftid_);
    std::swap(havenewtask_, other->havenewtask_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSOpenDailyTaskAwardResp::GetTypeName() const {
  return "fgame.CSOpenDailyTaskAwardResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSUpdateDailyTaskProgressReq::kTaskTypeFieldNumber;
const int CSUpdateDailyTaskProgressReq::kProgressFieldNumber;
#endif  // !_MSC_VER

CSUpdateDailyTaskProgressReq::CSUpdateDailyTaskProgressReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSUpdateDailyTaskProgressReq)
}

void CSUpdateDailyTaskProgressReq::InitAsDefaultInstance() {
}

CSUpdateDailyTaskProgressReq::CSUpdateDailyTaskProgressReq(const CSUpdateDailyTaskProgressReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSUpdateDailyTaskProgressReq)
}

void CSUpdateDailyTaskProgressReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSUpdateDailyTaskProgressReq::~CSUpdateDailyTaskProgressReq() {
  // @@protoc_insertion_point(destructor:fgame.CSUpdateDailyTaskProgressReq)
  SharedDtor();
}

void CSUpdateDailyTaskProgressReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSUpdateDailyTaskProgressReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSUpdateDailyTaskProgressReq& CSUpdateDailyTaskProgressReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSUpdateDailyTaskProgressReq* CSUpdateDailyTaskProgressReq::default_instance_ = NULL;

CSUpdateDailyTaskProgressReq* CSUpdateDailyTaskProgressReq::New() const {
  return new CSUpdateDailyTaskProgressReq;
}

void CSUpdateDailyTaskProgressReq::Clear() {
  tasktype_.Clear();
  progress_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSUpdateDailyTaskProgressReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSUpdateDailyTaskProgressReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 TaskType = 1;
      case 1: {
        if (tag == 8) {
         parse_TaskType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_tasktype())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_tasktype())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_TaskType;
        if (input->ExpectTag(16)) goto parse_Progress;
        break;
      }

      // repeated uint32 Progress = 2;
      case 2: {
        if (tag == 16) {
         parse_Progress:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_progress())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_progress())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Progress;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSUpdateDailyTaskProgressReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSUpdateDailyTaskProgressReq)
  return false;
#undef DO_
}

void CSUpdateDailyTaskProgressReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSUpdateDailyTaskProgressReq)
  // repeated uint32 TaskType = 1;
  for (int i = 0; i < this->tasktype_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->tasktype(i), output);
  }

  // repeated uint32 Progress = 2;
  for (int i = 0; i < this->progress_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->progress(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSUpdateDailyTaskProgressReq)
}

int CSUpdateDailyTaskProgressReq::ByteSize() const {
  int total_size = 0;

  // repeated uint32 TaskType = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->tasktype_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->tasktype(i));
    }
    total_size += 1 * this->tasktype_size() + data_size;
  }

  // repeated uint32 Progress = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->progress_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->progress(i));
    }
    total_size += 1 * this->progress_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSUpdateDailyTaskProgressReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSUpdateDailyTaskProgressReq*>(&from));
}

void CSUpdateDailyTaskProgressReq::MergeFrom(const CSUpdateDailyTaskProgressReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  tasktype_.MergeFrom(from.tasktype_);
  progress_.MergeFrom(from.progress_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSUpdateDailyTaskProgressReq::CopyFrom(const CSUpdateDailyTaskProgressReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSUpdateDailyTaskProgressReq::IsInitialized() const {

  return true;
}

void CSUpdateDailyTaskProgressReq::Swap(CSUpdateDailyTaskProgressReq* other) {
  if (other != this) {
    tasktype_.Swap(&other->tasktype_);
    progress_.Swap(&other->progress_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSUpdateDailyTaskProgressReq::GetTypeName() const {
  return "fgame.CSUpdateDailyTaskProgressReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSUpdateDailyTaskProgressResp::kOkFieldNumber;
const int CSUpdateDailyTaskProgressResp::kTaskTypeFieldNumber;
const int CSUpdateDailyTaskProgressResp::kProgressFieldNumber;
#endif  // !_MSC_VER

CSUpdateDailyTaskProgressResp::CSUpdateDailyTaskProgressResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSUpdateDailyTaskProgressResp)
}

void CSUpdateDailyTaskProgressResp::InitAsDefaultInstance() {
}

CSUpdateDailyTaskProgressResp::CSUpdateDailyTaskProgressResp(const CSUpdateDailyTaskProgressResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSUpdateDailyTaskProgressResp)
}

void CSUpdateDailyTaskProgressResp::SharedCtor() {
  _cached_size_ = 0;
  ok_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSUpdateDailyTaskProgressResp::~CSUpdateDailyTaskProgressResp() {
  // @@protoc_insertion_point(destructor:fgame.CSUpdateDailyTaskProgressResp)
  SharedDtor();
}

void CSUpdateDailyTaskProgressResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSUpdateDailyTaskProgressResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSUpdateDailyTaskProgressResp& CSUpdateDailyTaskProgressResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSUpdateDailyTaskProgressResp* CSUpdateDailyTaskProgressResp::default_instance_ = NULL;

CSUpdateDailyTaskProgressResp* CSUpdateDailyTaskProgressResp::New() const {
  return new CSUpdateDailyTaskProgressResp;
}

void CSUpdateDailyTaskProgressResp::Clear() {
  ok_ = false;
  tasktype_.Clear();
  progress_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSUpdateDailyTaskProgressResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSUpdateDailyTaskProgressResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool Ok = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ok_)));
          set_has_ok();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_TaskType;
        break;
      }

      // repeated uint32 TaskType = 2;
      case 2: {
        if (tag == 16) {
         parse_TaskType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_tasktype())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_tasktype())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_TaskType;
        if (input->ExpectTag(24)) goto parse_Progress;
        break;
      }

      // repeated uint32 Progress = 3;
      case 3: {
        if (tag == 24) {
         parse_Progress:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 24, input, this->mutable_progress())));
        } else if (tag == 26) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_progress())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Progress;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSUpdateDailyTaskProgressResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSUpdateDailyTaskProgressResp)
  return false;
#undef DO_
}

void CSUpdateDailyTaskProgressResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSUpdateDailyTaskProgressResp)
  // required bool Ok = 1;
  if (has_ok()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->ok(), output);
  }

  // repeated uint32 TaskType = 2;
  for (int i = 0; i < this->tasktype_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->tasktype(i), output);
  }

  // repeated uint32 Progress = 3;
  for (int i = 0; i < this->progress_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      3, this->progress(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSUpdateDailyTaskProgressResp)
}

int CSUpdateDailyTaskProgressResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool Ok = 1;
    if (has_ok()) {
      total_size += 1 + 1;
    }

  }
  // repeated uint32 TaskType = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->tasktype_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->tasktype(i));
    }
    total_size += 1 * this->tasktype_size() + data_size;
  }

  // repeated uint32 Progress = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->progress_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->progress(i));
    }
    total_size += 1 * this->progress_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSUpdateDailyTaskProgressResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSUpdateDailyTaskProgressResp*>(&from));
}

void CSUpdateDailyTaskProgressResp::MergeFrom(const CSUpdateDailyTaskProgressResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  tasktype_.MergeFrom(from.tasktype_);
  progress_.MergeFrom(from.progress_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ok()) {
      set_ok(from.ok());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSUpdateDailyTaskProgressResp::CopyFrom(const CSUpdateDailyTaskProgressResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSUpdateDailyTaskProgressResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSUpdateDailyTaskProgressResp::Swap(CSUpdateDailyTaskProgressResp* other) {
  if (other != this) {
    std::swap(ok_, other->ok_);
    tasktype_.Swap(&other->tasktype_);
    progress_.Swap(&other->progress_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSUpdateDailyTaskProgressResp::GetTypeName() const {
  return "fgame.CSUpdateDailyTaskProgressResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSRankWeekRewardInfoReq::CSRankWeekRewardInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRankWeekRewardInfoReq)
}

void CSRankWeekRewardInfoReq::InitAsDefaultInstance() {
}

CSRankWeekRewardInfoReq::CSRankWeekRewardInfoReq(const CSRankWeekRewardInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRankWeekRewardInfoReq)
}

void CSRankWeekRewardInfoReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRankWeekRewardInfoReq::~CSRankWeekRewardInfoReq() {
  // @@protoc_insertion_point(destructor:fgame.CSRankWeekRewardInfoReq)
  SharedDtor();
}

void CSRankWeekRewardInfoReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRankWeekRewardInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRankWeekRewardInfoReq& CSRankWeekRewardInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSRankWeekRewardInfoReq* CSRankWeekRewardInfoReq::default_instance_ = NULL;

CSRankWeekRewardInfoReq* CSRankWeekRewardInfoReq::New() const {
  return new CSRankWeekRewardInfoReq;
}

void CSRankWeekRewardInfoReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRankWeekRewardInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRankWeekRewardInfoReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRankWeekRewardInfoReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRankWeekRewardInfoReq)
  return false;
#undef DO_
}

void CSRankWeekRewardInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRankWeekRewardInfoReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRankWeekRewardInfoReq)
}

int CSRankWeekRewardInfoReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRankWeekRewardInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRankWeekRewardInfoReq*>(&from));
}

void CSRankWeekRewardInfoReq::MergeFrom(const CSRankWeekRewardInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRankWeekRewardInfoReq::CopyFrom(const CSRankWeekRewardInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRankWeekRewardInfoReq::IsInitialized() const {

  return true;
}

void CSRankWeekRewardInfoReq::Swap(CSRankWeekRewardInfoReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRankWeekRewardInfoReq::GetTypeName() const {
  return "fgame.CSRankWeekRewardInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSRankWeekRewardInfoResp::kStatusFieldNumber;
const int CSRankWeekRewardInfoResp::kPvpCountFieldNumber;
const int CSRankWeekRewardInfoResp::kGroupIdFieldNumber;
const int CSRankWeekRewardInfoResp::kRankFieldNumber;
#endif  // !_MSC_VER

CSRankWeekRewardInfoResp::CSRankWeekRewardInfoResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRankWeekRewardInfoResp)
}

void CSRankWeekRewardInfoResp::InitAsDefaultInstance() {
}

CSRankWeekRewardInfoResp::CSRankWeekRewardInfoResp(const CSRankWeekRewardInfoResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRankWeekRewardInfoResp)
}

void CSRankWeekRewardInfoResp::SharedCtor() {
  _cached_size_ = 0;
  status_ = false;
  pvpcount_ = 0u;
  groupid_ = 0u;
  rank_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRankWeekRewardInfoResp::~CSRankWeekRewardInfoResp() {
  // @@protoc_insertion_point(destructor:fgame.CSRankWeekRewardInfoResp)
  SharedDtor();
}

void CSRankWeekRewardInfoResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRankWeekRewardInfoResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRankWeekRewardInfoResp& CSRankWeekRewardInfoResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSRankWeekRewardInfoResp* CSRankWeekRewardInfoResp::default_instance_ = NULL;

CSRankWeekRewardInfoResp* CSRankWeekRewardInfoResp::New() const {
  return new CSRankWeekRewardInfoResp;
}

void CSRankWeekRewardInfoResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSRankWeekRewardInfoResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(status_, rank_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRankWeekRewardInfoResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRankWeekRewardInfoResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool Status = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_PvpCount;
        break;
      }

      // optional uint32 PvpCount = 2;
      case 2: {
        if (tag == 16) {
         parse_PvpCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pvpcount_)));
          set_has_pvpcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_GroupId;
        break;
      }

      // optional uint32 GroupId = 3;
      case 3: {
        if (tag == 24) {
         parse_GroupId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &groupid_)));
          set_has_groupid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Rank;
        break;
      }

      // optional uint32 Rank = 4;
      case 4: {
        if (tag == 32) {
         parse_Rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_)));
          set_has_rank();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRankWeekRewardInfoResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRankWeekRewardInfoResp)
  return false;
#undef DO_
}

void CSRankWeekRewardInfoResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRankWeekRewardInfoResp)
  // optional bool Status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->status(), output);
  }

  // optional uint32 PvpCount = 2;
  if (has_pvpcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->pvpcount(), output);
  }

  // optional uint32 GroupId = 3;
  if (has_groupid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->groupid(), output);
  }

  // optional uint32 Rank = 4;
  if (has_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->rank(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRankWeekRewardInfoResp)
}

int CSRankWeekRewardInfoResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool Status = 1;
    if (has_status()) {
      total_size += 1 + 1;
    }

    // optional uint32 PvpCount = 2;
    if (has_pvpcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pvpcount());
    }

    // optional uint32 GroupId = 3;
    if (has_groupid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->groupid());
    }

    // optional uint32 Rank = 4;
    if (has_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRankWeekRewardInfoResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRankWeekRewardInfoResp*>(&from));
}

void CSRankWeekRewardInfoResp::MergeFrom(const CSRankWeekRewardInfoResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_pvpcount()) {
      set_pvpcount(from.pvpcount());
    }
    if (from.has_groupid()) {
      set_groupid(from.groupid());
    }
    if (from.has_rank()) {
      set_rank(from.rank());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRankWeekRewardInfoResp::CopyFrom(const CSRankWeekRewardInfoResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRankWeekRewardInfoResp::IsInitialized() const {

  return true;
}

void CSRankWeekRewardInfoResp::Swap(CSRankWeekRewardInfoResp* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(pvpcount_, other->pvpcount_);
    std::swap(groupid_, other->groupid_);
    std::swap(rank_, other->rank_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRankWeekRewardInfoResp::GetTypeName() const {
  return "fgame.CSRankWeekRewardInfoResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSRankWeekRewardRewardReq::CSRankWeekRewardRewardReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRankWeekRewardRewardReq)
}

void CSRankWeekRewardRewardReq::InitAsDefaultInstance() {
}

CSRankWeekRewardRewardReq::CSRankWeekRewardRewardReq(const CSRankWeekRewardRewardReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRankWeekRewardRewardReq)
}

void CSRankWeekRewardRewardReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRankWeekRewardRewardReq::~CSRankWeekRewardRewardReq() {
  // @@protoc_insertion_point(destructor:fgame.CSRankWeekRewardRewardReq)
  SharedDtor();
}

void CSRankWeekRewardRewardReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRankWeekRewardRewardReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRankWeekRewardRewardReq& CSRankWeekRewardRewardReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSRankWeekRewardRewardReq* CSRankWeekRewardRewardReq::default_instance_ = NULL;

CSRankWeekRewardRewardReq* CSRankWeekRewardRewardReq::New() const {
  return new CSRankWeekRewardRewardReq;
}

void CSRankWeekRewardRewardReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRankWeekRewardRewardReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRankWeekRewardRewardReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRankWeekRewardRewardReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRankWeekRewardRewardReq)
  return false;
#undef DO_
}

void CSRankWeekRewardRewardReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRankWeekRewardRewardReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRankWeekRewardRewardReq)
}

int CSRankWeekRewardRewardReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRankWeekRewardRewardReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRankWeekRewardRewardReq*>(&from));
}

void CSRankWeekRewardRewardReq::MergeFrom(const CSRankWeekRewardRewardReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRankWeekRewardRewardReq::CopyFrom(const CSRankWeekRewardRewardReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRankWeekRewardRewardReq::IsInitialized() const {

  return true;
}

void CSRankWeekRewardRewardReq::Swap(CSRankWeekRewardRewardReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRankWeekRewardRewardReq::GetTypeName() const {
  return "fgame.CSRankWeekRewardRewardReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSRankWeekRewardRewardResp::kSuccessFieldNumber;
const int CSRankWeekRewardRewardResp::kErrorFieldNumber;
#endif  // !_MSC_VER

CSRankWeekRewardRewardResp::CSRankWeekRewardRewardResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRankWeekRewardRewardResp)
}

void CSRankWeekRewardRewardResp::InitAsDefaultInstance() {
}

CSRankWeekRewardRewardResp::CSRankWeekRewardRewardResp(const CSRankWeekRewardRewardResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRankWeekRewardRewardResp)
}

void CSRankWeekRewardRewardResp::SharedCtor() {
  _cached_size_ = 0;
  success_ = false;
  error_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRankWeekRewardRewardResp::~CSRankWeekRewardRewardResp() {
  // @@protoc_insertion_point(destructor:fgame.CSRankWeekRewardRewardResp)
  SharedDtor();
}

void CSRankWeekRewardRewardResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRankWeekRewardRewardResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRankWeekRewardRewardResp& CSRankWeekRewardRewardResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSRankWeekRewardRewardResp* CSRankWeekRewardRewardResp::default_instance_ = NULL;

CSRankWeekRewardRewardResp* CSRankWeekRewardRewardResp::New() const {
  return new CSRankWeekRewardRewardResp;
}

void CSRankWeekRewardRewardResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSRankWeekRewardRewardResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(success_, error_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRankWeekRewardRewardResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRankWeekRewardRewardResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool Success = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &success_)));
          set_has_success();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Error;
        break;
      }

      // optional uint32 Error = 2;
      case 2: {
        if (tag == 16) {
         parse_Error:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_)));
          set_has_error();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRankWeekRewardRewardResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRankWeekRewardRewardResp)
  return false;
#undef DO_
}

void CSRankWeekRewardRewardResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRankWeekRewardRewardResp)
  // optional bool Success = 1;
  if (has_success()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->success(), output);
  }

  // optional uint32 Error = 2;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->error(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRankWeekRewardRewardResp)
}

int CSRankWeekRewardRewardResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool Success = 1;
    if (has_success()) {
      total_size += 1 + 1;
    }

    // optional uint32 Error = 2;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRankWeekRewardRewardResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRankWeekRewardRewardResp*>(&from));
}

void CSRankWeekRewardRewardResp::MergeFrom(const CSRankWeekRewardRewardResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_success()) {
      set_success(from.success());
    }
    if (from.has_error()) {
      set_error(from.error());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRankWeekRewardRewardResp::CopyFrom(const CSRankWeekRewardRewardResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRankWeekRewardRewardResp::IsInitialized() const {

  return true;
}

void CSRankWeekRewardRewardResp::Swap(CSRankWeekRewardRewardResp* other) {
  if (other != this) {
    std::swap(success_, other->success_);
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRankWeekRewardRewardResp::GetTypeName() const {
  return "fgame.CSRankWeekRewardRewardResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSNewDailyTaskResp::kOkFieldNumber;
#endif  // !_MSC_VER

CSNewDailyTaskResp::CSNewDailyTaskResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSNewDailyTaskResp)
}

void CSNewDailyTaskResp::InitAsDefaultInstance() {
}

CSNewDailyTaskResp::CSNewDailyTaskResp(const CSNewDailyTaskResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSNewDailyTaskResp)
}

void CSNewDailyTaskResp::SharedCtor() {
  _cached_size_ = 0;
  ok_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSNewDailyTaskResp::~CSNewDailyTaskResp() {
  // @@protoc_insertion_point(destructor:fgame.CSNewDailyTaskResp)
  SharedDtor();
}

void CSNewDailyTaskResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSNewDailyTaskResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSNewDailyTaskResp& CSNewDailyTaskResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSNewDailyTaskResp* CSNewDailyTaskResp::default_instance_ = NULL;

CSNewDailyTaskResp* CSNewDailyTaskResp::New() const {
  return new CSNewDailyTaskResp;
}

void CSNewDailyTaskResp::Clear() {
  ok_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSNewDailyTaskResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSNewDailyTaskResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool Ok = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ok_)));
          set_has_ok();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSNewDailyTaskResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSNewDailyTaskResp)
  return false;
#undef DO_
}

void CSNewDailyTaskResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSNewDailyTaskResp)
  // required bool Ok = 1;
  if (has_ok()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->ok(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSNewDailyTaskResp)
}

int CSNewDailyTaskResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool Ok = 1;
    if (has_ok()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSNewDailyTaskResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSNewDailyTaskResp*>(&from));
}

void CSNewDailyTaskResp::MergeFrom(const CSNewDailyTaskResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ok()) {
      set_ok(from.ok());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSNewDailyTaskResp::CopyFrom(const CSNewDailyTaskResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSNewDailyTaskResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSNewDailyTaskResp::Swap(CSNewDailyTaskResp* other) {
  if (other != this) {
    std::swap(ok_, other->ok_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSNewDailyTaskResp::GetTypeName() const {
  return "fgame.CSNewDailyTaskResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSOpActAddResp::kActivityConifgFieldNumber;
#endif  // !_MSC_VER

CSOpActAddResp::CSOpActAddResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSOpActAddResp)
}

void CSOpActAddResp::InitAsDefaultInstance() {
}

CSOpActAddResp::CSOpActAddResp(const CSOpActAddResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSOpActAddResp)
}

void CSOpActAddResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  activityconifg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSOpActAddResp::~CSOpActAddResp() {
  // @@protoc_insertion_point(destructor:fgame.CSOpActAddResp)
  SharedDtor();
}

void CSOpActAddResp::SharedDtor() {
  if (activityconifg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete activityconifg_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSOpActAddResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSOpActAddResp& CSOpActAddResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSOpActAddResp* CSOpActAddResp::default_instance_ = NULL;

CSOpActAddResp* CSOpActAddResp::New() const {
  return new CSOpActAddResp;
}

void CSOpActAddResp::Clear() {
  if (has_activityconifg()) {
    if (activityconifg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      activityconifg_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSOpActAddResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSOpActAddResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string ActivityConifg = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_activityconifg()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSOpActAddResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSOpActAddResp)
  return false;
#undef DO_
}

void CSOpActAddResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSOpActAddResp)
  // required string ActivityConifg = 1;
  if (has_activityconifg()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->activityconifg(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSOpActAddResp)
}

int CSOpActAddResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string ActivityConifg = 1;
    if (has_activityconifg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->activityconifg());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSOpActAddResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSOpActAddResp*>(&from));
}

void CSOpActAddResp::MergeFrom(const CSOpActAddResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_activityconifg()) {
      set_activityconifg(from.activityconifg());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSOpActAddResp::CopyFrom(const CSOpActAddResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOpActAddResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSOpActAddResp::Swap(CSOpActAddResp* other) {
  if (other != this) {
    std::swap(activityconifg_, other->activityconifg_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSOpActAddResp::GetTypeName() const {
  return "fgame.CSOpActAddResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSOpActStateChangedResp::kActivityIdFieldNumber;
const int CSOpActStateChangedResp::kStateFieldNumber;
#endif  // !_MSC_VER

CSOpActStateChangedResp::CSOpActStateChangedResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSOpActStateChangedResp)
}

void CSOpActStateChangedResp::InitAsDefaultInstance() {
}

CSOpActStateChangedResp::CSOpActStateChangedResp(const CSOpActStateChangedResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSOpActStateChangedResp)
}

void CSOpActStateChangedResp::SharedCtor() {
  _cached_size_ = 0;
  activityid_ = 0u;
  state_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSOpActStateChangedResp::~CSOpActStateChangedResp() {
  // @@protoc_insertion_point(destructor:fgame.CSOpActStateChangedResp)
  SharedDtor();
}

void CSOpActStateChangedResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSOpActStateChangedResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSOpActStateChangedResp& CSOpActStateChangedResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSOpActStateChangedResp* CSOpActStateChangedResp::default_instance_ = NULL;

CSOpActStateChangedResp* CSOpActStateChangedResp::New() const {
  return new CSOpActStateChangedResp;
}

void CSOpActStateChangedResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSOpActStateChangedResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(activityid_, state_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSOpActStateChangedResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSOpActStateChangedResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ActivityId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &activityid_)));
          set_has_activityid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_state;
        break;
      }

      // required uint32 state = 2;
      case 2: {
        if (tag == 16) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSOpActStateChangedResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSOpActStateChangedResp)
  return false;
#undef DO_
}

void CSOpActStateChangedResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSOpActStateChangedResp)
  // required uint32 ActivityId = 1;
  if (has_activityid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->activityid(), output);
  }

  // required uint32 state = 2;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->state(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSOpActStateChangedResp)
}

int CSOpActStateChangedResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ActivityId = 1;
    if (has_activityid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->activityid());
    }

    // required uint32 state = 2;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->state());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSOpActStateChangedResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSOpActStateChangedResp*>(&from));
}

void CSOpActStateChangedResp::MergeFrom(const CSOpActStateChangedResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_activityid()) {
      set_activityid(from.activityid());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSOpActStateChangedResp::CopyFrom(const CSOpActStateChangedResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOpActStateChangedResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSOpActStateChangedResp::Swap(CSOpActStateChangedResp* other) {
  if (other != this) {
    std::swap(activityid_, other->activityid_);
    std::swap(state_, other->state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSOpActStateChangedResp::GetTypeName() const {
  return "fgame.CSOpActStateChangedResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSActSelfDataChangedResp::kSelfDataFieldNumber;
#endif  // !_MSC_VER

CSActSelfDataChangedResp::CSActSelfDataChangedResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSActSelfDataChangedResp)
}

void CSActSelfDataChangedResp::InitAsDefaultInstance() {
}

CSActSelfDataChangedResp::CSActSelfDataChangedResp(const CSActSelfDataChangedResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSActSelfDataChangedResp)
}

void CSActSelfDataChangedResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  selfdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSActSelfDataChangedResp::~CSActSelfDataChangedResp() {
  // @@protoc_insertion_point(destructor:fgame.CSActSelfDataChangedResp)
  SharedDtor();
}

void CSActSelfDataChangedResp::SharedDtor() {
  if (selfdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete selfdata_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSActSelfDataChangedResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSActSelfDataChangedResp& CSActSelfDataChangedResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSActSelfDataChangedResp* CSActSelfDataChangedResp::default_instance_ = NULL;

CSActSelfDataChangedResp* CSActSelfDataChangedResp::New() const {
  return new CSActSelfDataChangedResp;
}

void CSActSelfDataChangedResp::Clear() {
  if (has_selfdata()) {
    if (selfdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      selfdata_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSActSelfDataChangedResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSActSelfDataChangedResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string SelfData = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_selfdata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSActSelfDataChangedResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSActSelfDataChangedResp)
  return false;
#undef DO_
}

void CSActSelfDataChangedResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSActSelfDataChangedResp)
  // required string SelfData = 1;
  if (has_selfdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->selfdata(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSActSelfDataChangedResp)
}

int CSActSelfDataChangedResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string SelfData = 1;
    if (has_selfdata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->selfdata());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSActSelfDataChangedResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSActSelfDataChangedResp*>(&from));
}

void CSActSelfDataChangedResp::MergeFrom(const CSActSelfDataChangedResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_selfdata()) {
      set_selfdata(from.selfdata());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSActSelfDataChangedResp::CopyFrom(const CSActSelfDataChangedResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSActSelfDataChangedResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSActSelfDataChangedResp::Swap(CSActSelfDataChangedResp* other) {
  if (other != this) {
    std::swap(selfdata_, other->selfdata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSActSelfDataChangedResp::GetTypeName() const {
  return "fgame.CSActSelfDataChangedResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSActGlobalDataChangedResp::kGlobalDataFieldNumber;
#endif  // !_MSC_VER

CSActGlobalDataChangedResp::CSActGlobalDataChangedResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSActGlobalDataChangedResp)
}

void CSActGlobalDataChangedResp::InitAsDefaultInstance() {
}

CSActGlobalDataChangedResp::CSActGlobalDataChangedResp(const CSActGlobalDataChangedResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSActGlobalDataChangedResp)
}

void CSActGlobalDataChangedResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  globaldata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSActGlobalDataChangedResp::~CSActGlobalDataChangedResp() {
  // @@protoc_insertion_point(destructor:fgame.CSActGlobalDataChangedResp)
  SharedDtor();
}

void CSActGlobalDataChangedResp::SharedDtor() {
  if (globaldata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete globaldata_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSActGlobalDataChangedResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSActGlobalDataChangedResp& CSActGlobalDataChangedResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSActGlobalDataChangedResp* CSActGlobalDataChangedResp::default_instance_ = NULL;

CSActGlobalDataChangedResp* CSActGlobalDataChangedResp::New() const {
  return new CSActGlobalDataChangedResp;
}

void CSActGlobalDataChangedResp::Clear() {
  if (has_globaldata()) {
    if (globaldata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      globaldata_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSActGlobalDataChangedResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSActGlobalDataChangedResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string GlobalData = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_globaldata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSActGlobalDataChangedResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSActGlobalDataChangedResp)
  return false;
#undef DO_
}

void CSActGlobalDataChangedResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSActGlobalDataChangedResp)
  // required string GlobalData = 1;
  if (has_globaldata()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->globaldata(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSActGlobalDataChangedResp)
}

int CSActGlobalDataChangedResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string GlobalData = 1;
    if (has_globaldata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->globaldata());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSActGlobalDataChangedResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSActGlobalDataChangedResp*>(&from));
}

void CSActGlobalDataChangedResp::MergeFrom(const CSActGlobalDataChangedResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_globaldata()) {
      set_globaldata(from.globaldata());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSActGlobalDataChangedResp::CopyFrom(const CSActGlobalDataChangedResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSActGlobalDataChangedResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSActGlobalDataChangedResp::Swap(CSActGlobalDataChangedResp* other) {
  if (other != this) {
    std::swap(globaldata_, other->globaldata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSActGlobalDataChangedResp::GetTypeName() const {
  return "fgame.CSActGlobalDataChangedResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSOpActConfigListReq::CSOpActConfigListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSOpActConfigListReq)
}

void CSOpActConfigListReq::InitAsDefaultInstance() {
}

CSOpActConfigListReq::CSOpActConfigListReq(const CSOpActConfigListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSOpActConfigListReq)
}

void CSOpActConfigListReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSOpActConfigListReq::~CSOpActConfigListReq() {
  // @@protoc_insertion_point(destructor:fgame.CSOpActConfigListReq)
  SharedDtor();
}

void CSOpActConfigListReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSOpActConfigListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSOpActConfigListReq& CSOpActConfigListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSOpActConfigListReq* CSOpActConfigListReq::default_instance_ = NULL;

CSOpActConfigListReq* CSOpActConfigListReq::New() const {
  return new CSOpActConfigListReq;
}

void CSOpActConfigListReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSOpActConfigListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSOpActConfigListReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSOpActConfigListReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSOpActConfigListReq)
  return false;
#undef DO_
}

void CSOpActConfigListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSOpActConfigListReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSOpActConfigListReq)
}

int CSOpActConfigListReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSOpActConfigListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSOpActConfigListReq*>(&from));
}

void CSOpActConfigListReq::MergeFrom(const CSOpActConfigListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSOpActConfigListReq::CopyFrom(const CSOpActConfigListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOpActConfigListReq::IsInitialized() const {

  return true;
}

void CSOpActConfigListReq::Swap(CSOpActConfigListReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSOpActConfigListReq::GetTypeName() const {
  return "fgame.CSOpActConfigListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSOpActConfigListResp::kActivityConfigFieldNumber;
#endif  // !_MSC_VER

CSOpActConfigListResp::CSOpActConfigListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSOpActConfigListResp)
}

void CSOpActConfigListResp::InitAsDefaultInstance() {
}

CSOpActConfigListResp::CSOpActConfigListResp(const CSOpActConfigListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSOpActConfigListResp)
}

void CSOpActConfigListResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSOpActConfigListResp::~CSOpActConfigListResp() {
  // @@protoc_insertion_point(destructor:fgame.CSOpActConfigListResp)
  SharedDtor();
}

void CSOpActConfigListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSOpActConfigListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSOpActConfigListResp& CSOpActConfigListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSOpActConfigListResp* CSOpActConfigListResp::default_instance_ = NULL;

CSOpActConfigListResp* CSOpActConfigListResp::New() const {
  return new CSOpActConfigListResp;
}

void CSOpActConfigListResp::Clear() {
  activityconfig_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSOpActConfigListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSOpActConfigListResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string ActivityConfig = 1;
      case 1: {
        if (tag == 10) {
         parse_ActivityConfig:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_activityconfig()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_ActivityConfig;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSOpActConfigListResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSOpActConfigListResp)
  return false;
#undef DO_
}

void CSOpActConfigListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSOpActConfigListResp)
  // repeated string ActivityConfig = 1;
  for (int i = 0; i < this->activityconfig_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->activityconfig(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSOpActConfigListResp)
}

int CSOpActConfigListResp::ByteSize() const {
  int total_size = 0;

  // repeated string ActivityConfig = 1;
  total_size += 1 * this->activityconfig_size();
  for (int i = 0; i < this->activityconfig_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->activityconfig(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSOpActConfigListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSOpActConfigListResp*>(&from));
}

void CSOpActConfigListResp::MergeFrom(const CSOpActConfigListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  activityconfig_.MergeFrom(from.activityconfig_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSOpActConfigListResp::CopyFrom(const CSOpActConfigListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOpActConfigListResp::IsInitialized() const {

  return true;
}

void CSOpActConfigListResp::Swap(CSOpActConfigListResp* other) {
  if (other != this) {
    activityconfig_.Swap(&other->activityconfig_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSOpActConfigListResp::GetTypeName() const {
  return "fgame.CSOpActConfigListResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSOpActSelfDataListReq::CSOpActSelfDataListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSOpActSelfDataListReq)
}

void CSOpActSelfDataListReq::InitAsDefaultInstance() {
}

CSOpActSelfDataListReq::CSOpActSelfDataListReq(const CSOpActSelfDataListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSOpActSelfDataListReq)
}

void CSOpActSelfDataListReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSOpActSelfDataListReq::~CSOpActSelfDataListReq() {
  // @@protoc_insertion_point(destructor:fgame.CSOpActSelfDataListReq)
  SharedDtor();
}

void CSOpActSelfDataListReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSOpActSelfDataListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSOpActSelfDataListReq& CSOpActSelfDataListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSOpActSelfDataListReq* CSOpActSelfDataListReq::default_instance_ = NULL;

CSOpActSelfDataListReq* CSOpActSelfDataListReq::New() const {
  return new CSOpActSelfDataListReq;
}

void CSOpActSelfDataListReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSOpActSelfDataListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSOpActSelfDataListReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSOpActSelfDataListReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSOpActSelfDataListReq)
  return false;
#undef DO_
}

void CSOpActSelfDataListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSOpActSelfDataListReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSOpActSelfDataListReq)
}

int CSOpActSelfDataListReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSOpActSelfDataListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSOpActSelfDataListReq*>(&from));
}

void CSOpActSelfDataListReq::MergeFrom(const CSOpActSelfDataListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSOpActSelfDataListReq::CopyFrom(const CSOpActSelfDataListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOpActSelfDataListReq::IsInitialized() const {

  return true;
}

void CSOpActSelfDataListReq::Swap(CSOpActSelfDataListReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSOpActSelfDataListReq::GetTypeName() const {
  return "fgame.CSOpActSelfDataListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSOpActSelfDataListResp::kSelfDataFieldNumber;
#endif  // !_MSC_VER

CSOpActSelfDataListResp::CSOpActSelfDataListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSOpActSelfDataListResp)
}

void CSOpActSelfDataListResp::InitAsDefaultInstance() {
}

CSOpActSelfDataListResp::CSOpActSelfDataListResp(const CSOpActSelfDataListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSOpActSelfDataListResp)
}

void CSOpActSelfDataListResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSOpActSelfDataListResp::~CSOpActSelfDataListResp() {
  // @@protoc_insertion_point(destructor:fgame.CSOpActSelfDataListResp)
  SharedDtor();
}

void CSOpActSelfDataListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSOpActSelfDataListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSOpActSelfDataListResp& CSOpActSelfDataListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSOpActSelfDataListResp* CSOpActSelfDataListResp::default_instance_ = NULL;

CSOpActSelfDataListResp* CSOpActSelfDataListResp::New() const {
  return new CSOpActSelfDataListResp;
}

void CSOpActSelfDataListResp::Clear() {
  selfdata_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSOpActSelfDataListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSOpActSelfDataListResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string SelfData = 1;
      case 1: {
        if (tag == 10) {
         parse_SelfData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_selfdata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_SelfData;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSOpActSelfDataListResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSOpActSelfDataListResp)
  return false;
#undef DO_
}

void CSOpActSelfDataListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSOpActSelfDataListResp)
  // repeated string SelfData = 1;
  for (int i = 0; i < this->selfdata_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->selfdata(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSOpActSelfDataListResp)
}

int CSOpActSelfDataListResp::ByteSize() const {
  int total_size = 0;

  // repeated string SelfData = 1;
  total_size += 1 * this->selfdata_size();
  for (int i = 0; i < this->selfdata_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->selfdata(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSOpActSelfDataListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSOpActSelfDataListResp*>(&from));
}

void CSOpActSelfDataListResp::MergeFrom(const CSOpActSelfDataListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  selfdata_.MergeFrom(from.selfdata_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSOpActSelfDataListResp::CopyFrom(const CSOpActSelfDataListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOpActSelfDataListResp::IsInitialized() const {

  return true;
}

void CSOpActSelfDataListResp::Swap(CSOpActSelfDataListResp* other) {
  if (other != this) {
    selfdata_.Swap(&other->selfdata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSOpActSelfDataListResp::GetTypeName() const {
  return "fgame.CSOpActSelfDataListResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSOpActGlobalDataListReq::CSOpActGlobalDataListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSOpActGlobalDataListReq)
}

void CSOpActGlobalDataListReq::InitAsDefaultInstance() {
}

CSOpActGlobalDataListReq::CSOpActGlobalDataListReq(const CSOpActGlobalDataListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSOpActGlobalDataListReq)
}

void CSOpActGlobalDataListReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSOpActGlobalDataListReq::~CSOpActGlobalDataListReq() {
  // @@protoc_insertion_point(destructor:fgame.CSOpActGlobalDataListReq)
  SharedDtor();
}

void CSOpActGlobalDataListReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSOpActGlobalDataListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSOpActGlobalDataListReq& CSOpActGlobalDataListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSOpActGlobalDataListReq* CSOpActGlobalDataListReq::default_instance_ = NULL;

CSOpActGlobalDataListReq* CSOpActGlobalDataListReq::New() const {
  return new CSOpActGlobalDataListReq;
}

void CSOpActGlobalDataListReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSOpActGlobalDataListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSOpActGlobalDataListReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSOpActGlobalDataListReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSOpActGlobalDataListReq)
  return false;
#undef DO_
}

void CSOpActGlobalDataListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSOpActGlobalDataListReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSOpActGlobalDataListReq)
}

int CSOpActGlobalDataListReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSOpActGlobalDataListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSOpActGlobalDataListReq*>(&from));
}

void CSOpActGlobalDataListReq::MergeFrom(const CSOpActGlobalDataListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSOpActGlobalDataListReq::CopyFrom(const CSOpActGlobalDataListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOpActGlobalDataListReq::IsInitialized() const {

  return true;
}

void CSOpActGlobalDataListReq::Swap(CSOpActGlobalDataListReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSOpActGlobalDataListReq::GetTypeName() const {
  return "fgame.CSOpActGlobalDataListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSOpActGlobalDataListResp::kGlobalDataFieldNumber;
#endif  // !_MSC_VER

CSOpActGlobalDataListResp::CSOpActGlobalDataListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSOpActGlobalDataListResp)
}

void CSOpActGlobalDataListResp::InitAsDefaultInstance() {
}

CSOpActGlobalDataListResp::CSOpActGlobalDataListResp(const CSOpActGlobalDataListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSOpActGlobalDataListResp)
}

void CSOpActGlobalDataListResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSOpActGlobalDataListResp::~CSOpActGlobalDataListResp() {
  // @@protoc_insertion_point(destructor:fgame.CSOpActGlobalDataListResp)
  SharedDtor();
}

void CSOpActGlobalDataListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSOpActGlobalDataListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSOpActGlobalDataListResp& CSOpActGlobalDataListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSOpActGlobalDataListResp* CSOpActGlobalDataListResp::default_instance_ = NULL;

CSOpActGlobalDataListResp* CSOpActGlobalDataListResp::New() const {
  return new CSOpActGlobalDataListResp;
}

void CSOpActGlobalDataListResp::Clear() {
  globaldata_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSOpActGlobalDataListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSOpActGlobalDataListResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string GlobalData = 1;
      case 1: {
        if (tag == 10) {
         parse_GlobalData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_globaldata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_GlobalData;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSOpActGlobalDataListResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSOpActGlobalDataListResp)
  return false;
#undef DO_
}

void CSOpActGlobalDataListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSOpActGlobalDataListResp)
  // repeated string GlobalData = 1;
  for (int i = 0; i < this->globaldata_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->globaldata(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSOpActGlobalDataListResp)
}

int CSOpActGlobalDataListResp::ByteSize() const {
  int total_size = 0;

  // repeated string GlobalData = 1;
  total_size += 1 * this->globaldata_size();
  for (int i = 0; i < this->globaldata_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->globaldata(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSOpActGlobalDataListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSOpActGlobalDataListResp*>(&from));
}

void CSOpActGlobalDataListResp::MergeFrom(const CSOpActGlobalDataListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  globaldata_.MergeFrom(from.globaldata_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSOpActGlobalDataListResp::CopyFrom(const CSOpActGlobalDataListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOpActGlobalDataListResp::IsInitialized() const {

  return true;
}

void CSOpActGlobalDataListResp::Swap(CSOpActGlobalDataListResp* other) {
  if (other != this) {
    globaldata_.Swap(&other->globaldata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSOpActGlobalDataListResp::GetTypeName() const {
  return "fgame.CSOpActGlobalDataListResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSOpActDemoTakeReq::kActivityIdFieldNumber;
#endif  // !_MSC_VER

CSOpActDemoTakeReq::CSOpActDemoTakeReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSOpActDemoTakeReq)
}

void CSOpActDemoTakeReq::InitAsDefaultInstance() {
}

CSOpActDemoTakeReq::CSOpActDemoTakeReq(const CSOpActDemoTakeReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSOpActDemoTakeReq)
}

void CSOpActDemoTakeReq::SharedCtor() {
  _cached_size_ = 0;
  activityid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSOpActDemoTakeReq::~CSOpActDemoTakeReq() {
  // @@protoc_insertion_point(destructor:fgame.CSOpActDemoTakeReq)
  SharedDtor();
}

void CSOpActDemoTakeReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSOpActDemoTakeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSOpActDemoTakeReq& CSOpActDemoTakeReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSOpActDemoTakeReq* CSOpActDemoTakeReq::default_instance_ = NULL;

CSOpActDemoTakeReq* CSOpActDemoTakeReq::New() const {
  return new CSOpActDemoTakeReq;
}

void CSOpActDemoTakeReq::Clear() {
  activityid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSOpActDemoTakeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSOpActDemoTakeReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ActivityId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &activityid_)));
          set_has_activityid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSOpActDemoTakeReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSOpActDemoTakeReq)
  return false;
#undef DO_
}

void CSOpActDemoTakeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSOpActDemoTakeReq)
  // required uint32 ActivityId = 1;
  if (has_activityid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->activityid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSOpActDemoTakeReq)
}

int CSOpActDemoTakeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ActivityId = 1;
    if (has_activityid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->activityid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSOpActDemoTakeReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSOpActDemoTakeReq*>(&from));
}

void CSOpActDemoTakeReq::MergeFrom(const CSOpActDemoTakeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_activityid()) {
      set_activityid(from.activityid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSOpActDemoTakeReq::CopyFrom(const CSOpActDemoTakeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOpActDemoTakeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSOpActDemoTakeReq::Swap(CSOpActDemoTakeReq* other) {
  if (other != this) {
    std::swap(activityid_, other->activityid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSOpActDemoTakeReq::GetTypeName() const {
  return "fgame.CSOpActDemoTakeReq";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSOpActDemoTakeResp::CSOpActDemoTakeResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSOpActDemoTakeResp)
}

void CSOpActDemoTakeResp::InitAsDefaultInstance() {
}

CSOpActDemoTakeResp::CSOpActDemoTakeResp(const CSOpActDemoTakeResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSOpActDemoTakeResp)
}

void CSOpActDemoTakeResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSOpActDemoTakeResp::~CSOpActDemoTakeResp() {
  // @@protoc_insertion_point(destructor:fgame.CSOpActDemoTakeResp)
  SharedDtor();
}

void CSOpActDemoTakeResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSOpActDemoTakeResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSOpActDemoTakeResp& CSOpActDemoTakeResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Activity_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Activity_2eproto();
#endif
  return *default_instance_;
}

CSOpActDemoTakeResp* CSOpActDemoTakeResp::default_instance_ = NULL;

CSOpActDemoTakeResp* CSOpActDemoTakeResp::New() const {
  return new CSOpActDemoTakeResp;
}

void CSOpActDemoTakeResp::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSOpActDemoTakeResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSOpActDemoTakeResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSOpActDemoTakeResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSOpActDemoTakeResp)
  return false;
#undef DO_
}

void CSOpActDemoTakeResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSOpActDemoTakeResp)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSOpActDemoTakeResp)
}

int CSOpActDemoTakeResp::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSOpActDemoTakeResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSOpActDemoTakeResp*>(&from));
}

void CSOpActDemoTakeResp::MergeFrom(const CSOpActDemoTakeResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSOpActDemoTakeResp::CopyFrom(const CSOpActDemoTakeResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOpActDemoTakeResp::IsInitialized() const {

  return true;
}

void CSOpActDemoTakeResp::Swap(CSOpActDemoTakeResp* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSOpActDemoTakeResp::GetTypeName() const {
  return "fgame.CSOpActDemoTakeResp";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fgame

// @@protoc_insertion_point(global_scope)
