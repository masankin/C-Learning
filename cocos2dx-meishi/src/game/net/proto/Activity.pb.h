// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Activity.proto

#ifndef PROTOBUF_Activity_2eproto__INCLUDED
#define PROTOBUF_Activity_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "Player.pb.h"
// @@protoc_insertion_point(includes)

namespace fgame {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Activity_2eproto();
void protobuf_AssignDesc_Activity_2eproto();
void protobuf_ShutdownFile_Activity_2eproto();

class CSGetOpenActivityReq;
class CSOpenActivityInfo;
class CSGetOpenActivityResp;
class CSGetActivityDataReq;
class CSActivityInfo;
class CSGetActivityDataResp;
class CSReceiveActivityRewardReq;
class CSReceiveActivityRewardResp;
class CSGetPowerEnergyActivityDataReq;
class CSGetPowerEnergyActivityResp;
class CSReceivePowerEnergyReq;
class CSReceivePowerEnergyResp;
class CSSubActivity;
class CSActivityData;
class CSActivityListReq;
class CSActivityListResp;
class CSActivitySubmitReq;
class CSActivitySubmitResp;
class CSActivityUpdateResp;
class CSNewYearGetInfoReq;
class CSNewYearGetInfoResp;
class CSNewYearRewardReq;
class CSNewYearRewardResp;
class CSNewYearCmpReq;
class CSNewYearCmpResp;
class CSActivityCrazyDtlsReq;
class CSActivityCrazyDtlsResp;
class CSActivityCrazyUsageReq;
class CSActivityCrazyUsageResp;
class CSActivityCrazyUsableResp;
class CSOpenChestReq;
class CSRedPacketsGetInfoReq;
class CSRedPacketsGetInfoResp;
class CSRedPacketsGrebReq;
class CSRedPacketsGrebResp;
class CSRedPacketsOpenedReq;
class CSRedPacketsOpenedResp;
class CSChristmasDecorateReq;
class CSChristmasDecorateResp;
class CSChristmasTakeBonusReq;
class CSChristmasTakeBonusResp;
class CSChristmasGetDataReq;
class ChristmasTakeRecord;
class CSChristmasGetDataResp;
class CSChristmasGetRankReq;
class ChristmasRankItem;
class CSChristmasGetRankResp;
class CSValentineDataReq;
class CSValentineDataResp;
class CSValentineExchangeReq;
class CSValentineExchangeResp;
class CSDailyTaskStatusReq;
class CSDailyTaskStatusResp;
class CSRequestDailyTaskReq;
class DailyTaskInfo;
class CSRequestDailyTaskResp;
class CSUpdateTaskStatusReq;
class CSUpdateTaskStatusResp;
class CSChangeDailyTaskReq;
class CSChangeDailyTaskResp;
class CSOpenDailyTaskAwardReq;
class CSOpenDailyTaskAwardResp;
class CSUpdateDailyTaskProgressReq;
class CSUpdateDailyTaskProgressResp;
class CSRankWeekRewardInfoReq;
class CSRankWeekRewardInfoResp;
class CSRankWeekRewardRewardReq;
class CSRankWeekRewardRewardResp;
class CSNewDailyTaskResp;
class CSOpActAddResp;
class CSOpActStateChangedResp;
class CSActSelfDataChangedResp;
class CSActGlobalDataChangedResp;
class CSOpActConfigListReq;
class CSOpActConfigListResp;
class CSOpActSelfDataListReq;
class CSOpActSelfDataListResp;
class CSOpActGlobalDataListReq;
class CSOpActGlobalDataListResp;
class CSOpActDemoTakeReq;
class CSOpActDemoTakeResp;

// ===================================================================

class CSGetOpenActivityReq : public ::google::protobuf::MessageLite {
 public:
  CSGetOpenActivityReq();
  virtual ~CSGetOpenActivityReq();

  CSGetOpenActivityReq(const CSGetOpenActivityReq& from);

  inline CSGetOpenActivityReq& operator=(const CSGetOpenActivityReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetOpenActivityReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetOpenActivityReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetOpenActivityReq* other);

  // implements Message ----------------------------------------------

  CSGetOpenActivityReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetOpenActivityReq& from);
  void MergeFrom(const CSGetOpenActivityReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSGetOpenActivityReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSGetOpenActivityReq* default_instance_;
};
// -------------------------------------------------------------------

class CSOpenActivityInfo : public ::google::protobuf::MessageLite {
 public:
  CSOpenActivityInfo();
  virtual ~CSOpenActivityInfo();

  CSOpenActivityInfo(const CSOpenActivityInfo& from);

  inline CSOpenActivityInfo& operator=(const CSOpenActivityInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSOpenActivityInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOpenActivityInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOpenActivityInfo* other);

  // implements Message ----------------------------------------------

  CSOpenActivityInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOpenActivityInfo& from);
  void MergeFrom(const CSOpenActivityInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSOpenActivityInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSOpenActivityInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSGetOpenActivityResp : public ::google::protobuf::MessageLite {
 public:
  CSGetOpenActivityResp();
  virtual ~CSGetOpenActivityResp();

  CSGetOpenActivityResp(const CSGetOpenActivityResp& from);

  inline CSGetOpenActivityResp& operator=(const CSGetOpenActivityResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetOpenActivityResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetOpenActivityResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetOpenActivityResp* other);

  // implements Message ----------------------------------------------

  CSGetOpenActivityResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetOpenActivityResp& from);
  void MergeFrom(const CSGetOpenActivityResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.CSOpenActivityInfo OpenActivityInfo = 1;
  inline int openactivityinfo_size() const;
  inline void clear_openactivityinfo();
  static const int kOpenActivityInfoFieldNumber = 1;
  inline const ::fgame::CSOpenActivityInfo& openactivityinfo(int index) const;
  inline ::fgame::CSOpenActivityInfo* mutable_openactivityinfo(int index);
  inline ::fgame::CSOpenActivityInfo* add_openactivityinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSOpenActivityInfo >&
      openactivityinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSOpenActivityInfo >*
      mutable_openactivityinfo();

  // @@protoc_insertion_point(class_scope:fgame.CSGetOpenActivityResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSOpenActivityInfo > openactivityinfo_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSGetOpenActivityResp* default_instance_;
};
// -------------------------------------------------------------------

class CSGetActivityDataReq : public ::google::protobuf::MessageLite {
 public:
  CSGetActivityDataReq();
  virtual ~CSGetActivityDataReq();

  CSGetActivityDataReq(const CSGetActivityDataReq& from);

  inline CSGetActivityDataReq& operator=(const CSGetActivityDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetActivityDataReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetActivityDataReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetActivityDataReq* other);

  // implements Message ----------------------------------------------

  CSGetActivityDataReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetActivityDataReq& from);
  void MergeFrom(const CSGetActivityDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSGetActivityDataReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSGetActivityDataReq* default_instance_;
};
// -------------------------------------------------------------------

class CSActivityInfo : public ::google::protobuf::MessageLite {
 public:
  CSActivityInfo();
  virtual ~CSActivityInfo();

  CSActivityInfo(const CSActivityInfo& from);

  inline CSActivityInfo& operator=(const CSActivityInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSActivityInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActivityInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActivityInfo* other);

  // implements Message ----------------------------------------------

  CSActivityInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActivityInfo& from);
  void MergeFrom(const CSActivityInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 Stage = 2;
  inline bool has_stage() const;
  inline void clear_stage();
  static const int kStageFieldNumber = 2;
  inline ::google::protobuf::uint32 stage() const;
  inline void set_stage(::google::protobuf::uint32 value);

  // required uint32 Type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 Status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint32 Gift = 5;
  inline bool has_gift() const;
  inline void clear_gift();
  static const int kGiftFieldNumber = 5;
  inline ::google::protobuf::uint32 gift() const;
  inline void set_gift(::google::protobuf::uint32 value);

  // optional string StartTime = 6;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 6;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string EndTime = 7;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 7;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional uint32 Recharge_num = 8;
  inline bool has_recharge_num() const;
  inline void clear_recharge_num();
  static const int kRechargeNumFieldNumber = 8;
  inline ::google::protobuf::uint32 recharge_num() const;
  inline void set_recharge_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSActivityInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_stage();
  inline void clear_has_stage();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_gift();
  inline void clear_has_gift();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_recharge_num();
  inline void clear_has_recharge_num();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 stage_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 status_;
  ::std::string* starttime_;
  ::google::protobuf::uint32 gift_;
  ::google::protobuf::uint32 recharge_num_;
  ::std::string* endtime_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSActivityInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSGetActivityDataResp : public ::google::protobuf::MessageLite {
 public:
  CSGetActivityDataResp();
  virtual ~CSGetActivityDataResp();

  CSGetActivityDataResp(const CSGetActivityDataResp& from);

  inline CSGetActivityDataResp& operator=(const CSGetActivityDataResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetActivityDataResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetActivityDataResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetActivityDataResp* other);

  // implements Message ----------------------------------------------

  CSGetActivityDataResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetActivityDataResp& from);
  void MergeFrom(const CSGetActivityDataResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 DayCount = 1;
  inline bool has_daycount() const;
  inline void clear_daycount();
  static const int kDayCountFieldNumber = 1;
  inline ::google::protobuf::uint32 daycount() const;
  inline void set_daycount(::google::protobuf::uint32 value);

  // required uint32 RechargeCount = 2;
  inline bool has_rechargecount() const;
  inline void clear_rechargecount();
  static const int kRechargeCountFieldNumber = 2;
  inline ::google::protobuf::uint32 rechargecount() const;
  inline void set_rechargecount(::google::protobuf::uint32 value);

  // repeated .fgame.CSActivityInfo ActivityInfo = 3;
  inline int activityinfo_size() const;
  inline void clear_activityinfo();
  static const int kActivityInfoFieldNumber = 3;
  inline const ::fgame::CSActivityInfo& activityinfo(int index) const;
  inline ::fgame::CSActivityInfo* mutable_activityinfo(int index);
  inline ::fgame::CSActivityInfo* add_activityinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSActivityInfo >&
      activityinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSActivityInfo >*
      mutable_activityinfo();

  // @@protoc_insertion_point(class_scope:fgame.CSGetActivityDataResp)
 private:
  inline void set_has_daycount();
  inline void clear_has_daycount();
  inline void set_has_rechargecount();
  inline void clear_has_rechargecount();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 daycount_;
  ::google::protobuf::uint32 rechargecount_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSActivityInfo > activityinfo_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSGetActivityDataResp* default_instance_;
};
// -------------------------------------------------------------------

class CSReceiveActivityRewardReq : public ::google::protobuf::MessageLite {
 public:
  CSReceiveActivityRewardReq();
  virtual ~CSReceiveActivityRewardReq();

  CSReceiveActivityRewardReq(const CSReceiveActivityRewardReq& from);

  inline CSReceiveActivityRewardReq& operator=(const CSReceiveActivityRewardReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSReceiveActivityRewardReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSReceiveActivityRewardReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSReceiveActivityRewardReq* other);

  // implements Message ----------------------------------------------

  CSReceiveActivityRewardReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSReceiveActivityRewardReq& from);
  void MergeFrom(const CSReceiveActivityRewardReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 Stage = 2;
  inline bool has_stage() const;
  inline void clear_stage();
  static const int kStageFieldNumber = 2;
  inline ::google::protobuf::uint32 stage() const;
  inline void set_stage(::google::protobuf::uint32 value);

  // required uint32 Type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSReceiveActivityRewardReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_stage();
  inline void clear_has_stage();
  inline void set_has_type();
  inline void clear_has_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 stage_;
  ::google::protobuf::uint32 type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSReceiveActivityRewardReq* default_instance_;
};
// -------------------------------------------------------------------

class CSReceiveActivityRewardResp : public ::google::protobuf::MessageLite {
 public:
  CSReceiveActivityRewardResp();
  virtual ~CSReceiveActivityRewardResp();

  CSReceiveActivityRewardResp(const CSReceiveActivityRewardResp& from);

  inline CSReceiveActivityRewardResp& operator=(const CSReceiveActivityRewardResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSReceiveActivityRewardResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSReceiveActivityRewardResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSReceiveActivityRewardResp* other);

  // implements Message ----------------------------------------------

  CSReceiveActivityRewardResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSReceiveActivityRewardResp& from);
  void MergeFrom(const CSReceiveActivityRewardResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required uint32 Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 Id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSReceiveActivityRewardResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSReceiveActivityRewardResp* default_instance_;
};
// -------------------------------------------------------------------

class CSGetPowerEnergyActivityDataReq : public ::google::protobuf::MessageLite {
 public:
  CSGetPowerEnergyActivityDataReq();
  virtual ~CSGetPowerEnergyActivityDataReq();

  CSGetPowerEnergyActivityDataReq(const CSGetPowerEnergyActivityDataReq& from);

  inline CSGetPowerEnergyActivityDataReq& operator=(const CSGetPowerEnergyActivityDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetPowerEnergyActivityDataReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetPowerEnergyActivityDataReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetPowerEnergyActivityDataReq* other);

  // implements Message ----------------------------------------------

  CSGetPowerEnergyActivityDataReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetPowerEnergyActivityDataReq& from);
  void MergeFrom(const CSGetPowerEnergyActivityDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSGetPowerEnergyActivityDataReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSGetPowerEnergyActivityDataReq* default_instance_;
};
// -------------------------------------------------------------------

class CSGetPowerEnergyActivityResp : public ::google::protobuf::MessageLite {
 public:
  CSGetPowerEnergyActivityResp();
  virtual ~CSGetPowerEnergyActivityResp();

  CSGetPowerEnergyActivityResp(const CSGetPowerEnergyActivityResp& from);

  inline CSGetPowerEnergyActivityResp& operator=(const CSGetPowerEnergyActivityResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetPowerEnergyActivityResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetPowerEnergyActivityResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetPowerEnergyActivityResp* other);

  // implements Message ----------------------------------------------

  CSGetPowerEnergyActivityResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetPowerEnergyActivityResp& from);
  void MergeFrom(const CSGetPowerEnergyActivityResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 IsOpen = 2;
  inline bool has_isopen() const;
  inline void clear_isopen();
  static const int kIsOpenFieldNumber = 2;
  inline ::google::protobuf::uint32 isopen() const;
  inline void set_isopen(::google::protobuf::uint32 value);

  // required uint32 Status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // required uint32 StartTime = 4;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 starttime() const;
  inline void set_starttime(::google::protobuf::uint32 value);

  // required uint32 EndTime = 5;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 endtime() const;
  inline void set_endtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGetPowerEnergyActivityResp)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_isopen();
  inline void clear_has_isopen();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 isopen_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 starttime_;
  ::google::protobuf::uint32 endtime_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSGetPowerEnergyActivityResp* default_instance_;
};
// -------------------------------------------------------------------

class CSReceivePowerEnergyReq : public ::google::protobuf::MessageLite {
 public:
  CSReceivePowerEnergyReq();
  virtual ~CSReceivePowerEnergyReq();

  CSReceivePowerEnergyReq(const CSReceivePowerEnergyReq& from);

  inline CSReceivePowerEnergyReq& operator=(const CSReceivePowerEnergyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSReceivePowerEnergyReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSReceivePowerEnergyReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSReceivePowerEnergyReq* other);

  // implements Message ----------------------------------------------

  CSReceivePowerEnergyReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSReceivePowerEnergyReq& from);
  void MergeFrom(const CSReceivePowerEnergyReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSReceivePowerEnergyReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSReceivePowerEnergyReq* default_instance_;
};
// -------------------------------------------------------------------

class CSReceivePowerEnergyResp : public ::google::protobuf::MessageLite {
 public:
  CSReceivePowerEnergyResp();
  virtual ~CSReceivePowerEnergyResp();

  CSReceivePowerEnergyResp(const CSReceivePowerEnergyResp& from);

  inline CSReceivePowerEnergyResp& operator=(const CSReceivePowerEnergyResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSReceivePowerEnergyResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSReceivePowerEnergyResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSReceivePowerEnergyResp* other);

  // implements Message ----------------------------------------------

  CSReceivePowerEnergyResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSReceivePowerEnergyResp& from);
  void MergeFrom(const CSReceivePowerEnergyResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required uint32 Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSReceivePowerEnergyResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_type();
  inline void clear_has_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSReceivePowerEnergyResp* default_instance_;
};
// -------------------------------------------------------------------

class CSSubActivity : public ::google::protobuf::MessageLite {
 public:
  CSSubActivity();
  virtual ~CSSubActivity();

  CSSubActivity(const CSSubActivity& from);

  inline CSSubActivity& operator=(const CSSubActivity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSubActivity& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSubActivity* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSubActivity* other);

  // implements Message ----------------------------------------------

  CSSubActivity* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSubActivity& from);
  void MergeFrom(const CSSubActivity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Act_Id = 1;
  inline bool has_act_id() const;
  inline void clear_act_id();
  static const int kActIdFieldNumber = 1;
  inline ::google::protobuf::uint32 act_id() const;
  inline void set_act_id(::google::protobuf::uint32 value);

  // required uint32 Sub_Id = 2;
  inline bool has_sub_id() const;
  inline void clear_sub_id();
  static const int kSubIdFieldNumber = 2;
  inline ::google::protobuf::uint32 sub_id() const;
  inline void set_sub_id(::google::protobuf::uint32 value);

  // optional uint32 GiftId = 3;
  inline bool has_giftid() const;
  inline void clear_giftid();
  static const int kGiftIdFieldNumber = 3;
  inline ::google::protobuf::uint32 giftid() const;
  inline void set_giftid(::google::protobuf::uint32 value);

  // optional uint32 Request = 4;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 4;
  inline ::google::protobuf::uint32 request() const;
  inline void set_request(::google::protobuf::uint32 value);

  // optional uint32 Value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // optional bool Completed = 6;
  inline bool has_completed() const;
  inline void clear_completed();
  static const int kCompletedFieldNumber = 6;
  inline bool completed() const;
  inline void set_completed(bool value);

  // optional bool Submit = 7;
  inline bool has_submit() const;
  inline void clear_submit();
  static const int kSubmitFieldNumber = 7;
  inline bool submit() const;
  inline void set_submit(bool value);

  // @@protoc_insertion_point(class_scope:fgame.CSSubActivity)
 private:
  inline void set_has_act_id();
  inline void clear_has_act_id();
  inline void set_has_sub_id();
  inline void clear_has_sub_id();
  inline void set_has_giftid();
  inline void clear_has_giftid();
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_completed();
  inline void clear_has_completed();
  inline void set_has_submit();
  inline void clear_has_submit();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 act_id_;
  ::google::protobuf::uint32 sub_id_;
  ::google::protobuf::uint32 giftid_;
  ::google::protobuf::uint32 request_;
  ::google::protobuf::uint32 value_;
  bool completed_;
  bool submit_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSSubActivity* default_instance_;
};
// -------------------------------------------------------------------

class CSActivityData : public ::google::protobuf::MessageLite {
 public:
  CSActivityData();
  virtual ~CSActivityData();

  CSActivityData(const CSActivityData& from);

  inline CSActivityData& operator=(const CSActivityData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSActivityData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActivityData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActivityData* other);

  // implements Message ----------------------------------------------

  CSActivityData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActivityData& from);
  void MergeFrom(const CSActivityData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Act_type = 1;
  inline bool has_act_type() const;
  inline void clear_act_type();
  static const int kActTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 act_type() const;
  inline void set_act_type(::google::protobuf::uint32 value);

  // required uint32 Cur_SubId = 2;
  inline bool has_cur_subid() const;
  inline void clear_cur_subid();
  static const int kCurSubIdFieldNumber = 2;
  inline ::google::protobuf::uint32 cur_subid() const;
  inline void set_cur_subid(::google::protobuf::uint32 value);

  // required uint32 DaysRemain = 3;
  inline bool has_daysremain() const;
  inline void clear_daysremain();
  static const int kDaysRemainFieldNumber = 3;
  inline ::google::protobuf::uint32 daysremain() const;
  inline void set_daysremain(::google::protobuf::uint32 value);

  // repeated .fgame.CSSubActivity SubList = 4;
  inline int sublist_size() const;
  inline void clear_sublist();
  static const int kSubListFieldNumber = 4;
  inline const ::fgame::CSSubActivity& sublist(int index) const;
  inline ::fgame::CSSubActivity* mutable_sublist(int index);
  inline ::fgame::CSSubActivity* add_sublist();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSSubActivity >&
      sublist() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSSubActivity >*
      mutable_sublist();

  // @@protoc_insertion_point(class_scope:fgame.CSActivityData)
 private:
  inline void set_has_act_type();
  inline void clear_has_act_type();
  inline void set_has_cur_subid();
  inline void clear_has_cur_subid();
  inline void set_has_daysremain();
  inline void clear_has_daysremain();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 act_type_;
  ::google::protobuf::uint32 cur_subid_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSSubActivity > sublist_;
  ::google::protobuf::uint32 daysremain_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSActivityData* default_instance_;
};
// -------------------------------------------------------------------

class CSActivityListReq : public ::google::protobuf::MessageLite {
 public:
  CSActivityListReq();
  virtual ~CSActivityListReq();

  CSActivityListReq(const CSActivityListReq& from);

  inline CSActivityListReq& operator=(const CSActivityListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSActivityListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActivityListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActivityListReq* other);

  // implements Message ----------------------------------------------

  CSActivityListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActivityListReq& from);
  void MergeFrom(const CSActivityListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSActivityListReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSActivityListReq* default_instance_;
};
// -------------------------------------------------------------------

class CSActivityListResp : public ::google::protobuf::MessageLite {
 public:
  CSActivityListResp();
  virtual ~CSActivityListResp();

  CSActivityListResp(const CSActivityListResp& from);

  inline CSActivityListResp& operator=(const CSActivityListResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSActivityListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActivityListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActivityListResp* other);

  // implements Message ----------------------------------------------

  CSActivityListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActivityListResp& from);
  void MergeFrom(const CSActivityListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.CSActivityData ActivityList = 1;
  inline int activitylist_size() const;
  inline void clear_activitylist();
  static const int kActivityListFieldNumber = 1;
  inline const ::fgame::CSActivityData& activitylist(int index) const;
  inline ::fgame::CSActivityData* mutable_activitylist(int index);
  inline ::fgame::CSActivityData* add_activitylist();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSActivityData >&
      activitylist() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSActivityData >*
      mutable_activitylist();

  // @@protoc_insertion_point(class_scope:fgame.CSActivityListResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSActivityData > activitylist_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSActivityListResp* default_instance_;
};
// -------------------------------------------------------------------

class CSActivitySubmitReq : public ::google::protobuf::MessageLite {
 public:
  CSActivitySubmitReq();
  virtual ~CSActivitySubmitReq();

  CSActivitySubmitReq(const CSActivitySubmitReq& from);

  inline CSActivitySubmitReq& operator=(const CSActivitySubmitReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSActivitySubmitReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActivitySubmitReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActivitySubmitReq* other);

  // implements Message ----------------------------------------------

  CSActivitySubmitReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActivitySubmitReq& from);
  void MergeFrom(const CSActivitySubmitReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Act_Id = 1;
  inline bool has_act_id() const;
  inline void clear_act_id();
  static const int kActIdFieldNumber = 1;
  inline ::google::protobuf::uint32 act_id() const;
  inline void set_act_id(::google::protobuf::uint32 value);

  // required uint32 Sub_Id = 2;
  inline bool has_sub_id() const;
  inline void clear_sub_id();
  static const int kSubIdFieldNumber = 2;
  inline ::google::protobuf::uint32 sub_id() const;
  inline void set_sub_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSActivitySubmitReq)
 private:
  inline void set_has_act_id();
  inline void clear_has_act_id();
  inline void set_has_sub_id();
  inline void clear_has_sub_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 act_id_;
  ::google::protobuf::uint32 sub_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSActivitySubmitReq* default_instance_;
};
// -------------------------------------------------------------------

class CSActivitySubmitResp : public ::google::protobuf::MessageLite {
 public:
  CSActivitySubmitResp();
  virtual ~CSActivitySubmitResp();

  CSActivitySubmitResp(const CSActivitySubmitResp& from);

  inline CSActivitySubmitResp& operator=(const CSActivitySubmitResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSActivitySubmitResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActivitySubmitResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActivitySubmitResp* other);

  // implements Message ----------------------------------------------

  CSActivitySubmitResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActivitySubmitResp& from);
  void MergeFrom(const CSActivitySubmitResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Act_Id = 1;
  inline bool has_act_id() const;
  inline void clear_act_id();
  static const int kActIdFieldNumber = 1;
  inline ::google::protobuf::uint32 act_id() const;
  inline void set_act_id(::google::protobuf::uint32 value);

  // required uint32 Sub_Id = 2;
  inline bool has_sub_id() const;
  inline void clear_sub_id();
  static const int kSubIdFieldNumber = 2;
  inline ::google::protobuf::uint32 sub_id() const;
  inline void set_sub_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSActivitySubmitResp)
 private:
  inline void set_has_act_id();
  inline void clear_has_act_id();
  inline void set_has_sub_id();
  inline void clear_has_sub_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 act_id_;
  ::google::protobuf::uint32 sub_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSActivitySubmitResp* default_instance_;
};
// -------------------------------------------------------------------

class CSActivityUpdateResp : public ::google::protobuf::MessageLite {
 public:
  CSActivityUpdateResp();
  virtual ~CSActivityUpdateResp();

  CSActivityUpdateResp(const CSActivityUpdateResp& from);

  inline CSActivityUpdateResp& operator=(const CSActivityUpdateResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSActivityUpdateResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActivityUpdateResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActivityUpdateResp* other);

  // implements Message ----------------------------------------------

  CSActivityUpdateResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActivityUpdateResp& from);
  void MergeFrom(const CSActivityUpdateResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .fgame.CSSubActivity Activity = 1;
  inline bool has_activity() const;
  inline void clear_activity();
  static const int kActivityFieldNumber = 1;
  inline const ::fgame::CSSubActivity& activity() const;
  inline ::fgame::CSSubActivity* mutable_activity();
  inline ::fgame::CSSubActivity* release_activity();
  inline void set_allocated_activity(::fgame::CSSubActivity* activity);

  // @@protoc_insertion_point(class_scope:fgame.CSActivityUpdateResp)
 private:
  inline void set_has_activity();
  inline void clear_has_activity();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::fgame::CSSubActivity* activity_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSActivityUpdateResp* default_instance_;
};
// -------------------------------------------------------------------

class CSNewYearGetInfoReq : public ::google::protobuf::MessageLite {
 public:
  CSNewYearGetInfoReq();
  virtual ~CSNewYearGetInfoReq();

  CSNewYearGetInfoReq(const CSNewYearGetInfoReq& from);

  inline CSNewYearGetInfoReq& operator=(const CSNewYearGetInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSNewYearGetInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSNewYearGetInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSNewYearGetInfoReq* other);

  // implements Message ----------------------------------------------

  CSNewYearGetInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSNewYearGetInfoReq& from);
  void MergeFrom(const CSNewYearGetInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSNewYearGetInfoReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSNewYearGetInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class CSNewYearGetInfoResp : public ::google::protobuf::MessageLite {
 public:
  CSNewYearGetInfoResp();
  virtual ~CSNewYearGetInfoResp();

  CSNewYearGetInfoResp(const CSNewYearGetInfoResp& from);

  inline CSNewYearGetInfoResp& operator=(const CSNewYearGetInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSNewYearGetInfoResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSNewYearGetInfoResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSNewYearGetInfoResp* other);

  // implements Message ----------------------------------------------

  CSNewYearGetInfoResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSNewYearGetInfoResp& from);
  void MergeFrom(const CSNewYearGetInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 startTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 starttime() const;
  inline void set_starttime(::google::protobuf::uint32 value);

  // optional uint32 endTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 endtime() const;
  inline void set_endtime(::google::protobuf::uint32 value);

  // optional uint32 conditionId = 3;
  inline bool has_conditionid() const;
  inline void clear_conditionid();
  static const int kConditionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 conditionid() const;
  inline void set_conditionid(::google::protobuf::uint32 value);

  // optional uint32 completeCount = 4;
  inline bool has_completecount() const;
  inline void clear_completecount();
  static const int kCompleteCountFieldNumber = 4;
  inline ::google::protobuf::uint32 completecount() const;
  inline void set_completecount(::google::protobuf::uint32 value);

  // optional uint32 curCount = 5;
  inline bool has_curcount() const;
  inline void clear_curcount();
  static const int kCurCountFieldNumber = 5;
  inline ::google::protobuf::uint32 curcount() const;
  inline void set_curcount(::google::protobuf::uint32 value);

  // optional bool nextPacketTag = 6;
  inline bool has_nextpackettag() const;
  inline void clear_nextpackettag();
  static const int kNextPacketTagFieldNumber = 6;
  inline bool nextpackettag() const;
  inline void set_nextpackettag(bool value);

  // optional uint32 awardId = 7;
  inline bool has_awardid() const;
  inline void clear_awardid();
  static const int kAwardIdFieldNumber = 7;
  inline ::google::protobuf::uint32 awardid() const;
  inline void set_awardid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSNewYearGetInfoResp)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_conditionid();
  inline void clear_has_conditionid();
  inline void set_has_completecount();
  inline void clear_has_completecount();
  inline void set_has_curcount();
  inline void clear_has_curcount();
  inline void set_has_nextpackettag();
  inline void clear_has_nextpackettag();
  inline void set_has_awardid();
  inline void clear_has_awardid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 starttime_;
  ::google::protobuf::uint32 endtime_;
  ::google::protobuf::uint32 conditionid_;
  ::google::protobuf::uint32 completecount_;
  ::google::protobuf::uint32 curcount_;
  bool nextpackettag_;
  ::google::protobuf::uint32 awardid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSNewYearGetInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class CSNewYearRewardReq : public ::google::protobuf::MessageLite {
 public:
  CSNewYearRewardReq();
  virtual ~CSNewYearRewardReq();

  CSNewYearRewardReq(const CSNewYearRewardReq& from);

  inline CSNewYearRewardReq& operator=(const CSNewYearRewardReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSNewYearRewardReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSNewYearRewardReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSNewYearRewardReq* other);

  // implements Message ----------------------------------------------

  CSNewYearRewardReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSNewYearRewardReq& from);
  void MergeFrom(const CSNewYearRewardReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSNewYearRewardReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSNewYearRewardReq* default_instance_;
};
// -------------------------------------------------------------------

class CSNewYearRewardResp : public ::google::protobuf::MessageLite {
 public:
  CSNewYearRewardResp();
  virtual ~CSNewYearRewardResp();

  CSNewYearRewardResp(const CSNewYearRewardResp& from);

  inline CSNewYearRewardResp& operator=(const CSNewYearRewardResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSNewYearRewardResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSNewYearRewardResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSNewYearRewardResp* other);

  // implements Message ----------------------------------------------

  CSNewYearRewardResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSNewYearRewardResp& from);
  void MergeFrom(const CSNewYearRewardResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // optional .fgame.CSNewYearGetInfoResp nextTask = 2;
  inline bool has_nexttask() const;
  inline void clear_nexttask();
  static const int kNextTaskFieldNumber = 2;
  inline const ::fgame::CSNewYearGetInfoResp& nexttask() const;
  inline ::fgame::CSNewYearGetInfoResp* mutable_nexttask();
  inline ::fgame::CSNewYearGetInfoResp* release_nexttask();
  inline void set_allocated_nexttask(::fgame::CSNewYearGetInfoResp* nexttask);

  // @@protoc_insertion_point(class_scope:fgame.CSNewYearRewardResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_nexttask();
  inline void clear_has_nexttask();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::fgame::CSNewYearGetInfoResp* nexttask_;
  ::google::protobuf::uint32 ret_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSNewYearRewardResp* default_instance_;
};
// -------------------------------------------------------------------

class CSNewYearCmpReq : public ::google::protobuf::MessageLite {
 public:
  CSNewYearCmpReq();
  virtual ~CSNewYearCmpReq();

  CSNewYearCmpReq(const CSNewYearCmpReq& from);

  inline CSNewYearCmpReq& operator=(const CSNewYearCmpReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSNewYearCmpReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSNewYearCmpReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSNewYearCmpReq* other);

  // implements Message ----------------------------------------------

  CSNewYearCmpReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSNewYearCmpReq& from);
  void MergeFrom(const CSNewYearCmpReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSNewYearCmpReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSNewYearCmpReq* default_instance_;
};
// -------------------------------------------------------------------

class CSNewYearCmpResp : public ::google::protobuf::MessageLite {
 public:
  CSNewYearCmpResp();
  virtual ~CSNewYearCmpResp();

  CSNewYearCmpResp(const CSNewYearCmpResp& from);

  inline CSNewYearCmpResp& operator=(const CSNewYearCmpResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSNewYearCmpResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSNewYearCmpResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSNewYearCmpResp* other);

  // implements Message ----------------------------------------------

  CSNewYearCmpResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSNewYearCmpResp& from);
  void MergeFrom(const CSNewYearCmpResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSNewYearCmpResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSNewYearCmpResp* default_instance_;
};
// -------------------------------------------------------------------

class CSActivityCrazyDtlsReq : public ::google::protobuf::MessageLite {
 public:
  CSActivityCrazyDtlsReq();
  virtual ~CSActivityCrazyDtlsReq();

  CSActivityCrazyDtlsReq(const CSActivityCrazyDtlsReq& from);

  inline CSActivityCrazyDtlsReq& operator=(const CSActivityCrazyDtlsReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSActivityCrazyDtlsReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActivityCrazyDtlsReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActivityCrazyDtlsReq* other);

  // implements Message ----------------------------------------------

  CSActivityCrazyDtlsReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActivityCrazyDtlsReq& from);
  void MergeFrom(const CSActivityCrazyDtlsReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSActivityCrazyDtlsReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSActivityCrazyDtlsReq* default_instance_;
};
// -------------------------------------------------------------------

class CSActivityCrazyDtlsResp : public ::google::protobuf::MessageLite {
 public:
  CSActivityCrazyDtlsResp();
  virtual ~CSActivityCrazyDtlsResp();

  CSActivityCrazyDtlsResp(const CSActivityCrazyDtlsResp& from);

  inline CSActivityCrazyDtlsResp& operator=(const CSActivityCrazyDtlsResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSActivityCrazyDtlsResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActivityCrazyDtlsResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActivityCrazyDtlsResp* other);

  // implements Message ----------------------------------------------

  CSActivityCrazyDtlsResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActivityCrazyDtlsResp& from);
  void MergeFrom(const CSActivityCrazyDtlsResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 Points = 1;
  inline bool has_points() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline ::google::protobuf::uint32 points() const;
  inline void set_points(::google::protobuf::uint32 value);

  // optional uint32 Score = 2;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 2;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // optional uint32 Day = 3;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 3;
  inline ::google::protobuf::uint32 day() const;
  inline void set_day(::google::protobuf::uint32 value);

  // optional uint32 RewardId = 4;
  inline bool has_rewardid() const;
  inline void clear_rewardid();
  static const int kRewardIdFieldNumber = 4;
  inline ::google::protobuf::uint32 rewardid() const;
  inline void set_rewardid(::google::protobuf::uint32 value);

  // optional uint32 Usable = 5;
  inline bool has_usable() const;
  inline void clear_usable();
  static const int kUsableFieldNumber = 5;
  inline ::google::protobuf::uint32 usable() const;
  inline void set_usable(::google::protobuf::uint32 value);

  // optional uint32 ConditionState = 6;
  inline bool has_conditionstate() const;
  inline void clear_conditionstate();
  static const int kConditionStateFieldNumber = 6;
  inline ::google::protobuf::uint32 conditionstate() const;
  inline void set_conditionstate(::google::protobuf::uint32 value);

  // optional uint32 SubConditionState = 7;
  inline bool has_subconditionstate() const;
  inline void clear_subconditionstate();
  static const int kSubConditionStateFieldNumber = 7;
  inline ::google::protobuf::uint32 subconditionstate() const;
  inline void set_subconditionstate(::google::protobuf::uint32 value);

  // optional string CrazyTime = 8;
  inline bool has_crazytime() const;
  inline void clear_crazytime();
  static const int kCrazyTimeFieldNumber = 8;
  inline const ::std::string& crazytime() const;
  inline void set_crazytime(const ::std::string& value);
  inline void set_crazytime(const char* value);
  inline void set_crazytime(const char* value, size_t size);
  inline ::std::string* mutable_crazytime();
  inline ::std::string* release_crazytime();
  inline void set_allocated_crazytime(::std::string* crazytime);

  // @@protoc_insertion_point(class_scope:fgame.CSActivityCrazyDtlsResp)
 private:
  inline void set_has_points();
  inline void clear_has_points();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_rewardid();
  inline void clear_has_rewardid();
  inline void set_has_usable();
  inline void clear_has_usable();
  inline void set_has_conditionstate();
  inline void clear_has_conditionstate();
  inline void set_has_subconditionstate();
  inline void clear_has_subconditionstate();
  inline void set_has_crazytime();
  inline void clear_has_crazytime();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 points_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 day_;
  ::google::protobuf::uint32 rewardid_;
  ::google::protobuf::uint32 usable_;
  ::google::protobuf::uint32 conditionstate_;
  ::std::string* crazytime_;
  ::google::protobuf::uint32 subconditionstate_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSActivityCrazyDtlsResp* default_instance_;
};
// -------------------------------------------------------------------

class CSActivityCrazyUsageReq : public ::google::protobuf::MessageLite {
 public:
  CSActivityCrazyUsageReq();
  virtual ~CSActivityCrazyUsageReq();

  CSActivityCrazyUsageReq(const CSActivityCrazyUsageReq& from);

  inline CSActivityCrazyUsageReq& operator=(const CSActivityCrazyUsageReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSActivityCrazyUsageReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActivityCrazyUsageReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActivityCrazyUsageReq* other);

  // implements Message ----------------------------------------------

  CSActivityCrazyUsageReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActivityCrazyUsageReq& from);
  void MergeFrom(const CSActivityCrazyUsageReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 RewardId = 1;
  inline bool has_rewardid() const;
  inline void clear_rewardid();
  static const int kRewardIdFieldNumber = 1;
  inline ::google::protobuf::uint32 rewardid() const;
  inline void set_rewardid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSActivityCrazyUsageReq)
 private:
  inline void set_has_rewardid();
  inline void clear_has_rewardid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 rewardid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSActivityCrazyUsageReq* default_instance_;
};
// -------------------------------------------------------------------

class CSActivityCrazyUsageResp : public ::google::protobuf::MessageLite {
 public:
  CSActivityCrazyUsageResp();
  virtual ~CSActivityCrazyUsageResp();

  CSActivityCrazyUsageResp(const CSActivityCrazyUsageResp& from);

  inline CSActivityCrazyUsageResp& operator=(const CSActivityCrazyUsageResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSActivityCrazyUsageResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActivityCrazyUsageResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActivityCrazyUsageResp* other);

  // implements Message ----------------------------------------------

  CSActivityCrazyUsageResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActivityCrazyUsageResp& from);
  void MergeFrom(const CSActivityCrazyUsageResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 Points = 1;
  inline bool has_points() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline ::google::protobuf::uint32 points() const;
  inline void set_points(::google::protobuf::uint32 value);

  // optional uint32 GiftId = 2;
  inline bool has_giftid() const;
  inline void clear_giftid();
  static const int kGiftIdFieldNumber = 2;
  inline ::google::protobuf::uint32 giftid() const;
  inline void set_giftid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSActivityCrazyUsageResp)
 private:
  inline void set_has_points();
  inline void clear_has_points();
  inline void set_has_giftid();
  inline void clear_has_giftid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 points_;
  ::google::protobuf::uint32 giftid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSActivityCrazyUsageResp* default_instance_;
};
// -------------------------------------------------------------------

class CSActivityCrazyUsableResp : public ::google::protobuf::MessageLite {
 public:
  CSActivityCrazyUsableResp();
  virtual ~CSActivityCrazyUsableResp();

  CSActivityCrazyUsableResp(const CSActivityCrazyUsableResp& from);

  inline CSActivityCrazyUsableResp& operator=(const CSActivityCrazyUsableResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSActivityCrazyUsableResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActivityCrazyUsableResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActivityCrazyUsableResp* other);

  // implements Message ----------------------------------------------

  CSActivityCrazyUsableResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActivityCrazyUsableResp& from);
  void MergeFrom(const CSActivityCrazyUsableResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ConditionState = 1;
  inline bool has_conditionstate() const;
  inline void clear_conditionstate();
  static const int kConditionStateFieldNumber = 1;
  inline ::google::protobuf::uint32 conditionstate() const;
  inline void set_conditionstate(::google::protobuf::uint32 value);

  // optional uint32 SubConditionState = 2;
  inline bool has_subconditionstate() const;
  inline void clear_subconditionstate();
  static const int kSubConditionStateFieldNumber = 2;
  inline ::google::protobuf::uint32 subconditionstate() const;
  inline void set_subconditionstate(::google::protobuf::uint32 value);

  // optional uint32 Usable = 3;
  inline bool has_usable() const;
  inline void clear_usable();
  static const int kUsableFieldNumber = 3;
  inline ::google::protobuf::uint32 usable() const;
  inline void set_usable(::google::protobuf::uint32 value);

  // optional uint32 ExtraScore = 4;
  inline bool has_extrascore() const;
  inline void clear_extrascore();
  static const int kExtraScoreFieldNumber = 4;
  inline ::google::protobuf::uint32 extrascore() const;
  inline void set_extrascore(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSActivityCrazyUsableResp)
 private:
  inline void set_has_conditionstate();
  inline void clear_has_conditionstate();
  inline void set_has_subconditionstate();
  inline void clear_has_subconditionstate();
  inline void set_has_usable();
  inline void clear_has_usable();
  inline void set_has_extrascore();
  inline void clear_has_extrascore();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 conditionstate_;
  ::google::protobuf::uint32 subconditionstate_;
  ::google::protobuf::uint32 usable_;
  ::google::protobuf::uint32 extrascore_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSActivityCrazyUsableResp* default_instance_;
};
// -------------------------------------------------------------------

class CSOpenChestReq : public ::google::protobuf::MessageLite {
 public:
  CSOpenChestReq();
  virtual ~CSOpenChestReq();

  CSOpenChestReq(const CSOpenChestReq& from);

  inline CSOpenChestReq& operator=(const CSOpenChestReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSOpenChestReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOpenChestReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOpenChestReq* other);

  // implements Message ----------------------------------------------

  CSOpenChestReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOpenChestReq& from);
  void MergeFrom(const CSOpenChestReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ItemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 Count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSOpenChestReq)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_count();
  inline void clear_has_count();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 count_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSOpenChestReq* default_instance_;
};
// -------------------------------------------------------------------

class CSRedPacketsGetInfoReq : public ::google::protobuf::MessageLite {
 public:
  CSRedPacketsGetInfoReq();
  virtual ~CSRedPacketsGetInfoReq();

  CSRedPacketsGetInfoReq(const CSRedPacketsGetInfoReq& from);

  inline CSRedPacketsGetInfoReq& operator=(const CSRedPacketsGetInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRedPacketsGetInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRedPacketsGetInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRedPacketsGetInfoReq* other);

  // implements Message ----------------------------------------------

  CSRedPacketsGetInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRedPacketsGetInfoReq& from);
  void MergeFrom(const CSRedPacketsGetInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSRedPacketsGetInfoReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSRedPacketsGetInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class CSRedPacketsGetInfoResp : public ::google::protobuf::MessageLite {
 public:
  CSRedPacketsGetInfoResp();
  virtual ~CSRedPacketsGetInfoResp();

  CSRedPacketsGetInfoResp(const CSRedPacketsGetInfoResp& from);

  inline CSRedPacketsGetInfoResp& operator=(const CSRedPacketsGetInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRedPacketsGetInfoResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRedPacketsGetInfoResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRedPacketsGetInfoResp* other);

  // implements Message ----------------------------------------------

  CSRedPacketsGetInfoResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRedPacketsGetInfoResp& from);
  void MergeFrom(const CSRedPacketsGetInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // optional uint32 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSRedPacketsGetInfoResp)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_time();
  inline void clear_has_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 value_;
  ::google::protobuf::uint32 time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSRedPacketsGetInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class CSRedPacketsGrebReq : public ::google::protobuf::MessageLite {
 public:
  CSRedPacketsGrebReq();
  virtual ~CSRedPacketsGrebReq();

  CSRedPacketsGrebReq(const CSRedPacketsGrebReq& from);

  inline CSRedPacketsGrebReq& operator=(const CSRedPacketsGrebReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRedPacketsGrebReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRedPacketsGrebReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRedPacketsGrebReq* other);

  // implements Message ----------------------------------------------

  CSRedPacketsGrebReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRedPacketsGrebReq& from);
  void MergeFrom(const CSRedPacketsGrebReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSRedPacketsGrebReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSRedPacketsGrebReq* default_instance_;
};
// -------------------------------------------------------------------

class CSRedPacketsGrebResp : public ::google::protobuf::MessageLite {
 public:
  CSRedPacketsGrebResp();
  virtual ~CSRedPacketsGrebResp();

  CSRedPacketsGrebResp(const CSRedPacketsGrebResp& from);

  inline CSRedPacketsGrebResp& operator=(const CSRedPacketsGrebResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRedPacketsGrebResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRedPacketsGrebResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRedPacketsGrebResp* other);

  // implements Message ----------------------------------------------

  CSRedPacketsGrebResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRedPacketsGrebResp& from);
  void MergeFrom(const CSRedPacketsGrebResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // optional uint32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSRedPacketsGrebResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 value_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSRedPacketsGrebResp* default_instance_;
};
// -------------------------------------------------------------------

class CSRedPacketsOpenedReq : public ::google::protobuf::MessageLite {
 public:
  CSRedPacketsOpenedReq();
  virtual ~CSRedPacketsOpenedReq();

  CSRedPacketsOpenedReq(const CSRedPacketsOpenedReq& from);

  inline CSRedPacketsOpenedReq& operator=(const CSRedPacketsOpenedReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRedPacketsOpenedReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRedPacketsOpenedReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRedPacketsOpenedReq* other);

  // implements Message ----------------------------------------------

  CSRedPacketsOpenedReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRedPacketsOpenedReq& from);
  void MergeFrom(const CSRedPacketsOpenedReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSRedPacketsOpenedReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSRedPacketsOpenedReq* default_instance_;
};
// -------------------------------------------------------------------

class CSRedPacketsOpenedResp : public ::google::protobuf::MessageLite {
 public:
  CSRedPacketsOpenedResp();
  virtual ~CSRedPacketsOpenedResp();

  CSRedPacketsOpenedResp(const CSRedPacketsOpenedResp& from);

  inline CSRedPacketsOpenedResp& operator=(const CSRedPacketsOpenedResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRedPacketsOpenedResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRedPacketsOpenedResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRedPacketsOpenedResp* other);

  // implements Message ----------------------------------------------

  CSRedPacketsOpenedResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRedPacketsOpenedResp& from);
  void MergeFrom(const CSRedPacketsOpenedResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 startTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 starttime() const;
  inline void set_starttime(::google::protobuf::uint32 value);

  // optional uint32 endTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 endtime() const;
  inline void set_endtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSRedPacketsOpenedResp)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 starttime_;
  ::google::protobuf::uint32 endtime_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSRedPacketsOpenedResp* default_instance_;
};
// -------------------------------------------------------------------

class CSChristmasDecorateReq : public ::google::protobuf::MessageLite {
 public:
  CSChristmasDecorateReq();
  virtual ~CSChristmasDecorateReq();

  CSChristmasDecorateReq(const CSChristmasDecorateReq& from);

  inline CSChristmasDecorateReq& operator=(const CSChristmasDecorateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSChristmasDecorateReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChristmasDecorateReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChristmasDecorateReq* other);

  // implements Message ----------------------------------------------

  CSChristmasDecorateReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChristmasDecorateReq& from);
  void MergeFrom(const CSChristmasDecorateReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 Count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSChristmasDecorateReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_count();
  inline void clear_has_count();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 count_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSChristmasDecorateReq* default_instance_;
};
// -------------------------------------------------------------------

class CSChristmasDecorateResp : public ::google::protobuf::MessageLite {
 public:
  CSChristmasDecorateResp();
  virtual ~CSChristmasDecorateResp();

  CSChristmasDecorateResp(const CSChristmasDecorateResp& from);

  inline CSChristmasDecorateResp& operator=(const CSChristmasDecorateResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSChristmasDecorateResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChristmasDecorateResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChristmasDecorateResp* other);

  // implements Message ----------------------------------------------

  CSChristmasDecorateResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChristmasDecorateResp& from);
  void MergeFrom(const CSChristmasDecorateResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Score = 1;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 1;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // repeated .fgame.PropertyUpdateData UpdateData = 2;
  inline int updatedata_size() const;
  inline void clear_updatedata();
  static const int kUpdateDataFieldNumber = 2;
  inline const ::fgame::PropertyUpdateData& updatedata(int index) const;
  inline ::fgame::PropertyUpdateData* mutable_updatedata(int index);
  inline ::fgame::PropertyUpdateData* add_updatedata();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >&
      updatedata() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >*
      mutable_updatedata();

  // @@protoc_insertion_point(class_scope:fgame.CSChristmasDecorateResp)
 private:
  inline void set_has_score();
  inline void clear_has_score();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData > updatedata_;
  ::google::protobuf::int32 score_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSChristmasDecorateResp* default_instance_;
};
// -------------------------------------------------------------------

class CSChristmasTakeBonusReq : public ::google::protobuf::MessageLite {
 public:
  CSChristmasTakeBonusReq();
  virtual ~CSChristmasTakeBonusReq();

  CSChristmasTakeBonusReq(const CSChristmasTakeBonusReq& from);

  inline CSChristmasTakeBonusReq& operator=(const CSChristmasTakeBonusReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSChristmasTakeBonusReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChristmasTakeBonusReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChristmasTakeBonusReq* other);

  // implements Message ----------------------------------------------

  CSChristmasTakeBonusReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChristmasTakeBonusReq& from);
  void MergeFrom(const CSChristmasTakeBonusReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSChristmasTakeBonusReq)
 private:
  inline void set_has_level();
  inline void clear_has_level();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 level_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSChristmasTakeBonusReq* default_instance_;
};
// -------------------------------------------------------------------

class CSChristmasTakeBonusResp : public ::google::protobuf::MessageLite {
 public:
  CSChristmasTakeBonusResp();
  virtual ~CSChristmasTakeBonusResp();

  CSChristmasTakeBonusResp(const CSChristmasTakeBonusResp& from);

  inline CSChristmasTakeBonusResp& operator=(const CSChristmasTakeBonusResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSChristmasTakeBonusResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChristmasTakeBonusResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChristmasTakeBonusResp* other);

  // implements Message ----------------------------------------------

  CSChristmasTakeBonusResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChristmasTakeBonusResp& from);
  void MergeFrom(const CSChristmasTakeBonusResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.PropertyUpdateData UpdateData = 1;
  inline int updatedata_size() const;
  inline void clear_updatedata();
  static const int kUpdateDataFieldNumber = 1;
  inline const ::fgame::PropertyUpdateData& updatedata(int index) const;
  inline ::fgame::PropertyUpdateData* mutable_updatedata(int index);
  inline ::fgame::PropertyUpdateData* add_updatedata();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >&
      updatedata() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >*
      mutable_updatedata();

  // @@protoc_insertion_point(class_scope:fgame.CSChristmasTakeBonusResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData > updatedata_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSChristmasTakeBonusResp* default_instance_;
};
// -------------------------------------------------------------------

class CSChristmasGetDataReq : public ::google::protobuf::MessageLite {
 public:
  CSChristmasGetDataReq();
  virtual ~CSChristmasGetDataReq();

  CSChristmasGetDataReq(const CSChristmasGetDataReq& from);

  inline CSChristmasGetDataReq& operator=(const CSChristmasGetDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSChristmasGetDataReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChristmasGetDataReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChristmasGetDataReq* other);

  // implements Message ----------------------------------------------

  CSChristmasGetDataReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChristmasGetDataReq& from);
  void MergeFrom(const CSChristmasGetDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSChristmasGetDataReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSChristmasGetDataReq* default_instance_;
};
// -------------------------------------------------------------------

class ChristmasTakeRecord : public ::google::protobuf::MessageLite {
 public:
  ChristmasTakeRecord();
  virtual ~ChristmasTakeRecord();

  ChristmasTakeRecord(const ChristmasTakeRecord& from);

  inline ChristmasTakeRecord& operator=(const ChristmasTakeRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ChristmasTakeRecord& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChristmasTakeRecord* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChristmasTakeRecord* other);

  // implements Message ----------------------------------------------

  ChristmasTakeRecord* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChristmasTakeRecord& from);
  void MergeFrom(const ChristmasTakeRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required bool IsTake = 2;
  inline bool has_istake() const;
  inline void clear_istake();
  static const int kIsTakeFieldNumber = 2;
  inline bool istake() const;
  inline void set_istake(bool value);

  // @@protoc_insertion_point(class_scope:fgame.ChristmasTakeRecord)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_istake();
  inline void clear_has_istake();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 level_;
  bool istake_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static ChristmasTakeRecord* default_instance_;
};
// -------------------------------------------------------------------

class CSChristmasGetDataResp : public ::google::protobuf::MessageLite {
 public:
  CSChristmasGetDataResp();
  virtual ~CSChristmasGetDataResp();

  CSChristmasGetDataResp(const CSChristmasGetDataResp& from);

  inline CSChristmasGetDataResp& operator=(const CSChristmasGetDataResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSChristmasGetDataResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChristmasGetDataResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChristmasGetDataResp* other);

  // implements Message ----------------------------------------------

  CSChristmasGetDataResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChristmasGetDataResp& from);
  void MergeFrom(const CSChristmasGetDataResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 StartTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  inline ::google::protobuf::int32 starttime() const;
  inline void set_starttime(::google::protobuf::int32 value);

  // required int32 EndTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::int32 endtime() const;
  inline void set_endtime(::google::protobuf::int32 value);

  // optional int32 GlobalScore = 3;
  inline bool has_globalscore() const;
  inline void clear_globalscore();
  static const int kGlobalScoreFieldNumber = 3;
  inline ::google::protobuf::int32 globalscore() const;
  inline void set_globalscore(::google::protobuf::int32 value);

  // optional int32 SelfScore = 4;
  inline bool has_selfscore() const;
  inline void clear_selfscore();
  static const int kSelfScoreFieldNumber = 4;
  inline ::google::protobuf::int32 selfscore() const;
  inline void set_selfscore(::google::protobuf::int32 value);

  // repeated .fgame.ChristmasTakeRecord TakeRecord = 5;
  inline int takerecord_size() const;
  inline void clear_takerecord();
  static const int kTakeRecordFieldNumber = 5;
  inline const ::fgame::ChristmasTakeRecord& takerecord(int index) const;
  inline ::fgame::ChristmasTakeRecord* mutable_takerecord(int index);
  inline ::fgame::ChristmasTakeRecord* add_takerecord();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::ChristmasTakeRecord >&
      takerecord() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::ChristmasTakeRecord >*
      mutable_takerecord();

  // optional int32 DropEndTime = 6;
  inline bool has_dropendtime() const;
  inline void clear_dropendtime();
  static const int kDropEndTimeFieldNumber = 6;
  inline ::google::protobuf::int32 dropendtime() const;
  inline void set_dropendtime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSChristmasGetDataResp)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_globalscore();
  inline void clear_has_globalscore();
  inline void set_has_selfscore();
  inline void clear_has_selfscore();
  inline void set_has_dropendtime();
  inline void clear_has_dropendtime();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 starttime_;
  ::google::protobuf::int32 endtime_;
  ::google::protobuf::int32 globalscore_;
  ::google::protobuf::int32 selfscore_;
  ::google::protobuf::RepeatedPtrField< ::fgame::ChristmasTakeRecord > takerecord_;
  ::google::protobuf::int32 dropendtime_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSChristmasGetDataResp* default_instance_;
};
// -------------------------------------------------------------------

class CSChristmasGetRankReq : public ::google::protobuf::MessageLite {
 public:
  CSChristmasGetRankReq();
  virtual ~CSChristmasGetRankReq();

  CSChristmasGetRankReq(const CSChristmasGetRankReq& from);

  inline CSChristmasGetRankReq& operator=(const CSChristmasGetRankReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSChristmasGetRankReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChristmasGetRankReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChristmasGetRankReq* other);

  // implements Message ----------------------------------------------

  CSChristmasGetRankReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChristmasGetRankReq& from);
  void MergeFrom(const CSChristmasGetRankReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSChristmasGetRankReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSChristmasGetRankReq* default_instance_;
};
// -------------------------------------------------------------------

class ChristmasRankItem : public ::google::protobuf::MessageLite {
 public:
  ChristmasRankItem();
  virtual ~ChristmasRankItem();

  ChristmasRankItem(const ChristmasRankItem& from);

  inline ChristmasRankItem& operator=(const ChristmasRankItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ChristmasRankItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChristmasRankItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChristmasRankItem* other);

  // implements Message ----------------------------------------------

  ChristmasRankItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChristmasRankItem& from);
  void MergeFrom(const ChristmasRankItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Order = 1;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 1;
  inline ::google::protobuf::int32 order() const;
  inline void set_order(::google::protobuf::int32 value);

  // required int32 Id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string Name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 Score = 4;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 4;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // optional int32 VipLevel = 5;
  inline bool has_viplevel() const;
  inline void clear_viplevel();
  static const int kVipLevelFieldNumber = 5;
  inline ::google::protobuf::int32 viplevel() const;
  inline void set_viplevel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fgame.ChristmasRankItem)
 private:
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_viplevel();
  inline void clear_has_viplevel();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 order_;
  ::google::protobuf::int32 id_;
  ::std::string* name_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 viplevel_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static ChristmasRankItem* default_instance_;
};
// -------------------------------------------------------------------

class CSChristmasGetRankResp : public ::google::protobuf::MessageLite {
 public:
  CSChristmasGetRankResp();
  virtual ~CSChristmasGetRankResp();

  CSChristmasGetRankResp(const CSChristmasGetRankResp& from);

  inline CSChristmasGetRankResp& operator=(const CSChristmasGetRankResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSChristmasGetRankResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChristmasGetRankResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChristmasGetRankResp* other);

  // implements Message ----------------------------------------------

  CSChristmasGetRankResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChristmasGetRankResp& from);
  void MergeFrom(const CSChristmasGetRankResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.ChristmasRankItem RankItems = 1;
  inline int rankitems_size() const;
  inline void clear_rankitems();
  static const int kRankItemsFieldNumber = 1;
  inline const ::fgame::ChristmasRankItem& rankitems(int index) const;
  inline ::fgame::ChristmasRankItem* mutable_rankitems(int index);
  inline ::fgame::ChristmasRankItem* add_rankitems();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::ChristmasRankItem >&
      rankitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::ChristmasRankItem >*
      mutable_rankitems();

  // @@protoc_insertion_point(class_scope:fgame.CSChristmasGetRankResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::ChristmasRankItem > rankitems_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSChristmasGetRankResp* default_instance_;
};
// -------------------------------------------------------------------

class CSValentineDataReq : public ::google::protobuf::MessageLite {
 public:
  CSValentineDataReq();
  virtual ~CSValentineDataReq();

  CSValentineDataReq(const CSValentineDataReq& from);

  inline CSValentineDataReq& operator=(const CSValentineDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSValentineDataReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSValentineDataReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSValentineDataReq* other);

  // implements Message ----------------------------------------------

  CSValentineDataReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSValentineDataReq& from);
  void MergeFrom(const CSValentineDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSValentineDataReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSValentineDataReq* default_instance_;
};
// -------------------------------------------------------------------

class CSValentineDataResp : public ::google::protobuf::MessageLite {
 public:
  CSValentineDataResp();
  virtual ~CSValentineDataResp();

  CSValentineDataResp(const CSValentineDataResp& from);

  inline CSValentineDataResp& operator=(const CSValentineDataResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSValentineDataResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSValentineDataResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSValentineDataResp* other);

  // implements Message ----------------------------------------------

  CSValentineDataResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSValentineDataResp& from);
  void MergeFrom(const CSValentineDataResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 StartTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  inline ::google::protobuf::int32 starttime() const;
  inline void set_starttime(::google::protobuf::int32 value);

  // required int32 EndTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::int32 endtime() const;
  inline void set_endtime(::google::protobuf::int32 value);

  // optional int32 RedRose = 3;
  inline bool has_redrose() const;
  inline void clear_redrose();
  static const int kRedRoseFieldNumber = 3;
  inline ::google::protobuf::int32 redrose() const;
  inline void set_redrose(::google::protobuf::int32 value);

  // optional int32 PinkRose = 4;
  inline bool has_pinkrose() const;
  inline void clear_pinkrose();
  static const int kPinkRoseFieldNumber = 4;
  inline ::google::protobuf::int32 pinkrose() const;
  inline void set_pinkrose(::google::protobuf::int32 value);

  // optional int32 BlueRose = 5;
  inline bool has_bluerose() const;
  inline void clear_bluerose();
  static const int kBlueRoseFieldNumber = 5;
  inline ::google::protobuf::int32 bluerose() const;
  inline void set_bluerose(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSValentineDataResp)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_redrose();
  inline void clear_has_redrose();
  inline void set_has_pinkrose();
  inline void clear_has_pinkrose();
  inline void set_has_bluerose();
  inline void clear_has_bluerose();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 starttime_;
  ::google::protobuf::int32 endtime_;
  ::google::protobuf::int32 redrose_;
  ::google::protobuf::int32 pinkrose_;
  ::google::protobuf::int32 bluerose_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSValentineDataResp* default_instance_;
};
// -------------------------------------------------------------------

class CSValentineExchangeReq : public ::google::protobuf::MessageLite {
 public:
  CSValentineExchangeReq();
  virtual ~CSValentineExchangeReq();

  CSValentineExchangeReq(const CSValentineExchangeReq& from);

  inline CSValentineExchangeReq& operator=(const CSValentineExchangeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSValentineExchangeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSValentineExchangeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSValentineExchangeReq* other);

  // implements Message ----------------------------------------------

  CSValentineExchangeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSValentineExchangeReq& from);
  void MergeFrom(const CSValentineExchangeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ItemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSValentineExchangeReq)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 itemid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSValentineExchangeReq* default_instance_;
};
// -------------------------------------------------------------------

class CSValentineExchangeResp : public ::google::protobuf::MessageLite {
 public:
  CSValentineExchangeResp();
  virtual ~CSValentineExchangeResp();

  CSValentineExchangeResp(const CSValentineExchangeResp& from);

  inline CSValentineExchangeResp& operator=(const CSValentineExchangeResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSValentineExchangeResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSValentineExchangeResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSValentineExchangeResp* other);

  // implements Message ----------------------------------------------

  CSValentineExchangeResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSValentineExchangeResp& from);
  void MergeFrom(const CSValentineExchangeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSValentineExchangeResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSValentineExchangeResp* default_instance_;
};
// -------------------------------------------------------------------

class CSDailyTaskStatusReq : public ::google::protobuf::MessageLite {
 public:
  CSDailyTaskStatusReq();
  virtual ~CSDailyTaskStatusReq();

  CSDailyTaskStatusReq(const CSDailyTaskStatusReq& from);

  inline CSDailyTaskStatusReq& operator=(const CSDailyTaskStatusReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSDailyTaskStatusReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDailyTaskStatusReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDailyTaskStatusReq* other);

  // implements Message ----------------------------------------------

  CSDailyTaskStatusReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDailyTaskStatusReq& from);
  void MergeFrom(const CSDailyTaskStatusReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSDailyTaskStatusReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSDailyTaskStatusReq* default_instance_;
};
// -------------------------------------------------------------------

class CSDailyTaskStatusResp : public ::google::protobuf::MessageLite {
 public:
  CSDailyTaskStatusResp();
  virtual ~CSDailyTaskStatusResp();

  CSDailyTaskStatusResp(const CSDailyTaskStatusResp& from);

  inline CSDailyTaskStatusResp& operator=(const CSDailyTaskStatusResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSDailyTaskStatusResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDailyTaskStatusResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDailyTaskStatusResp* other);

  // implements Message ----------------------------------------------

  CSDailyTaskStatusResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDailyTaskStatusResp& from);
  void MergeFrom(const CSDailyTaskStatusResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool ShowDailyTask = 1;
  inline bool has_showdailytask() const;
  inline void clear_showdailytask();
  static const int kShowDailyTaskFieldNumber = 1;
  inline bool showdailytask() const;
  inline void set_showdailytask(bool value);

  // @@protoc_insertion_point(class_scope:fgame.CSDailyTaskStatusResp)
 private:
  inline void set_has_showdailytask();
  inline void clear_has_showdailytask();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool showdailytask_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSDailyTaskStatusResp* default_instance_;
};
// -------------------------------------------------------------------

class CSRequestDailyTaskReq : public ::google::protobuf::MessageLite {
 public:
  CSRequestDailyTaskReq();
  virtual ~CSRequestDailyTaskReq();

  CSRequestDailyTaskReq(const CSRequestDailyTaskReq& from);

  inline CSRequestDailyTaskReq& operator=(const CSRequestDailyTaskReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRequestDailyTaskReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRequestDailyTaskReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRequestDailyTaskReq* other);

  // implements Message ----------------------------------------------

  CSRequestDailyTaskReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRequestDailyTaskReq& from);
  void MergeFrom(const CSRequestDailyTaskReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSRequestDailyTaskReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSRequestDailyTaskReq* default_instance_;
};
// -------------------------------------------------------------------

class DailyTaskInfo : public ::google::protobuf::MessageLite {
 public:
  DailyTaskInfo();
  virtual ~DailyTaskInfo();

  DailyTaskInfo(const DailyTaskInfo& from);

  inline DailyTaskInfo& operator=(const DailyTaskInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DailyTaskInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DailyTaskInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DailyTaskInfo* other);

  // implements Message ----------------------------------------------

  DailyTaskInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DailyTaskInfo& from);
  void MergeFrom(const DailyTaskInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 TaskType = 1;
  inline bool has_tasktype() const;
  inline void clear_tasktype();
  static const int kTaskTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 tasktype() const;
  inline void set_tasktype(::google::protobuf::uint32 value);

  // required uint32 GiftID = 2;
  inline bool has_giftid() const;
  inline void clear_giftid();
  static const int kGiftIDFieldNumber = 2;
  inline ::google::protobuf::uint32 giftid() const;
  inline void set_giftid(::google::protobuf::uint32 value);

  // required uint32 Progress = 3;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 3;
  inline ::google::protobuf::uint32 progress() const;
  inline void set_progress(::google::protobuf::uint32 value);

  // required uint32 TotalProgress = 4;
  inline bool has_totalprogress() const;
  inline void clear_totalprogress();
  static const int kTotalProgressFieldNumber = 4;
  inline ::google::protobuf::uint32 totalprogress() const;
  inline void set_totalprogress(::google::protobuf::uint32 value);

  // required bool IsOpen = 5;
  inline bool has_isopen() const;
  inline void clear_isopen();
  static const int kIsOpenFieldNumber = 5;
  inline bool isopen() const;
  inline void set_isopen(bool value);

  // @@protoc_insertion_point(class_scope:fgame.DailyTaskInfo)
 private:
  inline void set_has_tasktype();
  inline void clear_has_tasktype();
  inline void set_has_giftid();
  inline void clear_has_giftid();
  inline void set_has_progress();
  inline void clear_has_progress();
  inline void set_has_totalprogress();
  inline void clear_has_totalprogress();
  inline void set_has_isopen();
  inline void clear_has_isopen();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 tasktype_;
  ::google::protobuf::uint32 giftid_;
  ::google::protobuf::uint32 progress_;
  ::google::protobuf::uint32 totalprogress_;
  bool isopen_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static DailyTaskInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSRequestDailyTaskResp : public ::google::protobuf::MessageLite {
 public:
  CSRequestDailyTaskResp();
  virtual ~CSRequestDailyTaskResp();

  CSRequestDailyTaskResp(const CSRequestDailyTaskResp& from);

  inline CSRequestDailyTaskResp& operator=(const CSRequestDailyTaskResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRequestDailyTaskResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRequestDailyTaskResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRequestDailyTaskResp* other);

  // implements Message ----------------------------------------------

  CSRequestDailyTaskResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRequestDailyTaskResp& from);
  void MergeFrom(const CSRequestDailyTaskResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.DailyTaskInfo TaskInfoList = 1;
  inline int taskinfolist_size() const;
  inline void clear_taskinfolist();
  static const int kTaskInfoListFieldNumber = 1;
  inline const ::fgame::DailyTaskInfo& taskinfolist(int index) const;
  inline ::fgame::DailyTaskInfo* mutable_taskinfolist(int index);
  inline ::fgame::DailyTaskInfo* add_taskinfolist();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::DailyTaskInfo >&
      taskinfolist() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::DailyTaskInfo >*
      mutable_taskinfolist();

  // required uint32 TaskProgress = 2;
  inline bool has_taskprogress() const;
  inline void clear_taskprogress();
  static const int kTaskProgressFieldNumber = 2;
  inline ::google::protobuf::uint32 taskprogress() const;
  inline void set_taskprogress(::google::protobuf::uint32 value);

  // required bool CanChange = 3;
  inline bool has_canchange() const;
  inline void clear_canchange();
  static const int kCanChangeFieldNumber = 3;
  inline bool canchange() const;
  inline void set_canchange(bool value);

  // @@protoc_insertion_point(class_scope:fgame.CSRequestDailyTaskResp)
 private:
  inline void set_has_taskprogress();
  inline void clear_has_taskprogress();
  inline void set_has_canchange();
  inline void clear_has_canchange();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::DailyTaskInfo > taskinfolist_;
  ::google::protobuf::uint32 taskprogress_;
  bool canchange_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSRequestDailyTaskResp* default_instance_;
};
// -------------------------------------------------------------------

class CSUpdateTaskStatusReq : public ::google::protobuf::MessageLite {
 public:
  CSUpdateTaskStatusReq();
  virtual ~CSUpdateTaskStatusReq();

  CSUpdateTaskStatusReq(const CSUpdateTaskStatusReq& from);

  inline CSUpdateTaskStatusReq& operator=(const CSUpdateTaskStatusReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSUpdateTaskStatusReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSUpdateTaskStatusReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSUpdateTaskStatusReq* other);

  // implements Message ----------------------------------------------

  CSUpdateTaskStatusReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSUpdateTaskStatusReq& from);
  void MergeFrom(const CSUpdateTaskStatusReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSUpdateTaskStatusReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSUpdateTaskStatusReq* default_instance_;
};
// -------------------------------------------------------------------

class CSUpdateTaskStatusResp : public ::google::protobuf::MessageLite {
 public:
  CSUpdateTaskStatusResp();
  virtual ~CSUpdateTaskStatusResp();

  CSUpdateTaskStatusResp(const CSUpdateTaskStatusResp& from);

  inline CSUpdateTaskStatusResp& operator=(const CSUpdateTaskStatusResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSUpdateTaskStatusResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSUpdateTaskStatusResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSUpdateTaskStatusResp* other);

  // implements Message ----------------------------------------------

  CSUpdateTaskStatusResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSUpdateTaskStatusResp& from);
  void MergeFrom(const CSUpdateTaskStatusResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 TaskType = 1;
  inline bool has_tasktype() const;
  inline void clear_tasktype();
  static const int kTaskTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 tasktype() const;
  inline void set_tasktype(::google::protobuf::uint32 value);

  // required bool IsOpen = 2;
  inline bool has_isopen() const;
  inline void clear_isopen();
  static const int kIsOpenFieldNumber = 2;
  inline bool isopen() const;
  inline void set_isopen(bool value);

  // @@protoc_insertion_point(class_scope:fgame.CSUpdateTaskStatusResp)
 private:
  inline void set_has_tasktype();
  inline void clear_has_tasktype();
  inline void set_has_isopen();
  inline void clear_has_isopen();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 tasktype_;
  bool isopen_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSUpdateTaskStatusResp* default_instance_;
};
// -------------------------------------------------------------------

class CSChangeDailyTaskReq : public ::google::protobuf::MessageLite {
 public:
  CSChangeDailyTaskReq();
  virtual ~CSChangeDailyTaskReq();

  CSChangeDailyTaskReq(const CSChangeDailyTaskReq& from);

  inline CSChangeDailyTaskReq& operator=(const CSChangeDailyTaskReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSChangeDailyTaskReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChangeDailyTaskReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChangeDailyTaskReq* other);

  // implements Message ----------------------------------------------

  CSChangeDailyTaskReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChangeDailyTaskReq& from);
  void MergeFrom(const CSChangeDailyTaskReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 TaskType = 1;
  inline bool has_tasktype() const;
  inline void clear_tasktype();
  static const int kTaskTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 tasktype() const;
  inline void set_tasktype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSChangeDailyTaskReq)
 private:
  inline void set_has_tasktype();
  inline void clear_has_tasktype();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 tasktype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSChangeDailyTaskReq* default_instance_;
};
// -------------------------------------------------------------------

class CSChangeDailyTaskResp : public ::google::protobuf::MessageLite {
 public:
  CSChangeDailyTaskResp();
  virtual ~CSChangeDailyTaskResp();

  CSChangeDailyTaskResp(const CSChangeDailyTaskResp& from);

  inline CSChangeDailyTaskResp& operator=(const CSChangeDailyTaskResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSChangeDailyTaskResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChangeDailyTaskResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChangeDailyTaskResp* other);

  // implements Message ----------------------------------------------

  CSChangeDailyTaskResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChangeDailyTaskResp& from);
  void MergeFrom(const CSChangeDailyTaskResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool Result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // optional .fgame.DailyTaskInfo NewTask = 2;
  inline bool has_newtask() const;
  inline void clear_newtask();
  static const int kNewTaskFieldNumber = 2;
  inline const ::fgame::DailyTaskInfo& newtask() const;
  inline ::fgame::DailyTaskInfo* mutable_newtask();
  inline ::fgame::DailyTaskInfo* release_newtask();
  inline void set_allocated_newtask(::fgame::DailyTaskInfo* newtask);

  // @@protoc_insertion_point(class_scope:fgame.CSChangeDailyTaskResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_newtask();
  inline void clear_has_newtask();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::fgame::DailyTaskInfo* newtask_;
  bool result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSChangeDailyTaskResp* default_instance_;
};
// -------------------------------------------------------------------

class CSOpenDailyTaskAwardReq : public ::google::protobuf::MessageLite {
 public:
  CSOpenDailyTaskAwardReq();
  virtual ~CSOpenDailyTaskAwardReq();

  CSOpenDailyTaskAwardReq(const CSOpenDailyTaskAwardReq& from);

  inline CSOpenDailyTaskAwardReq& operator=(const CSOpenDailyTaskAwardReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSOpenDailyTaskAwardReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOpenDailyTaskAwardReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOpenDailyTaskAwardReq* other);

  // implements Message ----------------------------------------------

  CSOpenDailyTaskAwardReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOpenDailyTaskAwardReq& from);
  void MergeFrom(const CSOpenDailyTaskAwardReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSOpenDailyTaskAwardReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSOpenDailyTaskAwardReq* default_instance_;
};
// -------------------------------------------------------------------

class CSOpenDailyTaskAwardResp : public ::google::protobuf::MessageLite {
 public:
  CSOpenDailyTaskAwardResp();
  virtual ~CSOpenDailyTaskAwardResp();

  CSOpenDailyTaskAwardResp(const CSOpenDailyTaskAwardResp& from);

  inline CSOpenDailyTaskAwardResp& operator=(const CSOpenDailyTaskAwardResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSOpenDailyTaskAwardResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOpenDailyTaskAwardResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOpenDailyTaskAwardResp* other);

  // implements Message ----------------------------------------------

  CSOpenDailyTaskAwardResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOpenDailyTaskAwardResp& from);
  void MergeFrom(const CSOpenDailyTaskAwardResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool Ok = 1;
  inline bool has_ok() const;
  inline void clear_ok();
  static const int kOkFieldNumber = 1;
  inline bool ok() const;
  inline void set_ok(bool value);

  // optional uint32 GiftID = 2;
  inline bool has_giftid() const;
  inline void clear_giftid();
  static const int kGiftIDFieldNumber = 2;
  inline ::google::protobuf::uint32 giftid() const;
  inline void set_giftid(::google::protobuf::uint32 value);

  // optional bool HaveNewTask = 3;
  inline bool has_havenewtask() const;
  inline void clear_havenewtask();
  static const int kHaveNewTaskFieldNumber = 3;
  inline bool havenewtask() const;
  inline void set_havenewtask(bool value);

  // @@protoc_insertion_point(class_scope:fgame.CSOpenDailyTaskAwardResp)
 private:
  inline void set_has_ok();
  inline void clear_has_ok();
  inline void set_has_giftid();
  inline void clear_has_giftid();
  inline void set_has_havenewtask();
  inline void clear_has_havenewtask();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 giftid_;
  bool ok_;
  bool havenewtask_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSOpenDailyTaskAwardResp* default_instance_;
};
// -------------------------------------------------------------------

class CSUpdateDailyTaskProgressReq : public ::google::protobuf::MessageLite {
 public:
  CSUpdateDailyTaskProgressReq();
  virtual ~CSUpdateDailyTaskProgressReq();

  CSUpdateDailyTaskProgressReq(const CSUpdateDailyTaskProgressReq& from);

  inline CSUpdateDailyTaskProgressReq& operator=(const CSUpdateDailyTaskProgressReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSUpdateDailyTaskProgressReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSUpdateDailyTaskProgressReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSUpdateDailyTaskProgressReq* other);

  // implements Message ----------------------------------------------

  CSUpdateDailyTaskProgressReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSUpdateDailyTaskProgressReq& from);
  void MergeFrom(const CSUpdateDailyTaskProgressReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 TaskType = 1;
  inline int tasktype_size() const;
  inline void clear_tasktype();
  static const int kTaskTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 tasktype(int index) const;
  inline void set_tasktype(int index, ::google::protobuf::uint32 value);
  inline void add_tasktype(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      tasktype() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_tasktype();

  // repeated uint32 Progress = 2;
  inline int progress_size() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 2;
  inline ::google::protobuf::uint32 progress(int index) const;
  inline void set_progress(int index, ::google::protobuf::uint32 value);
  inline void add_progress(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      progress() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_progress();

  // @@protoc_insertion_point(class_scope:fgame.CSUpdateDailyTaskProgressReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > tasktype_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > progress_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSUpdateDailyTaskProgressReq* default_instance_;
};
// -------------------------------------------------------------------

class CSUpdateDailyTaskProgressResp : public ::google::protobuf::MessageLite {
 public:
  CSUpdateDailyTaskProgressResp();
  virtual ~CSUpdateDailyTaskProgressResp();

  CSUpdateDailyTaskProgressResp(const CSUpdateDailyTaskProgressResp& from);

  inline CSUpdateDailyTaskProgressResp& operator=(const CSUpdateDailyTaskProgressResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSUpdateDailyTaskProgressResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSUpdateDailyTaskProgressResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSUpdateDailyTaskProgressResp* other);

  // implements Message ----------------------------------------------

  CSUpdateDailyTaskProgressResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSUpdateDailyTaskProgressResp& from);
  void MergeFrom(const CSUpdateDailyTaskProgressResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool Ok = 1;
  inline bool has_ok() const;
  inline void clear_ok();
  static const int kOkFieldNumber = 1;
  inline bool ok() const;
  inline void set_ok(bool value);

  // repeated uint32 TaskType = 2;
  inline int tasktype_size() const;
  inline void clear_tasktype();
  static const int kTaskTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 tasktype(int index) const;
  inline void set_tasktype(int index, ::google::protobuf::uint32 value);
  inline void add_tasktype(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      tasktype() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_tasktype();

  // repeated uint32 Progress = 3;
  inline int progress_size() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 3;
  inline ::google::protobuf::uint32 progress(int index) const;
  inline void set_progress(int index, ::google::protobuf::uint32 value);
  inline void add_progress(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      progress() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_progress();

  // @@protoc_insertion_point(class_scope:fgame.CSUpdateDailyTaskProgressResp)
 private:
  inline void set_has_ok();
  inline void clear_has_ok();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > tasktype_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > progress_;
  bool ok_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSUpdateDailyTaskProgressResp* default_instance_;
};
// -------------------------------------------------------------------

class CSRankWeekRewardInfoReq : public ::google::protobuf::MessageLite {
 public:
  CSRankWeekRewardInfoReq();
  virtual ~CSRankWeekRewardInfoReq();

  CSRankWeekRewardInfoReq(const CSRankWeekRewardInfoReq& from);

  inline CSRankWeekRewardInfoReq& operator=(const CSRankWeekRewardInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRankWeekRewardInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRankWeekRewardInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRankWeekRewardInfoReq* other);

  // implements Message ----------------------------------------------

  CSRankWeekRewardInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRankWeekRewardInfoReq& from);
  void MergeFrom(const CSRankWeekRewardInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSRankWeekRewardInfoReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSRankWeekRewardInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class CSRankWeekRewardInfoResp : public ::google::protobuf::MessageLite {
 public:
  CSRankWeekRewardInfoResp();
  virtual ~CSRankWeekRewardInfoResp();

  CSRankWeekRewardInfoResp(const CSRankWeekRewardInfoResp& from);

  inline CSRankWeekRewardInfoResp& operator=(const CSRankWeekRewardInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRankWeekRewardInfoResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRankWeekRewardInfoResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRankWeekRewardInfoResp* other);

  // implements Message ----------------------------------------------

  CSRankWeekRewardInfoResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRankWeekRewardInfoResp& from);
  void MergeFrom(const CSRankWeekRewardInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline bool status() const;
  inline void set_status(bool value);

  // optional uint32 PvpCount = 2;
  inline bool has_pvpcount() const;
  inline void clear_pvpcount();
  static const int kPvpCountFieldNumber = 2;
  inline ::google::protobuf::uint32 pvpcount() const;
  inline void set_pvpcount(::google::protobuf::uint32 value);

  // optional uint32 GroupId = 3;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIdFieldNumber = 3;
  inline ::google::protobuf::uint32 groupid() const;
  inline void set_groupid(::google::protobuf::uint32 value);

  // optional uint32 Rank = 4;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 4;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSRankWeekRewardInfoResp)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_pvpcount();
  inline void clear_has_pvpcount();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_rank();
  inline void clear_has_rank();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool status_;
  ::google::protobuf::uint32 pvpcount_;
  ::google::protobuf::uint32 groupid_;
  ::google::protobuf::uint32 rank_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSRankWeekRewardInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class CSRankWeekRewardRewardReq : public ::google::protobuf::MessageLite {
 public:
  CSRankWeekRewardRewardReq();
  virtual ~CSRankWeekRewardRewardReq();

  CSRankWeekRewardRewardReq(const CSRankWeekRewardRewardReq& from);

  inline CSRankWeekRewardRewardReq& operator=(const CSRankWeekRewardRewardReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRankWeekRewardRewardReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRankWeekRewardRewardReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRankWeekRewardRewardReq* other);

  // implements Message ----------------------------------------------

  CSRankWeekRewardRewardReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRankWeekRewardRewardReq& from);
  void MergeFrom(const CSRankWeekRewardRewardReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSRankWeekRewardRewardReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSRankWeekRewardRewardReq* default_instance_;
};
// -------------------------------------------------------------------

class CSRankWeekRewardRewardResp : public ::google::protobuf::MessageLite {
 public:
  CSRankWeekRewardRewardResp();
  virtual ~CSRankWeekRewardRewardResp();

  CSRankWeekRewardRewardResp(const CSRankWeekRewardRewardResp& from);

  inline CSRankWeekRewardRewardResp& operator=(const CSRankWeekRewardRewardResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRankWeekRewardRewardResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRankWeekRewardRewardResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRankWeekRewardRewardResp* other);

  // implements Message ----------------------------------------------

  CSRankWeekRewardRewardResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRankWeekRewardRewardResp& from);
  void MergeFrom(const CSRankWeekRewardRewardResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);

  // optional uint32 Error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline ::google::protobuf::uint32 error() const;
  inline void set_error(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSRankWeekRewardRewardResp)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_error();
  inline void clear_has_error();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool success_;
  ::google::protobuf::uint32 error_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSRankWeekRewardRewardResp* default_instance_;
};
// -------------------------------------------------------------------

class CSNewDailyTaskResp : public ::google::protobuf::MessageLite {
 public:
  CSNewDailyTaskResp();
  virtual ~CSNewDailyTaskResp();

  CSNewDailyTaskResp(const CSNewDailyTaskResp& from);

  inline CSNewDailyTaskResp& operator=(const CSNewDailyTaskResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSNewDailyTaskResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSNewDailyTaskResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSNewDailyTaskResp* other);

  // implements Message ----------------------------------------------

  CSNewDailyTaskResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSNewDailyTaskResp& from);
  void MergeFrom(const CSNewDailyTaskResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool Ok = 1;
  inline bool has_ok() const;
  inline void clear_ok();
  static const int kOkFieldNumber = 1;
  inline bool ok() const;
  inline void set_ok(bool value);

  // @@protoc_insertion_point(class_scope:fgame.CSNewDailyTaskResp)
 private:
  inline void set_has_ok();
  inline void clear_has_ok();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool ok_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSNewDailyTaskResp* default_instance_;
};
// -------------------------------------------------------------------

class CSOpActAddResp : public ::google::protobuf::MessageLite {
 public:
  CSOpActAddResp();
  virtual ~CSOpActAddResp();

  CSOpActAddResp(const CSOpActAddResp& from);

  inline CSOpActAddResp& operator=(const CSOpActAddResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSOpActAddResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOpActAddResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOpActAddResp* other);

  // implements Message ----------------------------------------------

  CSOpActAddResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOpActAddResp& from);
  void MergeFrom(const CSOpActAddResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ActivityConifg = 1;
  inline bool has_activityconifg() const;
  inline void clear_activityconifg();
  static const int kActivityConifgFieldNumber = 1;
  inline const ::std::string& activityconifg() const;
  inline void set_activityconifg(const ::std::string& value);
  inline void set_activityconifg(const char* value);
  inline void set_activityconifg(const char* value, size_t size);
  inline ::std::string* mutable_activityconifg();
  inline ::std::string* release_activityconifg();
  inline void set_allocated_activityconifg(::std::string* activityconifg);

  // @@protoc_insertion_point(class_scope:fgame.CSOpActAddResp)
 private:
  inline void set_has_activityconifg();
  inline void clear_has_activityconifg();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* activityconifg_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSOpActAddResp* default_instance_;
};
// -------------------------------------------------------------------

class CSOpActStateChangedResp : public ::google::protobuf::MessageLite {
 public:
  CSOpActStateChangedResp();
  virtual ~CSOpActStateChangedResp();

  CSOpActStateChangedResp(const CSOpActStateChangedResp& from);

  inline CSOpActStateChangedResp& operator=(const CSOpActStateChangedResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSOpActStateChangedResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOpActStateChangedResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOpActStateChangedResp* other);

  // implements Message ----------------------------------------------

  CSOpActStateChangedResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOpActStateChangedResp& from);
  void MergeFrom(const CSOpActStateChangedResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ActivityId = 1;
  inline bool has_activityid() const;
  inline void clear_activityid();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::uint32 activityid() const;
  inline void set_activityid(::google::protobuf::uint32 value);

  // required uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSOpActStateChangedResp)
 private:
  inline void set_has_activityid();
  inline void clear_has_activityid();
  inline void set_has_state();
  inline void clear_has_state();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 activityid_;
  ::google::protobuf::uint32 state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSOpActStateChangedResp* default_instance_;
};
// -------------------------------------------------------------------

class CSActSelfDataChangedResp : public ::google::protobuf::MessageLite {
 public:
  CSActSelfDataChangedResp();
  virtual ~CSActSelfDataChangedResp();

  CSActSelfDataChangedResp(const CSActSelfDataChangedResp& from);

  inline CSActSelfDataChangedResp& operator=(const CSActSelfDataChangedResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSActSelfDataChangedResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActSelfDataChangedResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActSelfDataChangedResp* other);

  // implements Message ----------------------------------------------

  CSActSelfDataChangedResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActSelfDataChangedResp& from);
  void MergeFrom(const CSActSelfDataChangedResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string SelfData = 1;
  inline bool has_selfdata() const;
  inline void clear_selfdata();
  static const int kSelfDataFieldNumber = 1;
  inline const ::std::string& selfdata() const;
  inline void set_selfdata(const ::std::string& value);
  inline void set_selfdata(const char* value);
  inline void set_selfdata(const char* value, size_t size);
  inline ::std::string* mutable_selfdata();
  inline ::std::string* release_selfdata();
  inline void set_allocated_selfdata(::std::string* selfdata);

  // @@protoc_insertion_point(class_scope:fgame.CSActSelfDataChangedResp)
 private:
  inline void set_has_selfdata();
  inline void clear_has_selfdata();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* selfdata_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSActSelfDataChangedResp* default_instance_;
};
// -------------------------------------------------------------------

class CSActGlobalDataChangedResp : public ::google::protobuf::MessageLite {
 public:
  CSActGlobalDataChangedResp();
  virtual ~CSActGlobalDataChangedResp();

  CSActGlobalDataChangedResp(const CSActGlobalDataChangedResp& from);

  inline CSActGlobalDataChangedResp& operator=(const CSActGlobalDataChangedResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSActGlobalDataChangedResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActGlobalDataChangedResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActGlobalDataChangedResp* other);

  // implements Message ----------------------------------------------

  CSActGlobalDataChangedResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActGlobalDataChangedResp& from);
  void MergeFrom(const CSActGlobalDataChangedResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string GlobalData = 1;
  inline bool has_globaldata() const;
  inline void clear_globaldata();
  static const int kGlobalDataFieldNumber = 1;
  inline const ::std::string& globaldata() const;
  inline void set_globaldata(const ::std::string& value);
  inline void set_globaldata(const char* value);
  inline void set_globaldata(const char* value, size_t size);
  inline ::std::string* mutable_globaldata();
  inline ::std::string* release_globaldata();
  inline void set_allocated_globaldata(::std::string* globaldata);

  // @@protoc_insertion_point(class_scope:fgame.CSActGlobalDataChangedResp)
 private:
  inline void set_has_globaldata();
  inline void clear_has_globaldata();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* globaldata_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSActGlobalDataChangedResp* default_instance_;
};
// -------------------------------------------------------------------

class CSOpActConfigListReq : public ::google::protobuf::MessageLite {
 public:
  CSOpActConfigListReq();
  virtual ~CSOpActConfigListReq();

  CSOpActConfigListReq(const CSOpActConfigListReq& from);

  inline CSOpActConfigListReq& operator=(const CSOpActConfigListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSOpActConfigListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOpActConfigListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOpActConfigListReq* other);

  // implements Message ----------------------------------------------

  CSOpActConfigListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOpActConfigListReq& from);
  void MergeFrom(const CSOpActConfigListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSOpActConfigListReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSOpActConfigListReq* default_instance_;
};
// -------------------------------------------------------------------

class CSOpActConfigListResp : public ::google::protobuf::MessageLite {
 public:
  CSOpActConfigListResp();
  virtual ~CSOpActConfigListResp();

  CSOpActConfigListResp(const CSOpActConfigListResp& from);

  inline CSOpActConfigListResp& operator=(const CSOpActConfigListResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSOpActConfigListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOpActConfigListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOpActConfigListResp* other);

  // implements Message ----------------------------------------------

  CSOpActConfigListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOpActConfigListResp& from);
  void MergeFrom(const CSOpActConfigListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ActivityConfig = 1;
  inline int activityconfig_size() const;
  inline void clear_activityconfig();
  static const int kActivityConfigFieldNumber = 1;
  inline const ::std::string& activityconfig(int index) const;
  inline ::std::string* mutable_activityconfig(int index);
  inline void set_activityconfig(int index, const ::std::string& value);
  inline void set_activityconfig(int index, const char* value);
  inline void set_activityconfig(int index, const char* value, size_t size);
  inline ::std::string* add_activityconfig();
  inline void add_activityconfig(const ::std::string& value);
  inline void add_activityconfig(const char* value);
  inline void add_activityconfig(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& activityconfig() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_activityconfig();

  // @@protoc_insertion_point(class_scope:fgame.CSOpActConfigListResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> activityconfig_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSOpActConfigListResp* default_instance_;
};
// -------------------------------------------------------------------

class CSOpActSelfDataListReq : public ::google::protobuf::MessageLite {
 public:
  CSOpActSelfDataListReq();
  virtual ~CSOpActSelfDataListReq();

  CSOpActSelfDataListReq(const CSOpActSelfDataListReq& from);

  inline CSOpActSelfDataListReq& operator=(const CSOpActSelfDataListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSOpActSelfDataListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOpActSelfDataListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOpActSelfDataListReq* other);

  // implements Message ----------------------------------------------

  CSOpActSelfDataListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOpActSelfDataListReq& from);
  void MergeFrom(const CSOpActSelfDataListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSOpActSelfDataListReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSOpActSelfDataListReq* default_instance_;
};
// -------------------------------------------------------------------

class CSOpActSelfDataListResp : public ::google::protobuf::MessageLite {
 public:
  CSOpActSelfDataListResp();
  virtual ~CSOpActSelfDataListResp();

  CSOpActSelfDataListResp(const CSOpActSelfDataListResp& from);

  inline CSOpActSelfDataListResp& operator=(const CSOpActSelfDataListResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSOpActSelfDataListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOpActSelfDataListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOpActSelfDataListResp* other);

  // implements Message ----------------------------------------------

  CSOpActSelfDataListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOpActSelfDataListResp& from);
  void MergeFrom(const CSOpActSelfDataListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string SelfData = 1;
  inline int selfdata_size() const;
  inline void clear_selfdata();
  static const int kSelfDataFieldNumber = 1;
  inline const ::std::string& selfdata(int index) const;
  inline ::std::string* mutable_selfdata(int index);
  inline void set_selfdata(int index, const ::std::string& value);
  inline void set_selfdata(int index, const char* value);
  inline void set_selfdata(int index, const char* value, size_t size);
  inline ::std::string* add_selfdata();
  inline void add_selfdata(const ::std::string& value);
  inline void add_selfdata(const char* value);
  inline void add_selfdata(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& selfdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_selfdata();

  // @@protoc_insertion_point(class_scope:fgame.CSOpActSelfDataListResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> selfdata_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSOpActSelfDataListResp* default_instance_;
};
// -------------------------------------------------------------------

class CSOpActGlobalDataListReq : public ::google::protobuf::MessageLite {
 public:
  CSOpActGlobalDataListReq();
  virtual ~CSOpActGlobalDataListReq();

  CSOpActGlobalDataListReq(const CSOpActGlobalDataListReq& from);

  inline CSOpActGlobalDataListReq& operator=(const CSOpActGlobalDataListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSOpActGlobalDataListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOpActGlobalDataListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOpActGlobalDataListReq* other);

  // implements Message ----------------------------------------------

  CSOpActGlobalDataListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOpActGlobalDataListReq& from);
  void MergeFrom(const CSOpActGlobalDataListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSOpActGlobalDataListReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSOpActGlobalDataListReq* default_instance_;
};
// -------------------------------------------------------------------

class CSOpActGlobalDataListResp : public ::google::protobuf::MessageLite {
 public:
  CSOpActGlobalDataListResp();
  virtual ~CSOpActGlobalDataListResp();

  CSOpActGlobalDataListResp(const CSOpActGlobalDataListResp& from);

  inline CSOpActGlobalDataListResp& operator=(const CSOpActGlobalDataListResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSOpActGlobalDataListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOpActGlobalDataListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOpActGlobalDataListResp* other);

  // implements Message ----------------------------------------------

  CSOpActGlobalDataListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOpActGlobalDataListResp& from);
  void MergeFrom(const CSOpActGlobalDataListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string GlobalData = 1;
  inline int globaldata_size() const;
  inline void clear_globaldata();
  static const int kGlobalDataFieldNumber = 1;
  inline const ::std::string& globaldata(int index) const;
  inline ::std::string* mutable_globaldata(int index);
  inline void set_globaldata(int index, const ::std::string& value);
  inline void set_globaldata(int index, const char* value);
  inline void set_globaldata(int index, const char* value, size_t size);
  inline ::std::string* add_globaldata();
  inline void add_globaldata(const ::std::string& value);
  inline void add_globaldata(const char* value);
  inline void add_globaldata(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& globaldata() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_globaldata();

  // @@protoc_insertion_point(class_scope:fgame.CSOpActGlobalDataListResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> globaldata_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSOpActGlobalDataListResp* default_instance_;
};
// -------------------------------------------------------------------

class CSOpActDemoTakeReq : public ::google::protobuf::MessageLite {
 public:
  CSOpActDemoTakeReq();
  virtual ~CSOpActDemoTakeReq();

  CSOpActDemoTakeReq(const CSOpActDemoTakeReq& from);

  inline CSOpActDemoTakeReq& operator=(const CSOpActDemoTakeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSOpActDemoTakeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOpActDemoTakeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOpActDemoTakeReq* other);

  // implements Message ----------------------------------------------

  CSOpActDemoTakeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOpActDemoTakeReq& from);
  void MergeFrom(const CSOpActDemoTakeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ActivityId = 1;
  inline bool has_activityid() const;
  inline void clear_activityid();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::uint32 activityid() const;
  inline void set_activityid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSOpActDemoTakeReq)
 private:
  inline void set_has_activityid();
  inline void clear_has_activityid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 activityid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSOpActDemoTakeReq* default_instance_;
};
// -------------------------------------------------------------------

class CSOpActDemoTakeResp : public ::google::protobuf::MessageLite {
 public:
  CSOpActDemoTakeResp();
  virtual ~CSOpActDemoTakeResp();

  CSOpActDemoTakeResp(const CSOpActDemoTakeResp& from);

  inline CSOpActDemoTakeResp& operator=(const CSOpActDemoTakeResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSOpActDemoTakeResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOpActDemoTakeResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOpActDemoTakeResp* other);

  // implements Message ----------------------------------------------

  CSOpActDemoTakeResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOpActDemoTakeResp& from);
  void MergeFrom(const CSOpActDemoTakeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSOpActDemoTakeResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Activity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Activity_2eproto();
  #endif
  friend void protobuf_AssignDesc_Activity_2eproto();
  friend void protobuf_ShutdownFile_Activity_2eproto();

  void InitAsDefaultInstance();
  static CSOpActDemoTakeResp* default_instance_;
};
// ===================================================================


// ===================================================================

// CSGetOpenActivityReq

// -------------------------------------------------------------------

// CSOpenActivityInfo

// required uint32 Type = 1;
inline bool CSOpenActivityInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSOpenActivityInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSOpenActivityInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSOpenActivityInfo::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSOpenActivityInfo::type() const {
  // @@protoc_insertion_point(field_get:fgame.CSOpenActivityInfo.Type)
  return type_;
}
inline void CSOpenActivityInfo::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSOpenActivityInfo.Type)
}

// -------------------------------------------------------------------

// CSGetOpenActivityResp

// repeated .fgame.CSOpenActivityInfo OpenActivityInfo = 1;
inline int CSGetOpenActivityResp::openactivityinfo_size() const {
  return openactivityinfo_.size();
}
inline void CSGetOpenActivityResp::clear_openactivityinfo() {
  openactivityinfo_.Clear();
}
inline const ::fgame::CSOpenActivityInfo& CSGetOpenActivityResp::openactivityinfo(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSGetOpenActivityResp.OpenActivityInfo)
  return openactivityinfo_.Get(index);
}
inline ::fgame::CSOpenActivityInfo* CSGetOpenActivityResp::mutable_openactivityinfo(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSGetOpenActivityResp.OpenActivityInfo)
  return openactivityinfo_.Mutable(index);
}
inline ::fgame::CSOpenActivityInfo* CSGetOpenActivityResp::add_openactivityinfo() {
  // @@protoc_insertion_point(field_add:fgame.CSGetOpenActivityResp.OpenActivityInfo)
  return openactivityinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSOpenActivityInfo >&
CSGetOpenActivityResp::openactivityinfo() const {
  // @@protoc_insertion_point(field_list:fgame.CSGetOpenActivityResp.OpenActivityInfo)
  return openactivityinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSOpenActivityInfo >*
CSGetOpenActivityResp::mutable_openactivityinfo() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSGetOpenActivityResp.OpenActivityInfo)
  return &openactivityinfo_;
}

// -------------------------------------------------------------------

// CSGetActivityDataReq

// -------------------------------------------------------------------

// CSActivityInfo

// required uint32 Id = 1;
inline bool CSActivityInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSActivityInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSActivityInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSActivityInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSActivityInfo::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityInfo.Id)
  return id_;
}
inline void CSActivityInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityInfo.Id)
}

// required uint32 Stage = 2;
inline bool CSActivityInfo::has_stage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSActivityInfo::set_has_stage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSActivityInfo::clear_has_stage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSActivityInfo::clear_stage() {
  stage_ = 0u;
  clear_has_stage();
}
inline ::google::protobuf::uint32 CSActivityInfo::stage() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityInfo.Stage)
  return stage_;
}
inline void CSActivityInfo::set_stage(::google::protobuf::uint32 value) {
  set_has_stage();
  stage_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityInfo.Stage)
}

// required uint32 Type = 3;
inline bool CSActivityInfo::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSActivityInfo::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSActivityInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSActivityInfo::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSActivityInfo::type() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityInfo.Type)
  return type_;
}
inline void CSActivityInfo::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityInfo.Type)
}

// optional uint32 Status = 4;
inline bool CSActivityInfo::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSActivityInfo::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSActivityInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSActivityInfo::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 CSActivityInfo::status() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityInfo.Status)
  return status_;
}
inline void CSActivityInfo::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityInfo.Status)
}

// optional uint32 Gift = 5;
inline bool CSActivityInfo::has_gift() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSActivityInfo::set_has_gift() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSActivityInfo::clear_has_gift() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSActivityInfo::clear_gift() {
  gift_ = 0u;
  clear_has_gift();
}
inline ::google::protobuf::uint32 CSActivityInfo::gift() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityInfo.Gift)
  return gift_;
}
inline void CSActivityInfo::set_gift(::google::protobuf::uint32 value) {
  set_has_gift();
  gift_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityInfo.Gift)
}

// optional string StartTime = 6;
inline bool CSActivityInfo::has_starttime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSActivityInfo::set_has_starttime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSActivityInfo::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSActivityInfo::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& CSActivityInfo::starttime() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityInfo.StartTime)
  return *starttime_;
}
inline void CSActivityInfo::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSActivityInfo.StartTime)
}
inline void CSActivityInfo::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSActivityInfo.StartTime)
}
inline void CSActivityInfo::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSActivityInfo.StartTime)
}
inline ::std::string* CSActivityInfo::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    starttime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSActivityInfo.StartTime)
  return starttime_;
}
inline ::std::string* CSActivityInfo::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSActivityInfo::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSActivityInfo.StartTime)
}

// optional string EndTime = 7;
inline bool CSActivityInfo::has_endtime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSActivityInfo::set_has_endtime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSActivityInfo::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSActivityInfo::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& CSActivityInfo::endtime() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityInfo.EndTime)
  return *endtime_;
}
inline void CSActivityInfo::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSActivityInfo.EndTime)
}
inline void CSActivityInfo::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSActivityInfo.EndTime)
}
inline void CSActivityInfo::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSActivityInfo.EndTime)
}
inline ::std::string* CSActivityInfo::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endtime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSActivityInfo.EndTime)
  return endtime_;
}
inline ::std::string* CSActivityInfo::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSActivityInfo::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSActivityInfo.EndTime)
}

// optional uint32 Recharge_num = 8;
inline bool CSActivityInfo::has_recharge_num() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSActivityInfo::set_has_recharge_num() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSActivityInfo::clear_has_recharge_num() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSActivityInfo::clear_recharge_num() {
  recharge_num_ = 0u;
  clear_has_recharge_num();
}
inline ::google::protobuf::uint32 CSActivityInfo::recharge_num() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityInfo.Recharge_num)
  return recharge_num_;
}
inline void CSActivityInfo::set_recharge_num(::google::protobuf::uint32 value) {
  set_has_recharge_num();
  recharge_num_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityInfo.Recharge_num)
}

// -------------------------------------------------------------------

// CSGetActivityDataResp

// required uint32 DayCount = 1;
inline bool CSGetActivityDataResp::has_daycount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGetActivityDataResp::set_has_daycount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGetActivityDataResp::clear_has_daycount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGetActivityDataResp::clear_daycount() {
  daycount_ = 0u;
  clear_has_daycount();
}
inline ::google::protobuf::uint32 CSGetActivityDataResp::daycount() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetActivityDataResp.DayCount)
  return daycount_;
}
inline void CSGetActivityDataResp::set_daycount(::google::protobuf::uint32 value) {
  set_has_daycount();
  daycount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetActivityDataResp.DayCount)
}

// required uint32 RechargeCount = 2;
inline bool CSGetActivityDataResp::has_rechargecount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGetActivityDataResp::set_has_rechargecount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGetActivityDataResp::clear_has_rechargecount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGetActivityDataResp::clear_rechargecount() {
  rechargecount_ = 0u;
  clear_has_rechargecount();
}
inline ::google::protobuf::uint32 CSGetActivityDataResp::rechargecount() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetActivityDataResp.RechargeCount)
  return rechargecount_;
}
inline void CSGetActivityDataResp::set_rechargecount(::google::protobuf::uint32 value) {
  set_has_rechargecount();
  rechargecount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetActivityDataResp.RechargeCount)
}

// repeated .fgame.CSActivityInfo ActivityInfo = 3;
inline int CSGetActivityDataResp::activityinfo_size() const {
  return activityinfo_.size();
}
inline void CSGetActivityDataResp::clear_activityinfo() {
  activityinfo_.Clear();
}
inline const ::fgame::CSActivityInfo& CSGetActivityDataResp::activityinfo(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSGetActivityDataResp.ActivityInfo)
  return activityinfo_.Get(index);
}
inline ::fgame::CSActivityInfo* CSGetActivityDataResp::mutable_activityinfo(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSGetActivityDataResp.ActivityInfo)
  return activityinfo_.Mutable(index);
}
inline ::fgame::CSActivityInfo* CSGetActivityDataResp::add_activityinfo() {
  // @@protoc_insertion_point(field_add:fgame.CSGetActivityDataResp.ActivityInfo)
  return activityinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSActivityInfo >&
CSGetActivityDataResp::activityinfo() const {
  // @@protoc_insertion_point(field_list:fgame.CSGetActivityDataResp.ActivityInfo)
  return activityinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSActivityInfo >*
CSGetActivityDataResp::mutable_activityinfo() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSGetActivityDataResp.ActivityInfo)
  return &activityinfo_;
}

// -------------------------------------------------------------------

// CSReceiveActivityRewardReq

// required uint32 Id = 1;
inline bool CSReceiveActivityRewardReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSReceiveActivityRewardReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSReceiveActivityRewardReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSReceiveActivityRewardReq::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSReceiveActivityRewardReq::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSReceiveActivityRewardReq.Id)
  return id_;
}
inline void CSReceiveActivityRewardReq::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSReceiveActivityRewardReq.Id)
}

// required uint32 Stage = 2;
inline bool CSReceiveActivityRewardReq::has_stage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSReceiveActivityRewardReq::set_has_stage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSReceiveActivityRewardReq::clear_has_stage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSReceiveActivityRewardReq::clear_stage() {
  stage_ = 0u;
  clear_has_stage();
}
inline ::google::protobuf::uint32 CSReceiveActivityRewardReq::stage() const {
  // @@protoc_insertion_point(field_get:fgame.CSReceiveActivityRewardReq.Stage)
  return stage_;
}
inline void CSReceiveActivityRewardReq::set_stage(::google::protobuf::uint32 value) {
  set_has_stage();
  stage_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSReceiveActivityRewardReq.Stage)
}

// required uint32 Type = 3;
inline bool CSReceiveActivityRewardReq::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSReceiveActivityRewardReq::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSReceiveActivityRewardReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSReceiveActivityRewardReq::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSReceiveActivityRewardReq::type() const {
  // @@protoc_insertion_point(field_get:fgame.CSReceiveActivityRewardReq.Type)
  return type_;
}
inline void CSReceiveActivityRewardReq::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSReceiveActivityRewardReq.Type)
}

// -------------------------------------------------------------------

// CSReceiveActivityRewardResp

// required uint32 Ret = 1;
inline bool CSReceiveActivityRewardResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSReceiveActivityRewardResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSReceiveActivityRewardResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSReceiveActivityRewardResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSReceiveActivityRewardResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSReceiveActivityRewardResp.Ret)
  return ret_;
}
inline void CSReceiveActivityRewardResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSReceiveActivityRewardResp.Ret)
}

// required uint32 Type = 2;
inline bool CSReceiveActivityRewardResp::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSReceiveActivityRewardResp::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSReceiveActivityRewardResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSReceiveActivityRewardResp::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSReceiveActivityRewardResp::type() const {
  // @@protoc_insertion_point(field_get:fgame.CSReceiveActivityRewardResp.Type)
  return type_;
}
inline void CSReceiveActivityRewardResp::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSReceiveActivityRewardResp.Type)
}

// required uint32 Id = 3;
inline bool CSReceiveActivityRewardResp::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSReceiveActivityRewardResp::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSReceiveActivityRewardResp::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSReceiveActivityRewardResp::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSReceiveActivityRewardResp::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSReceiveActivityRewardResp.Id)
  return id_;
}
inline void CSReceiveActivityRewardResp::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSReceiveActivityRewardResp.Id)
}

// -------------------------------------------------------------------

// CSGetPowerEnergyActivityDataReq

// -------------------------------------------------------------------

// CSGetPowerEnergyActivityResp

// required uint32 Id = 1;
inline bool CSGetPowerEnergyActivityResp::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGetPowerEnergyActivityResp::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGetPowerEnergyActivityResp::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGetPowerEnergyActivityResp::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSGetPowerEnergyActivityResp::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetPowerEnergyActivityResp.Id)
  return id_;
}
inline void CSGetPowerEnergyActivityResp::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetPowerEnergyActivityResp.Id)
}

// required uint32 IsOpen = 2;
inline bool CSGetPowerEnergyActivityResp::has_isopen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGetPowerEnergyActivityResp::set_has_isopen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGetPowerEnergyActivityResp::clear_has_isopen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGetPowerEnergyActivityResp::clear_isopen() {
  isopen_ = 0u;
  clear_has_isopen();
}
inline ::google::protobuf::uint32 CSGetPowerEnergyActivityResp::isopen() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetPowerEnergyActivityResp.IsOpen)
  return isopen_;
}
inline void CSGetPowerEnergyActivityResp::set_isopen(::google::protobuf::uint32 value) {
  set_has_isopen();
  isopen_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetPowerEnergyActivityResp.IsOpen)
}

// required uint32 Status = 3;
inline bool CSGetPowerEnergyActivityResp::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSGetPowerEnergyActivityResp::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSGetPowerEnergyActivityResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSGetPowerEnergyActivityResp::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 CSGetPowerEnergyActivityResp::status() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetPowerEnergyActivityResp.Status)
  return status_;
}
inline void CSGetPowerEnergyActivityResp::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetPowerEnergyActivityResp.Status)
}

// required uint32 StartTime = 4;
inline bool CSGetPowerEnergyActivityResp::has_starttime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSGetPowerEnergyActivityResp::set_has_starttime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSGetPowerEnergyActivityResp::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSGetPowerEnergyActivityResp::clear_starttime() {
  starttime_ = 0u;
  clear_has_starttime();
}
inline ::google::protobuf::uint32 CSGetPowerEnergyActivityResp::starttime() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetPowerEnergyActivityResp.StartTime)
  return starttime_;
}
inline void CSGetPowerEnergyActivityResp::set_starttime(::google::protobuf::uint32 value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetPowerEnergyActivityResp.StartTime)
}

// required uint32 EndTime = 5;
inline bool CSGetPowerEnergyActivityResp::has_endtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSGetPowerEnergyActivityResp::set_has_endtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSGetPowerEnergyActivityResp::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSGetPowerEnergyActivityResp::clear_endtime() {
  endtime_ = 0u;
  clear_has_endtime();
}
inline ::google::protobuf::uint32 CSGetPowerEnergyActivityResp::endtime() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetPowerEnergyActivityResp.EndTime)
  return endtime_;
}
inline void CSGetPowerEnergyActivityResp::set_endtime(::google::protobuf::uint32 value) {
  set_has_endtime();
  endtime_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetPowerEnergyActivityResp.EndTime)
}

// -------------------------------------------------------------------

// CSReceivePowerEnergyReq

// required uint32 Id = 1;
inline bool CSReceivePowerEnergyReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSReceivePowerEnergyReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSReceivePowerEnergyReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSReceivePowerEnergyReq::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSReceivePowerEnergyReq::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSReceivePowerEnergyReq.Id)
  return id_;
}
inline void CSReceivePowerEnergyReq::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSReceivePowerEnergyReq.Id)
}

// required uint32 Type = 2;
inline bool CSReceivePowerEnergyReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSReceivePowerEnergyReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSReceivePowerEnergyReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSReceivePowerEnergyReq::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSReceivePowerEnergyReq::type() const {
  // @@protoc_insertion_point(field_get:fgame.CSReceivePowerEnergyReq.Type)
  return type_;
}
inline void CSReceivePowerEnergyReq::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSReceivePowerEnergyReq.Type)
}

// -------------------------------------------------------------------

// CSReceivePowerEnergyResp

// required uint32 Ret = 1;
inline bool CSReceivePowerEnergyResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSReceivePowerEnergyResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSReceivePowerEnergyResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSReceivePowerEnergyResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSReceivePowerEnergyResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSReceivePowerEnergyResp.Ret)
  return ret_;
}
inline void CSReceivePowerEnergyResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSReceivePowerEnergyResp.Ret)
}

// required uint32 Type = 2;
inline bool CSReceivePowerEnergyResp::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSReceivePowerEnergyResp::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSReceivePowerEnergyResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSReceivePowerEnergyResp::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSReceivePowerEnergyResp::type() const {
  // @@protoc_insertion_point(field_get:fgame.CSReceivePowerEnergyResp.Type)
  return type_;
}
inline void CSReceivePowerEnergyResp::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSReceivePowerEnergyResp.Type)
}

// -------------------------------------------------------------------

// CSSubActivity

// required uint32 Act_Id = 1;
inline bool CSSubActivity::has_act_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSubActivity::set_has_act_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSubActivity::clear_has_act_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSubActivity::clear_act_id() {
  act_id_ = 0u;
  clear_has_act_id();
}
inline ::google::protobuf::uint32 CSSubActivity::act_id() const {
  // @@protoc_insertion_point(field_get:fgame.CSSubActivity.Act_Id)
  return act_id_;
}
inline void CSSubActivity::set_act_id(::google::protobuf::uint32 value) {
  set_has_act_id();
  act_id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSubActivity.Act_Id)
}

// required uint32 Sub_Id = 2;
inline bool CSSubActivity::has_sub_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSSubActivity::set_has_sub_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSSubActivity::clear_has_sub_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSSubActivity::clear_sub_id() {
  sub_id_ = 0u;
  clear_has_sub_id();
}
inline ::google::protobuf::uint32 CSSubActivity::sub_id() const {
  // @@protoc_insertion_point(field_get:fgame.CSSubActivity.Sub_Id)
  return sub_id_;
}
inline void CSSubActivity::set_sub_id(::google::protobuf::uint32 value) {
  set_has_sub_id();
  sub_id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSubActivity.Sub_Id)
}

// optional uint32 GiftId = 3;
inline bool CSSubActivity::has_giftid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSSubActivity::set_has_giftid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSSubActivity::clear_has_giftid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSSubActivity::clear_giftid() {
  giftid_ = 0u;
  clear_has_giftid();
}
inline ::google::protobuf::uint32 CSSubActivity::giftid() const {
  // @@protoc_insertion_point(field_get:fgame.CSSubActivity.GiftId)
  return giftid_;
}
inline void CSSubActivity::set_giftid(::google::protobuf::uint32 value) {
  set_has_giftid();
  giftid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSubActivity.GiftId)
}

// optional uint32 Request = 4;
inline bool CSSubActivity::has_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSSubActivity::set_has_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSSubActivity::clear_has_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSSubActivity::clear_request() {
  request_ = 0u;
  clear_has_request();
}
inline ::google::protobuf::uint32 CSSubActivity::request() const {
  // @@protoc_insertion_point(field_get:fgame.CSSubActivity.Request)
  return request_;
}
inline void CSSubActivity::set_request(::google::protobuf::uint32 value) {
  set_has_request();
  request_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSubActivity.Request)
}

// optional uint32 Value = 5;
inline bool CSSubActivity::has_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSSubActivity::set_has_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSSubActivity::clear_has_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSSubActivity::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 CSSubActivity::value() const {
  // @@protoc_insertion_point(field_get:fgame.CSSubActivity.Value)
  return value_;
}
inline void CSSubActivity::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSubActivity.Value)
}

// optional bool Completed = 6;
inline bool CSSubActivity::has_completed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSSubActivity::set_has_completed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSSubActivity::clear_has_completed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSSubActivity::clear_completed() {
  completed_ = false;
  clear_has_completed();
}
inline bool CSSubActivity::completed() const {
  // @@protoc_insertion_point(field_get:fgame.CSSubActivity.Completed)
  return completed_;
}
inline void CSSubActivity::set_completed(bool value) {
  set_has_completed();
  completed_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSubActivity.Completed)
}

// optional bool Submit = 7;
inline bool CSSubActivity::has_submit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSSubActivity::set_has_submit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSSubActivity::clear_has_submit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSSubActivity::clear_submit() {
  submit_ = false;
  clear_has_submit();
}
inline bool CSSubActivity::submit() const {
  // @@protoc_insertion_point(field_get:fgame.CSSubActivity.Submit)
  return submit_;
}
inline void CSSubActivity::set_submit(bool value) {
  set_has_submit();
  submit_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSubActivity.Submit)
}

// -------------------------------------------------------------------

// CSActivityData

// required uint32 Act_type = 1;
inline bool CSActivityData::has_act_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSActivityData::set_has_act_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSActivityData::clear_has_act_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSActivityData::clear_act_type() {
  act_type_ = 0u;
  clear_has_act_type();
}
inline ::google::protobuf::uint32 CSActivityData::act_type() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityData.Act_type)
  return act_type_;
}
inline void CSActivityData::set_act_type(::google::protobuf::uint32 value) {
  set_has_act_type();
  act_type_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityData.Act_type)
}

// required uint32 Cur_SubId = 2;
inline bool CSActivityData::has_cur_subid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSActivityData::set_has_cur_subid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSActivityData::clear_has_cur_subid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSActivityData::clear_cur_subid() {
  cur_subid_ = 0u;
  clear_has_cur_subid();
}
inline ::google::protobuf::uint32 CSActivityData::cur_subid() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityData.Cur_SubId)
  return cur_subid_;
}
inline void CSActivityData::set_cur_subid(::google::protobuf::uint32 value) {
  set_has_cur_subid();
  cur_subid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityData.Cur_SubId)
}

// required uint32 DaysRemain = 3;
inline bool CSActivityData::has_daysremain() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSActivityData::set_has_daysremain() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSActivityData::clear_has_daysremain() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSActivityData::clear_daysremain() {
  daysremain_ = 0u;
  clear_has_daysremain();
}
inline ::google::protobuf::uint32 CSActivityData::daysremain() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityData.DaysRemain)
  return daysremain_;
}
inline void CSActivityData::set_daysremain(::google::protobuf::uint32 value) {
  set_has_daysremain();
  daysremain_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityData.DaysRemain)
}

// repeated .fgame.CSSubActivity SubList = 4;
inline int CSActivityData::sublist_size() const {
  return sublist_.size();
}
inline void CSActivityData::clear_sublist() {
  sublist_.Clear();
}
inline const ::fgame::CSSubActivity& CSActivityData::sublist(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityData.SubList)
  return sublist_.Get(index);
}
inline ::fgame::CSSubActivity* CSActivityData::mutable_sublist(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSActivityData.SubList)
  return sublist_.Mutable(index);
}
inline ::fgame::CSSubActivity* CSActivityData::add_sublist() {
  // @@protoc_insertion_point(field_add:fgame.CSActivityData.SubList)
  return sublist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSSubActivity >&
CSActivityData::sublist() const {
  // @@protoc_insertion_point(field_list:fgame.CSActivityData.SubList)
  return sublist_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSSubActivity >*
CSActivityData::mutable_sublist() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSActivityData.SubList)
  return &sublist_;
}

// -------------------------------------------------------------------

// CSActivityListReq

// -------------------------------------------------------------------

// CSActivityListResp

// repeated .fgame.CSActivityData ActivityList = 1;
inline int CSActivityListResp::activitylist_size() const {
  return activitylist_.size();
}
inline void CSActivityListResp::clear_activitylist() {
  activitylist_.Clear();
}
inline const ::fgame::CSActivityData& CSActivityListResp::activitylist(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityListResp.ActivityList)
  return activitylist_.Get(index);
}
inline ::fgame::CSActivityData* CSActivityListResp::mutable_activitylist(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSActivityListResp.ActivityList)
  return activitylist_.Mutable(index);
}
inline ::fgame::CSActivityData* CSActivityListResp::add_activitylist() {
  // @@protoc_insertion_point(field_add:fgame.CSActivityListResp.ActivityList)
  return activitylist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSActivityData >&
CSActivityListResp::activitylist() const {
  // @@protoc_insertion_point(field_list:fgame.CSActivityListResp.ActivityList)
  return activitylist_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSActivityData >*
CSActivityListResp::mutable_activitylist() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSActivityListResp.ActivityList)
  return &activitylist_;
}

// -------------------------------------------------------------------

// CSActivitySubmitReq

// required uint32 Act_Id = 1;
inline bool CSActivitySubmitReq::has_act_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSActivitySubmitReq::set_has_act_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSActivitySubmitReq::clear_has_act_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSActivitySubmitReq::clear_act_id() {
  act_id_ = 0u;
  clear_has_act_id();
}
inline ::google::protobuf::uint32 CSActivitySubmitReq::act_id() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivitySubmitReq.Act_Id)
  return act_id_;
}
inline void CSActivitySubmitReq::set_act_id(::google::protobuf::uint32 value) {
  set_has_act_id();
  act_id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivitySubmitReq.Act_Id)
}

// required uint32 Sub_Id = 2;
inline bool CSActivitySubmitReq::has_sub_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSActivitySubmitReq::set_has_sub_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSActivitySubmitReq::clear_has_sub_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSActivitySubmitReq::clear_sub_id() {
  sub_id_ = 0u;
  clear_has_sub_id();
}
inline ::google::protobuf::uint32 CSActivitySubmitReq::sub_id() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivitySubmitReq.Sub_Id)
  return sub_id_;
}
inline void CSActivitySubmitReq::set_sub_id(::google::protobuf::uint32 value) {
  set_has_sub_id();
  sub_id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivitySubmitReq.Sub_Id)
}

// -------------------------------------------------------------------

// CSActivitySubmitResp

// required uint32 Act_Id = 1;
inline bool CSActivitySubmitResp::has_act_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSActivitySubmitResp::set_has_act_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSActivitySubmitResp::clear_has_act_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSActivitySubmitResp::clear_act_id() {
  act_id_ = 0u;
  clear_has_act_id();
}
inline ::google::protobuf::uint32 CSActivitySubmitResp::act_id() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivitySubmitResp.Act_Id)
  return act_id_;
}
inline void CSActivitySubmitResp::set_act_id(::google::protobuf::uint32 value) {
  set_has_act_id();
  act_id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivitySubmitResp.Act_Id)
}

// required uint32 Sub_Id = 2;
inline bool CSActivitySubmitResp::has_sub_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSActivitySubmitResp::set_has_sub_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSActivitySubmitResp::clear_has_sub_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSActivitySubmitResp::clear_sub_id() {
  sub_id_ = 0u;
  clear_has_sub_id();
}
inline ::google::protobuf::uint32 CSActivitySubmitResp::sub_id() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivitySubmitResp.Sub_Id)
  return sub_id_;
}
inline void CSActivitySubmitResp::set_sub_id(::google::protobuf::uint32 value) {
  set_has_sub_id();
  sub_id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivitySubmitResp.Sub_Id)
}

// -------------------------------------------------------------------

// CSActivityUpdateResp

// required .fgame.CSSubActivity Activity = 1;
inline bool CSActivityUpdateResp::has_activity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSActivityUpdateResp::set_has_activity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSActivityUpdateResp::clear_has_activity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSActivityUpdateResp::clear_activity() {
  if (activity_ != NULL) activity_->::fgame::CSSubActivity::Clear();
  clear_has_activity();
}
inline const ::fgame::CSSubActivity& CSActivityUpdateResp::activity() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityUpdateResp.Activity)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return activity_ != NULL ? *activity_ : *default_instance().activity_;
#else
  return activity_ != NULL ? *activity_ : *default_instance_->activity_;
#endif
}
inline ::fgame::CSSubActivity* CSActivityUpdateResp::mutable_activity() {
  set_has_activity();
  if (activity_ == NULL) activity_ = new ::fgame::CSSubActivity;
  // @@protoc_insertion_point(field_mutable:fgame.CSActivityUpdateResp.Activity)
  return activity_;
}
inline ::fgame::CSSubActivity* CSActivityUpdateResp::release_activity() {
  clear_has_activity();
  ::fgame::CSSubActivity* temp = activity_;
  activity_ = NULL;
  return temp;
}
inline void CSActivityUpdateResp::set_allocated_activity(::fgame::CSSubActivity* activity) {
  delete activity_;
  activity_ = activity;
  if (activity) {
    set_has_activity();
  } else {
    clear_has_activity();
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSActivityUpdateResp.Activity)
}

// -------------------------------------------------------------------

// CSNewYearGetInfoReq

// -------------------------------------------------------------------

// CSNewYearGetInfoResp

// optional uint32 startTime = 1;
inline bool CSNewYearGetInfoResp::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSNewYearGetInfoResp::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSNewYearGetInfoResp::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSNewYearGetInfoResp::clear_starttime() {
  starttime_ = 0u;
  clear_has_starttime();
}
inline ::google::protobuf::uint32 CSNewYearGetInfoResp::starttime() const {
  // @@protoc_insertion_point(field_get:fgame.CSNewYearGetInfoResp.startTime)
  return starttime_;
}
inline void CSNewYearGetInfoResp::set_starttime(::google::protobuf::uint32 value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSNewYearGetInfoResp.startTime)
}

// optional uint32 endTime = 2;
inline bool CSNewYearGetInfoResp::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSNewYearGetInfoResp::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSNewYearGetInfoResp::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSNewYearGetInfoResp::clear_endtime() {
  endtime_ = 0u;
  clear_has_endtime();
}
inline ::google::protobuf::uint32 CSNewYearGetInfoResp::endtime() const {
  // @@protoc_insertion_point(field_get:fgame.CSNewYearGetInfoResp.endTime)
  return endtime_;
}
inline void CSNewYearGetInfoResp::set_endtime(::google::protobuf::uint32 value) {
  set_has_endtime();
  endtime_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSNewYearGetInfoResp.endTime)
}

// optional uint32 conditionId = 3;
inline bool CSNewYearGetInfoResp::has_conditionid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSNewYearGetInfoResp::set_has_conditionid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSNewYearGetInfoResp::clear_has_conditionid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSNewYearGetInfoResp::clear_conditionid() {
  conditionid_ = 0u;
  clear_has_conditionid();
}
inline ::google::protobuf::uint32 CSNewYearGetInfoResp::conditionid() const {
  // @@protoc_insertion_point(field_get:fgame.CSNewYearGetInfoResp.conditionId)
  return conditionid_;
}
inline void CSNewYearGetInfoResp::set_conditionid(::google::protobuf::uint32 value) {
  set_has_conditionid();
  conditionid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSNewYearGetInfoResp.conditionId)
}

// optional uint32 completeCount = 4;
inline bool CSNewYearGetInfoResp::has_completecount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSNewYearGetInfoResp::set_has_completecount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSNewYearGetInfoResp::clear_has_completecount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSNewYearGetInfoResp::clear_completecount() {
  completecount_ = 0u;
  clear_has_completecount();
}
inline ::google::protobuf::uint32 CSNewYearGetInfoResp::completecount() const {
  // @@protoc_insertion_point(field_get:fgame.CSNewYearGetInfoResp.completeCount)
  return completecount_;
}
inline void CSNewYearGetInfoResp::set_completecount(::google::protobuf::uint32 value) {
  set_has_completecount();
  completecount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSNewYearGetInfoResp.completeCount)
}

// optional uint32 curCount = 5;
inline bool CSNewYearGetInfoResp::has_curcount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSNewYearGetInfoResp::set_has_curcount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSNewYearGetInfoResp::clear_has_curcount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSNewYearGetInfoResp::clear_curcount() {
  curcount_ = 0u;
  clear_has_curcount();
}
inline ::google::protobuf::uint32 CSNewYearGetInfoResp::curcount() const {
  // @@protoc_insertion_point(field_get:fgame.CSNewYearGetInfoResp.curCount)
  return curcount_;
}
inline void CSNewYearGetInfoResp::set_curcount(::google::protobuf::uint32 value) {
  set_has_curcount();
  curcount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSNewYearGetInfoResp.curCount)
}

// optional bool nextPacketTag = 6;
inline bool CSNewYearGetInfoResp::has_nextpackettag() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSNewYearGetInfoResp::set_has_nextpackettag() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSNewYearGetInfoResp::clear_has_nextpackettag() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSNewYearGetInfoResp::clear_nextpackettag() {
  nextpackettag_ = false;
  clear_has_nextpackettag();
}
inline bool CSNewYearGetInfoResp::nextpackettag() const {
  // @@protoc_insertion_point(field_get:fgame.CSNewYearGetInfoResp.nextPacketTag)
  return nextpackettag_;
}
inline void CSNewYearGetInfoResp::set_nextpackettag(bool value) {
  set_has_nextpackettag();
  nextpackettag_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSNewYearGetInfoResp.nextPacketTag)
}

// optional uint32 awardId = 7;
inline bool CSNewYearGetInfoResp::has_awardid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSNewYearGetInfoResp::set_has_awardid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSNewYearGetInfoResp::clear_has_awardid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSNewYearGetInfoResp::clear_awardid() {
  awardid_ = 0u;
  clear_has_awardid();
}
inline ::google::protobuf::uint32 CSNewYearGetInfoResp::awardid() const {
  // @@protoc_insertion_point(field_get:fgame.CSNewYearGetInfoResp.awardId)
  return awardid_;
}
inline void CSNewYearGetInfoResp::set_awardid(::google::protobuf::uint32 value) {
  set_has_awardid();
  awardid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSNewYearGetInfoResp.awardId)
}

// -------------------------------------------------------------------

// CSNewYearRewardReq

// -------------------------------------------------------------------

// CSNewYearRewardResp

// optional uint32 ret = 1;
inline bool CSNewYearRewardResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSNewYearRewardResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSNewYearRewardResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSNewYearRewardResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSNewYearRewardResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSNewYearRewardResp.ret)
  return ret_;
}
inline void CSNewYearRewardResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSNewYearRewardResp.ret)
}

// optional .fgame.CSNewYearGetInfoResp nextTask = 2;
inline bool CSNewYearRewardResp::has_nexttask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSNewYearRewardResp::set_has_nexttask() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSNewYearRewardResp::clear_has_nexttask() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSNewYearRewardResp::clear_nexttask() {
  if (nexttask_ != NULL) nexttask_->::fgame::CSNewYearGetInfoResp::Clear();
  clear_has_nexttask();
}
inline const ::fgame::CSNewYearGetInfoResp& CSNewYearRewardResp::nexttask() const {
  // @@protoc_insertion_point(field_get:fgame.CSNewYearRewardResp.nextTask)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return nexttask_ != NULL ? *nexttask_ : *default_instance().nexttask_;
#else
  return nexttask_ != NULL ? *nexttask_ : *default_instance_->nexttask_;
#endif
}
inline ::fgame::CSNewYearGetInfoResp* CSNewYearRewardResp::mutable_nexttask() {
  set_has_nexttask();
  if (nexttask_ == NULL) nexttask_ = new ::fgame::CSNewYearGetInfoResp;
  // @@protoc_insertion_point(field_mutable:fgame.CSNewYearRewardResp.nextTask)
  return nexttask_;
}
inline ::fgame::CSNewYearGetInfoResp* CSNewYearRewardResp::release_nexttask() {
  clear_has_nexttask();
  ::fgame::CSNewYearGetInfoResp* temp = nexttask_;
  nexttask_ = NULL;
  return temp;
}
inline void CSNewYearRewardResp::set_allocated_nexttask(::fgame::CSNewYearGetInfoResp* nexttask) {
  delete nexttask_;
  nexttask_ = nexttask;
  if (nexttask) {
    set_has_nexttask();
  } else {
    clear_has_nexttask();
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSNewYearRewardResp.nextTask)
}

// -------------------------------------------------------------------

// CSNewYearCmpReq

// -------------------------------------------------------------------

// CSNewYearCmpResp

// -------------------------------------------------------------------

// CSActivityCrazyDtlsReq

// -------------------------------------------------------------------

// CSActivityCrazyDtlsResp

// optional uint32 Points = 1;
inline bool CSActivityCrazyDtlsResp::has_points() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSActivityCrazyDtlsResp::set_has_points() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSActivityCrazyDtlsResp::clear_has_points() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSActivityCrazyDtlsResp::clear_points() {
  points_ = 0u;
  clear_has_points();
}
inline ::google::protobuf::uint32 CSActivityCrazyDtlsResp::points() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityCrazyDtlsResp.Points)
  return points_;
}
inline void CSActivityCrazyDtlsResp::set_points(::google::protobuf::uint32 value) {
  set_has_points();
  points_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityCrazyDtlsResp.Points)
}

// optional uint32 Score = 2;
inline bool CSActivityCrazyDtlsResp::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSActivityCrazyDtlsResp::set_has_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSActivityCrazyDtlsResp::clear_has_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSActivityCrazyDtlsResp::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 CSActivityCrazyDtlsResp::score() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityCrazyDtlsResp.Score)
  return score_;
}
inline void CSActivityCrazyDtlsResp::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityCrazyDtlsResp.Score)
}

// optional uint32 Day = 3;
inline bool CSActivityCrazyDtlsResp::has_day() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSActivityCrazyDtlsResp::set_has_day() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSActivityCrazyDtlsResp::clear_has_day() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSActivityCrazyDtlsResp::clear_day() {
  day_ = 0u;
  clear_has_day();
}
inline ::google::protobuf::uint32 CSActivityCrazyDtlsResp::day() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityCrazyDtlsResp.Day)
  return day_;
}
inline void CSActivityCrazyDtlsResp::set_day(::google::protobuf::uint32 value) {
  set_has_day();
  day_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityCrazyDtlsResp.Day)
}

// optional uint32 RewardId = 4;
inline bool CSActivityCrazyDtlsResp::has_rewardid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSActivityCrazyDtlsResp::set_has_rewardid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSActivityCrazyDtlsResp::clear_has_rewardid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSActivityCrazyDtlsResp::clear_rewardid() {
  rewardid_ = 0u;
  clear_has_rewardid();
}
inline ::google::protobuf::uint32 CSActivityCrazyDtlsResp::rewardid() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityCrazyDtlsResp.RewardId)
  return rewardid_;
}
inline void CSActivityCrazyDtlsResp::set_rewardid(::google::protobuf::uint32 value) {
  set_has_rewardid();
  rewardid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityCrazyDtlsResp.RewardId)
}

// optional uint32 Usable = 5;
inline bool CSActivityCrazyDtlsResp::has_usable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSActivityCrazyDtlsResp::set_has_usable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSActivityCrazyDtlsResp::clear_has_usable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSActivityCrazyDtlsResp::clear_usable() {
  usable_ = 0u;
  clear_has_usable();
}
inline ::google::protobuf::uint32 CSActivityCrazyDtlsResp::usable() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityCrazyDtlsResp.Usable)
  return usable_;
}
inline void CSActivityCrazyDtlsResp::set_usable(::google::protobuf::uint32 value) {
  set_has_usable();
  usable_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityCrazyDtlsResp.Usable)
}

// optional uint32 ConditionState = 6;
inline bool CSActivityCrazyDtlsResp::has_conditionstate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSActivityCrazyDtlsResp::set_has_conditionstate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSActivityCrazyDtlsResp::clear_has_conditionstate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSActivityCrazyDtlsResp::clear_conditionstate() {
  conditionstate_ = 0u;
  clear_has_conditionstate();
}
inline ::google::protobuf::uint32 CSActivityCrazyDtlsResp::conditionstate() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityCrazyDtlsResp.ConditionState)
  return conditionstate_;
}
inline void CSActivityCrazyDtlsResp::set_conditionstate(::google::protobuf::uint32 value) {
  set_has_conditionstate();
  conditionstate_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityCrazyDtlsResp.ConditionState)
}

// optional uint32 SubConditionState = 7;
inline bool CSActivityCrazyDtlsResp::has_subconditionstate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSActivityCrazyDtlsResp::set_has_subconditionstate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSActivityCrazyDtlsResp::clear_has_subconditionstate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSActivityCrazyDtlsResp::clear_subconditionstate() {
  subconditionstate_ = 0u;
  clear_has_subconditionstate();
}
inline ::google::protobuf::uint32 CSActivityCrazyDtlsResp::subconditionstate() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityCrazyDtlsResp.SubConditionState)
  return subconditionstate_;
}
inline void CSActivityCrazyDtlsResp::set_subconditionstate(::google::protobuf::uint32 value) {
  set_has_subconditionstate();
  subconditionstate_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityCrazyDtlsResp.SubConditionState)
}

// optional string CrazyTime = 8;
inline bool CSActivityCrazyDtlsResp::has_crazytime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSActivityCrazyDtlsResp::set_has_crazytime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSActivityCrazyDtlsResp::clear_has_crazytime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSActivityCrazyDtlsResp::clear_crazytime() {
  if (crazytime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    crazytime_->clear();
  }
  clear_has_crazytime();
}
inline const ::std::string& CSActivityCrazyDtlsResp::crazytime() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityCrazyDtlsResp.CrazyTime)
  return *crazytime_;
}
inline void CSActivityCrazyDtlsResp::set_crazytime(const ::std::string& value) {
  set_has_crazytime();
  if (crazytime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    crazytime_ = new ::std::string;
  }
  crazytime_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSActivityCrazyDtlsResp.CrazyTime)
}
inline void CSActivityCrazyDtlsResp::set_crazytime(const char* value) {
  set_has_crazytime();
  if (crazytime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    crazytime_ = new ::std::string;
  }
  crazytime_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSActivityCrazyDtlsResp.CrazyTime)
}
inline void CSActivityCrazyDtlsResp::set_crazytime(const char* value, size_t size) {
  set_has_crazytime();
  if (crazytime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    crazytime_ = new ::std::string;
  }
  crazytime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSActivityCrazyDtlsResp.CrazyTime)
}
inline ::std::string* CSActivityCrazyDtlsResp::mutable_crazytime() {
  set_has_crazytime();
  if (crazytime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    crazytime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSActivityCrazyDtlsResp.CrazyTime)
  return crazytime_;
}
inline ::std::string* CSActivityCrazyDtlsResp::release_crazytime() {
  clear_has_crazytime();
  if (crazytime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = crazytime_;
    crazytime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSActivityCrazyDtlsResp::set_allocated_crazytime(::std::string* crazytime) {
  if (crazytime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete crazytime_;
  }
  if (crazytime) {
    set_has_crazytime();
    crazytime_ = crazytime;
  } else {
    clear_has_crazytime();
    crazytime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSActivityCrazyDtlsResp.CrazyTime)
}

// -------------------------------------------------------------------

// CSActivityCrazyUsageReq

// optional uint32 RewardId = 1;
inline bool CSActivityCrazyUsageReq::has_rewardid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSActivityCrazyUsageReq::set_has_rewardid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSActivityCrazyUsageReq::clear_has_rewardid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSActivityCrazyUsageReq::clear_rewardid() {
  rewardid_ = 0u;
  clear_has_rewardid();
}
inline ::google::protobuf::uint32 CSActivityCrazyUsageReq::rewardid() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityCrazyUsageReq.RewardId)
  return rewardid_;
}
inline void CSActivityCrazyUsageReq::set_rewardid(::google::protobuf::uint32 value) {
  set_has_rewardid();
  rewardid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityCrazyUsageReq.RewardId)
}

// -------------------------------------------------------------------

// CSActivityCrazyUsageResp

// optional uint32 Points = 1;
inline bool CSActivityCrazyUsageResp::has_points() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSActivityCrazyUsageResp::set_has_points() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSActivityCrazyUsageResp::clear_has_points() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSActivityCrazyUsageResp::clear_points() {
  points_ = 0u;
  clear_has_points();
}
inline ::google::protobuf::uint32 CSActivityCrazyUsageResp::points() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityCrazyUsageResp.Points)
  return points_;
}
inline void CSActivityCrazyUsageResp::set_points(::google::protobuf::uint32 value) {
  set_has_points();
  points_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityCrazyUsageResp.Points)
}

// optional uint32 GiftId = 2;
inline bool CSActivityCrazyUsageResp::has_giftid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSActivityCrazyUsageResp::set_has_giftid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSActivityCrazyUsageResp::clear_has_giftid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSActivityCrazyUsageResp::clear_giftid() {
  giftid_ = 0u;
  clear_has_giftid();
}
inline ::google::protobuf::uint32 CSActivityCrazyUsageResp::giftid() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityCrazyUsageResp.GiftId)
  return giftid_;
}
inline void CSActivityCrazyUsageResp::set_giftid(::google::protobuf::uint32 value) {
  set_has_giftid();
  giftid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityCrazyUsageResp.GiftId)
}

// -------------------------------------------------------------------

// CSActivityCrazyUsableResp

// optional uint32 ConditionState = 1;
inline bool CSActivityCrazyUsableResp::has_conditionstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSActivityCrazyUsableResp::set_has_conditionstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSActivityCrazyUsableResp::clear_has_conditionstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSActivityCrazyUsableResp::clear_conditionstate() {
  conditionstate_ = 0u;
  clear_has_conditionstate();
}
inline ::google::protobuf::uint32 CSActivityCrazyUsableResp::conditionstate() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityCrazyUsableResp.ConditionState)
  return conditionstate_;
}
inline void CSActivityCrazyUsableResp::set_conditionstate(::google::protobuf::uint32 value) {
  set_has_conditionstate();
  conditionstate_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityCrazyUsableResp.ConditionState)
}

// optional uint32 SubConditionState = 2;
inline bool CSActivityCrazyUsableResp::has_subconditionstate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSActivityCrazyUsableResp::set_has_subconditionstate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSActivityCrazyUsableResp::clear_has_subconditionstate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSActivityCrazyUsableResp::clear_subconditionstate() {
  subconditionstate_ = 0u;
  clear_has_subconditionstate();
}
inline ::google::protobuf::uint32 CSActivityCrazyUsableResp::subconditionstate() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityCrazyUsableResp.SubConditionState)
  return subconditionstate_;
}
inline void CSActivityCrazyUsableResp::set_subconditionstate(::google::protobuf::uint32 value) {
  set_has_subconditionstate();
  subconditionstate_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityCrazyUsableResp.SubConditionState)
}

// optional uint32 Usable = 3;
inline bool CSActivityCrazyUsableResp::has_usable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSActivityCrazyUsableResp::set_has_usable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSActivityCrazyUsableResp::clear_has_usable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSActivityCrazyUsableResp::clear_usable() {
  usable_ = 0u;
  clear_has_usable();
}
inline ::google::protobuf::uint32 CSActivityCrazyUsableResp::usable() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityCrazyUsableResp.Usable)
  return usable_;
}
inline void CSActivityCrazyUsableResp::set_usable(::google::protobuf::uint32 value) {
  set_has_usable();
  usable_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityCrazyUsableResp.Usable)
}

// optional uint32 ExtraScore = 4;
inline bool CSActivityCrazyUsableResp::has_extrascore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSActivityCrazyUsableResp::set_has_extrascore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSActivityCrazyUsableResp::clear_has_extrascore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSActivityCrazyUsableResp::clear_extrascore() {
  extrascore_ = 0u;
  clear_has_extrascore();
}
inline ::google::protobuf::uint32 CSActivityCrazyUsableResp::extrascore() const {
  // @@protoc_insertion_point(field_get:fgame.CSActivityCrazyUsableResp.ExtraScore)
  return extrascore_;
}
inline void CSActivityCrazyUsableResp::set_extrascore(::google::protobuf::uint32 value) {
  set_has_extrascore();
  extrascore_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSActivityCrazyUsableResp.ExtraScore)
}

// -------------------------------------------------------------------

// CSOpenChestReq

// required int32 ItemId = 1;
inline bool CSOpenChestReq::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSOpenChestReq::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSOpenChestReq::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSOpenChestReq::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 CSOpenChestReq::itemid() const {
  // @@protoc_insertion_point(field_get:fgame.CSOpenChestReq.ItemId)
  return itemid_;
}
inline void CSOpenChestReq::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSOpenChestReq.ItemId)
}

// optional int32 Count = 2;
inline bool CSOpenChestReq::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSOpenChestReq::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSOpenChestReq::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSOpenChestReq::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 CSOpenChestReq::count() const {
  // @@protoc_insertion_point(field_get:fgame.CSOpenChestReq.Count)
  return count_;
}
inline void CSOpenChestReq::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSOpenChestReq.Count)
}

// -------------------------------------------------------------------

// CSRedPacketsGetInfoReq

// -------------------------------------------------------------------

// CSRedPacketsGetInfoResp

// optional uint32 status = 1;
inline bool CSRedPacketsGetInfoResp::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRedPacketsGetInfoResp::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRedPacketsGetInfoResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRedPacketsGetInfoResp::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 CSRedPacketsGetInfoResp::status() const {
  // @@protoc_insertion_point(field_get:fgame.CSRedPacketsGetInfoResp.status)
  return status_;
}
inline void CSRedPacketsGetInfoResp::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRedPacketsGetInfoResp.status)
}

// optional uint32 value = 2;
inline bool CSRedPacketsGetInfoResp::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRedPacketsGetInfoResp::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRedPacketsGetInfoResp::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRedPacketsGetInfoResp::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 CSRedPacketsGetInfoResp::value() const {
  // @@protoc_insertion_point(field_get:fgame.CSRedPacketsGetInfoResp.value)
  return value_;
}
inline void CSRedPacketsGetInfoResp::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRedPacketsGetInfoResp.value)
}

// optional uint32 time = 3;
inline bool CSRedPacketsGetInfoResp::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSRedPacketsGetInfoResp::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSRedPacketsGetInfoResp::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSRedPacketsGetInfoResp::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 CSRedPacketsGetInfoResp::time() const {
  // @@protoc_insertion_point(field_get:fgame.CSRedPacketsGetInfoResp.time)
  return time_;
}
inline void CSRedPacketsGetInfoResp::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRedPacketsGetInfoResp.time)
}

// -------------------------------------------------------------------

// CSRedPacketsGrebReq

// -------------------------------------------------------------------

// CSRedPacketsGrebResp

// optional uint32 ret = 1;
inline bool CSRedPacketsGrebResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRedPacketsGrebResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRedPacketsGrebResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRedPacketsGrebResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSRedPacketsGrebResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSRedPacketsGrebResp.ret)
  return ret_;
}
inline void CSRedPacketsGrebResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRedPacketsGrebResp.ret)
}

// optional uint32 value = 2;
inline bool CSRedPacketsGrebResp::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRedPacketsGrebResp::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRedPacketsGrebResp::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRedPacketsGrebResp::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 CSRedPacketsGrebResp::value() const {
  // @@protoc_insertion_point(field_get:fgame.CSRedPacketsGrebResp.value)
  return value_;
}
inline void CSRedPacketsGrebResp::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRedPacketsGrebResp.value)
}

// -------------------------------------------------------------------

// CSRedPacketsOpenedReq

// -------------------------------------------------------------------

// CSRedPacketsOpenedResp

// optional uint32 startTime = 1;
inline bool CSRedPacketsOpenedResp::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRedPacketsOpenedResp::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRedPacketsOpenedResp::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRedPacketsOpenedResp::clear_starttime() {
  starttime_ = 0u;
  clear_has_starttime();
}
inline ::google::protobuf::uint32 CSRedPacketsOpenedResp::starttime() const {
  // @@protoc_insertion_point(field_get:fgame.CSRedPacketsOpenedResp.startTime)
  return starttime_;
}
inline void CSRedPacketsOpenedResp::set_starttime(::google::protobuf::uint32 value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRedPacketsOpenedResp.startTime)
}

// optional uint32 endTime = 2;
inline bool CSRedPacketsOpenedResp::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRedPacketsOpenedResp::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRedPacketsOpenedResp::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRedPacketsOpenedResp::clear_endtime() {
  endtime_ = 0u;
  clear_has_endtime();
}
inline ::google::protobuf::uint32 CSRedPacketsOpenedResp::endtime() const {
  // @@protoc_insertion_point(field_get:fgame.CSRedPacketsOpenedResp.endTime)
  return endtime_;
}
inline void CSRedPacketsOpenedResp::set_endtime(::google::protobuf::uint32 value) {
  set_has_endtime();
  endtime_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRedPacketsOpenedResp.endTime)
}

// -------------------------------------------------------------------

// CSChristmasDecorateReq

// required int32 Type = 1;
inline bool CSChristmasDecorateReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChristmasDecorateReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChristmasDecorateReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChristmasDecorateReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 CSChristmasDecorateReq::type() const {
  // @@protoc_insertion_point(field_get:fgame.CSChristmasDecorateReq.Type)
  return type_;
}
inline void CSChristmasDecorateReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSChristmasDecorateReq.Type)
}

// optional int32 Count = 2;
inline bool CSChristmasDecorateReq::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSChristmasDecorateReq::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSChristmasDecorateReq::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSChristmasDecorateReq::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 CSChristmasDecorateReq::count() const {
  // @@protoc_insertion_point(field_get:fgame.CSChristmasDecorateReq.Count)
  return count_;
}
inline void CSChristmasDecorateReq::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSChristmasDecorateReq.Count)
}

// -------------------------------------------------------------------

// CSChristmasDecorateResp

// required int32 Score = 1;
inline bool CSChristmasDecorateResp::has_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChristmasDecorateResp::set_has_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChristmasDecorateResp::clear_has_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChristmasDecorateResp::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 CSChristmasDecorateResp::score() const {
  // @@protoc_insertion_point(field_get:fgame.CSChristmasDecorateResp.Score)
  return score_;
}
inline void CSChristmasDecorateResp::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSChristmasDecorateResp.Score)
}

// repeated .fgame.PropertyUpdateData UpdateData = 2;
inline int CSChristmasDecorateResp::updatedata_size() const {
  return updatedata_.size();
}
inline void CSChristmasDecorateResp::clear_updatedata() {
  updatedata_.Clear();
}
inline const ::fgame::PropertyUpdateData& CSChristmasDecorateResp::updatedata(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSChristmasDecorateResp.UpdateData)
  return updatedata_.Get(index);
}
inline ::fgame::PropertyUpdateData* CSChristmasDecorateResp::mutable_updatedata(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSChristmasDecorateResp.UpdateData)
  return updatedata_.Mutable(index);
}
inline ::fgame::PropertyUpdateData* CSChristmasDecorateResp::add_updatedata() {
  // @@protoc_insertion_point(field_add:fgame.CSChristmasDecorateResp.UpdateData)
  return updatedata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >&
CSChristmasDecorateResp::updatedata() const {
  // @@protoc_insertion_point(field_list:fgame.CSChristmasDecorateResp.UpdateData)
  return updatedata_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >*
CSChristmasDecorateResp::mutable_updatedata() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSChristmasDecorateResp.UpdateData)
  return &updatedata_;
}

// -------------------------------------------------------------------

// CSChristmasTakeBonusReq

// required int32 Level = 1;
inline bool CSChristmasTakeBonusReq::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChristmasTakeBonusReq::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChristmasTakeBonusReq::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChristmasTakeBonusReq::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 CSChristmasTakeBonusReq::level() const {
  // @@protoc_insertion_point(field_get:fgame.CSChristmasTakeBonusReq.Level)
  return level_;
}
inline void CSChristmasTakeBonusReq::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSChristmasTakeBonusReq.Level)
}

// -------------------------------------------------------------------

// CSChristmasTakeBonusResp

// repeated .fgame.PropertyUpdateData UpdateData = 1;
inline int CSChristmasTakeBonusResp::updatedata_size() const {
  return updatedata_.size();
}
inline void CSChristmasTakeBonusResp::clear_updatedata() {
  updatedata_.Clear();
}
inline const ::fgame::PropertyUpdateData& CSChristmasTakeBonusResp::updatedata(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSChristmasTakeBonusResp.UpdateData)
  return updatedata_.Get(index);
}
inline ::fgame::PropertyUpdateData* CSChristmasTakeBonusResp::mutable_updatedata(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSChristmasTakeBonusResp.UpdateData)
  return updatedata_.Mutable(index);
}
inline ::fgame::PropertyUpdateData* CSChristmasTakeBonusResp::add_updatedata() {
  // @@protoc_insertion_point(field_add:fgame.CSChristmasTakeBonusResp.UpdateData)
  return updatedata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >&
CSChristmasTakeBonusResp::updatedata() const {
  // @@protoc_insertion_point(field_list:fgame.CSChristmasTakeBonusResp.UpdateData)
  return updatedata_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >*
CSChristmasTakeBonusResp::mutable_updatedata() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSChristmasTakeBonusResp.UpdateData)
  return &updatedata_;
}

// -------------------------------------------------------------------

// CSChristmasGetDataReq

// -------------------------------------------------------------------

// ChristmasTakeRecord

// required int32 Level = 1;
inline bool ChristmasTakeRecord::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChristmasTakeRecord::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChristmasTakeRecord::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChristmasTakeRecord::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 ChristmasTakeRecord::level() const {
  // @@protoc_insertion_point(field_get:fgame.ChristmasTakeRecord.Level)
  return level_;
}
inline void ChristmasTakeRecord::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:fgame.ChristmasTakeRecord.Level)
}

// required bool IsTake = 2;
inline bool ChristmasTakeRecord::has_istake() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChristmasTakeRecord::set_has_istake() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChristmasTakeRecord::clear_has_istake() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChristmasTakeRecord::clear_istake() {
  istake_ = false;
  clear_has_istake();
}
inline bool ChristmasTakeRecord::istake() const {
  // @@protoc_insertion_point(field_get:fgame.ChristmasTakeRecord.IsTake)
  return istake_;
}
inline void ChristmasTakeRecord::set_istake(bool value) {
  set_has_istake();
  istake_ = value;
  // @@protoc_insertion_point(field_set:fgame.ChristmasTakeRecord.IsTake)
}

// -------------------------------------------------------------------

// CSChristmasGetDataResp

// required int32 StartTime = 1;
inline bool CSChristmasGetDataResp::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChristmasGetDataResp::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChristmasGetDataResp::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChristmasGetDataResp::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline ::google::protobuf::int32 CSChristmasGetDataResp::starttime() const {
  // @@protoc_insertion_point(field_get:fgame.CSChristmasGetDataResp.StartTime)
  return starttime_;
}
inline void CSChristmasGetDataResp::set_starttime(::google::protobuf::int32 value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSChristmasGetDataResp.StartTime)
}

// required int32 EndTime = 2;
inline bool CSChristmasGetDataResp::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSChristmasGetDataResp::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSChristmasGetDataResp::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSChristmasGetDataResp::clear_endtime() {
  endtime_ = 0;
  clear_has_endtime();
}
inline ::google::protobuf::int32 CSChristmasGetDataResp::endtime() const {
  // @@protoc_insertion_point(field_get:fgame.CSChristmasGetDataResp.EndTime)
  return endtime_;
}
inline void CSChristmasGetDataResp::set_endtime(::google::protobuf::int32 value) {
  set_has_endtime();
  endtime_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSChristmasGetDataResp.EndTime)
}

// optional int32 GlobalScore = 3;
inline bool CSChristmasGetDataResp::has_globalscore() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSChristmasGetDataResp::set_has_globalscore() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSChristmasGetDataResp::clear_has_globalscore() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSChristmasGetDataResp::clear_globalscore() {
  globalscore_ = 0;
  clear_has_globalscore();
}
inline ::google::protobuf::int32 CSChristmasGetDataResp::globalscore() const {
  // @@protoc_insertion_point(field_get:fgame.CSChristmasGetDataResp.GlobalScore)
  return globalscore_;
}
inline void CSChristmasGetDataResp::set_globalscore(::google::protobuf::int32 value) {
  set_has_globalscore();
  globalscore_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSChristmasGetDataResp.GlobalScore)
}

// optional int32 SelfScore = 4;
inline bool CSChristmasGetDataResp::has_selfscore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSChristmasGetDataResp::set_has_selfscore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSChristmasGetDataResp::clear_has_selfscore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSChristmasGetDataResp::clear_selfscore() {
  selfscore_ = 0;
  clear_has_selfscore();
}
inline ::google::protobuf::int32 CSChristmasGetDataResp::selfscore() const {
  // @@protoc_insertion_point(field_get:fgame.CSChristmasGetDataResp.SelfScore)
  return selfscore_;
}
inline void CSChristmasGetDataResp::set_selfscore(::google::protobuf::int32 value) {
  set_has_selfscore();
  selfscore_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSChristmasGetDataResp.SelfScore)
}

// repeated .fgame.ChristmasTakeRecord TakeRecord = 5;
inline int CSChristmasGetDataResp::takerecord_size() const {
  return takerecord_.size();
}
inline void CSChristmasGetDataResp::clear_takerecord() {
  takerecord_.Clear();
}
inline const ::fgame::ChristmasTakeRecord& CSChristmasGetDataResp::takerecord(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSChristmasGetDataResp.TakeRecord)
  return takerecord_.Get(index);
}
inline ::fgame::ChristmasTakeRecord* CSChristmasGetDataResp::mutable_takerecord(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSChristmasGetDataResp.TakeRecord)
  return takerecord_.Mutable(index);
}
inline ::fgame::ChristmasTakeRecord* CSChristmasGetDataResp::add_takerecord() {
  // @@protoc_insertion_point(field_add:fgame.CSChristmasGetDataResp.TakeRecord)
  return takerecord_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::ChristmasTakeRecord >&
CSChristmasGetDataResp::takerecord() const {
  // @@protoc_insertion_point(field_list:fgame.CSChristmasGetDataResp.TakeRecord)
  return takerecord_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::ChristmasTakeRecord >*
CSChristmasGetDataResp::mutable_takerecord() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSChristmasGetDataResp.TakeRecord)
  return &takerecord_;
}

// optional int32 DropEndTime = 6;
inline bool CSChristmasGetDataResp::has_dropendtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSChristmasGetDataResp::set_has_dropendtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSChristmasGetDataResp::clear_has_dropendtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSChristmasGetDataResp::clear_dropendtime() {
  dropendtime_ = 0;
  clear_has_dropendtime();
}
inline ::google::protobuf::int32 CSChristmasGetDataResp::dropendtime() const {
  // @@protoc_insertion_point(field_get:fgame.CSChristmasGetDataResp.DropEndTime)
  return dropendtime_;
}
inline void CSChristmasGetDataResp::set_dropendtime(::google::protobuf::int32 value) {
  set_has_dropendtime();
  dropendtime_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSChristmasGetDataResp.DropEndTime)
}

// -------------------------------------------------------------------

// CSChristmasGetRankReq

// -------------------------------------------------------------------

// ChristmasRankItem

// required int32 Order = 1;
inline bool ChristmasRankItem::has_order() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChristmasRankItem::set_has_order() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChristmasRankItem::clear_has_order() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChristmasRankItem::clear_order() {
  order_ = 0;
  clear_has_order();
}
inline ::google::protobuf::int32 ChristmasRankItem::order() const {
  // @@protoc_insertion_point(field_get:fgame.ChristmasRankItem.Order)
  return order_;
}
inline void ChristmasRankItem::set_order(::google::protobuf::int32 value) {
  set_has_order();
  order_ = value;
  // @@protoc_insertion_point(field_set:fgame.ChristmasRankItem.Order)
}

// required int32 Id = 2;
inline bool ChristmasRankItem::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChristmasRankItem::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChristmasRankItem::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChristmasRankItem::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ChristmasRankItem::id() const {
  // @@protoc_insertion_point(field_get:fgame.ChristmasRankItem.Id)
  return id_;
}
inline void ChristmasRankItem::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.ChristmasRankItem.Id)
}

// required string Name = 3;
inline bool ChristmasRankItem::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChristmasRankItem::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChristmasRankItem::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChristmasRankItem::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ChristmasRankItem::name() const {
  // @@protoc_insertion_point(field_get:fgame.ChristmasRankItem.Name)
  return *name_;
}
inline void ChristmasRankItem::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.ChristmasRankItem.Name)
}
inline void ChristmasRankItem::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.ChristmasRankItem.Name)
}
inline void ChristmasRankItem::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.ChristmasRankItem.Name)
}
inline ::std::string* ChristmasRankItem::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.ChristmasRankItem.Name)
  return name_;
}
inline ::std::string* ChristmasRankItem::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChristmasRankItem::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.ChristmasRankItem.Name)
}

// required int32 Score = 4;
inline bool ChristmasRankItem::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChristmasRankItem::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChristmasRankItem::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChristmasRankItem::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 ChristmasRankItem::score() const {
  // @@protoc_insertion_point(field_get:fgame.ChristmasRankItem.Score)
  return score_;
}
inline void ChristmasRankItem::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:fgame.ChristmasRankItem.Score)
}

// optional int32 VipLevel = 5;
inline bool ChristmasRankItem::has_viplevel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChristmasRankItem::set_has_viplevel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChristmasRankItem::clear_has_viplevel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChristmasRankItem::clear_viplevel() {
  viplevel_ = 0;
  clear_has_viplevel();
}
inline ::google::protobuf::int32 ChristmasRankItem::viplevel() const {
  // @@protoc_insertion_point(field_get:fgame.ChristmasRankItem.VipLevel)
  return viplevel_;
}
inline void ChristmasRankItem::set_viplevel(::google::protobuf::int32 value) {
  set_has_viplevel();
  viplevel_ = value;
  // @@protoc_insertion_point(field_set:fgame.ChristmasRankItem.VipLevel)
}

// -------------------------------------------------------------------

// CSChristmasGetRankResp

// repeated .fgame.ChristmasRankItem RankItems = 1;
inline int CSChristmasGetRankResp::rankitems_size() const {
  return rankitems_.size();
}
inline void CSChristmasGetRankResp::clear_rankitems() {
  rankitems_.Clear();
}
inline const ::fgame::ChristmasRankItem& CSChristmasGetRankResp::rankitems(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSChristmasGetRankResp.RankItems)
  return rankitems_.Get(index);
}
inline ::fgame::ChristmasRankItem* CSChristmasGetRankResp::mutable_rankitems(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSChristmasGetRankResp.RankItems)
  return rankitems_.Mutable(index);
}
inline ::fgame::ChristmasRankItem* CSChristmasGetRankResp::add_rankitems() {
  // @@protoc_insertion_point(field_add:fgame.CSChristmasGetRankResp.RankItems)
  return rankitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::ChristmasRankItem >&
CSChristmasGetRankResp::rankitems() const {
  // @@protoc_insertion_point(field_list:fgame.CSChristmasGetRankResp.RankItems)
  return rankitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::ChristmasRankItem >*
CSChristmasGetRankResp::mutable_rankitems() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSChristmasGetRankResp.RankItems)
  return &rankitems_;
}

// -------------------------------------------------------------------

// CSValentineDataReq

// -------------------------------------------------------------------

// CSValentineDataResp

// required int32 StartTime = 1;
inline bool CSValentineDataResp::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSValentineDataResp::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSValentineDataResp::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSValentineDataResp::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline ::google::protobuf::int32 CSValentineDataResp::starttime() const {
  // @@protoc_insertion_point(field_get:fgame.CSValentineDataResp.StartTime)
  return starttime_;
}
inline void CSValentineDataResp::set_starttime(::google::protobuf::int32 value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSValentineDataResp.StartTime)
}

// required int32 EndTime = 2;
inline bool CSValentineDataResp::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSValentineDataResp::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSValentineDataResp::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSValentineDataResp::clear_endtime() {
  endtime_ = 0;
  clear_has_endtime();
}
inline ::google::protobuf::int32 CSValentineDataResp::endtime() const {
  // @@protoc_insertion_point(field_get:fgame.CSValentineDataResp.EndTime)
  return endtime_;
}
inline void CSValentineDataResp::set_endtime(::google::protobuf::int32 value) {
  set_has_endtime();
  endtime_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSValentineDataResp.EndTime)
}

// optional int32 RedRose = 3;
inline bool CSValentineDataResp::has_redrose() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSValentineDataResp::set_has_redrose() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSValentineDataResp::clear_has_redrose() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSValentineDataResp::clear_redrose() {
  redrose_ = 0;
  clear_has_redrose();
}
inline ::google::protobuf::int32 CSValentineDataResp::redrose() const {
  // @@protoc_insertion_point(field_get:fgame.CSValentineDataResp.RedRose)
  return redrose_;
}
inline void CSValentineDataResp::set_redrose(::google::protobuf::int32 value) {
  set_has_redrose();
  redrose_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSValentineDataResp.RedRose)
}

// optional int32 PinkRose = 4;
inline bool CSValentineDataResp::has_pinkrose() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSValentineDataResp::set_has_pinkrose() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSValentineDataResp::clear_has_pinkrose() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSValentineDataResp::clear_pinkrose() {
  pinkrose_ = 0;
  clear_has_pinkrose();
}
inline ::google::protobuf::int32 CSValentineDataResp::pinkrose() const {
  // @@protoc_insertion_point(field_get:fgame.CSValentineDataResp.PinkRose)
  return pinkrose_;
}
inline void CSValentineDataResp::set_pinkrose(::google::protobuf::int32 value) {
  set_has_pinkrose();
  pinkrose_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSValentineDataResp.PinkRose)
}

// optional int32 BlueRose = 5;
inline bool CSValentineDataResp::has_bluerose() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSValentineDataResp::set_has_bluerose() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSValentineDataResp::clear_has_bluerose() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSValentineDataResp::clear_bluerose() {
  bluerose_ = 0;
  clear_has_bluerose();
}
inline ::google::protobuf::int32 CSValentineDataResp::bluerose() const {
  // @@protoc_insertion_point(field_get:fgame.CSValentineDataResp.BlueRose)
  return bluerose_;
}
inline void CSValentineDataResp::set_bluerose(::google::protobuf::int32 value) {
  set_has_bluerose();
  bluerose_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSValentineDataResp.BlueRose)
}

// -------------------------------------------------------------------

// CSValentineExchangeReq

// required int32 ItemId = 1;
inline bool CSValentineExchangeReq::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSValentineExchangeReq::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSValentineExchangeReq::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSValentineExchangeReq::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 CSValentineExchangeReq::itemid() const {
  // @@protoc_insertion_point(field_get:fgame.CSValentineExchangeReq.ItemId)
  return itemid_;
}
inline void CSValentineExchangeReq::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSValentineExchangeReq.ItemId)
}

// -------------------------------------------------------------------

// CSValentineExchangeResp

// -------------------------------------------------------------------

// CSDailyTaskStatusReq

// -------------------------------------------------------------------

// CSDailyTaskStatusResp

// required bool ShowDailyTask = 1;
inline bool CSDailyTaskStatusResp::has_showdailytask() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDailyTaskStatusResp::set_has_showdailytask() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDailyTaskStatusResp::clear_has_showdailytask() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDailyTaskStatusResp::clear_showdailytask() {
  showdailytask_ = false;
  clear_has_showdailytask();
}
inline bool CSDailyTaskStatusResp::showdailytask() const {
  // @@protoc_insertion_point(field_get:fgame.CSDailyTaskStatusResp.ShowDailyTask)
  return showdailytask_;
}
inline void CSDailyTaskStatusResp::set_showdailytask(bool value) {
  set_has_showdailytask();
  showdailytask_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSDailyTaskStatusResp.ShowDailyTask)
}

// -------------------------------------------------------------------

// CSRequestDailyTaskReq

// -------------------------------------------------------------------

// DailyTaskInfo

// required uint32 TaskType = 1;
inline bool DailyTaskInfo::has_tasktype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DailyTaskInfo::set_has_tasktype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DailyTaskInfo::clear_has_tasktype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DailyTaskInfo::clear_tasktype() {
  tasktype_ = 0u;
  clear_has_tasktype();
}
inline ::google::protobuf::uint32 DailyTaskInfo::tasktype() const {
  // @@protoc_insertion_point(field_get:fgame.DailyTaskInfo.TaskType)
  return tasktype_;
}
inline void DailyTaskInfo::set_tasktype(::google::protobuf::uint32 value) {
  set_has_tasktype();
  tasktype_ = value;
  // @@protoc_insertion_point(field_set:fgame.DailyTaskInfo.TaskType)
}

// required uint32 GiftID = 2;
inline bool DailyTaskInfo::has_giftid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DailyTaskInfo::set_has_giftid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DailyTaskInfo::clear_has_giftid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DailyTaskInfo::clear_giftid() {
  giftid_ = 0u;
  clear_has_giftid();
}
inline ::google::protobuf::uint32 DailyTaskInfo::giftid() const {
  // @@protoc_insertion_point(field_get:fgame.DailyTaskInfo.GiftID)
  return giftid_;
}
inline void DailyTaskInfo::set_giftid(::google::protobuf::uint32 value) {
  set_has_giftid();
  giftid_ = value;
  // @@protoc_insertion_point(field_set:fgame.DailyTaskInfo.GiftID)
}

// required uint32 Progress = 3;
inline bool DailyTaskInfo::has_progress() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DailyTaskInfo::set_has_progress() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DailyTaskInfo::clear_has_progress() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DailyTaskInfo::clear_progress() {
  progress_ = 0u;
  clear_has_progress();
}
inline ::google::protobuf::uint32 DailyTaskInfo::progress() const {
  // @@protoc_insertion_point(field_get:fgame.DailyTaskInfo.Progress)
  return progress_;
}
inline void DailyTaskInfo::set_progress(::google::protobuf::uint32 value) {
  set_has_progress();
  progress_ = value;
  // @@protoc_insertion_point(field_set:fgame.DailyTaskInfo.Progress)
}

// required uint32 TotalProgress = 4;
inline bool DailyTaskInfo::has_totalprogress() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DailyTaskInfo::set_has_totalprogress() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DailyTaskInfo::clear_has_totalprogress() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DailyTaskInfo::clear_totalprogress() {
  totalprogress_ = 0u;
  clear_has_totalprogress();
}
inline ::google::protobuf::uint32 DailyTaskInfo::totalprogress() const {
  // @@protoc_insertion_point(field_get:fgame.DailyTaskInfo.TotalProgress)
  return totalprogress_;
}
inline void DailyTaskInfo::set_totalprogress(::google::protobuf::uint32 value) {
  set_has_totalprogress();
  totalprogress_ = value;
  // @@protoc_insertion_point(field_set:fgame.DailyTaskInfo.TotalProgress)
}

// required bool IsOpen = 5;
inline bool DailyTaskInfo::has_isopen() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DailyTaskInfo::set_has_isopen() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DailyTaskInfo::clear_has_isopen() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DailyTaskInfo::clear_isopen() {
  isopen_ = false;
  clear_has_isopen();
}
inline bool DailyTaskInfo::isopen() const {
  // @@protoc_insertion_point(field_get:fgame.DailyTaskInfo.IsOpen)
  return isopen_;
}
inline void DailyTaskInfo::set_isopen(bool value) {
  set_has_isopen();
  isopen_ = value;
  // @@protoc_insertion_point(field_set:fgame.DailyTaskInfo.IsOpen)
}

// -------------------------------------------------------------------

// CSRequestDailyTaskResp

// repeated .fgame.DailyTaskInfo TaskInfoList = 1;
inline int CSRequestDailyTaskResp::taskinfolist_size() const {
  return taskinfolist_.size();
}
inline void CSRequestDailyTaskResp::clear_taskinfolist() {
  taskinfolist_.Clear();
}
inline const ::fgame::DailyTaskInfo& CSRequestDailyTaskResp::taskinfolist(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSRequestDailyTaskResp.TaskInfoList)
  return taskinfolist_.Get(index);
}
inline ::fgame::DailyTaskInfo* CSRequestDailyTaskResp::mutable_taskinfolist(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSRequestDailyTaskResp.TaskInfoList)
  return taskinfolist_.Mutable(index);
}
inline ::fgame::DailyTaskInfo* CSRequestDailyTaskResp::add_taskinfolist() {
  // @@protoc_insertion_point(field_add:fgame.CSRequestDailyTaskResp.TaskInfoList)
  return taskinfolist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::DailyTaskInfo >&
CSRequestDailyTaskResp::taskinfolist() const {
  // @@protoc_insertion_point(field_list:fgame.CSRequestDailyTaskResp.TaskInfoList)
  return taskinfolist_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::DailyTaskInfo >*
CSRequestDailyTaskResp::mutable_taskinfolist() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSRequestDailyTaskResp.TaskInfoList)
  return &taskinfolist_;
}

// required uint32 TaskProgress = 2;
inline bool CSRequestDailyTaskResp::has_taskprogress() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRequestDailyTaskResp::set_has_taskprogress() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRequestDailyTaskResp::clear_has_taskprogress() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRequestDailyTaskResp::clear_taskprogress() {
  taskprogress_ = 0u;
  clear_has_taskprogress();
}
inline ::google::protobuf::uint32 CSRequestDailyTaskResp::taskprogress() const {
  // @@protoc_insertion_point(field_get:fgame.CSRequestDailyTaskResp.TaskProgress)
  return taskprogress_;
}
inline void CSRequestDailyTaskResp::set_taskprogress(::google::protobuf::uint32 value) {
  set_has_taskprogress();
  taskprogress_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRequestDailyTaskResp.TaskProgress)
}

// required bool CanChange = 3;
inline bool CSRequestDailyTaskResp::has_canchange() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSRequestDailyTaskResp::set_has_canchange() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSRequestDailyTaskResp::clear_has_canchange() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSRequestDailyTaskResp::clear_canchange() {
  canchange_ = false;
  clear_has_canchange();
}
inline bool CSRequestDailyTaskResp::canchange() const {
  // @@protoc_insertion_point(field_get:fgame.CSRequestDailyTaskResp.CanChange)
  return canchange_;
}
inline void CSRequestDailyTaskResp::set_canchange(bool value) {
  set_has_canchange();
  canchange_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRequestDailyTaskResp.CanChange)
}

// -------------------------------------------------------------------

// CSUpdateTaskStatusReq

// -------------------------------------------------------------------

// CSUpdateTaskStatusResp

// required uint32 TaskType = 1;
inline bool CSUpdateTaskStatusResp::has_tasktype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSUpdateTaskStatusResp::set_has_tasktype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSUpdateTaskStatusResp::clear_has_tasktype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSUpdateTaskStatusResp::clear_tasktype() {
  tasktype_ = 0u;
  clear_has_tasktype();
}
inline ::google::protobuf::uint32 CSUpdateTaskStatusResp::tasktype() const {
  // @@protoc_insertion_point(field_get:fgame.CSUpdateTaskStatusResp.TaskType)
  return tasktype_;
}
inline void CSUpdateTaskStatusResp::set_tasktype(::google::protobuf::uint32 value) {
  set_has_tasktype();
  tasktype_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSUpdateTaskStatusResp.TaskType)
}

// required bool IsOpen = 2;
inline bool CSUpdateTaskStatusResp::has_isopen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSUpdateTaskStatusResp::set_has_isopen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSUpdateTaskStatusResp::clear_has_isopen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSUpdateTaskStatusResp::clear_isopen() {
  isopen_ = false;
  clear_has_isopen();
}
inline bool CSUpdateTaskStatusResp::isopen() const {
  // @@protoc_insertion_point(field_get:fgame.CSUpdateTaskStatusResp.IsOpen)
  return isopen_;
}
inline void CSUpdateTaskStatusResp::set_isopen(bool value) {
  set_has_isopen();
  isopen_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSUpdateTaskStatusResp.IsOpen)
}

// -------------------------------------------------------------------

// CSChangeDailyTaskReq

// required uint32 TaskType = 1;
inline bool CSChangeDailyTaskReq::has_tasktype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChangeDailyTaskReq::set_has_tasktype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChangeDailyTaskReq::clear_has_tasktype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChangeDailyTaskReq::clear_tasktype() {
  tasktype_ = 0u;
  clear_has_tasktype();
}
inline ::google::protobuf::uint32 CSChangeDailyTaskReq::tasktype() const {
  // @@protoc_insertion_point(field_get:fgame.CSChangeDailyTaskReq.TaskType)
  return tasktype_;
}
inline void CSChangeDailyTaskReq::set_tasktype(::google::protobuf::uint32 value) {
  set_has_tasktype();
  tasktype_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSChangeDailyTaskReq.TaskType)
}

// -------------------------------------------------------------------

// CSChangeDailyTaskResp

// required bool Result = 1;
inline bool CSChangeDailyTaskResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChangeDailyTaskResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChangeDailyTaskResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChangeDailyTaskResp::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool CSChangeDailyTaskResp::result() const {
  // @@protoc_insertion_point(field_get:fgame.CSChangeDailyTaskResp.Result)
  return result_;
}
inline void CSChangeDailyTaskResp::set_result(bool value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSChangeDailyTaskResp.Result)
}

// optional .fgame.DailyTaskInfo NewTask = 2;
inline bool CSChangeDailyTaskResp::has_newtask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSChangeDailyTaskResp::set_has_newtask() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSChangeDailyTaskResp::clear_has_newtask() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSChangeDailyTaskResp::clear_newtask() {
  if (newtask_ != NULL) newtask_->::fgame::DailyTaskInfo::Clear();
  clear_has_newtask();
}
inline const ::fgame::DailyTaskInfo& CSChangeDailyTaskResp::newtask() const {
  // @@protoc_insertion_point(field_get:fgame.CSChangeDailyTaskResp.NewTask)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return newtask_ != NULL ? *newtask_ : *default_instance().newtask_;
#else
  return newtask_ != NULL ? *newtask_ : *default_instance_->newtask_;
#endif
}
inline ::fgame::DailyTaskInfo* CSChangeDailyTaskResp::mutable_newtask() {
  set_has_newtask();
  if (newtask_ == NULL) newtask_ = new ::fgame::DailyTaskInfo;
  // @@protoc_insertion_point(field_mutable:fgame.CSChangeDailyTaskResp.NewTask)
  return newtask_;
}
inline ::fgame::DailyTaskInfo* CSChangeDailyTaskResp::release_newtask() {
  clear_has_newtask();
  ::fgame::DailyTaskInfo* temp = newtask_;
  newtask_ = NULL;
  return temp;
}
inline void CSChangeDailyTaskResp::set_allocated_newtask(::fgame::DailyTaskInfo* newtask) {
  delete newtask_;
  newtask_ = newtask;
  if (newtask) {
    set_has_newtask();
  } else {
    clear_has_newtask();
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSChangeDailyTaskResp.NewTask)
}

// -------------------------------------------------------------------

// CSOpenDailyTaskAwardReq

// -------------------------------------------------------------------

// CSOpenDailyTaskAwardResp

// required bool Ok = 1;
inline bool CSOpenDailyTaskAwardResp::has_ok() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSOpenDailyTaskAwardResp::set_has_ok() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSOpenDailyTaskAwardResp::clear_has_ok() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSOpenDailyTaskAwardResp::clear_ok() {
  ok_ = false;
  clear_has_ok();
}
inline bool CSOpenDailyTaskAwardResp::ok() const {
  // @@protoc_insertion_point(field_get:fgame.CSOpenDailyTaskAwardResp.Ok)
  return ok_;
}
inline void CSOpenDailyTaskAwardResp::set_ok(bool value) {
  set_has_ok();
  ok_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSOpenDailyTaskAwardResp.Ok)
}

// optional uint32 GiftID = 2;
inline bool CSOpenDailyTaskAwardResp::has_giftid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSOpenDailyTaskAwardResp::set_has_giftid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSOpenDailyTaskAwardResp::clear_has_giftid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSOpenDailyTaskAwardResp::clear_giftid() {
  giftid_ = 0u;
  clear_has_giftid();
}
inline ::google::protobuf::uint32 CSOpenDailyTaskAwardResp::giftid() const {
  // @@protoc_insertion_point(field_get:fgame.CSOpenDailyTaskAwardResp.GiftID)
  return giftid_;
}
inline void CSOpenDailyTaskAwardResp::set_giftid(::google::protobuf::uint32 value) {
  set_has_giftid();
  giftid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSOpenDailyTaskAwardResp.GiftID)
}

// optional bool HaveNewTask = 3;
inline bool CSOpenDailyTaskAwardResp::has_havenewtask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSOpenDailyTaskAwardResp::set_has_havenewtask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSOpenDailyTaskAwardResp::clear_has_havenewtask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSOpenDailyTaskAwardResp::clear_havenewtask() {
  havenewtask_ = false;
  clear_has_havenewtask();
}
inline bool CSOpenDailyTaskAwardResp::havenewtask() const {
  // @@protoc_insertion_point(field_get:fgame.CSOpenDailyTaskAwardResp.HaveNewTask)
  return havenewtask_;
}
inline void CSOpenDailyTaskAwardResp::set_havenewtask(bool value) {
  set_has_havenewtask();
  havenewtask_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSOpenDailyTaskAwardResp.HaveNewTask)
}

// -------------------------------------------------------------------

// CSUpdateDailyTaskProgressReq

// repeated uint32 TaskType = 1;
inline int CSUpdateDailyTaskProgressReq::tasktype_size() const {
  return tasktype_.size();
}
inline void CSUpdateDailyTaskProgressReq::clear_tasktype() {
  tasktype_.Clear();
}
inline ::google::protobuf::uint32 CSUpdateDailyTaskProgressReq::tasktype(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSUpdateDailyTaskProgressReq.TaskType)
  return tasktype_.Get(index);
}
inline void CSUpdateDailyTaskProgressReq::set_tasktype(int index, ::google::protobuf::uint32 value) {
  tasktype_.Set(index, value);
  // @@protoc_insertion_point(field_set:fgame.CSUpdateDailyTaskProgressReq.TaskType)
}
inline void CSUpdateDailyTaskProgressReq::add_tasktype(::google::protobuf::uint32 value) {
  tasktype_.Add(value);
  // @@protoc_insertion_point(field_add:fgame.CSUpdateDailyTaskProgressReq.TaskType)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSUpdateDailyTaskProgressReq::tasktype() const {
  // @@protoc_insertion_point(field_list:fgame.CSUpdateDailyTaskProgressReq.TaskType)
  return tasktype_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSUpdateDailyTaskProgressReq::mutable_tasktype() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSUpdateDailyTaskProgressReq.TaskType)
  return &tasktype_;
}

// repeated uint32 Progress = 2;
inline int CSUpdateDailyTaskProgressReq::progress_size() const {
  return progress_.size();
}
inline void CSUpdateDailyTaskProgressReq::clear_progress() {
  progress_.Clear();
}
inline ::google::protobuf::uint32 CSUpdateDailyTaskProgressReq::progress(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSUpdateDailyTaskProgressReq.Progress)
  return progress_.Get(index);
}
inline void CSUpdateDailyTaskProgressReq::set_progress(int index, ::google::protobuf::uint32 value) {
  progress_.Set(index, value);
  // @@protoc_insertion_point(field_set:fgame.CSUpdateDailyTaskProgressReq.Progress)
}
inline void CSUpdateDailyTaskProgressReq::add_progress(::google::protobuf::uint32 value) {
  progress_.Add(value);
  // @@protoc_insertion_point(field_add:fgame.CSUpdateDailyTaskProgressReq.Progress)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSUpdateDailyTaskProgressReq::progress() const {
  // @@protoc_insertion_point(field_list:fgame.CSUpdateDailyTaskProgressReq.Progress)
  return progress_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSUpdateDailyTaskProgressReq::mutable_progress() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSUpdateDailyTaskProgressReq.Progress)
  return &progress_;
}

// -------------------------------------------------------------------

// CSUpdateDailyTaskProgressResp

// required bool Ok = 1;
inline bool CSUpdateDailyTaskProgressResp::has_ok() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSUpdateDailyTaskProgressResp::set_has_ok() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSUpdateDailyTaskProgressResp::clear_has_ok() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSUpdateDailyTaskProgressResp::clear_ok() {
  ok_ = false;
  clear_has_ok();
}
inline bool CSUpdateDailyTaskProgressResp::ok() const {
  // @@protoc_insertion_point(field_get:fgame.CSUpdateDailyTaskProgressResp.Ok)
  return ok_;
}
inline void CSUpdateDailyTaskProgressResp::set_ok(bool value) {
  set_has_ok();
  ok_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSUpdateDailyTaskProgressResp.Ok)
}

// repeated uint32 TaskType = 2;
inline int CSUpdateDailyTaskProgressResp::tasktype_size() const {
  return tasktype_.size();
}
inline void CSUpdateDailyTaskProgressResp::clear_tasktype() {
  tasktype_.Clear();
}
inline ::google::protobuf::uint32 CSUpdateDailyTaskProgressResp::tasktype(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSUpdateDailyTaskProgressResp.TaskType)
  return tasktype_.Get(index);
}
inline void CSUpdateDailyTaskProgressResp::set_tasktype(int index, ::google::protobuf::uint32 value) {
  tasktype_.Set(index, value);
  // @@protoc_insertion_point(field_set:fgame.CSUpdateDailyTaskProgressResp.TaskType)
}
inline void CSUpdateDailyTaskProgressResp::add_tasktype(::google::protobuf::uint32 value) {
  tasktype_.Add(value);
  // @@protoc_insertion_point(field_add:fgame.CSUpdateDailyTaskProgressResp.TaskType)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSUpdateDailyTaskProgressResp::tasktype() const {
  // @@protoc_insertion_point(field_list:fgame.CSUpdateDailyTaskProgressResp.TaskType)
  return tasktype_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSUpdateDailyTaskProgressResp::mutable_tasktype() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSUpdateDailyTaskProgressResp.TaskType)
  return &tasktype_;
}

// repeated uint32 Progress = 3;
inline int CSUpdateDailyTaskProgressResp::progress_size() const {
  return progress_.size();
}
inline void CSUpdateDailyTaskProgressResp::clear_progress() {
  progress_.Clear();
}
inline ::google::protobuf::uint32 CSUpdateDailyTaskProgressResp::progress(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSUpdateDailyTaskProgressResp.Progress)
  return progress_.Get(index);
}
inline void CSUpdateDailyTaskProgressResp::set_progress(int index, ::google::protobuf::uint32 value) {
  progress_.Set(index, value);
  // @@protoc_insertion_point(field_set:fgame.CSUpdateDailyTaskProgressResp.Progress)
}
inline void CSUpdateDailyTaskProgressResp::add_progress(::google::protobuf::uint32 value) {
  progress_.Add(value);
  // @@protoc_insertion_point(field_add:fgame.CSUpdateDailyTaskProgressResp.Progress)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSUpdateDailyTaskProgressResp::progress() const {
  // @@protoc_insertion_point(field_list:fgame.CSUpdateDailyTaskProgressResp.Progress)
  return progress_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSUpdateDailyTaskProgressResp::mutable_progress() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSUpdateDailyTaskProgressResp.Progress)
  return &progress_;
}

// -------------------------------------------------------------------

// CSRankWeekRewardInfoReq

// -------------------------------------------------------------------

// CSRankWeekRewardInfoResp

// optional bool Status = 1;
inline bool CSRankWeekRewardInfoResp::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRankWeekRewardInfoResp::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRankWeekRewardInfoResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRankWeekRewardInfoResp::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool CSRankWeekRewardInfoResp::status() const {
  // @@protoc_insertion_point(field_get:fgame.CSRankWeekRewardInfoResp.Status)
  return status_;
}
inline void CSRankWeekRewardInfoResp::set_status(bool value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRankWeekRewardInfoResp.Status)
}

// optional uint32 PvpCount = 2;
inline bool CSRankWeekRewardInfoResp::has_pvpcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRankWeekRewardInfoResp::set_has_pvpcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRankWeekRewardInfoResp::clear_has_pvpcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRankWeekRewardInfoResp::clear_pvpcount() {
  pvpcount_ = 0u;
  clear_has_pvpcount();
}
inline ::google::protobuf::uint32 CSRankWeekRewardInfoResp::pvpcount() const {
  // @@protoc_insertion_point(field_get:fgame.CSRankWeekRewardInfoResp.PvpCount)
  return pvpcount_;
}
inline void CSRankWeekRewardInfoResp::set_pvpcount(::google::protobuf::uint32 value) {
  set_has_pvpcount();
  pvpcount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRankWeekRewardInfoResp.PvpCount)
}

// optional uint32 GroupId = 3;
inline bool CSRankWeekRewardInfoResp::has_groupid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSRankWeekRewardInfoResp::set_has_groupid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSRankWeekRewardInfoResp::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSRankWeekRewardInfoResp::clear_groupid() {
  groupid_ = 0u;
  clear_has_groupid();
}
inline ::google::protobuf::uint32 CSRankWeekRewardInfoResp::groupid() const {
  // @@protoc_insertion_point(field_get:fgame.CSRankWeekRewardInfoResp.GroupId)
  return groupid_;
}
inline void CSRankWeekRewardInfoResp::set_groupid(::google::protobuf::uint32 value) {
  set_has_groupid();
  groupid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRankWeekRewardInfoResp.GroupId)
}

// optional uint32 Rank = 4;
inline bool CSRankWeekRewardInfoResp::has_rank() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSRankWeekRewardInfoResp::set_has_rank() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSRankWeekRewardInfoResp::clear_has_rank() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSRankWeekRewardInfoResp::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 CSRankWeekRewardInfoResp::rank() const {
  // @@protoc_insertion_point(field_get:fgame.CSRankWeekRewardInfoResp.Rank)
  return rank_;
}
inline void CSRankWeekRewardInfoResp::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRankWeekRewardInfoResp.Rank)
}

// -------------------------------------------------------------------

// CSRankWeekRewardRewardReq

// -------------------------------------------------------------------

// CSRankWeekRewardRewardResp

// optional bool Success = 1;
inline bool CSRankWeekRewardRewardResp::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRankWeekRewardRewardResp::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRankWeekRewardRewardResp::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRankWeekRewardRewardResp::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool CSRankWeekRewardRewardResp::success() const {
  // @@protoc_insertion_point(field_get:fgame.CSRankWeekRewardRewardResp.Success)
  return success_;
}
inline void CSRankWeekRewardRewardResp::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRankWeekRewardRewardResp.Success)
}

// optional uint32 Error = 2;
inline bool CSRankWeekRewardRewardResp::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRankWeekRewardRewardResp::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRankWeekRewardRewardResp::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRankWeekRewardRewardResp::clear_error() {
  error_ = 0u;
  clear_has_error();
}
inline ::google::protobuf::uint32 CSRankWeekRewardRewardResp::error() const {
  // @@protoc_insertion_point(field_get:fgame.CSRankWeekRewardRewardResp.Error)
  return error_;
}
inline void CSRankWeekRewardRewardResp::set_error(::google::protobuf::uint32 value) {
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRankWeekRewardRewardResp.Error)
}

// -------------------------------------------------------------------

// CSNewDailyTaskResp

// required bool Ok = 1;
inline bool CSNewDailyTaskResp::has_ok() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSNewDailyTaskResp::set_has_ok() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSNewDailyTaskResp::clear_has_ok() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSNewDailyTaskResp::clear_ok() {
  ok_ = false;
  clear_has_ok();
}
inline bool CSNewDailyTaskResp::ok() const {
  // @@protoc_insertion_point(field_get:fgame.CSNewDailyTaskResp.Ok)
  return ok_;
}
inline void CSNewDailyTaskResp::set_ok(bool value) {
  set_has_ok();
  ok_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSNewDailyTaskResp.Ok)
}

// -------------------------------------------------------------------

// CSOpActAddResp

// required string ActivityConifg = 1;
inline bool CSOpActAddResp::has_activityconifg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSOpActAddResp::set_has_activityconifg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSOpActAddResp::clear_has_activityconifg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSOpActAddResp::clear_activityconifg() {
  if (activityconifg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    activityconifg_->clear();
  }
  clear_has_activityconifg();
}
inline const ::std::string& CSOpActAddResp::activityconifg() const {
  // @@protoc_insertion_point(field_get:fgame.CSOpActAddResp.ActivityConifg)
  return *activityconifg_;
}
inline void CSOpActAddResp::set_activityconifg(const ::std::string& value) {
  set_has_activityconifg();
  if (activityconifg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    activityconifg_ = new ::std::string;
  }
  activityconifg_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSOpActAddResp.ActivityConifg)
}
inline void CSOpActAddResp::set_activityconifg(const char* value) {
  set_has_activityconifg();
  if (activityconifg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    activityconifg_ = new ::std::string;
  }
  activityconifg_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSOpActAddResp.ActivityConifg)
}
inline void CSOpActAddResp::set_activityconifg(const char* value, size_t size) {
  set_has_activityconifg();
  if (activityconifg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    activityconifg_ = new ::std::string;
  }
  activityconifg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSOpActAddResp.ActivityConifg)
}
inline ::std::string* CSOpActAddResp::mutable_activityconifg() {
  set_has_activityconifg();
  if (activityconifg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    activityconifg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSOpActAddResp.ActivityConifg)
  return activityconifg_;
}
inline ::std::string* CSOpActAddResp::release_activityconifg() {
  clear_has_activityconifg();
  if (activityconifg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = activityconifg_;
    activityconifg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSOpActAddResp::set_allocated_activityconifg(::std::string* activityconifg) {
  if (activityconifg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete activityconifg_;
  }
  if (activityconifg) {
    set_has_activityconifg();
    activityconifg_ = activityconifg;
  } else {
    clear_has_activityconifg();
    activityconifg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSOpActAddResp.ActivityConifg)
}

// -------------------------------------------------------------------

// CSOpActStateChangedResp

// required uint32 ActivityId = 1;
inline bool CSOpActStateChangedResp::has_activityid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSOpActStateChangedResp::set_has_activityid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSOpActStateChangedResp::clear_has_activityid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSOpActStateChangedResp::clear_activityid() {
  activityid_ = 0u;
  clear_has_activityid();
}
inline ::google::protobuf::uint32 CSOpActStateChangedResp::activityid() const {
  // @@protoc_insertion_point(field_get:fgame.CSOpActStateChangedResp.ActivityId)
  return activityid_;
}
inline void CSOpActStateChangedResp::set_activityid(::google::protobuf::uint32 value) {
  set_has_activityid();
  activityid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSOpActStateChangedResp.ActivityId)
}

// required uint32 state = 2;
inline bool CSOpActStateChangedResp::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSOpActStateChangedResp::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSOpActStateChangedResp::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSOpActStateChangedResp::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 CSOpActStateChangedResp::state() const {
  // @@protoc_insertion_point(field_get:fgame.CSOpActStateChangedResp.state)
  return state_;
}
inline void CSOpActStateChangedResp::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSOpActStateChangedResp.state)
}

// -------------------------------------------------------------------

// CSActSelfDataChangedResp

// required string SelfData = 1;
inline bool CSActSelfDataChangedResp::has_selfdata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSActSelfDataChangedResp::set_has_selfdata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSActSelfDataChangedResp::clear_has_selfdata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSActSelfDataChangedResp::clear_selfdata() {
  if (selfdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    selfdata_->clear();
  }
  clear_has_selfdata();
}
inline const ::std::string& CSActSelfDataChangedResp::selfdata() const {
  // @@protoc_insertion_point(field_get:fgame.CSActSelfDataChangedResp.SelfData)
  return *selfdata_;
}
inline void CSActSelfDataChangedResp::set_selfdata(const ::std::string& value) {
  set_has_selfdata();
  if (selfdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    selfdata_ = new ::std::string;
  }
  selfdata_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSActSelfDataChangedResp.SelfData)
}
inline void CSActSelfDataChangedResp::set_selfdata(const char* value) {
  set_has_selfdata();
  if (selfdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    selfdata_ = new ::std::string;
  }
  selfdata_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSActSelfDataChangedResp.SelfData)
}
inline void CSActSelfDataChangedResp::set_selfdata(const char* value, size_t size) {
  set_has_selfdata();
  if (selfdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    selfdata_ = new ::std::string;
  }
  selfdata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSActSelfDataChangedResp.SelfData)
}
inline ::std::string* CSActSelfDataChangedResp::mutable_selfdata() {
  set_has_selfdata();
  if (selfdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    selfdata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSActSelfDataChangedResp.SelfData)
  return selfdata_;
}
inline ::std::string* CSActSelfDataChangedResp::release_selfdata() {
  clear_has_selfdata();
  if (selfdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = selfdata_;
    selfdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSActSelfDataChangedResp::set_allocated_selfdata(::std::string* selfdata) {
  if (selfdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete selfdata_;
  }
  if (selfdata) {
    set_has_selfdata();
    selfdata_ = selfdata;
  } else {
    clear_has_selfdata();
    selfdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSActSelfDataChangedResp.SelfData)
}

// -------------------------------------------------------------------

// CSActGlobalDataChangedResp

// required string GlobalData = 1;
inline bool CSActGlobalDataChangedResp::has_globaldata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSActGlobalDataChangedResp::set_has_globaldata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSActGlobalDataChangedResp::clear_has_globaldata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSActGlobalDataChangedResp::clear_globaldata() {
  if (globaldata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    globaldata_->clear();
  }
  clear_has_globaldata();
}
inline const ::std::string& CSActGlobalDataChangedResp::globaldata() const {
  // @@protoc_insertion_point(field_get:fgame.CSActGlobalDataChangedResp.GlobalData)
  return *globaldata_;
}
inline void CSActGlobalDataChangedResp::set_globaldata(const ::std::string& value) {
  set_has_globaldata();
  if (globaldata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    globaldata_ = new ::std::string;
  }
  globaldata_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSActGlobalDataChangedResp.GlobalData)
}
inline void CSActGlobalDataChangedResp::set_globaldata(const char* value) {
  set_has_globaldata();
  if (globaldata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    globaldata_ = new ::std::string;
  }
  globaldata_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSActGlobalDataChangedResp.GlobalData)
}
inline void CSActGlobalDataChangedResp::set_globaldata(const char* value, size_t size) {
  set_has_globaldata();
  if (globaldata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    globaldata_ = new ::std::string;
  }
  globaldata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSActGlobalDataChangedResp.GlobalData)
}
inline ::std::string* CSActGlobalDataChangedResp::mutable_globaldata() {
  set_has_globaldata();
  if (globaldata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    globaldata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSActGlobalDataChangedResp.GlobalData)
  return globaldata_;
}
inline ::std::string* CSActGlobalDataChangedResp::release_globaldata() {
  clear_has_globaldata();
  if (globaldata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = globaldata_;
    globaldata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSActGlobalDataChangedResp::set_allocated_globaldata(::std::string* globaldata) {
  if (globaldata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete globaldata_;
  }
  if (globaldata) {
    set_has_globaldata();
    globaldata_ = globaldata;
  } else {
    clear_has_globaldata();
    globaldata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSActGlobalDataChangedResp.GlobalData)
}

// -------------------------------------------------------------------

// CSOpActConfigListReq

// -------------------------------------------------------------------

// CSOpActConfigListResp

// repeated string ActivityConfig = 1;
inline int CSOpActConfigListResp::activityconfig_size() const {
  return activityconfig_.size();
}
inline void CSOpActConfigListResp::clear_activityconfig() {
  activityconfig_.Clear();
}
inline const ::std::string& CSOpActConfigListResp::activityconfig(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSOpActConfigListResp.ActivityConfig)
  return activityconfig_.Get(index);
}
inline ::std::string* CSOpActConfigListResp::mutable_activityconfig(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSOpActConfigListResp.ActivityConfig)
  return activityconfig_.Mutable(index);
}
inline void CSOpActConfigListResp::set_activityconfig(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:fgame.CSOpActConfigListResp.ActivityConfig)
  activityconfig_.Mutable(index)->assign(value);
}
inline void CSOpActConfigListResp::set_activityconfig(int index, const char* value) {
  activityconfig_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSOpActConfigListResp.ActivityConfig)
}
inline void CSOpActConfigListResp::set_activityconfig(int index, const char* value, size_t size) {
  activityconfig_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSOpActConfigListResp.ActivityConfig)
}
inline ::std::string* CSOpActConfigListResp::add_activityconfig() {
  return activityconfig_.Add();
}
inline void CSOpActConfigListResp::add_activityconfig(const ::std::string& value) {
  activityconfig_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fgame.CSOpActConfigListResp.ActivityConfig)
}
inline void CSOpActConfigListResp::add_activityconfig(const char* value) {
  activityconfig_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fgame.CSOpActConfigListResp.ActivityConfig)
}
inline void CSOpActConfigListResp::add_activityconfig(const char* value, size_t size) {
  activityconfig_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fgame.CSOpActConfigListResp.ActivityConfig)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CSOpActConfigListResp::activityconfig() const {
  // @@protoc_insertion_point(field_list:fgame.CSOpActConfigListResp.ActivityConfig)
  return activityconfig_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CSOpActConfigListResp::mutable_activityconfig() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSOpActConfigListResp.ActivityConfig)
  return &activityconfig_;
}

// -------------------------------------------------------------------

// CSOpActSelfDataListReq

// -------------------------------------------------------------------

// CSOpActSelfDataListResp

// repeated string SelfData = 1;
inline int CSOpActSelfDataListResp::selfdata_size() const {
  return selfdata_.size();
}
inline void CSOpActSelfDataListResp::clear_selfdata() {
  selfdata_.Clear();
}
inline const ::std::string& CSOpActSelfDataListResp::selfdata(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSOpActSelfDataListResp.SelfData)
  return selfdata_.Get(index);
}
inline ::std::string* CSOpActSelfDataListResp::mutable_selfdata(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSOpActSelfDataListResp.SelfData)
  return selfdata_.Mutable(index);
}
inline void CSOpActSelfDataListResp::set_selfdata(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:fgame.CSOpActSelfDataListResp.SelfData)
  selfdata_.Mutable(index)->assign(value);
}
inline void CSOpActSelfDataListResp::set_selfdata(int index, const char* value) {
  selfdata_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSOpActSelfDataListResp.SelfData)
}
inline void CSOpActSelfDataListResp::set_selfdata(int index, const char* value, size_t size) {
  selfdata_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSOpActSelfDataListResp.SelfData)
}
inline ::std::string* CSOpActSelfDataListResp::add_selfdata() {
  return selfdata_.Add();
}
inline void CSOpActSelfDataListResp::add_selfdata(const ::std::string& value) {
  selfdata_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fgame.CSOpActSelfDataListResp.SelfData)
}
inline void CSOpActSelfDataListResp::add_selfdata(const char* value) {
  selfdata_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fgame.CSOpActSelfDataListResp.SelfData)
}
inline void CSOpActSelfDataListResp::add_selfdata(const char* value, size_t size) {
  selfdata_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fgame.CSOpActSelfDataListResp.SelfData)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CSOpActSelfDataListResp::selfdata() const {
  // @@protoc_insertion_point(field_list:fgame.CSOpActSelfDataListResp.SelfData)
  return selfdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CSOpActSelfDataListResp::mutable_selfdata() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSOpActSelfDataListResp.SelfData)
  return &selfdata_;
}

// -------------------------------------------------------------------

// CSOpActGlobalDataListReq

// -------------------------------------------------------------------

// CSOpActGlobalDataListResp

// repeated string GlobalData = 1;
inline int CSOpActGlobalDataListResp::globaldata_size() const {
  return globaldata_.size();
}
inline void CSOpActGlobalDataListResp::clear_globaldata() {
  globaldata_.Clear();
}
inline const ::std::string& CSOpActGlobalDataListResp::globaldata(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSOpActGlobalDataListResp.GlobalData)
  return globaldata_.Get(index);
}
inline ::std::string* CSOpActGlobalDataListResp::mutable_globaldata(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSOpActGlobalDataListResp.GlobalData)
  return globaldata_.Mutable(index);
}
inline void CSOpActGlobalDataListResp::set_globaldata(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:fgame.CSOpActGlobalDataListResp.GlobalData)
  globaldata_.Mutable(index)->assign(value);
}
inline void CSOpActGlobalDataListResp::set_globaldata(int index, const char* value) {
  globaldata_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSOpActGlobalDataListResp.GlobalData)
}
inline void CSOpActGlobalDataListResp::set_globaldata(int index, const char* value, size_t size) {
  globaldata_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSOpActGlobalDataListResp.GlobalData)
}
inline ::std::string* CSOpActGlobalDataListResp::add_globaldata() {
  return globaldata_.Add();
}
inline void CSOpActGlobalDataListResp::add_globaldata(const ::std::string& value) {
  globaldata_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fgame.CSOpActGlobalDataListResp.GlobalData)
}
inline void CSOpActGlobalDataListResp::add_globaldata(const char* value) {
  globaldata_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fgame.CSOpActGlobalDataListResp.GlobalData)
}
inline void CSOpActGlobalDataListResp::add_globaldata(const char* value, size_t size) {
  globaldata_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fgame.CSOpActGlobalDataListResp.GlobalData)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CSOpActGlobalDataListResp::globaldata() const {
  // @@protoc_insertion_point(field_list:fgame.CSOpActGlobalDataListResp.GlobalData)
  return globaldata_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CSOpActGlobalDataListResp::mutable_globaldata() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSOpActGlobalDataListResp.GlobalData)
  return &globaldata_;
}

// -------------------------------------------------------------------

// CSOpActDemoTakeReq

// required uint32 ActivityId = 1;
inline bool CSOpActDemoTakeReq::has_activityid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSOpActDemoTakeReq::set_has_activityid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSOpActDemoTakeReq::clear_has_activityid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSOpActDemoTakeReq::clear_activityid() {
  activityid_ = 0u;
  clear_has_activityid();
}
inline ::google::protobuf::uint32 CSOpActDemoTakeReq::activityid() const {
  // @@protoc_insertion_point(field_get:fgame.CSOpActDemoTakeReq.ActivityId)
  return activityid_;
}
inline void CSOpActDemoTakeReq::set_activityid(::google::protobuf::uint32 value) {
  set_has_activityid();
  activityid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSOpActDemoTakeReq.ActivityId)
}

// -------------------------------------------------------------------

// CSOpActDemoTakeResp


// @@protoc_insertion_point(namespace_scope)

}  // namespace fgame

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Activity_2eproto__INCLUDED
