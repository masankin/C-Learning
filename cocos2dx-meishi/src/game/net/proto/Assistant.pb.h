// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Assistant.proto

#ifndef PROTOBUF_Assistant_2eproto__INCLUDED
#define PROTOBUF_Assistant_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace fgame {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Assistant_2eproto();
void protobuf_AssignDesc_Assistant_2eproto();
void protobuf_ShutdownFile_Assistant_2eproto();

class AssistantInfo;
class CSAsSyncInfoReq;
class CSAsSyncInfoResp;
class CSAsNewAddReq;
class CSAsNewAddResp;
class CSAsOperateReq;
class CSAsOperateResp;
class CSAsUseCardReq;
class CSAsUseCardResp;

// ===================================================================

class AssistantInfo : public ::google::protobuf::MessageLite {
 public:
  AssistantInfo();
  virtual ~AssistantInfo();

  AssistantInfo(const AssistantInfo& from);

  inline AssistantInfo& operator=(const AssistantInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AssistantInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AssistantInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AssistantInfo* other);

  // implements Message ----------------------------------------------

  AssistantInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AssistantInfo& from);
  void MergeFrom(const AssistantInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 AssistantId = 1;
  inline bool has_assistantid() const;
  inline void clear_assistantid();
  static const int kAssistantIdFieldNumber = 1;
  inline ::google::protobuf::uint32 assistantid() const;
  inline void set_assistantid(::google::protobuf::uint32 value);

  // required uint32 Level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint32 Quality = 3;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 3;
  inline ::google::protobuf::uint32 quality() const;
  inline void set_quality(::google::protobuf::uint32 value);

  // required bool IsInBattle = 4;
  inline bool has_isinbattle() const;
  inline void clear_isinbattle();
  static const int kIsInBattleFieldNumber = 4;
  inline bool isinbattle() const;
  inline void set_isinbattle(bool value);

  // required uint32 ExpTime = 5;
  inline bool has_exptime() const;
  inline void clear_exptime();
  static const int kExpTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 exptime() const;
  inline void set_exptime(::google::protobuf::uint32 value);

  // repeated uint32 ActiveSkills = 6;
  inline int activeskills_size() const;
  inline void clear_activeskills();
  static const int kActiveSkillsFieldNumber = 6;
  inline ::google::protobuf::uint32 activeskills(int index) const;
  inline void set_activeskills(int index, ::google::protobuf::uint32 value);
  inline void add_activeskills(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      activeskills() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_activeskills();

  // repeated uint32 PassiveSkills = 7;
  inline int passiveskills_size() const;
  inline void clear_passiveskills();
  static const int kPassiveSkillsFieldNumber = 7;
  inline ::google::protobuf::uint32 passiveskills(int index) const;
  inline void set_passiveskills(int index, ::google::protobuf::uint32 value);
  inline void add_passiveskills(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      passiveskills() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_passiveskills();

  // @@protoc_insertion_point(class_scope:fgame.AssistantInfo)
 private:
  inline void set_has_assistantid();
  inline void clear_has_assistantid();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_isinbattle();
  inline void clear_has_isinbattle();
  inline void set_has_exptime();
  inline void clear_has_exptime();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 assistantid_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 quality_;
  bool isinbattle_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > activeskills_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > passiveskills_;
  ::google::protobuf::uint32 exptime_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Assistant_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Assistant_2eproto();
  #endif
  friend void protobuf_AssignDesc_Assistant_2eproto();
  friend void protobuf_ShutdownFile_Assistant_2eproto();

  void InitAsDefaultInstance();
  static AssistantInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSAsSyncInfoReq : public ::google::protobuf::MessageLite {
 public:
  CSAsSyncInfoReq();
  virtual ~CSAsSyncInfoReq();

  CSAsSyncInfoReq(const CSAsSyncInfoReq& from);

  inline CSAsSyncInfoReq& operator=(const CSAsSyncInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSAsSyncInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAsSyncInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAsSyncInfoReq* other);

  // implements Message ----------------------------------------------

  CSAsSyncInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAsSyncInfoReq& from);
  void MergeFrom(const CSAsSyncInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSAsSyncInfoReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Assistant_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Assistant_2eproto();
  #endif
  friend void protobuf_AssignDesc_Assistant_2eproto();
  friend void protobuf_ShutdownFile_Assistant_2eproto();

  void InitAsDefaultInstance();
  static CSAsSyncInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class CSAsSyncInfoResp : public ::google::protobuf::MessageLite {
 public:
  CSAsSyncInfoResp();
  virtual ~CSAsSyncInfoResp();

  CSAsSyncInfoResp(const CSAsSyncInfoResp& from);

  inline CSAsSyncInfoResp& operator=(const CSAsSyncInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSAsSyncInfoResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAsSyncInfoResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAsSyncInfoResp* other);

  // implements Message ----------------------------------------------

  CSAsSyncInfoResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAsSyncInfoResp& from);
  void MergeFrom(const CSAsSyncInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.AssistantInfo Assistant = 1;
  inline int assistant_size() const;
  inline void clear_assistant();
  static const int kAssistantFieldNumber = 1;
  inline const ::fgame::AssistantInfo& assistant(int index) const;
  inline ::fgame::AssistantInfo* mutable_assistant(int index);
  inline ::fgame::AssistantInfo* add_assistant();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::AssistantInfo >&
      assistant() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::AssistantInfo >*
      mutable_assistant();

  // @@protoc_insertion_point(class_scope:fgame.CSAsSyncInfoResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::AssistantInfo > assistant_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Assistant_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Assistant_2eproto();
  #endif
  friend void protobuf_AssignDesc_Assistant_2eproto();
  friend void protobuf_ShutdownFile_Assistant_2eproto();

  void InitAsDefaultInstance();
  static CSAsSyncInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class CSAsNewAddReq : public ::google::protobuf::MessageLite {
 public:
  CSAsNewAddReq();
  virtual ~CSAsNewAddReq();

  CSAsNewAddReq(const CSAsNewAddReq& from);

  inline CSAsNewAddReq& operator=(const CSAsNewAddReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSAsNewAddReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAsNewAddReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAsNewAddReq* other);

  // implements Message ----------------------------------------------

  CSAsNewAddReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAsNewAddReq& from);
  void MergeFrom(const CSAsNewAddReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSAsNewAddReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Assistant_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Assistant_2eproto();
  #endif
  friend void protobuf_AssignDesc_Assistant_2eproto();
  friend void protobuf_ShutdownFile_Assistant_2eproto();

  void InitAsDefaultInstance();
  static CSAsNewAddReq* default_instance_;
};
// -------------------------------------------------------------------

class CSAsNewAddResp : public ::google::protobuf::MessageLite {
 public:
  CSAsNewAddResp();
  virtual ~CSAsNewAddResp();

  CSAsNewAddResp(const CSAsNewAddResp& from);

  inline CSAsNewAddResp& operator=(const CSAsNewAddResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSAsNewAddResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAsNewAddResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAsNewAddResp* other);

  // implements Message ----------------------------------------------

  CSAsNewAddResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAsNewAddResp& from);
  void MergeFrom(const CSAsNewAddResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.AssistantInfo NewAddAssistant = 1;
  inline int newaddassistant_size() const;
  inline void clear_newaddassistant();
  static const int kNewAddAssistantFieldNumber = 1;
  inline const ::fgame::AssistantInfo& newaddassistant(int index) const;
  inline ::fgame::AssistantInfo* mutable_newaddassistant(int index);
  inline ::fgame::AssistantInfo* add_newaddassistant();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::AssistantInfo >&
      newaddassistant() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::AssistantInfo >*
      mutable_newaddassistant();

  // @@protoc_insertion_point(class_scope:fgame.CSAsNewAddResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::AssistantInfo > newaddassistant_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Assistant_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Assistant_2eproto();
  #endif
  friend void protobuf_AssignDesc_Assistant_2eproto();
  friend void protobuf_ShutdownFile_Assistant_2eproto();

  void InitAsDefaultInstance();
  static CSAsNewAddResp* default_instance_;
};
// -------------------------------------------------------------------

class CSAsOperateReq : public ::google::protobuf::MessageLite {
 public:
  CSAsOperateReq();
  virtual ~CSAsOperateReq();

  CSAsOperateReq(const CSAsOperateReq& from);

  inline CSAsOperateReq& operator=(const CSAsOperateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSAsOperateReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAsOperateReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAsOperateReq* other);

  // implements Message ----------------------------------------------

  CSAsOperateReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAsOperateReq& from);
  void MergeFrom(const CSAsOperateReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 AssistantId = 1;
  inline bool has_assistantid() const;
  inline void clear_assistantid();
  static const int kAssistantIdFieldNumber = 1;
  inline ::google::protobuf::uint32 assistantid() const;
  inline void set_assistantid(::google::protobuf::uint32 value);

  // required uint32 Operation = 2;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 2;
  inline ::google::protobuf::uint32 operation() const;
  inline void set_operation(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSAsOperateReq)
 private:
  inline void set_has_assistantid();
  inline void clear_has_assistantid();
  inline void set_has_operation();
  inline void clear_has_operation();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 assistantid_;
  ::google::protobuf::uint32 operation_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Assistant_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Assistant_2eproto();
  #endif
  friend void protobuf_AssignDesc_Assistant_2eproto();
  friend void protobuf_ShutdownFile_Assistant_2eproto();

  void InitAsDefaultInstance();
  static CSAsOperateReq* default_instance_;
};
// -------------------------------------------------------------------

class CSAsOperateResp : public ::google::protobuf::MessageLite {
 public:
  CSAsOperateResp();
  virtual ~CSAsOperateResp();

  CSAsOperateResp(const CSAsOperateResp& from);

  inline CSAsOperateResp& operator=(const CSAsOperateResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSAsOperateResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAsOperateResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAsOperateResp* other);

  // implements Message ----------------------------------------------

  CSAsOperateResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAsOperateResp& from);
  void MergeFrom(const CSAsOperateResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 AssistantId = 1;
  inline bool has_assistantid() const;
  inline void clear_assistantid();
  static const int kAssistantIdFieldNumber = 1;
  inline ::google::protobuf::uint32 assistantid() const;
  inline void set_assistantid(::google::protobuf::uint32 value);

  // required uint32 Operation = 2;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 2;
  inline ::google::protobuf::uint32 operation() const;
  inline void set_operation(::google::protobuf::uint32 value);

  // required bool Res = 3;
  inline bool has_res() const;
  inline void clear_res();
  static const int kResFieldNumber = 3;
  inline bool res() const;
  inline void set_res(bool value);

  // @@protoc_insertion_point(class_scope:fgame.CSAsOperateResp)
 private:
  inline void set_has_assistantid();
  inline void clear_has_assistantid();
  inline void set_has_operation();
  inline void clear_has_operation();
  inline void set_has_res();
  inline void clear_has_res();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 assistantid_;
  ::google::protobuf::uint32 operation_;
  bool res_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Assistant_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Assistant_2eproto();
  #endif
  friend void protobuf_AssignDesc_Assistant_2eproto();
  friend void protobuf_ShutdownFile_Assistant_2eproto();

  void InitAsDefaultInstance();
  static CSAsOperateResp* default_instance_;
};
// -------------------------------------------------------------------

class CSAsUseCardReq : public ::google::protobuf::MessageLite {
 public:
  CSAsUseCardReq();
  virtual ~CSAsUseCardReq();

  CSAsUseCardReq(const CSAsUseCardReq& from);

  inline CSAsUseCardReq& operator=(const CSAsUseCardReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSAsUseCardReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAsUseCardReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAsUseCardReq* other);

  // implements Message ----------------------------------------------

  CSAsUseCardReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAsUseCardReq& from);
  void MergeFrom(const CSAsUseCardReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 AssistantId = 1;
  inline bool has_assistantid() const;
  inline void clear_assistantid();
  static const int kAssistantIdFieldNumber = 1;
  inline ::google::protobuf::uint32 assistantid() const;
  inline void set_assistantid(::google::protobuf::uint32 value);

  // required uint32 CardID = 2;
  inline bool has_cardid() const;
  inline void clear_cardid();
  static const int kCardIDFieldNumber = 2;
  inline ::google::protobuf::uint32 cardid() const;
  inline void set_cardid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSAsUseCardReq)
 private:
  inline void set_has_assistantid();
  inline void clear_has_assistantid();
  inline void set_has_cardid();
  inline void clear_has_cardid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 assistantid_;
  ::google::protobuf::uint32 cardid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Assistant_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Assistant_2eproto();
  #endif
  friend void protobuf_AssignDesc_Assistant_2eproto();
  friend void protobuf_ShutdownFile_Assistant_2eproto();

  void InitAsDefaultInstance();
  static CSAsUseCardReq* default_instance_;
};
// -------------------------------------------------------------------

class CSAsUseCardResp : public ::google::protobuf::MessageLite {
 public:
  CSAsUseCardResp();
  virtual ~CSAsUseCardResp();

  CSAsUseCardResp(const CSAsUseCardResp& from);

  inline CSAsUseCardResp& operator=(const CSAsUseCardResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSAsUseCardResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAsUseCardResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAsUseCardResp* other);

  // implements Message ----------------------------------------------

  CSAsUseCardResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAsUseCardResp& from);
  void MergeFrom(const CSAsUseCardResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 AssistantId = 1;
  inline bool has_assistantid() const;
  inline void clear_assistantid();
  static const int kAssistantIdFieldNumber = 1;
  inline ::google::protobuf::uint32 assistantid() const;
  inline void set_assistantid(::google::protobuf::uint32 value);

  // required uint32 CardID = 2;
  inline bool has_cardid() const;
  inline void clear_cardid();
  static const int kCardIDFieldNumber = 2;
  inline ::google::protobuf::uint32 cardid() const;
  inline void set_cardid(::google::protobuf::uint32 value);

  // required bool Res = 3;
  inline bool has_res() const;
  inline void clear_res();
  static const int kResFieldNumber = 3;
  inline bool res() const;
  inline void set_res(bool value);

  // @@protoc_insertion_point(class_scope:fgame.CSAsUseCardResp)
 private:
  inline void set_has_assistantid();
  inline void clear_has_assistantid();
  inline void set_has_cardid();
  inline void clear_has_cardid();
  inline void set_has_res();
  inline void clear_has_res();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 assistantid_;
  ::google::protobuf::uint32 cardid_;
  bool res_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Assistant_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Assistant_2eproto();
  #endif
  friend void protobuf_AssignDesc_Assistant_2eproto();
  friend void protobuf_ShutdownFile_Assistant_2eproto();

  void InitAsDefaultInstance();
  static CSAsUseCardResp* default_instance_;
};
// ===================================================================


// ===================================================================

// AssistantInfo

// required uint32 AssistantId = 1;
inline bool AssistantInfo::has_assistantid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssistantInfo::set_has_assistantid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssistantInfo::clear_has_assistantid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssistantInfo::clear_assistantid() {
  assistantid_ = 0u;
  clear_has_assistantid();
}
inline ::google::protobuf::uint32 AssistantInfo::assistantid() const {
  // @@protoc_insertion_point(field_get:fgame.AssistantInfo.AssistantId)
  return assistantid_;
}
inline void AssistantInfo::set_assistantid(::google::protobuf::uint32 value) {
  set_has_assistantid();
  assistantid_ = value;
  // @@protoc_insertion_point(field_set:fgame.AssistantInfo.AssistantId)
}

// required uint32 Level = 2;
inline bool AssistantInfo::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AssistantInfo::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AssistantInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AssistantInfo::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 AssistantInfo::level() const {
  // @@protoc_insertion_point(field_get:fgame.AssistantInfo.Level)
  return level_;
}
inline void AssistantInfo::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:fgame.AssistantInfo.Level)
}

// required uint32 Quality = 3;
inline bool AssistantInfo::has_quality() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AssistantInfo::set_has_quality() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AssistantInfo::clear_has_quality() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AssistantInfo::clear_quality() {
  quality_ = 0u;
  clear_has_quality();
}
inline ::google::protobuf::uint32 AssistantInfo::quality() const {
  // @@protoc_insertion_point(field_get:fgame.AssistantInfo.Quality)
  return quality_;
}
inline void AssistantInfo::set_quality(::google::protobuf::uint32 value) {
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:fgame.AssistantInfo.Quality)
}

// required bool IsInBattle = 4;
inline bool AssistantInfo::has_isinbattle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AssistantInfo::set_has_isinbattle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AssistantInfo::clear_has_isinbattle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AssistantInfo::clear_isinbattle() {
  isinbattle_ = false;
  clear_has_isinbattle();
}
inline bool AssistantInfo::isinbattle() const {
  // @@protoc_insertion_point(field_get:fgame.AssistantInfo.IsInBattle)
  return isinbattle_;
}
inline void AssistantInfo::set_isinbattle(bool value) {
  set_has_isinbattle();
  isinbattle_ = value;
  // @@protoc_insertion_point(field_set:fgame.AssistantInfo.IsInBattle)
}

// required uint32 ExpTime = 5;
inline bool AssistantInfo::has_exptime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AssistantInfo::set_has_exptime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AssistantInfo::clear_has_exptime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AssistantInfo::clear_exptime() {
  exptime_ = 0u;
  clear_has_exptime();
}
inline ::google::protobuf::uint32 AssistantInfo::exptime() const {
  // @@protoc_insertion_point(field_get:fgame.AssistantInfo.ExpTime)
  return exptime_;
}
inline void AssistantInfo::set_exptime(::google::protobuf::uint32 value) {
  set_has_exptime();
  exptime_ = value;
  // @@protoc_insertion_point(field_set:fgame.AssistantInfo.ExpTime)
}

// repeated uint32 ActiveSkills = 6;
inline int AssistantInfo::activeskills_size() const {
  return activeskills_.size();
}
inline void AssistantInfo::clear_activeskills() {
  activeskills_.Clear();
}
inline ::google::protobuf::uint32 AssistantInfo::activeskills(int index) const {
  // @@protoc_insertion_point(field_get:fgame.AssistantInfo.ActiveSkills)
  return activeskills_.Get(index);
}
inline void AssistantInfo::set_activeskills(int index, ::google::protobuf::uint32 value) {
  activeskills_.Set(index, value);
  // @@protoc_insertion_point(field_set:fgame.AssistantInfo.ActiveSkills)
}
inline void AssistantInfo::add_activeskills(::google::protobuf::uint32 value) {
  activeskills_.Add(value);
  // @@protoc_insertion_point(field_add:fgame.AssistantInfo.ActiveSkills)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AssistantInfo::activeskills() const {
  // @@protoc_insertion_point(field_list:fgame.AssistantInfo.ActiveSkills)
  return activeskills_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AssistantInfo::mutable_activeskills() {
  // @@protoc_insertion_point(field_mutable_list:fgame.AssistantInfo.ActiveSkills)
  return &activeskills_;
}

// repeated uint32 PassiveSkills = 7;
inline int AssistantInfo::passiveskills_size() const {
  return passiveskills_.size();
}
inline void AssistantInfo::clear_passiveskills() {
  passiveskills_.Clear();
}
inline ::google::protobuf::uint32 AssistantInfo::passiveskills(int index) const {
  // @@protoc_insertion_point(field_get:fgame.AssistantInfo.PassiveSkills)
  return passiveskills_.Get(index);
}
inline void AssistantInfo::set_passiveskills(int index, ::google::protobuf::uint32 value) {
  passiveskills_.Set(index, value);
  // @@protoc_insertion_point(field_set:fgame.AssistantInfo.PassiveSkills)
}
inline void AssistantInfo::add_passiveskills(::google::protobuf::uint32 value) {
  passiveskills_.Add(value);
  // @@protoc_insertion_point(field_add:fgame.AssistantInfo.PassiveSkills)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AssistantInfo::passiveskills() const {
  // @@protoc_insertion_point(field_list:fgame.AssistantInfo.PassiveSkills)
  return passiveskills_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AssistantInfo::mutable_passiveskills() {
  // @@protoc_insertion_point(field_mutable_list:fgame.AssistantInfo.PassiveSkills)
  return &passiveskills_;
}

// -------------------------------------------------------------------

// CSAsSyncInfoReq

// -------------------------------------------------------------------

// CSAsSyncInfoResp

// repeated .fgame.AssistantInfo Assistant = 1;
inline int CSAsSyncInfoResp::assistant_size() const {
  return assistant_.size();
}
inline void CSAsSyncInfoResp::clear_assistant() {
  assistant_.Clear();
}
inline const ::fgame::AssistantInfo& CSAsSyncInfoResp::assistant(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSAsSyncInfoResp.Assistant)
  return assistant_.Get(index);
}
inline ::fgame::AssistantInfo* CSAsSyncInfoResp::mutable_assistant(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSAsSyncInfoResp.Assistant)
  return assistant_.Mutable(index);
}
inline ::fgame::AssistantInfo* CSAsSyncInfoResp::add_assistant() {
  // @@protoc_insertion_point(field_add:fgame.CSAsSyncInfoResp.Assistant)
  return assistant_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::AssistantInfo >&
CSAsSyncInfoResp::assistant() const {
  // @@protoc_insertion_point(field_list:fgame.CSAsSyncInfoResp.Assistant)
  return assistant_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::AssistantInfo >*
CSAsSyncInfoResp::mutable_assistant() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSAsSyncInfoResp.Assistant)
  return &assistant_;
}

// -------------------------------------------------------------------

// CSAsNewAddReq

// -------------------------------------------------------------------

// CSAsNewAddResp

// repeated .fgame.AssistantInfo NewAddAssistant = 1;
inline int CSAsNewAddResp::newaddassistant_size() const {
  return newaddassistant_.size();
}
inline void CSAsNewAddResp::clear_newaddassistant() {
  newaddassistant_.Clear();
}
inline const ::fgame::AssistantInfo& CSAsNewAddResp::newaddassistant(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSAsNewAddResp.NewAddAssistant)
  return newaddassistant_.Get(index);
}
inline ::fgame::AssistantInfo* CSAsNewAddResp::mutable_newaddassistant(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSAsNewAddResp.NewAddAssistant)
  return newaddassistant_.Mutable(index);
}
inline ::fgame::AssistantInfo* CSAsNewAddResp::add_newaddassistant() {
  // @@protoc_insertion_point(field_add:fgame.CSAsNewAddResp.NewAddAssistant)
  return newaddassistant_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::AssistantInfo >&
CSAsNewAddResp::newaddassistant() const {
  // @@protoc_insertion_point(field_list:fgame.CSAsNewAddResp.NewAddAssistant)
  return newaddassistant_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::AssistantInfo >*
CSAsNewAddResp::mutable_newaddassistant() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSAsNewAddResp.NewAddAssistant)
  return &newaddassistant_;
}

// -------------------------------------------------------------------

// CSAsOperateReq

// required uint32 AssistantId = 1;
inline bool CSAsOperateReq::has_assistantid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAsOperateReq::set_has_assistantid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAsOperateReq::clear_has_assistantid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAsOperateReq::clear_assistantid() {
  assistantid_ = 0u;
  clear_has_assistantid();
}
inline ::google::protobuf::uint32 CSAsOperateReq::assistantid() const {
  // @@protoc_insertion_point(field_get:fgame.CSAsOperateReq.AssistantId)
  return assistantid_;
}
inline void CSAsOperateReq::set_assistantid(::google::protobuf::uint32 value) {
  set_has_assistantid();
  assistantid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSAsOperateReq.AssistantId)
}

// required uint32 Operation = 2;
inline bool CSAsOperateReq::has_operation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAsOperateReq::set_has_operation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAsOperateReq::clear_has_operation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAsOperateReq::clear_operation() {
  operation_ = 0u;
  clear_has_operation();
}
inline ::google::protobuf::uint32 CSAsOperateReq::operation() const {
  // @@protoc_insertion_point(field_get:fgame.CSAsOperateReq.Operation)
  return operation_;
}
inline void CSAsOperateReq::set_operation(::google::protobuf::uint32 value) {
  set_has_operation();
  operation_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSAsOperateReq.Operation)
}

// -------------------------------------------------------------------

// CSAsOperateResp

// required uint32 AssistantId = 1;
inline bool CSAsOperateResp::has_assistantid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAsOperateResp::set_has_assistantid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAsOperateResp::clear_has_assistantid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAsOperateResp::clear_assistantid() {
  assistantid_ = 0u;
  clear_has_assistantid();
}
inline ::google::protobuf::uint32 CSAsOperateResp::assistantid() const {
  // @@protoc_insertion_point(field_get:fgame.CSAsOperateResp.AssistantId)
  return assistantid_;
}
inline void CSAsOperateResp::set_assistantid(::google::protobuf::uint32 value) {
  set_has_assistantid();
  assistantid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSAsOperateResp.AssistantId)
}

// required uint32 Operation = 2;
inline bool CSAsOperateResp::has_operation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAsOperateResp::set_has_operation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAsOperateResp::clear_has_operation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAsOperateResp::clear_operation() {
  operation_ = 0u;
  clear_has_operation();
}
inline ::google::protobuf::uint32 CSAsOperateResp::operation() const {
  // @@protoc_insertion_point(field_get:fgame.CSAsOperateResp.Operation)
  return operation_;
}
inline void CSAsOperateResp::set_operation(::google::protobuf::uint32 value) {
  set_has_operation();
  operation_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSAsOperateResp.Operation)
}

// required bool Res = 3;
inline bool CSAsOperateResp::has_res() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSAsOperateResp::set_has_res() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSAsOperateResp::clear_has_res() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSAsOperateResp::clear_res() {
  res_ = false;
  clear_has_res();
}
inline bool CSAsOperateResp::res() const {
  // @@protoc_insertion_point(field_get:fgame.CSAsOperateResp.Res)
  return res_;
}
inline void CSAsOperateResp::set_res(bool value) {
  set_has_res();
  res_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSAsOperateResp.Res)
}

// -------------------------------------------------------------------

// CSAsUseCardReq

// required uint32 AssistantId = 1;
inline bool CSAsUseCardReq::has_assistantid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAsUseCardReq::set_has_assistantid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAsUseCardReq::clear_has_assistantid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAsUseCardReq::clear_assistantid() {
  assistantid_ = 0u;
  clear_has_assistantid();
}
inline ::google::protobuf::uint32 CSAsUseCardReq::assistantid() const {
  // @@protoc_insertion_point(field_get:fgame.CSAsUseCardReq.AssistantId)
  return assistantid_;
}
inline void CSAsUseCardReq::set_assistantid(::google::protobuf::uint32 value) {
  set_has_assistantid();
  assistantid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSAsUseCardReq.AssistantId)
}

// required uint32 CardID = 2;
inline bool CSAsUseCardReq::has_cardid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAsUseCardReq::set_has_cardid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAsUseCardReq::clear_has_cardid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAsUseCardReq::clear_cardid() {
  cardid_ = 0u;
  clear_has_cardid();
}
inline ::google::protobuf::uint32 CSAsUseCardReq::cardid() const {
  // @@protoc_insertion_point(field_get:fgame.CSAsUseCardReq.CardID)
  return cardid_;
}
inline void CSAsUseCardReq::set_cardid(::google::protobuf::uint32 value) {
  set_has_cardid();
  cardid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSAsUseCardReq.CardID)
}

// -------------------------------------------------------------------

// CSAsUseCardResp

// required uint32 AssistantId = 1;
inline bool CSAsUseCardResp::has_assistantid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAsUseCardResp::set_has_assistantid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAsUseCardResp::clear_has_assistantid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAsUseCardResp::clear_assistantid() {
  assistantid_ = 0u;
  clear_has_assistantid();
}
inline ::google::protobuf::uint32 CSAsUseCardResp::assistantid() const {
  // @@protoc_insertion_point(field_get:fgame.CSAsUseCardResp.AssistantId)
  return assistantid_;
}
inline void CSAsUseCardResp::set_assistantid(::google::protobuf::uint32 value) {
  set_has_assistantid();
  assistantid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSAsUseCardResp.AssistantId)
}

// required uint32 CardID = 2;
inline bool CSAsUseCardResp::has_cardid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAsUseCardResp::set_has_cardid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAsUseCardResp::clear_has_cardid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAsUseCardResp::clear_cardid() {
  cardid_ = 0u;
  clear_has_cardid();
}
inline ::google::protobuf::uint32 CSAsUseCardResp::cardid() const {
  // @@protoc_insertion_point(field_get:fgame.CSAsUseCardResp.CardID)
  return cardid_;
}
inline void CSAsUseCardResp::set_cardid(::google::protobuf::uint32 value) {
  set_has_cardid();
  cardid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSAsUseCardResp.CardID)
}

// required bool Res = 3;
inline bool CSAsUseCardResp::has_res() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSAsUseCardResp::set_has_res() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSAsUseCardResp::clear_has_res() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSAsUseCardResp::clear_res() {
  res_ = false;
  clear_has_res();
}
inline bool CSAsUseCardResp::res() const {
  // @@protoc_insertion_point(field_get:fgame.CSAsUseCardResp.Res)
  return res_;
}
inline void CSAsUseCardResp::set_res(bool value) {
  set_has_res();
  res_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSAsUseCardResp.Res)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fgame

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Assistant_2eproto__INCLUDED
