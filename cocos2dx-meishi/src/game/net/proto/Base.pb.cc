// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Base.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Base.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace fgame {

void protobuf_ShutdownFile_Base_2eproto() {
  delete CSErrorMsg::default_instance_;
  delete CSLoginReq::default_instance_;
  delete CSLoginResp::default_instance_;
  delete CSLogoutReq::default_instance_;
  delete CSRegReq::default_instance_;
  delete CSRegResp::default_instance_;
  delete CSHeartBeatReq::default_instance_;
  delete CSKickPlayerReq::default_instance_;
  delete CSStopKickPlayerReq::default_instance_;
  delete CSHeartBeatResp::default_instance_;
  delete CSRequestPKeyReq::default_instance_;
  delete CSRequestPKeyResp::default_instance_;
  delete CSSendClientKeyReq::default_instance_;
  delete CSSendClientKeyResp::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_Base_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_Base_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  CSErrorMsg::default_instance_ = new CSErrorMsg();
  CSLoginReq::default_instance_ = new CSLoginReq();
  CSLoginResp::default_instance_ = new CSLoginResp();
  CSLogoutReq::default_instance_ = new CSLogoutReq();
  CSRegReq::default_instance_ = new CSRegReq();
  CSRegResp::default_instance_ = new CSRegResp();
  CSHeartBeatReq::default_instance_ = new CSHeartBeatReq();
  CSKickPlayerReq::default_instance_ = new CSKickPlayerReq();
  CSStopKickPlayerReq::default_instance_ = new CSStopKickPlayerReq();
  CSHeartBeatResp::default_instance_ = new CSHeartBeatResp();
  CSRequestPKeyReq::default_instance_ = new CSRequestPKeyReq();
  CSRequestPKeyResp::default_instance_ = new CSRequestPKeyResp();
  CSSendClientKeyReq::default_instance_ = new CSSendClientKeyReq();
  CSSendClientKeyResp::default_instance_ = new CSSendClientKeyResp();
  CSErrorMsg::default_instance_->InitAsDefaultInstance();
  CSLoginReq::default_instance_->InitAsDefaultInstance();
  CSLoginResp::default_instance_->InitAsDefaultInstance();
  CSLogoutReq::default_instance_->InitAsDefaultInstance();
  CSRegReq::default_instance_->InitAsDefaultInstance();
  CSRegResp::default_instance_->InitAsDefaultInstance();
  CSHeartBeatReq::default_instance_->InitAsDefaultInstance();
  CSKickPlayerReq::default_instance_->InitAsDefaultInstance();
  CSStopKickPlayerReq::default_instance_->InitAsDefaultInstance();
  CSHeartBeatResp::default_instance_->InitAsDefaultInstance();
  CSRequestPKeyReq::default_instance_->InitAsDefaultInstance();
  CSRequestPKeyResp::default_instance_->InitAsDefaultInstance();
  CSSendClientKeyReq::default_instance_->InitAsDefaultInstance();
  CSSendClientKeyResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Base_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_Base_2eproto_once_);
void protobuf_AddDesc_Base_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_Base_2eproto_once_,
                 &protobuf_AddDesc_Base_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Base_2eproto {
  StaticDescriptorInitializer_Base_2eproto() {
    protobuf_AddDesc_Base_2eproto();
  }
} static_descriptor_initializer_Base_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int CSErrorMsg::kErrCodeFieldNumber;
#endif  // !_MSC_VER

CSErrorMsg::CSErrorMsg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSErrorMsg)
}

void CSErrorMsg::InitAsDefaultInstance() {
}

CSErrorMsg::CSErrorMsg(const CSErrorMsg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSErrorMsg)
}

void CSErrorMsg::SharedCtor() {
  _cached_size_ = 0;
  errcode_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSErrorMsg::~CSErrorMsg() {
  // @@protoc_insertion_point(destructor:fgame.CSErrorMsg)
  SharedDtor();
}

void CSErrorMsg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSErrorMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSErrorMsg& CSErrorMsg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Base_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Base_2eproto();
#endif
  return *default_instance_;
}

CSErrorMsg* CSErrorMsg::default_instance_ = NULL;

CSErrorMsg* CSErrorMsg::New() const {
  return new CSErrorMsg;
}

void CSErrorMsg::Clear() {
  errcode_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSErrorMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSErrorMsg)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ErrCode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &errcode_)));
          set_has_errcode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSErrorMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSErrorMsg)
  return false;
#undef DO_
}

void CSErrorMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSErrorMsg)
  // required uint32 ErrCode = 1;
  if (has_errcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->errcode(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSErrorMsg)
}

int CSErrorMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ErrCode = 1;
    if (has_errcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->errcode());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSErrorMsg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSErrorMsg*>(&from));
}

void CSErrorMsg::MergeFrom(const CSErrorMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_errcode()) {
      set_errcode(from.errcode());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSErrorMsg::CopyFrom(const CSErrorMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSErrorMsg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSErrorMsg::Swap(CSErrorMsg* other) {
  if (other != this) {
    std::swap(errcode_, other->errcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSErrorMsg::GetTypeName() const {
  return "fgame.CSErrorMsg";
}


// ===================================================================

#ifndef _MSC_VER
const int CSLoginReq::kOpenIdFieldNumber;
const int CSLoginReq::kChannelIdFieldNumber;
const int CSLoginReq::kTokenFieldNumber;
const int CSLoginReq::kParamsFieldNumber;
const int CSLoginReq::kSecretKeyFieldNumber;
const int CSLoginReq::kGameServerNameFieldNumber;
#endif  // !_MSC_VER

CSLoginReq::CSLoginReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSLoginReq)
}

void CSLoginReq::InitAsDefaultInstance() {
}

CSLoginReq::CSLoginReq(const CSLoginReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSLoginReq)
}

void CSLoginReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  channelid_ = 0u;
  token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  params_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  secretkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gameservername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSLoginReq::~CSLoginReq() {
  // @@protoc_insertion_point(destructor:fgame.CSLoginReq)
  SharedDtor();
}

void CSLoginReq::SharedDtor() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (params_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete params_;
  }
  if (secretkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete secretkey_;
  }
  if (gameservername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gameservername_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSLoginReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSLoginReq& CSLoginReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Base_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Base_2eproto();
#endif
  return *default_instance_;
}

CSLoginReq* CSLoginReq::default_instance_ = NULL;

CSLoginReq* CSLoginReq::New() const {
  return new CSLoginReq;
}

void CSLoginReq::Clear() {
  if (_has_bits_[0 / 32] & 63) {
    if (has_openid()) {
      if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        openid_->clear();
      }
    }
    channelid_ = 0u;
    if (has_token()) {
      if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        token_->clear();
      }
    }
    if (has_params()) {
      if (params_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        params_->clear();
      }
    }
    if (has_secretkey()) {
      if (secretkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        secretkey_->clear();
      }
    }
    if (has_gameservername()) {
      if (gameservername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        gameservername_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSLoginReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSLoginReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string OpenId = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_openid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ChannelId;
        break;
      }

      // required uint32 ChannelId = 2;
      case 2: {
        if (tag == 16) {
         parse_ChannelId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &channelid_)));
          set_has_channelid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_Token;
        break;
      }

      // optional string Token = 3;
      case 3: {
        if (tag == 26) {
         parse_Token:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_token()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_Params;
        break;
      }

      // optional string Params = 4;
      case 4: {
        if (tag == 34) {
         parse_Params:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_params()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_SecretKey;
        break;
      }

      // optional string SecretKey = 5;
      case 5: {
        if (tag == 42) {
         parse_SecretKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_secretkey()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_GameServerName;
        break;
      }

      // optional string GameServerName = 6;
      case 6: {
        if (tag == 50) {
         parse_GameServerName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gameservername()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSLoginReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSLoginReq)
  return false;
#undef DO_
}

void CSLoginReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSLoginReq)
  // required string OpenId = 1;
  if (has_openid()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->openid(), output);
  }

  // required uint32 ChannelId = 2;
  if (has_channelid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->channelid(), output);
  }

  // optional string Token = 3;
  if (has_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->token(), output);
  }

  // optional string Params = 4;
  if (has_params()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->params(), output);
  }

  // optional string SecretKey = 5;
  if (has_secretkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->secretkey(), output);
  }

  // optional string GameServerName = 6;
  if (has_gameservername()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->gameservername(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSLoginReq)
}

int CSLoginReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string OpenId = 1;
    if (has_openid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->openid());
    }

    // required uint32 ChannelId = 2;
    if (has_channelid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->channelid());
    }

    // optional string Token = 3;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->token());
    }

    // optional string Params = 4;
    if (has_params()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->params());
    }

    // optional string SecretKey = 5;
    if (has_secretkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->secretkey());
    }

    // optional string GameServerName = 6;
    if (has_gameservername()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->gameservername());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSLoginReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSLoginReq*>(&from));
}

void CSLoginReq::MergeFrom(const CSLoginReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_openid()) {
      set_openid(from.openid());
    }
    if (from.has_channelid()) {
      set_channelid(from.channelid());
    }
    if (from.has_token()) {
      set_token(from.token());
    }
    if (from.has_params()) {
      set_params(from.params());
    }
    if (from.has_secretkey()) {
      set_secretkey(from.secretkey());
    }
    if (from.has_gameservername()) {
      set_gameservername(from.gameservername());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSLoginReq::CopyFrom(const CSLoginReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSLoginReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSLoginReq::Swap(CSLoginReq* other) {
  if (other != this) {
    std::swap(openid_, other->openid_);
    std::swap(channelid_, other->channelid_);
    std::swap(token_, other->token_);
    std::swap(params_, other->params_);
    std::swap(secretkey_, other->secretkey_);
    std::swap(gameservername_, other->gameservername_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSLoginReq::GetTypeName() const {
  return "fgame.CSLoginReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSLoginResp::kUinFieldNumber;
const int CSLoginResp::kGameServerAddrFieldNumber;
const int CSLoginResp::kOpenIdFieldNumber;
const int CSLoginResp::kAuthTokenFieldNumber;
const int CSLoginResp::kGrayReleaseFieldNumber;
const int CSLoginResp::kStopGameFlagFieldNumber;
#endif  // !_MSC_VER

CSLoginResp::CSLoginResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSLoginResp)
}

void CSLoginResp::InitAsDefaultInstance() {
}

CSLoginResp::CSLoginResp(const CSLoginResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSLoginResp)
}

void CSLoginResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  gameserveraddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  authtoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  grayrelease_ = 0u;
  stopgameflag_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSLoginResp::~CSLoginResp() {
  // @@protoc_insertion_point(destructor:fgame.CSLoginResp)
  SharedDtor();
}

void CSLoginResp::SharedDtor() {
  if (gameserveraddr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gameserveraddr_;
  }
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (authtoken_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete authtoken_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSLoginResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSLoginResp& CSLoginResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Base_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Base_2eproto();
#endif
  return *default_instance_;
}

CSLoginResp* CSLoginResp::default_instance_ = NULL;

CSLoginResp* CSLoginResp::New() const {
  return new CSLoginResp;
}

void CSLoginResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSLoginResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(grayrelease_, stopgameflag_);
    uin_ = GOOGLE_ULONGLONG(0);
    if (has_gameserveraddr()) {
      if (gameserveraddr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        gameserveraddr_->clear();
      }
    }
    if (has_openid()) {
      if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        openid_->clear();
      }
    }
    if (has_authtoken()) {
      if (authtoken_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        authtoken_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSLoginResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSLoginResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_GameServerAddr;
        break;
      }

      // optional string GameServerAddr = 2;
      case 2: {
        if (tag == 18) {
         parse_GameServerAddr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gameserveraddr()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_OpenId;
        break;
      }

      // optional string OpenId = 3;
      case 3: {
        if (tag == 26) {
         parse_OpenId:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_openid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_AuthToken;
        break;
      }

      // optional string AuthToken = 4;
      case 4: {
        if (tag == 34) {
         parse_AuthToken:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_authtoken()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_GrayRelease;
        break;
      }

      // optional uint32 GrayRelease = 5;
      case 5: {
        if (tag == 40) {
         parse_GrayRelease:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &grayrelease_)));
          set_has_grayrelease();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_StopGameFlag;
        break;
      }

      // optional uint32 StopGameFlag = 6;
      case 6: {
        if (tag == 48) {
         parse_StopGameFlag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &stopgameflag_)));
          set_has_stopgameflag();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSLoginResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSLoginResp)
  return false;
#undef DO_
}

void CSLoginResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSLoginResp)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  // optional string GameServerAddr = 2;
  if (has_gameserveraddr()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->gameserveraddr(), output);
  }

  // optional string OpenId = 3;
  if (has_openid()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->openid(), output);
  }

  // optional string AuthToken = 4;
  if (has_authtoken()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->authtoken(), output);
  }

  // optional uint32 GrayRelease = 5;
  if (has_grayrelease()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->grayrelease(), output);
  }

  // optional uint32 StopGameFlag = 6;
  if (has_stopgameflag()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->stopgameflag(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSLoginResp)
}

int CSLoginResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

    // optional string GameServerAddr = 2;
    if (has_gameserveraddr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->gameserveraddr());
    }

    // optional string OpenId = 3;
    if (has_openid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->openid());
    }

    // optional string AuthToken = 4;
    if (has_authtoken()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->authtoken());
    }

    // optional uint32 GrayRelease = 5;
    if (has_grayrelease()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->grayrelease());
    }

    // optional uint32 StopGameFlag = 6;
    if (has_stopgameflag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->stopgameflag());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSLoginResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSLoginResp*>(&from));
}

void CSLoginResp::MergeFrom(const CSLoginResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_gameserveraddr()) {
      set_gameserveraddr(from.gameserveraddr());
    }
    if (from.has_openid()) {
      set_openid(from.openid());
    }
    if (from.has_authtoken()) {
      set_authtoken(from.authtoken());
    }
    if (from.has_grayrelease()) {
      set_grayrelease(from.grayrelease());
    }
    if (from.has_stopgameflag()) {
      set_stopgameflag(from.stopgameflag());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSLoginResp::CopyFrom(const CSLoginResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSLoginResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSLoginResp::Swap(CSLoginResp* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(gameserveraddr_, other->gameserveraddr_);
    std::swap(openid_, other->openid_);
    std::swap(authtoken_, other->authtoken_);
    std::swap(grayrelease_, other->grayrelease_);
    std::swap(stopgameflag_, other->stopgameflag_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSLoginResp::GetTypeName() const {
  return "fgame.CSLoginResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSLogoutReq::kUinFieldNumber;
#endif  // !_MSC_VER

CSLogoutReq::CSLogoutReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSLogoutReq)
}

void CSLogoutReq::InitAsDefaultInstance() {
}

CSLogoutReq::CSLogoutReq(const CSLogoutReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSLogoutReq)
}

void CSLogoutReq::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSLogoutReq::~CSLogoutReq() {
  // @@protoc_insertion_point(destructor:fgame.CSLogoutReq)
  SharedDtor();
}

void CSLogoutReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSLogoutReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSLogoutReq& CSLogoutReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Base_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Base_2eproto();
#endif
  return *default_instance_;
}

CSLogoutReq* CSLogoutReq::default_instance_ = NULL;

CSLogoutReq* CSLogoutReq::New() const {
  return new CSLogoutReq;
}

void CSLogoutReq::Clear() {
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSLogoutReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSLogoutReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSLogoutReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSLogoutReq)
  return false;
#undef DO_
}

void CSLogoutReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSLogoutReq)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSLogoutReq)
}

int CSLogoutReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSLogoutReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSLogoutReq*>(&from));
}

void CSLogoutReq::MergeFrom(const CSLogoutReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSLogoutReq::CopyFrom(const CSLogoutReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSLogoutReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSLogoutReq::Swap(CSLogoutReq* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSLogoutReq::GetTypeName() const {
  return "fgame.CSLogoutReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSRegReq::kAccountFieldNumber;
const int CSRegReq::kPwdFieldNumber;
#endif  // !_MSC_VER

CSRegReq::CSRegReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRegReq)
}

void CSRegReq::InitAsDefaultInstance() {
}

CSRegReq::CSRegReq(const CSRegReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRegReq)
}

void CSRegReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRegReq::~CSRegReq() {
  // @@protoc_insertion_point(destructor:fgame.CSRegReq)
  SharedDtor();
}

void CSRegReq::SharedDtor() {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete account_;
  }
  if (pwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pwd_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRegReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRegReq& CSRegReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Base_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Base_2eproto();
#endif
  return *default_instance_;
}

CSRegReq* CSRegReq::default_instance_ = NULL;

CSRegReq* CSRegReq::New() const {
  return new CSRegReq;
}

void CSRegReq::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        account_->clear();
      }
    }
    if (has_pwd()) {
      if (pwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        pwd_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRegReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRegReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string Account = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Pwd;
        break;
      }

      // required string Pwd = 2;
      case 2: {
        if (tag == 18) {
         parse_Pwd:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pwd()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRegReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRegReq)
  return false;
#undef DO_
}

void CSRegReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRegReq)
  // required string Account = 1;
  if (has_account()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->account(), output);
  }

  // required string Pwd = 2;
  if (has_pwd()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->pwd(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRegReq)
}

int CSRegReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string Account = 1;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // required string Pwd = 2;
    if (has_pwd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pwd());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRegReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRegReq*>(&from));
}

void CSRegReq::MergeFrom(const CSRegReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_pwd()) {
      set_pwd(from.pwd());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRegReq::CopyFrom(const CSRegReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRegReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSRegReq::Swap(CSRegReq* other) {
  if (other != this) {
    std::swap(account_, other->account_);
    std::swap(pwd_, other->pwd_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRegReq::GetTypeName() const {
  return "fgame.CSRegReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSRegResp::kUinFieldNumber;
#endif  // !_MSC_VER

CSRegResp::CSRegResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRegResp)
}

void CSRegResp::InitAsDefaultInstance() {
}

CSRegResp::CSRegResp(const CSRegResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRegResp)
}

void CSRegResp::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRegResp::~CSRegResp() {
  // @@protoc_insertion_point(destructor:fgame.CSRegResp)
  SharedDtor();
}

void CSRegResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRegResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRegResp& CSRegResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Base_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Base_2eproto();
#endif
  return *default_instance_;
}

CSRegResp* CSRegResp::default_instance_ = NULL;

CSRegResp* CSRegResp::New() const {
  return new CSRegResp;
}

void CSRegResp::Clear() {
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRegResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRegResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRegResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRegResp)
  return false;
#undef DO_
}

void CSRegResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRegResp)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRegResp)
}

int CSRegResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRegResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRegResp*>(&from));
}

void CSRegResp::MergeFrom(const CSRegResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRegResp::CopyFrom(const CSRegResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRegResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSRegResp::Swap(CSRegResp* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRegResp::GetTypeName() const {
  return "fgame.CSRegResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSHeartBeatReq::CSHeartBeatReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSHeartBeatReq)
}

void CSHeartBeatReq::InitAsDefaultInstance() {
}

CSHeartBeatReq::CSHeartBeatReq(const CSHeartBeatReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSHeartBeatReq)
}

void CSHeartBeatReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSHeartBeatReq::~CSHeartBeatReq() {
  // @@protoc_insertion_point(destructor:fgame.CSHeartBeatReq)
  SharedDtor();
}

void CSHeartBeatReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSHeartBeatReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSHeartBeatReq& CSHeartBeatReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Base_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Base_2eproto();
#endif
  return *default_instance_;
}

CSHeartBeatReq* CSHeartBeatReq::default_instance_ = NULL;

CSHeartBeatReq* CSHeartBeatReq::New() const {
  return new CSHeartBeatReq;
}

void CSHeartBeatReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSHeartBeatReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSHeartBeatReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSHeartBeatReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSHeartBeatReq)
  return false;
#undef DO_
}

void CSHeartBeatReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSHeartBeatReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSHeartBeatReq)
}

int CSHeartBeatReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSHeartBeatReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSHeartBeatReq*>(&from));
}

void CSHeartBeatReq::MergeFrom(const CSHeartBeatReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSHeartBeatReq::CopyFrom(const CSHeartBeatReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSHeartBeatReq::IsInitialized() const {

  return true;
}

void CSHeartBeatReq::Swap(CSHeartBeatReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSHeartBeatReq::GetTypeName() const {
  return "fgame.CSHeartBeatReq";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSKickPlayerReq::CSKickPlayerReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSKickPlayerReq)
}

void CSKickPlayerReq::InitAsDefaultInstance() {
}

CSKickPlayerReq::CSKickPlayerReq(const CSKickPlayerReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSKickPlayerReq)
}

void CSKickPlayerReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSKickPlayerReq::~CSKickPlayerReq() {
  // @@protoc_insertion_point(destructor:fgame.CSKickPlayerReq)
  SharedDtor();
}

void CSKickPlayerReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSKickPlayerReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSKickPlayerReq& CSKickPlayerReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Base_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Base_2eproto();
#endif
  return *default_instance_;
}

CSKickPlayerReq* CSKickPlayerReq::default_instance_ = NULL;

CSKickPlayerReq* CSKickPlayerReq::New() const {
  return new CSKickPlayerReq;
}

void CSKickPlayerReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSKickPlayerReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSKickPlayerReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSKickPlayerReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSKickPlayerReq)
  return false;
#undef DO_
}

void CSKickPlayerReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSKickPlayerReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSKickPlayerReq)
}

int CSKickPlayerReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSKickPlayerReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSKickPlayerReq*>(&from));
}

void CSKickPlayerReq::MergeFrom(const CSKickPlayerReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSKickPlayerReq::CopyFrom(const CSKickPlayerReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSKickPlayerReq::IsInitialized() const {

  return true;
}

void CSKickPlayerReq::Swap(CSKickPlayerReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSKickPlayerReq::GetTypeName() const {
  return "fgame.CSKickPlayerReq";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSStopKickPlayerReq::CSStopKickPlayerReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSStopKickPlayerReq)
}

void CSStopKickPlayerReq::InitAsDefaultInstance() {
}

CSStopKickPlayerReq::CSStopKickPlayerReq(const CSStopKickPlayerReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSStopKickPlayerReq)
}

void CSStopKickPlayerReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSStopKickPlayerReq::~CSStopKickPlayerReq() {
  // @@protoc_insertion_point(destructor:fgame.CSStopKickPlayerReq)
  SharedDtor();
}

void CSStopKickPlayerReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSStopKickPlayerReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSStopKickPlayerReq& CSStopKickPlayerReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Base_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Base_2eproto();
#endif
  return *default_instance_;
}

CSStopKickPlayerReq* CSStopKickPlayerReq::default_instance_ = NULL;

CSStopKickPlayerReq* CSStopKickPlayerReq::New() const {
  return new CSStopKickPlayerReq;
}

void CSStopKickPlayerReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSStopKickPlayerReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSStopKickPlayerReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSStopKickPlayerReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSStopKickPlayerReq)
  return false;
#undef DO_
}

void CSStopKickPlayerReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSStopKickPlayerReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSStopKickPlayerReq)
}

int CSStopKickPlayerReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSStopKickPlayerReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSStopKickPlayerReq*>(&from));
}

void CSStopKickPlayerReq::MergeFrom(const CSStopKickPlayerReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSStopKickPlayerReq::CopyFrom(const CSStopKickPlayerReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSStopKickPlayerReq::IsInitialized() const {

  return true;
}

void CSStopKickPlayerReq::Swap(CSStopKickPlayerReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSStopKickPlayerReq::GetTypeName() const {
  return "fgame.CSStopKickPlayerReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSHeartBeatResp::kRetFieldNumber;
const int CSHeartBeatResp::kTsFieldNumber;
#endif  // !_MSC_VER

CSHeartBeatResp::CSHeartBeatResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSHeartBeatResp)
}

void CSHeartBeatResp::InitAsDefaultInstance() {
}

CSHeartBeatResp::CSHeartBeatResp(const CSHeartBeatResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSHeartBeatResp)
}

void CSHeartBeatResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  ts_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSHeartBeatResp::~CSHeartBeatResp() {
  // @@protoc_insertion_point(destructor:fgame.CSHeartBeatResp)
  SharedDtor();
}

void CSHeartBeatResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSHeartBeatResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSHeartBeatResp& CSHeartBeatResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Base_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Base_2eproto();
#endif
  return *default_instance_;
}

CSHeartBeatResp* CSHeartBeatResp::default_instance_ = NULL;

CSHeartBeatResp* CSHeartBeatResp::New() const {
  return new CSHeartBeatResp;
}

void CSHeartBeatResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSHeartBeatResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ret_, ts_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSHeartBeatResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSHeartBeatResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Ts;
        break;
      }

      // optional uint32 Ts = 2;
      case 2: {
        if (tag == 16) {
         parse_Ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSHeartBeatResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSHeartBeatResp)
  return false;
#undef DO_
}

void CSHeartBeatResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSHeartBeatResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // optional uint32 Ts = 2;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->ts(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSHeartBeatResp)
}

int CSHeartBeatResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // optional uint32 Ts = 2;
    if (has_ts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ts());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSHeartBeatResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSHeartBeatResp*>(&from));
}

void CSHeartBeatResp::MergeFrom(const CSHeartBeatResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_ts()) {
      set_ts(from.ts());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSHeartBeatResp::CopyFrom(const CSHeartBeatResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSHeartBeatResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSHeartBeatResp::Swap(CSHeartBeatResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(ts_, other->ts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSHeartBeatResp::GetTypeName() const {
  return "fgame.CSHeartBeatResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSRequestPKeyReq::kDummyFieldNumber;
const int CSRequestPKeyReq::kNotUsedFieldNumber;
#endif  // !_MSC_VER

CSRequestPKeyReq::CSRequestPKeyReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRequestPKeyReq)
}

void CSRequestPKeyReq::InitAsDefaultInstance() {
}

CSRequestPKeyReq::CSRequestPKeyReq(const CSRequestPKeyReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRequestPKeyReq)
}

void CSRequestPKeyReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  dummy_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  not_used_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRequestPKeyReq::~CSRequestPKeyReq() {
  // @@protoc_insertion_point(destructor:fgame.CSRequestPKeyReq)
  SharedDtor();
}

void CSRequestPKeyReq::SharedDtor() {
  if (dummy_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dummy_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRequestPKeyReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRequestPKeyReq& CSRequestPKeyReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Base_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Base_2eproto();
#endif
  return *default_instance_;
}

CSRequestPKeyReq* CSRequestPKeyReq::default_instance_ = NULL;

CSRequestPKeyReq* CSRequestPKeyReq::New() const {
  return new CSRequestPKeyReq;
}

void CSRequestPKeyReq::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_dummy()) {
      if (dummy_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        dummy_->clear();
      }
    }
    not_used_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRequestPKeyReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRequestPKeyReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes dummy = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_dummy()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_not_used;
        break;
      }

      // required int32 not_used = 2;
      case 2: {
        if (tag == 16) {
         parse_not_used:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &not_used_)));
          set_has_not_used();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRequestPKeyReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRequestPKeyReq)
  return false;
#undef DO_
}

void CSRequestPKeyReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRequestPKeyReq)
  // required bytes dummy = 1;
  if (has_dummy()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->dummy(), output);
  }

  // required int32 not_used = 2;
  if (has_not_used()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->not_used(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRequestPKeyReq)
}

int CSRequestPKeyReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes dummy = 1;
    if (has_dummy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->dummy());
    }

    // required int32 not_used = 2;
    if (has_not_used()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->not_used());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRequestPKeyReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRequestPKeyReq*>(&from));
}

void CSRequestPKeyReq::MergeFrom(const CSRequestPKeyReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dummy()) {
      set_dummy(from.dummy());
    }
    if (from.has_not_used()) {
      set_not_used(from.not_used());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRequestPKeyReq::CopyFrom(const CSRequestPKeyReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRequestPKeyReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSRequestPKeyReq::Swap(CSRequestPKeyReq* other) {
  if (other != this) {
    std::swap(dummy_, other->dummy_);
    std::swap(not_used_, other->not_used_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRequestPKeyReq::GetTypeName() const {
  return "fgame.CSRequestPKeyReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSRequestPKeyResp::kPkeyIdFieldNumber;
const int CSRequestPKeyResp::kPkeyFieldNumber;
#endif  // !_MSC_VER

CSRequestPKeyResp::CSRequestPKeyResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRequestPKeyResp)
}

void CSRequestPKeyResp::InitAsDefaultInstance() {
}

CSRequestPKeyResp::CSRequestPKeyResp(const CSRequestPKeyResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRequestPKeyResp)
}

void CSRequestPKeyResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  pkey_id_ = 0u;
  pkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRequestPKeyResp::~CSRequestPKeyResp() {
  // @@protoc_insertion_point(destructor:fgame.CSRequestPKeyResp)
  SharedDtor();
}

void CSRequestPKeyResp::SharedDtor() {
  if (pkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pkey_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRequestPKeyResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRequestPKeyResp& CSRequestPKeyResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Base_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Base_2eproto();
#endif
  return *default_instance_;
}

CSRequestPKeyResp* CSRequestPKeyResp::default_instance_ = NULL;

CSRequestPKeyResp* CSRequestPKeyResp::New() const {
  return new CSRequestPKeyResp;
}

void CSRequestPKeyResp::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    pkey_id_ = 0u;
    if (has_pkey()) {
      if (pkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        pkey_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRequestPKeyResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRequestPKeyResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 pkey_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pkey_id_)));
          set_has_pkey_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pkey;
        break;
      }

      // required string pkey = 2;
      case 2: {
        if (tag == 18) {
         parse_pkey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pkey()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRequestPKeyResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRequestPKeyResp)
  return false;
#undef DO_
}

void CSRequestPKeyResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRequestPKeyResp)
  // required uint32 pkey_id = 1;
  if (has_pkey_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->pkey_id(), output);
  }

  // required string pkey = 2;
  if (has_pkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->pkey(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRequestPKeyResp)
}

int CSRequestPKeyResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 pkey_id = 1;
    if (has_pkey_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pkey_id());
    }

    // required string pkey = 2;
    if (has_pkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pkey());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRequestPKeyResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRequestPKeyResp*>(&from));
}

void CSRequestPKeyResp::MergeFrom(const CSRequestPKeyResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pkey_id()) {
      set_pkey_id(from.pkey_id());
    }
    if (from.has_pkey()) {
      set_pkey(from.pkey());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRequestPKeyResp::CopyFrom(const CSRequestPKeyResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRequestPKeyResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSRequestPKeyResp::Swap(CSRequestPKeyResp* other) {
  if (other != this) {
    std::swap(pkey_id_, other->pkey_id_);
    std::swap(pkey_, other->pkey_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRequestPKeyResp::GetTypeName() const {
  return "fgame.CSRequestPKeyResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSendClientKeyReq::kClientKeyFieldNumber;
#endif  // !_MSC_VER

CSSendClientKeyReq::CSSendClientKeyReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSendClientKeyReq)
}

void CSSendClientKeyReq::InitAsDefaultInstance() {
}

CSSendClientKeyReq::CSSendClientKeyReq(const CSSendClientKeyReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSendClientKeyReq)
}

void CSSendClientKeyReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  client_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSendClientKeyReq::~CSSendClientKeyReq() {
  // @@protoc_insertion_point(destructor:fgame.CSSendClientKeyReq)
  SharedDtor();
}

void CSSendClientKeyReq::SharedDtor() {
  if (client_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_key_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSendClientKeyReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSendClientKeyReq& CSSendClientKeyReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Base_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Base_2eproto();
#endif
  return *default_instance_;
}

CSSendClientKeyReq* CSSendClientKeyReq::default_instance_ = NULL;

CSSendClientKeyReq* CSSendClientKeyReq::New() const {
  return new CSSendClientKeyReq;
}

void CSSendClientKeyReq::Clear() {
  if (has_client_key()) {
    if (client_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      client_key_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSendClientKeyReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSendClientKeyReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes client_key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_client_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSendClientKeyReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSendClientKeyReq)
  return false;
#undef DO_
}

void CSSendClientKeyReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSendClientKeyReq)
  // required bytes client_key = 1;
  if (has_client_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->client_key(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSendClientKeyReq)
}

int CSSendClientKeyReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes client_key = 1;
    if (has_client_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->client_key());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSendClientKeyReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSendClientKeyReq*>(&from));
}

void CSSendClientKeyReq::MergeFrom(const CSSendClientKeyReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_client_key()) {
      set_client_key(from.client_key());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSendClientKeyReq::CopyFrom(const CSSendClientKeyReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSendClientKeyReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSSendClientKeyReq::Swap(CSSendClientKeyReq* other) {
  if (other != this) {
    std::swap(client_key_, other->client_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSendClientKeyReq::GetTypeName() const {
  return "fgame.CSSendClientKeyReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSendClientKeyResp::kOkFieldNumber;
const int CSSendClientKeyResp::kSKeyFieldNumber;
const int CSSendClientKeyResp::kPayloadFieldNumber;
#endif  // !_MSC_VER

CSSendClientKeyResp::CSSendClientKeyResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSendClientKeyResp)
}

void CSSendClientKeyResp::InitAsDefaultInstance() {
}

CSSendClientKeyResp::CSSendClientKeyResp(const CSSendClientKeyResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSendClientKeyResp)
}

void CSSendClientKeyResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ok_ = false;
  s_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSendClientKeyResp::~CSSendClientKeyResp() {
  // @@protoc_insertion_point(destructor:fgame.CSSendClientKeyResp)
  SharedDtor();
}

void CSSendClientKeyResp::SharedDtor() {
  if (s_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_key_;
  }
  if (payload_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete payload_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSendClientKeyResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSendClientKeyResp& CSSendClientKeyResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Base_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Base_2eproto();
#endif
  return *default_instance_;
}

CSSendClientKeyResp* CSSendClientKeyResp::default_instance_ = NULL;

CSSendClientKeyResp* CSSendClientKeyResp::New() const {
  return new CSSendClientKeyResp;
}

void CSSendClientKeyResp::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    ok_ = false;
    if (has_s_key()) {
      if (s_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        s_key_->clear();
      }
    }
    if (has_payload()) {
      if (payload_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        payload_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSendClientKeyResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSendClientKeyResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool ok = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ok_)));
          set_has_ok();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_s_key;
        break;
      }

      // required bytes s_key = 2;
      case 2: {
        if (tag == 18) {
         parse_s_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_s_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_payload;
        break;
      }

      // required string payload = 3;
      case 3: {
        if (tag == 26) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_payload()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSendClientKeyResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSendClientKeyResp)
  return false;
#undef DO_
}

void CSSendClientKeyResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSendClientKeyResp)
  // required bool ok = 1;
  if (has_ok()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->ok(), output);
  }

  // required bytes s_key = 2;
  if (has_s_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->s_key(), output);
  }

  // required string payload = 3;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->payload(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSendClientKeyResp)
}

int CSSendClientKeyResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool ok = 1;
    if (has_ok()) {
      total_size += 1 + 1;
    }

    // required bytes s_key = 2;
    if (has_s_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->s_key());
    }

    // required string payload = 3;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->payload());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSendClientKeyResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSendClientKeyResp*>(&from));
}

void CSSendClientKeyResp::MergeFrom(const CSSendClientKeyResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ok()) {
      set_ok(from.ok());
    }
    if (from.has_s_key()) {
      set_s_key(from.s_key());
    }
    if (from.has_payload()) {
      set_payload(from.payload());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSendClientKeyResp::CopyFrom(const CSSendClientKeyResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSendClientKeyResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSSendClientKeyResp::Swap(CSSendClientKeyResp* other) {
  if (other != this) {
    std::swap(ok_, other->ok_);
    std::swap(s_key_, other->s_key_);
    std::swap(payload_, other->payload_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSendClientKeyResp::GetTypeName() const {
  return "fgame.CSSendClientKeyResp";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fgame

// @@protoc_insertion_point(global_scope)
