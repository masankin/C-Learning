// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Base.proto

#ifndef PROTOBUF_Base_2eproto__INCLUDED
#define PROTOBUF_Base_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace fgame {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Base_2eproto();
void protobuf_AssignDesc_Base_2eproto();
void protobuf_ShutdownFile_Base_2eproto();

class CSErrorMsg;
class CSLoginReq;
class CSLoginResp;
class CSLogoutReq;
class CSRegReq;
class CSRegResp;
class CSHeartBeatReq;
class CSKickPlayerReq;
class CSStopKickPlayerReq;
class CSHeartBeatResp;
class CSRequestPKeyReq;
class CSRequestPKeyResp;
class CSSendClientKeyReq;
class CSSendClientKeyResp;

// ===================================================================

class CSErrorMsg : public ::google::protobuf::MessageLite {
 public:
  CSErrorMsg();
  virtual ~CSErrorMsg();

  CSErrorMsg(const CSErrorMsg& from);

  inline CSErrorMsg& operator=(const CSErrorMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSErrorMsg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSErrorMsg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSErrorMsg* other);

  // implements Message ----------------------------------------------

  CSErrorMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSErrorMsg& from);
  void MergeFrom(const CSErrorMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ErrCode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSErrorMsg)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errcode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Base_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Base_2eproto();
  #endif
  friend void protobuf_AssignDesc_Base_2eproto();
  friend void protobuf_ShutdownFile_Base_2eproto();

  void InitAsDefaultInstance();
  static CSErrorMsg* default_instance_;
};
// -------------------------------------------------------------------

class CSLoginReq : public ::google::protobuf::MessageLite {
 public:
  CSLoginReq();
  virtual ~CSLoginReq();

  CSLoginReq(const CSLoginReq& from);

  inline CSLoginReq& operator=(const CSLoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSLoginReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSLoginReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSLoginReq* other);

  // implements Message ----------------------------------------------

  CSLoginReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSLoginReq& from);
  void MergeFrom(const CSLoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string OpenId = 1;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenIdFieldNumber = 1;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // required uint32 ChannelId = 2;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIdFieldNumber = 2;
  inline ::google::protobuf::uint32 channelid() const;
  inline void set_channelid(::google::protobuf::uint32 value);

  // optional string Token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string Params = 4;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 4;
  inline const ::std::string& params() const;
  inline void set_params(const ::std::string& value);
  inline void set_params(const char* value);
  inline void set_params(const char* value, size_t size);
  inline ::std::string* mutable_params();
  inline ::std::string* release_params();
  inline void set_allocated_params(::std::string* params);

  // optional string SecretKey = 5;
  inline bool has_secretkey() const;
  inline void clear_secretkey();
  static const int kSecretKeyFieldNumber = 5;
  inline const ::std::string& secretkey() const;
  inline void set_secretkey(const ::std::string& value);
  inline void set_secretkey(const char* value);
  inline void set_secretkey(const char* value, size_t size);
  inline ::std::string* mutable_secretkey();
  inline ::std::string* release_secretkey();
  inline void set_allocated_secretkey(::std::string* secretkey);

  // optional string GameServerName = 6;
  inline bool has_gameservername() const;
  inline void clear_gameservername();
  static const int kGameServerNameFieldNumber = 6;
  inline const ::std::string& gameservername() const;
  inline void set_gameservername(const ::std::string& value);
  inline void set_gameservername(const char* value);
  inline void set_gameservername(const char* value, size_t size);
  inline ::std::string* mutable_gameservername();
  inline ::std::string* release_gameservername();
  inline void set_allocated_gameservername(::std::string* gameservername);

  // @@protoc_insertion_point(class_scope:fgame.CSLoginReq)
 private:
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_params();
  inline void clear_has_params();
  inline void set_has_secretkey();
  inline void clear_has_secretkey();
  inline void set_has_gameservername();
  inline void clear_has_gameservername();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* openid_;
  ::std::string* token_;
  ::std::string* params_;
  ::std::string* secretkey_;
  ::std::string* gameservername_;
  ::google::protobuf::uint32 channelid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Base_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Base_2eproto();
  #endif
  friend void protobuf_AssignDesc_Base_2eproto();
  friend void protobuf_ShutdownFile_Base_2eproto();

  void InitAsDefaultInstance();
  static CSLoginReq* default_instance_;
};
// -------------------------------------------------------------------

class CSLoginResp : public ::google::protobuf::MessageLite {
 public:
  CSLoginResp();
  virtual ~CSLoginResp();

  CSLoginResp(const CSLoginResp& from);

  inline CSLoginResp& operator=(const CSLoginResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSLoginResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSLoginResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSLoginResp* other);

  // implements Message ----------------------------------------------

  CSLoginResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSLoginResp& from);
  void MergeFrom(const CSLoginResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // optional string GameServerAddr = 2;
  inline bool has_gameserveraddr() const;
  inline void clear_gameserveraddr();
  static const int kGameServerAddrFieldNumber = 2;
  inline const ::std::string& gameserveraddr() const;
  inline void set_gameserveraddr(const ::std::string& value);
  inline void set_gameserveraddr(const char* value);
  inline void set_gameserveraddr(const char* value, size_t size);
  inline ::std::string* mutable_gameserveraddr();
  inline ::std::string* release_gameserveraddr();
  inline void set_allocated_gameserveraddr(::std::string* gameserveraddr);

  // optional string OpenId = 3;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenIdFieldNumber = 3;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional string AuthToken = 4;
  inline bool has_authtoken() const;
  inline void clear_authtoken();
  static const int kAuthTokenFieldNumber = 4;
  inline const ::std::string& authtoken() const;
  inline void set_authtoken(const ::std::string& value);
  inline void set_authtoken(const char* value);
  inline void set_authtoken(const char* value, size_t size);
  inline ::std::string* mutable_authtoken();
  inline ::std::string* release_authtoken();
  inline void set_allocated_authtoken(::std::string* authtoken);

  // optional uint32 GrayRelease = 5;
  inline bool has_grayrelease() const;
  inline void clear_grayrelease();
  static const int kGrayReleaseFieldNumber = 5;
  inline ::google::protobuf::uint32 grayrelease() const;
  inline void set_grayrelease(::google::protobuf::uint32 value);

  // optional uint32 StopGameFlag = 6;
  inline bool has_stopgameflag() const;
  inline void clear_stopgameflag();
  static const int kStopGameFlagFieldNumber = 6;
  inline ::google::protobuf::uint32 stopgameflag() const;
  inline void set_stopgameflag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSLoginResp)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_gameserveraddr();
  inline void clear_has_gameserveraddr();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_authtoken();
  inline void clear_has_authtoken();
  inline void set_has_grayrelease();
  inline void clear_has_grayrelease();
  inline void set_has_stopgameflag();
  inline void clear_has_stopgameflag();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  ::std::string* gameserveraddr_;
  ::std::string* openid_;
  ::std::string* authtoken_;
  ::google::protobuf::uint32 grayrelease_;
  ::google::protobuf::uint32 stopgameflag_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Base_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Base_2eproto();
  #endif
  friend void protobuf_AssignDesc_Base_2eproto();
  friend void protobuf_ShutdownFile_Base_2eproto();

  void InitAsDefaultInstance();
  static CSLoginResp* default_instance_;
};
// -------------------------------------------------------------------

class CSLogoutReq : public ::google::protobuf::MessageLite {
 public:
  CSLogoutReq();
  virtual ~CSLogoutReq();

  CSLogoutReq(const CSLogoutReq& from);

  inline CSLogoutReq& operator=(const CSLogoutReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSLogoutReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSLogoutReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSLogoutReq* other);

  // implements Message ----------------------------------------------

  CSLogoutReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSLogoutReq& from);
  void MergeFrom(const CSLogoutReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:fgame.CSLogoutReq)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Base_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Base_2eproto();
  #endif
  friend void protobuf_AssignDesc_Base_2eproto();
  friend void protobuf_ShutdownFile_Base_2eproto();

  void InitAsDefaultInstance();
  static CSLogoutReq* default_instance_;
};
// -------------------------------------------------------------------

class CSRegReq : public ::google::protobuf::MessageLite {
 public:
  CSRegReq();
  virtual ~CSRegReq();

  CSRegReq(const CSRegReq& from);

  inline CSRegReq& operator=(const CSRegReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRegReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRegReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRegReq* other);

  // implements Message ----------------------------------------------

  CSRegReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRegReq& from);
  void MergeFrom(const CSRegReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // required string Pwd = 2;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 2;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  inline void set_allocated_pwd(::std::string* pwd);

  // @@protoc_insertion_point(class_scope:fgame.CSRegReq)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_pwd();
  inline void clear_has_pwd();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* account_;
  ::std::string* pwd_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Base_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Base_2eproto();
  #endif
  friend void protobuf_AssignDesc_Base_2eproto();
  friend void protobuf_ShutdownFile_Base_2eproto();

  void InitAsDefaultInstance();
  static CSRegReq* default_instance_;
};
// -------------------------------------------------------------------

class CSRegResp : public ::google::protobuf::MessageLite {
 public:
  CSRegResp();
  virtual ~CSRegResp();

  CSRegResp(const CSRegResp& from);

  inline CSRegResp& operator=(const CSRegResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRegResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRegResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRegResp* other);

  // implements Message ----------------------------------------------

  CSRegResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRegResp& from);
  void MergeFrom(const CSRegResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:fgame.CSRegResp)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Base_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Base_2eproto();
  #endif
  friend void protobuf_AssignDesc_Base_2eproto();
  friend void protobuf_ShutdownFile_Base_2eproto();

  void InitAsDefaultInstance();
  static CSRegResp* default_instance_;
};
// -------------------------------------------------------------------

class CSHeartBeatReq : public ::google::protobuf::MessageLite {
 public:
  CSHeartBeatReq();
  virtual ~CSHeartBeatReq();

  CSHeartBeatReq(const CSHeartBeatReq& from);

  inline CSHeartBeatReq& operator=(const CSHeartBeatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSHeartBeatReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSHeartBeatReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSHeartBeatReq* other);

  // implements Message ----------------------------------------------

  CSHeartBeatReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSHeartBeatReq& from);
  void MergeFrom(const CSHeartBeatReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSHeartBeatReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Base_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Base_2eproto();
  #endif
  friend void protobuf_AssignDesc_Base_2eproto();
  friend void protobuf_ShutdownFile_Base_2eproto();

  void InitAsDefaultInstance();
  static CSHeartBeatReq* default_instance_;
};
// -------------------------------------------------------------------

class CSKickPlayerReq : public ::google::protobuf::MessageLite {
 public:
  CSKickPlayerReq();
  virtual ~CSKickPlayerReq();

  CSKickPlayerReq(const CSKickPlayerReq& from);

  inline CSKickPlayerReq& operator=(const CSKickPlayerReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSKickPlayerReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSKickPlayerReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSKickPlayerReq* other);

  // implements Message ----------------------------------------------

  CSKickPlayerReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSKickPlayerReq& from);
  void MergeFrom(const CSKickPlayerReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSKickPlayerReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Base_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Base_2eproto();
  #endif
  friend void protobuf_AssignDesc_Base_2eproto();
  friend void protobuf_ShutdownFile_Base_2eproto();

  void InitAsDefaultInstance();
  static CSKickPlayerReq* default_instance_;
};
// -------------------------------------------------------------------

class CSStopKickPlayerReq : public ::google::protobuf::MessageLite {
 public:
  CSStopKickPlayerReq();
  virtual ~CSStopKickPlayerReq();

  CSStopKickPlayerReq(const CSStopKickPlayerReq& from);

  inline CSStopKickPlayerReq& operator=(const CSStopKickPlayerReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSStopKickPlayerReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSStopKickPlayerReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSStopKickPlayerReq* other);

  // implements Message ----------------------------------------------

  CSStopKickPlayerReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSStopKickPlayerReq& from);
  void MergeFrom(const CSStopKickPlayerReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSStopKickPlayerReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Base_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Base_2eproto();
  #endif
  friend void protobuf_AssignDesc_Base_2eproto();
  friend void protobuf_ShutdownFile_Base_2eproto();

  void InitAsDefaultInstance();
  static CSStopKickPlayerReq* default_instance_;
};
// -------------------------------------------------------------------

class CSHeartBeatResp : public ::google::protobuf::MessageLite {
 public:
  CSHeartBeatResp();
  virtual ~CSHeartBeatResp();

  CSHeartBeatResp(const CSHeartBeatResp& from);

  inline CSHeartBeatResp& operator=(const CSHeartBeatResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSHeartBeatResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSHeartBeatResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSHeartBeatResp* other);

  // implements Message ----------------------------------------------

  CSHeartBeatResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSHeartBeatResp& from);
  void MergeFrom(const CSHeartBeatResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // optional uint32 Ts = 2;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 2;
  inline ::google::protobuf::uint32 ts() const;
  inline void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSHeartBeatResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_ts();
  inline void clear_has_ts();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 ts_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Base_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Base_2eproto();
  #endif
  friend void protobuf_AssignDesc_Base_2eproto();
  friend void protobuf_ShutdownFile_Base_2eproto();

  void InitAsDefaultInstance();
  static CSHeartBeatResp* default_instance_;
};
// -------------------------------------------------------------------

class CSRequestPKeyReq : public ::google::protobuf::MessageLite {
 public:
  CSRequestPKeyReq();
  virtual ~CSRequestPKeyReq();

  CSRequestPKeyReq(const CSRequestPKeyReq& from);

  inline CSRequestPKeyReq& operator=(const CSRequestPKeyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRequestPKeyReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRequestPKeyReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRequestPKeyReq* other);

  // implements Message ----------------------------------------------

  CSRequestPKeyReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRequestPKeyReq& from);
  void MergeFrom(const CSRequestPKeyReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes dummy = 1;
  inline bool has_dummy() const;
  inline void clear_dummy();
  static const int kDummyFieldNumber = 1;
  inline const ::std::string& dummy() const;
  inline void set_dummy(const ::std::string& value);
  inline void set_dummy(const char* value);
  inline void set_dummy(const void* value, size_t size);
  inline ::std::string* mutable_dummy();
  inline ::std::string* release_dummy();
  inline void set_allocated_dummy(::std::string* dummy);

  // required int32 not_used = 2;
  inline bool has_not_used() const;
  inline void clear_not_used();
  static const int kNotUsedFieldNumber = 2;
  inline ::google::protobuf::int32 not_used() const;
  inline void set_not_used(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSRequestPKeyReq)
 private:
  inline void set_has_dummy();
  inline void clear_has_dummy();
  inline void set_has_not_used();
  inline void clear_has_not_used();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* dummy_;
  ::google::protobuf::int32 not_used_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Base_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Base_2eproto();
  #endif
  friend void protobuf_AssignDesc_Base_2eproto();
  friend void protobuf_ShutdownFile_Base_2eproto();

  void InitAsDefaultInstance();
  static CSRequestPKeyReq* default_instance_;
};
// -------------------------------------------------------------------

class CSRequestPKeyResp : public ::google::protobuf::MessageLite {
 public:
  CSRequestPKeyResp();
  virtual ~CSRequestPKeyResp();

  CSRequestPKeyResp(const CSRequestPKeyResp& from);

  inline CSRequestPKeyResp& operator=(const CSRequestPKeyResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRequestPKeyResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRequestPKeyResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRequestPKeyResp* other);

  // implements Message ----------------------------------------------

  CSRequestPKeyResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRequestPKeyResp& from);
  void MergeFrom(const CSRequestPKeyResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 pkey_id = 1;
  inline bool has_pkey_id() const;
  inline void clear_pkey_id();
  static const int kPkeyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 pkey_id() const;
  inline void set_pkey_id(::google::protobuf::uint32 value);

  // required string pkey = 2;
  inline bool has_pkey() const;
  inline void clear_pkey();
  static const int kPkeyFieldNumber = 2;
  inline const ::std::string& pkey() const;
  inline void set_pkey(const ::std::string& value);
  inline void set_pkey(const char* value);
  inline void set_pkey(const char* value, size_t size);
  inline ::std::string* mutable_pkey();
  inline ::std::string* release_pkey();
  inline void set_allocated_pkey(::std::string* pkey);

  // @@protoc_insertion_point(class_scope:fgame.CSRequestPKeyResp)
 private:
  inline void set_has_pkey_id();
  inline void clear_has_pkey_id();
  inline void set_has_pkey();
  inline void clear_has_pkey();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* pkey_;
  ::google::protobuf::uint32 pkey_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Base_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Base_2eproto();
  #endif
  friend void protobuf_AssignDesc_Base_2eproto();
  friend void protobuf_ShutdownFile_Base_2eproto();

  void InitAsDefaultInstance();
  static CSRequestPKeyResp* default_instance_;
};
// -------------------------------------------------------------------

class CSSendClientKeyReq : public ::google::protobuf::MessageLite {
 public:
  CSSendClientKeyReq();
  virtual ~CSSendClientKeyReq();

  CSSendClientKeyReq(const CSSendClientKeyReq& from);

  inline CSSendClientKeyReq& operator=(const CSSendClientKeyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSendClientKeyReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSendClientKeyReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSendClientKeyReq* other);

  // implements Message ----------------------------------------------

  CSSendClientKeyReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSendClientKeyReq& from);
  void MergeFrom(const CSSendClientKeyReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes client_key = 1;
  inline bool has_client_key() const;
  inline void clear_client_key();
  static const int kClientKeyFieldNumber = 1;
  inline const ::std::string& client_key() const;
  inline void set_client_key(const ::std::string& value);
  inline void set_client_key(const char* value);
  inline void set_client_key(const void* value, size_t size);
  inline ::std::string* mutable_client_key();
  inline ::std::string* release_client_key();
  inline void set_allocated_client_key(::std::string* client_key);

  // @@protoc_insertion_point(class_scope:fgame.CSSendClientKeyReq)
 private:
  inline void set_has_client_key();
  inline void clear_has_client_key();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_key_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Base_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Base_2eproto();
  #endif
  friend void protobuf_AssignDesc_Base_2eproto();
  friend void protobuf_ShutdownFile_Base_2eproto();

  void InitAsDefaultInstance();
  static CSSendClientKeyReq* default_instance_;
};
// -------------------------------------------------------------------

class CSSendClientKeyResp : public ::google::protobuf::MessageLite {
 public:
  CSSendClientKeyResp();
  virtual ~CSSendClientKeyResp();

  CSSendClientKeyResp(const CSSendClientKeyResp& from);

  inline CSSendClientKeyResp& operator=(const CSSendClientKeyResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSendClientKeyResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSendClientKeyResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSendClientKeyResp* other);

  // implements Message ----------------------------------------------

  CSSendClientKeyResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSendClientKeyResp& from);
  void MergeFrom(const CSSendClientKeyResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool ok = 1;
  inline bool has_ok() const;
  inline void clear_ok();
  static const int kOkFieldNumber = 1;
  inline bool ok() const;
  inline void set_ok(bool value);

  // required bytes s_key = 2;
  inline bool has_s_key() const;
  inline void clear_s_key();
  static const int kSKeyFieldNumber = 2;
  inline const ::std::string& s_key() const;
  inline void set_s_key(const ::std::string& value);
  inline void set_s_key(const char* value);
  inline void set_s_key(const void* value, size_t size);
  inline ::std::string* mutable_s_key();
  inline ::std::string* release_s_key();
  inline void set_allocated_s_key(::std::string* s_key);

  // required string payload = 3;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 3;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const char* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:fgame.CSSendClientKeyResp)
 private:
  inline void set_has_ok();
  inline void clear_has_ok();
  inline void set_has_s_key();
  inline void clear_has_s_key();
  inline void set_has_payload();
  inline void clear_has_payload();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* s_key_;
  ::std::string* payload_;
  bool ok_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Base_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Base_2eproto();
  #endif
  friend void protobuf_AssignDesc_Base_2eproto();
  friend void protobuf_ShutdownFile_Base_2eproto();

  void InitAsDefaultInstance();
  static CSSendClientKeyResp* default_instance_;
};
// ===================================================================


// ===================================================================

// CSErrorMsg

// required uint32 ErrCode = 1;
inline bool CSErrorMsg::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSErrorMsg::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSErrorMsg::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSErrorMsg::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 CSErrorMsg::errcode() const {
  // @@protoc_insertion_point(field_get:fgame.CSErrorMsg.ErrCode)
  return errcode_;
}
inline void CSErrorMsg::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSErrorMsg.ErrCode)
}

// -------------------------------------------------------------------

// CSLoginReq

// required string OpenId = 1;
inline bool CSLoginReq::has_openid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSLoginReq::set_has_openid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSLoginReq::clear_has_openid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSLoginReq::clear_openid() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& CSLoginReq::openid() const {
  // @@protoc_insertion_point(field_get:fgame.CSLoginReq.OpenId)
  return *openid_;
}
inline void CSLoginReq::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSLoginReq.OpenId)
}
inline void CSLoginReq::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSLoginReq.OpenId)
}
inline void CSLoginReq::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSLoginReq.OpenId)
}
inline ::std::string* CSLoginReq::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSLoginReq.OpenId)
  return openid_;
}
inline ::std::string* CSLoginReq::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSLoginReq::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSLoginReq.OpenId)
}

// required uint32 ChannelId = 2;
inline bool CSLoginReq::has_channelid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSLoginReq::set_has_channelid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSLoginReq::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSLoginReq::clear_channelid() {
  channelid_ = 0u;
  clear_has_channelid();
}
inline ::google::protobuf::uint32 CSLoginReq::channelid() const {
  // @@protoc_insertion_point(field_get:fgame.CSLoginReq.ChannelId)
  return channelid_;
}
inline void CSLoginReq::set_channelid(::google::protobuf::uint32 value) {
  set_has_channelid();
  channelid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSLoginReq.ChannelId)
}

// optional string Token = 3;
inline bool CSLoginReq::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSLoginReq::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSLoginReq::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSLoginReq::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CSLoginReq::token() const {
  // @@protoc_insertion_point(field_get:fgame.CSLoginReq.Token)
  return *token_;
}
inline void CSLoginReq::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSLoginReq.Token)
}
inline void CSLoginReq::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSLoginReq.Token)
}
inline void CSLoginReq::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSLoginReq.Token)
}
inline ::std::string* CSLoginReq::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSLoginReq.Token)
  return token_;
}
inline ::std::string* CSLoginReq::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSLoginReq::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSLoginReq.Token)
}

// optional string Params = 4;
inline bool CSLoginReq::has_params() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSLoginReq::set_has_params() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSLoginReq::clear_has_params() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSLoginReq::clear_params() {
  if (params_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    params_->clear();
  }
  clear_has_params();
}
inline const ::std::string& CSLoginReq::params() const {
  // @@protoc_insertion_point(field_get:fgame.CSLoginReq.Params)
  return *params_;
}
inline void CSLoginReq::set_params(const ::std::string& value) {
  set_has_params();
  if (params_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    params_ = new ::std::string;
  }
  params_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSLoginReq.Params)
}
inline void CSLoginReq::set_params(const char* value) {
  set_has_params();
  if (params_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    params_ = new ::std::string;
  }
  params_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSLoginReq.Params)
}
inline void CSLoginReq::set_params(const char* value, size_t size) {
  set_has_params();
  if (params_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    params_ = new ::std::string;
  }
  params_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSLoginReq.Params)
}
inline ::std::string* CSLoginReq::mutable_params() {
  set_has_params();
  if (params_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    params_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSLoginReq.Params)
  return params_;
}
inline ::std::string* CSLoginReq::release_params() {
  clear_has_params();
  if (params_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = params_;
    params_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSLoginReq::set_allocated_params(::std::string* params) {
  if (params_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete params_;
  }
  if (params) {
    set_has_params();
    params_ = params;
  } else {
    clear_has_params();
    params_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSLoginReq.Params)
}

// optional string SecretKey = 5;
inline bool CSLoginReq::has_secretkey() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSLoginReq::set_has_secretkey() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSLoginReq::clear_has_secretkey() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSLoginReq::clear_secretkey() {
  if (secretkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secretkey_->clear();
  }
  clear_has_secretkey();
}
inline const ::std::string& CSLoginReq::secretkey() const {
  // @@protoc_insertion_point(field_get:fgame.CSLoginReq.SecretKey)
  return *secretkey_;
}
inline void CSLoginReq::set_secretkey(const ::std::string& value) {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSLoginReq.SecretKey)
}
inline void CSLoginReq::set_secretkey(const char* value) {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSLoginReq.SecretKey)
}
inline void CSLoginReq::set_secretkey(const char* value, size_t size) {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSLoginReq.SecretKey)
}
inline ::std::string* CSLoginReq::mutable_secretkey() {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secretkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSLoginReq.SecretKey)
  return secretkey_;
}
inline ::std::string* CSLoginReq::release_secretkey() {
  clear_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = secretkey_;
    secretkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSLoginReq::set_allocated_secretkey(::std::string* secretkey) {
  if (secretkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete secretkey_;
  }
  if (secretkey) {
    set_has_secretkey();
    secretkey_ = secretkey;
  } else {
    clear_has_secretkey();
    secretkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSLoginReq.SecretKey)
}

// optional string GameServerName = 6;
inline bool CSLoginReq::has_gameservername() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSLoginReq::set_has_gameservername() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSLoginReq::clear_has_gameservername() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSLoginReq::clear_gameservername() {
  if (gameservername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_->clear();
  }
  clear_has_gameservername();
}
inline const ::std::string& CSLoginReq::gameservername() const {
  // @@protoc_insertion_point(field_get:fgame.CSLoginReq.GameServerName)
  return *gameservername_;
}
inline void CSLoginReq::set_gameservername(const ::std::string& value) {
  set_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_ = new ::std::string;
  }
  gameservername_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSLoginReq.GameServerName)
}
inline void CSLoginReq::set_gameservername(const char* value) {
  set_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_ = new ::std::string;
  }
  gameservername_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSLoginReq.GameServerName)
}
inline void CSLoginReq::set_gameservername(const char* value, size_t size) {
  set_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_ = new ::std::string;
  }
  gameservername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSLoginReq.GameServerName)
}
inline ::std::string* CSLoginReq::mutable_gameservername() {
  set_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSLoginReq.GameServerName)
  return gameservername_;
}
inline ::std::string* CSLoginReq::release_gameservername() {
  clear_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gameservername_;
    gameservername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSLoginReq::set_allocated_gameservername(::std::string* gameservername) {
  if (gameservername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gameservername_;
  }
  if (gameservername) {
    set_has_gameservername();
    gameservername_ = gameservername;
  } else {
    clear_has_gameservername();
    gameservername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSLoginReq.GameServerName)
}

// -------------------------------------------------------------------

// CSLoginResp

// required uint64 Uin = 1;
inline bool CSLoginResp::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSLoginResp::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSLoginResp::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSLoginResp::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSLoginResp::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSLoginResp.Uin)
  return uin_;
}
inline void CSLoginResp::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSLoginResp.Uin)
}

// optional string GameServerAddr = 2;
inline bool CSLoginResp::has_gameserveraddr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSLoginResp::set_has_gameserveraddr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSLoginResp::clear_has_gameserveraddr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSLoginResp::clear_gameserveraddr() {
  if (gameserveraddr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameserveraddr_->clear();
  }
  clear_has_gameserveraddr();
}
inline const ::std::string& CSLoginResp::gameserveraddr() const {
  // @@protoc_insertion_point(field_get:fgame.CSLoginResp.GameServerAddr)
  return *gameserveraddr_;
}
inline void CSLoginResp::set_gameserveraddr(const ::std::string& value) {
  set_has_gameserveraddr();
  if (gameserveraddr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameserveraddr_ = new ::std::string;
  }
  gameserveraddr_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSLoginResp.GameServerAddr)
}
inline void CSLoginResp::set_gameserveraddr(const char* value) {
  set_has_gameserveraddr();
  if (gameserveraddr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameserveraddr_ = new ::std::string;
  }
  gameserveraddr_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSLoginResp.GameServerAddr)
}
inline void CSLoginResp::set_gameserveraddr(const char* value, size_t size) {
  set_has_gameserveraddr();
  if (gameserveraddr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameserveraddr_ = new ::std::string;
  }
  gameserveraddr_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSLoginResp.GameServerAddr)
}
inline ::std::string* CSLoginResp::mutable_gameserveraddr() {
  set_has_gameserveraddr();
  if (gameserveraddr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameserveraddr_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSLoginResp.GameServerAddr)
  return gameserveraddr_;
}
inline ::std::string* CSLoginResp::release_gameserveraddr() {
  clear_has_gameserveraddr();
  if (gameserveraddr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gameserveraddr_;
    gameserveraddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSLoginResp::set_allocated_gameserveraddr(::std::string* gameserveraddr) {
  if (gameserveraddr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gameserveraddr_;
  }
  if (gameserveraddr) {
    set_has_gameserveraddr();
    gameserveraddr_ = gameserveraddr;
  } else {
    clear_has_gameserveraddr();
    gameserveraddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSLoginResp.GameServerAddr)
}

// optional string OpenId = 3;
inline bool CSLoginResp::has_openid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSLoginResp::set_has_openid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSLoginResp::clear_has_openid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSLoginResp::clear_openid() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& CSLoginResp::openid() const {
  // @@protoc_insertion_point(field_get:fgame.CSLoginResp.OpenId)
  return *openid_;
}
inline void CSLoginResp::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSLoginResp.OpenId)
}
inline void CSLoginResp::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSLoginResp.OpenId)
}
inline void CSLoginResp::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSLoginResp.OpenId)
}
inline ::std::string* CSLoginResp::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSLoginResp.OpenId)
  return openid_;
}
inline ::std::string* CSLoginResp::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSLoginResp::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSLoginResp.OpenId)
}

// optional string AuthToken = 4;
inline bool CSLoginResp::has_authtoken() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSLoginResp::set_has_authtoken() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSLoginResp::clear_has_authtoken() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSLoginResp::clear_authtoken() {
  if (authtoken_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authtoken_->clear();
  }
  clear_has_authtoken();
}
inline const ::std::string& CSLoginResp::authtoken() const {
  // @@protoc_insertion_point(field_get:fgame.CSLoginResp.AuthToken)
  return *authtoken_;
}
inline void CSLoginResp::set_authtoken(const ::std::string& value) {
  set_has_authtoken();
  if (authtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authtoken_ = new ::std::string;
  }
  authtoken_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSLoginResp.AuthToken)
}
inline void CSLoginResp::set_authtoken(const char* value) {
  set_has_authtoken();
  if (authtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authtoken_ = new ::std::string;
  }
  authtoken_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSLoginResp.AuthToken)
}
inline void CSLoginResp::set_authtoken(const char* value, size_t size) {
  set_has_authtoken();
  if (authtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authtoken_ = new ::std::string;
  }
  authtoken_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSLoginResp.AuthToken)
}
inline ::std::string* CSLoginResp::mutable_authtoken() {
  set_has_authtoken();
  if (authtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authtoken_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSLoginResp.AuthToken)
  return authtoken_;
}
inline ::std::string* CSLoginResp::release_authtoken() {
  clear_has_authtoken();
  if (authtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = authtoken_;
    authtoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSLoginResp::set_allocated_authtoken(::std::string* authtoken) {
  if (authtoken_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete authtoken_;
  }
  if (authtoken) {
    set_has_authtoken();
    authtoken_ = authtoken;
  } else {
    clear_has_authtoken();
    authtoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSLoginResp.AuthToken)
}

// optional uint32 GrayRelease = 5;
inline bool CSLoginResp::has_grayrelease() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSLoginResp::set_has_grayrelease() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSLoginResp::clear_has_grayrelease() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSLoginResp::clear_grayrelease() {
  grayrelease_ = 0u;
  clear_has_grayrelease();
}
inline ::google::protobuf::uint32 CSLoginResp::grayrelease() const {
  // @@protoc_insertion_point(field_get:fgame.CSLoginResp.GrayRelease)
  return grayrelease_;
}
inline void CSLoginResp::set_grayrelease(::google::protobuf::uint32 value) {
  set_has_grayrelease();
  grayrelease_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSLoginResp.GrayRelease)
}

// optional uint32 StopGameFlag = 6;
inline bool CSLoginResp::has_stopgameflag() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSLoginResp::set_has_stopgameflag() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSLoginResp::clear_has_stopgameflag() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSLoginResp::clear_stopgameflag() {
  stopgameflag_ = 0u;
  clear_has_stopgameflag();
}
inline ::google::protobuf::uint32 CSLoginResp::stopgameflag() const {
  // @@protoc_insertion_point(field_get:fgame.CSLoginResp.StopGameFlag)
  return stopgameflag_;
}
inline void CSLoginResp::set_stopgameflag(::google::protobuf::uint32 value) {
  set_has_stopgameflag();
  stopgameflag_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSLoginResp.StopGameFlag)
}

// -------------------------------------------------------------------

// CSLogoutReq

// required uint64 Uin = 1;
inline bool CSLogoutReq::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSLogoutReq::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSLogoutReq::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSLogoutReq::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSLogoutReq::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSLogoutReq.Uin)
  return uin_;
}
inline void CSLogoutReq::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSLogoutReq.Uin)
}

// -------------------------------------------------------------------

// CSRegReq

// required string Account = 1;
inline bool CSRegReq::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRegReq::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRegReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRegReq::clear_account() {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& CSRegReq::account() const {
  // @@protoc_insertion_point(field_get:fgame.CSRegReq.Account)
  return *account_;
}
inline void CSRegReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSRegReq.Account)
}
inline void CSRegReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSRegReq.Account)
}
inline void CSRegReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSRegReq.Account)
}
inline ::std::string* CSRegReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSRegReq.Account)
  return account_;
}
inline ::std::string* CSRegReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSRegReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSRegReq.Account)
}

// required string Pwd = 2;
inline bool CSRegReq::has_pwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRegReq::set_has_pwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRegReq::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRegReq::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& CSRegReq::pwd() const {
  // @@protoc_insertion_point(field_get:fgame.CSRegReq.Pwd)
  return *pwd_;
}
inline void CSRegReq::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSRegReq.Pwd)
}
inline void CSRegReq::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSRegReq.Pwd)
}
inline void CSRegReq::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSRegReq.Pwd)
}
inline ::std::string* CSRegReq::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSRegReq.Pwd)
  return pwd_;
}
inline ::std::string* CSRegReq::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSRegReq::set_allocated_pwd(::std::string* pwd) {
  if (pwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pwd_;
  }
  if (pwd) {
    set_has_pwd();
    pwd_ = pwd;
  } else {
    clear_has_pwd();
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSRegReq.Pwd)
}

// -------------------------------------------------------------------

// CSRegResp

// required uint64 Uin = 1;
inline bool CSRegResp::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRegResp::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRegResp::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRegResp::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSRegResp::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSRegResp.Uin)
  return uin_;
}
inline void CSRegResp::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRegResp.Uin)
}

// -------------------------------------------------------------------

// CSHeartBeatReq

// -------------------------------------------------------------------

// CSKickPlayerReq

// -------------------------------------------------------------------

// CSStopKickPlayerReq

// -------------------------------------------------------------------

// CSHeartBeatResp

// required uint32 Ret = 1;
inline bool CSHeartBeatResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSHeartBeatResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSHeartBeatResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSHeartBeatResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSHeartBeatResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSHeartBeatResp.Ret)
  return ret_;
}
inline void CSHeartBeatResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSHeartBeatResp.Ret)
}

// optional uint32 Ts = 2;
inline bool CSHeartBeatResp::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSHeartBeatResp::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSHeartBeatResp::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSHeartBeatResp::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 CSHeartBeatResp::ts() const {
  // @@protoc_insertion_point(field_get:fgame.CSHeartBeatResp.Ts)
  return ts_;
}
inline void CSHeartBeatResp::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSHeartBeatResp.Ts)
}

// -------------------------------------------------------------------

// CSRequestPKeyReq

// required bytes dummy = 1;
inline bool CSRequestPKeyReq::has_dummy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRequestPKeyReq::set_has_dummy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRequestPKeyReq::clear_has_dummy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRequestPKeyReq::clear_dummy() {
  if (dummy_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dummy_->clear();
  }
  clear_has_dummy();
}
inline const ::std::string& CSRequestPKeyReq::dummy() const {
  // @@protoc_insertion_point(field_get:fgame.CSRequestPKeyReq.dummy)
  return *dummy_;
}
inline void CSRequestPKeyReq::set_dummy(const ::std::string& value) {
  set_has_dummy();
  if (dummy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dummy_ = new ::std::string;
  }
  dummy_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSRequestPKeyReq.dummy)
}
inline void CSRequestPKeyReq::set_dummy(const char* value) {
  set_has_dummy();
  if (dummy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dummy_ = new ::std::string;
  }
  dummy_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSRequestPKeyReq.dummy)
}
inline void CSRequestPKeyReq::set_dummy(const void* value, size_t size) {
  set_has_dummy();
  if (dummy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dummy_ = new ::std::string;
  }
  dummy_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSRequestPKeyReq.dummy)
}
inline ::std::string* CSRequestPKeyReq::mutable_dummy() {
  set_has_dummy();
  if (dummy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dummy_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSRequestPKeyReq.dummy)
  return dummy_;
}
inline ::std::string* CSRequestPKeyReq::release_dummy() {
  clear_has_dummy();
  if (dummy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dummy_;
    dummy_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSRequestPKeyReq::set_allocated_dummy(::std::string* dummy) {
  if (dummy_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dummy_;
  }
  if (dummy) {
    set_has_dummy();
    dummy_ = dummy;
  } else {
    clear_has_dummy();
    dummy_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSRequestPKeyReq.dummy)
}

// required int32 not_used = 2;
inline bool CSRequestPKeyReq::has_not_used() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRequestPKeyReq::set_has_not_used() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRequestPKeyReq::clear_has_not_used() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRequestPKeyReq::clear_not_used() {
  not_used_ = 0;
  clear_has_not_used();
}
inline ::google::protobuf::int32 CSRequestPKeyReq::not_used() const {
  // @@protoc_insertion_point(field_get:fgame.CSRequestPKeyReq.not_used)
  return not_used_;
}
inline void CSRequestPKeyReq::set_not_used(::google::protobuf::int32 value) {
  set_has_not_used();
  not_used_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRequestPKeyReq.not_used)
}

// -------------------------------------------------------------------

// CSRequestPKeyResp

// required uint32 pkey_id = 1;
inline bool CSRequestPKeyResp::has_pkey_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRequestPKeyResp::set_has_pkey_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRequestPKeyResp::clear_has_pkey_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRequestPKeyResp::clear_pkey_id() {
  pkey_id_ = 0u;
  clear_has_pkey_id();
}
inline ::google::protobuf::uint32 CSRequestPKeyResp::pkey_id() const {
  // @@protoc_insertion_point(field_get:fgame.CSRequestPKeyResp.pkey_id)
  return pkey_id_;
}
inline void CSRequestPKeyResp::set_pkey_id(::google::protobuf::uint32 value) {
  set_has_pkey_id();
  pkey_id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRequestPKeyResp.pkey_id)
}

// required string pkey = 2;
inline bool CSRequestPKeyResp::has_pkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRequestPKeyResp::set_has_pkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRequestPKeyResp::clear_has_pkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRequestPKeyResp::clear_pkey() {
  if (pkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pkey_->clear();
  }
  clear_has_pkey();
}
inline const ::std::string& CSRequestPKeyResp::pkey() const {
  // @@protoc_insertion_point(field_get:fgame.CSRequestPKeyResp.pkey)
  return *pkey_;
}
inline void CSRequestPKeyResp::set_pkey(const ::std::string& value) {
  set_has_pkey();
  if (pkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pkey_ = new ::std::string;
  }
  pkey_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSRequestPKeyResp.pkey)
}
inline void CSRequestPKeyResp::set_pkey(const char* value) {
  set_has_pkey();
  if (pkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pkey_ = new ::std::string;
  }
  pkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSRequestPKeyResp.pkey)
}
inline void CSRequestPKeyResp::set_pkey(const char* value, size_t size) {
  set_has_pkey();
  if (pkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pkey_ = new ::std::string;
  }
  pkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSRequestPKeyResp.pkey)
}
inline ::std::string* CSRequestPKeyResp::mutable_pkey() {
  set_has_pkey();
  if (pkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSRequestPKeyResp.pkey)
  return pkey_;
}
inline ::std::string* CSRequestPKeyResp::release_pkey() {
  clear_has_pkey();
  if (pkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pkey_;
    pkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSRequestPKeyResp::set_allocated_pkey(::std::string* pkey) {
  if (pkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pkey_;
  }
  if (pkey) {
    set_has_pkey();
    pkey_ = pkey;
  } else {
    clear_has_pkey();
    pkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSRequestPKeyResp.pkey)
}

// -------------------------------------------------------------------

// CSSendClientKeyReq

// required bytes client_key = 1;
inline bool CSSendClientKeyReq::has_client_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSendClientKeyReq::set_has_client_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSendClientKeyReq::clear_has_client_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSendClientKeyReq::clear_client_key() {
  if (client_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_key_->clear();
  }
  clear_has_client_key();
}
inline const ::std::string& CSSendClientKeyReq::client_key() const {
  // @@protoc_insertion_point(field_get:fgame.CSSendClientKeyReq.client_key)
  return *client_key_;
}
inline void CSSendClientKeyReq::set_client_key(const ::std::string& value) {
  set_has_client_key();
  if (client_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_key_ = new ::std::string;
  }
  client_key_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSSendClientKeyReq.client_key)
}
inline void CSSendClientKeyReq::set_client_key(const char* value) {
  set_has_client_key();
  if (client_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_key_ = new ::std::string;
  }
  client_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSSendClientKeyReq.client_key)
}
inline void CSSendClientKeyReq::set_client_key(const void* value, size_t size) {
  set_has_client_key();
  if (client_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_key_ = new ::std::string;
  }
  client_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSSendClientKeyReq.client_key)
}
inline ::std::string* CSSendClientKeyReq::mutable_client_key() {
  set_has_client_key();
  if (client_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSSendClientKeyReq.client_key)
  return client_key_;
}
inline ::std::string* CSSendClientKeyReq::release_client_key() {
  clear_has_client_key();
  if (client_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_key_;
    client_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSSendClientKeyReq::set_allocated_client_key(::std::string* client_key) {
  if (client_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_key_;
  }
  if (client_key) {
    set_has_client_key();
    client_key_ = client_key;
  } else {
    clear_has_client_key();
    client_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSSendClientKeyReq.client_key)
}

// -------------------------------------------------------------------

// CSSendClientKeyResp

// required bool ok = 1;
inline bool CSSendClientKeyResp::has_ok() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSendClientKeyResp::set_has_ok() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSendClientKeyResp::clear_has_ok() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSendClientKeyResp::clear_ok() {
  ok_ = false;
  clear_has_ok();
}
inline bool CSSendClientKeyResp::ok() const {
  // @@protoc_insertion_point(field_get:fgame.CSSendClientKeyResp.ok)
  return ok_;
}
inline void CSSendClientKeyResp::set_ok(bool value) {
  set_has_ok();
  ok_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSendClientKeyResp.ok)
}

// required bytes s_key = 2;
inline bool CSSendClientKeyResp::has_s_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSSendClientKeyResp::set_has_s_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSSendClientKeyResp::clear_has_s_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSSendClientKeyResp::clear_s_key() {
  if (s_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_key_->clear();
  }
  clear_has_s_key();
}
inline const ::std::string& CSSendClientKeyResp::s_key() const {
  // @@protoc_insertion_point(field_get:fgame.CSSendClientKeyResp.s_key)
  return *s_key_;
}
inline void CSSendClientKeyResp::set_s_key(const ::std::string& value) {
  set_has_s_key();
  if (s_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_key_ = new ::std::string;
  }
  s_key_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSSendClientKeyResp.s_key)
}
inline void CSSendClientKeyResp::set_s_key(const char* value) {
  set_has_s_key();
  if (s_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_key_ = new ::std::string;
  }
  s_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSSendClientKeyResp.s_key)
}
inline void CSSendClientKeyResp::set_s_key(const void* value, size_t size) {
  set_has_s_key();
  if (s_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_key_ = new ::std::string;
  }
  s_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSSendClientKeyResp.s_key)
}
inline ::std::string* CSSendClientKeyResp::mutable_s_key() {
  set_has_s_key();
  if (s_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSSendClientKeyResp.s_key)
  return s_key_;
}
inline ::std::string* CSSendClientKeyResp::release_s_key() {
  clear_has_s_key();
  if (s_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_key_;
    s_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSSendClientKeyResp::set_allocated_s_key(::std::string* s_key) {
  if (s_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_key_;
  }
  if (s_key) {
    set_has_s_key();
    s_key_ = s_key;
  } else {
    clear_has_s_key();
    s_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSSendClientKeyResp.s_key)
}

// required string payload = 3;
inline bool CSSendClientKeyResp::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSSendClientKeyResp::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSSendClientKeyResp::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSSendClientKeyResp::clear_payload() {
  if (payload_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& CSSendClientKeyResp::payload() const {
  // @@protoc_insertion_point(field_get:fgame.CSSendClientKeyResp.payload)
  return *payload_;
}
inline void CSSendClientKeyResp::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSSendClientKeyResp.payload)
}
inline void CSSendClientKeyResp::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSSendClientKeyResp.payload)
}
inline void CSSendClientKeyResp::set_payload(const char* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSSendClientKeyResp.payload)
}
inline ::std::string* CSSendClientKeyResp::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSSendClientKeyResp.payload)
  return payload_;
}
inline ::std::string* CSSendClientKeyResp::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSSendClientKeyResp::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSSendClientKeyResp.payload)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fgame

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Base_2eproto__INCLUDED
