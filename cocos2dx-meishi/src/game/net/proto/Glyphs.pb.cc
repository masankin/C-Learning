// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Glyphs.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Glyphs.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace fgame {

void protobuf_ShutdownFile_Glyphs_2eproto() {
  delete CSGlyphsRequestInfoReq::default_instance_;
  delete GlyphInfo::default_instance_;
  delete CSGlyphsRequestInfoResp::default_instance_;
  delete CSGlyphsRequestBasicInfoReq::default_instance_;
  delete StuffInfo::default_instance_;
  delete CSGlyphsRequestBasicInfoResp::default_instance_;
  delete CSGlyphsActiveReq::default_instance_;
  delete CSGlyphsActiveResp::default_instance_;
  delete CSGlyphsUpgradeReq::default_instance_;
  delete CSGlyphsUpgradeResp::default_instance_;
  delete PvpGlyphData::default_instance_;
  delete PvpGlyphPlayer::default_instance_;
  delete CSGlyphsPvpInfoReq::default_instance_;
  delete CSGlyphsPvpInfoResp::default_instance_;
  delete CSNotifyGlyphsUpdateReq::default_instance_;
  delete CSNotifyGlyphsUpdateResp::default_instance_;
  delete CSGlyphGuideReq::default_instance_;
  delete CSGlyphGuideResp::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_Glyphs_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_Glyphs_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  CSGlyphsRequestInfoReq::default_instance_ = new CSGlyphsRequestInfoReq();
  GlyphInfo::default_instance_ = new GlyphInfo();
  CSGlyphsRequestInfoResp::default_instance_ = new CSGlyphsRequestInfoResp();
  CSGlyphsRequestBasicInfoReq::default_instance_ = new CSGlyphsRequestBasicInfoReq();
  StuffInfo::default_instance_ = new StuffInfo();
  CSGlyphsRequestBasicInfoResp::default_instance_ = new CSGlyphsRequestBasicInfoResp();
  CSGlyphsActiveReq::default_instance_ = new CSGlyphsActiveReq();
  CSGlyphsActiveResp::default_instance_ = new CSGlyphsActiveResp();
  CSGlyphsUpgradeReq::default_instance_ = new CSGlyphsUpgradeReq();
  CSGlyphsUpgradeResp::default_instance_ = new CSGlyphsUpgradeResp();
  PvpGlyphData::default_instance_ = new PvpGlyphData();
  PvpGlyphPlayer::default_instance_ = new PvpGlyphPlayer();
  CSGlyphsPvpInfoReq::default_instance_ = new CSGlyphsPvpInfoReq();
  CSGlyphsPvpInfoResp::default_instance_ = new CSGlyphsPvpInfoResp();
  CSNotifyGlyphsUpdateReq::default_instance_ = new CSNotifyGlyphsUpdateReq();
  CSNotifyGlyphsUpdateResp::default_instance_ = new CSNotifyGlyphsUpdateResp();
  CSGlyphGuideReq::default_instance_ = new CSGlyphGuideReq();
  CSGlyphGuideResp::default_instance_ = new CSGlyphGuideResp();
  CSGlyphsRequestInfoReq::default_instance_->InitAsDefaultInstance();
  GlyphInfo::default_instance_->InitAsDefaultInstance();
  CSGlyphsRequestInfoResp::default_instance_->InitAsDefaultInstance();
  CSGlyphsRequestBasicInfoReq::default_instance_->InitAsDefaultInstance();
  StuffInfo::default_instance_->InitAsDefaultInstance();
  CSGlyphsRequestBasicInfoResp::default_instance_->InitAsDefaultInstance();
  CSGlyphsActiveReq::default_instance_->InitAsDefaultInstance();
  CSGlyphsActiveResp::default_instance_->InitAsDefaultInstance();
  CSGlyphsUpgradeReq::default_instance_->InitAsDefaultInstance();
  CSGlyphsUpgradeResp::default_instance_->InitAsDefaultInstance();
  PvpGlyphData::default_instance_->InitAsDefaultInstance();
  PvpGlyphPlayer::default_instance_->InitAsDefaultInstance();
  CSGlyphsPvpInfoReq::default_instance_->InitAsDefaultInstance();
  CSGlyphsPvpInfoResp::default_instance_->InitAsDefaultInstance();
  CSNotifyGlyphsUpdateReq::default_instance_->InitAsDefaultInstance();
  CSNotifyGlyphsUpdateResp::default_instance_->InitAsDefaultInstance();
  CSGlyphGuideReq::default_instance_->InitAsDefaultInstance();
  CSGlyphGuideResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Glyphs_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_Glyphs_2eproto_once_);
void protobuf_AddDesc_Glyphs_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_Glyphs_2eproto_once_,
                 &protobuf_AddDesc_Glyphs_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Glyphs_2eproto {
  StaticDescriptorInitializer_Glyphs_2eproto() {
    protobuf_AddDesc_Glyphs_2eproto();
  }
} static_descriptor_initializer_Glyphs_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSGlyphsRequestInfoReq::CSGlyphsRequestInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGlyphsRequestInfoReq)
}

void CSGlyphsRequestInfoReq::InitAsDefaultInstance() {
}

CSGlyphsRequestInfoReq::CSGlyphsRequestInfoReq(const CSGlyphsRequestInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGlyphsRequestInfoReq)
}

void CSGlyphsRequestInfoReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGlyphsRequestInfoReq::~CSGlyphsRequestInfoReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGlyphsRequestInfoReq)
  SharedDtor();
}

void CSGlyphsRequestInfoReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGlyphsRequestInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGlyphsRequestInfoReq& CSGlyphsRequestInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Glyphs_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Glyphs_2eproto();
#endif
  return *default_instance_;
}

CSGlyphsRequestInfoReq* CSGlyphsRequestInfoReq::default_instance_ = NULL;

CSGlyphsRequestInfoReq* CSGlyphsRequestInfoReq::New() const {
  return new CSGlyphsRequestInfoReq;
}

void CSGlyphsRequestInfoReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGlyphsRequestInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGlyphsRequestInfoReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGlyphsRequestInfoReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGlyphsRequestInfoReq)
  return false;
#undef DO_
}

void CSGlyphsRequestInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGlyphsRequestInfoReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGlyphsRequestInfoReq)
}

int CSGlyphsRequestInfoReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGlyphsRequestInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGlyphsRequestInfoReq*>(&from));
}

void CSGlyphsRequestInfoReq::MergeFrom(const CSGlyphsRequestInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGlyphsRequestInfoReq::CopyFrom(const CSGlyphsRequestInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGlyphsRequestInfoReq::IsInitialized() const {

  return true;
}

void CSGlyphsRequestInfoReq::Swap(CSGlyphsRequestInfoReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGlyphsRequestInfoReq::GetTypeName() const {
  return "fgame.CSGlyphsRequestInfoReq";
}


// ===================================================================

bool GlyphInfo_Status_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GlyphInfo_Status GlyphInfo::NotOpen;
const GlyphInfo_Status GlyphInfo::CanActive;
const GlyphInfo_Status GlyphInfo::Active;
const GlyphInfo_Status GlyphInfo::LevelCan;
const GlyphInfo_Status GlyphInfo::VipCan;
const GlyphInfo_Status GlyphInfo::VipNot;
const GlyphInfo_Status GlyphInfo::Status_MIN;
const GlyphInfo_Status GlyphInfo::Status_MAX;
const int GlyphInfo::Status_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GlyphInfo::kGlyphIDFieldNumber;
const int GlyphInfo::kLevelFieldNumber;
const int GlyphInfo::kStatusFieldNumber;
#endif  // !_MSC_VER

GlyphInfo::GlyphInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.GlyphInfo)
}

void GlyphInfo::InitAsDefaultInstance() {
}

GlyphInfo::GlyphInfo(const GlyphInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.GlyphInfo)
}

void GlyphInfo::SharedCtor() {
  _cached_size_ = 0;
  glyphid_ = 0;
  level_ = 0;
  status_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GlyphInfo::~GlyphInfo() {
  // @@protoc_insertion_point(destructor:fgame.GlyphInfo)
  SharedDtor();
}

void GlyphInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GlyphInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GlyphInfo& GlyphInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Glyphs_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Glyphs_2eproto();
#endif
  return *default_instance_;
}

GlyphInfo* GlyphInfo::default_instance_ = NULL;

GlyphInfo* GlyphInfo::New() const {
  return new GlyphInfo;
}

void GlyphInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GlyphInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(glyphid_, level_);
    status_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GlyphInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.GlyphInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 glyphID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &glyphid_)));
          set_has_glyphid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_level;
        break;
      }

      // required int32 level = 2;
      case 2: {
        if (tag == 16) {
         parse_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_status;
        break;
      }

      // required .fgame.GlyphInfo.Status status = 3;
      case 3: {
        if (tag == 24) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::fgame::GlyphInfo_Status_IsValid(value)) {
            set_status(static_cast< ::fgame::GlyphInfo_Status >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.GlyphInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.GlyphInfo)
  return false;
#undef DO_
}

void GlyphInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.GlyphInfo)
  // required int32 glyphID = 1;
  if (has_glyphid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->glyphid(), output);
  }

  // required int32 level = 2;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->level(), output);
  }

  // required .fgame.GlyphInfo.Status status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->status(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.GlyphInfo)
}

int GlyphInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 glyphID = 1;
    if (has_glyphid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->glyphid());
    }

    // required int32 level = 2;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->level());
    }

    // required .fgame.GlyphInfo.Status status = 3;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GlyphInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GlyphInfo*>(&from));
}

void GlyphInfo::MergeFrom(const GlyphInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_glyphid()) {
      set_glyphid(from.glyphid());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GlyphInfo::CopyFrom(const GlyphInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlyphInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void GlyphInfo::Swap(GlyphInfo* other) {
  if (other != this) {
    std::swap(glyphid_, other->glyphid_);
    std::swap(level_, other->level_);
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GlyphInfo::GetTypeName() const {
  return "fgame.GlyphInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGlyphsRequestInfoResp::kGlyphDataFieldNumber;
#endif  // !_MSC_VER

CSGlyphsRequestInfoResp::CSGlyphsRequestInfoResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGlyphsRequestInfoResp)
}

void CSGlyphsRequestInfoResp::InitAsDefaultInstance() {
}

CSGlyphsRequestInfoResp::CSGlyphsRequestInfoResp(const CSGlyphsRequestInfoResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGlyphsRequestInfoResp)
}

void CSGlyphsRequestInfoResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGlyphsRequestInfoResp::~CSGlyphsRequestInfoResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGlyphsRequestInfoResp)
  SharedDtor();
}

void CSGlyphsRequestInfoResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGlyphsRequestInfoResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGlyphsRequestInfoResp& CSGlyphsRequestInfoResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Glyphs_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Glyphs_2eproto();
#endif
  return *default_instance_;
}

CSGlyphsRequestInfoResp* CSGlyphsRequestInfoResp::default_instance_ = NULL;

CSGlyphsRequestInfoResp* CSGlyphsRequestInfoResp::New() const {
  return new CSGlyphsRequestInfoResp;
}

void CSGlyphsRequestInfoResp::Clear() {
  glyphdata_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGlyphsRequestInfoResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGlyphsRequestInfoResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.GlyphInfo glyphData = 1;
      case 1: {
        if (tag == 10) {
         parse_glyphData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_glyphdata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_glyphData;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGlyphsRequestInfoResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGlyphsRequestInfoResp)
  return false;
#undef DO_
}

void CSGlyphsRequestInfoResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGlyphsRequestInfoResp)
  // repeated .fgame.GlyphInfo glyphData = 1;
  for (int i = 0; i < this->glyphdata_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->glyphdata(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGlyphsRequestInfoResp)
}

int CSGlyphsRequestInfoResp::ByteSize() const {
  int total_size = 0;

  // repeated .fgame.GlyphInfo glyphData = 1;
  total_size += 1 * this->glyphdata_size();
  for (int i = 0; i < this->glyphdata_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->glyphdata(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGlyphsRequestInfoResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGlyphsRequestInfoResp*>(&from));
}

void CSGlyphsRequestInfoResp::MergeFrom(const CSGlyphsRequestInfoResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  glyphdata_.MergeFrom(from.glyphdata_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGlyphsRequestInfoResp::CopyFrom(const CSGlyphsRequestInfoResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGlyphsRequestInfoResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->glyphdata())) return false;
  return true;
}

void CSGlyphsRequestInfoResp::Swap(CSGlyphsRequestInfoResp* other) {
  if (other != this) {
    glyphdata_.Swap(&other->glyphdata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGlyphsRequestInfoResp::GetTypeName() const {
  return "fgame.CSGlyphsRequestInfoResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSGlyphsRequestBasicInfoReq::CSGlyphsRequestBasicInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGlyphsRequestBasicInfoReq)
}

void CSGlyphsRequestBasicInfoReq::InitAsDefaultInstance() {
}

CSGlyphsRequestBasicInfoReq::CSGlyphsRequestBasicInfoReq(const CSGlyphsRequestBasicInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGlyphsRequestBasicInfoReq)
}

void CSGlyphsRequestBasicInfoReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGlyphsRequestBasicInfoReq::~CSGlyphsRequestBasicInfoReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGlyphsRequestBasicInfoReq)
  SharedDtor();
}

void CSGlyphsRequestBasicInfoReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGlyphsRequestBasicInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGlyphsRequestBasicInfoReq& CSGlyphsRequestBasicInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Glyphs_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Glyphs_2eproto();
#endif
  return *default_instance_;
}

CSGlyphsRequestBasicInfoReq* CSGlyphsRequestBasicInfoReq::default_instance_ = NULL;

CSGlyphsRequestBasicInfoReq* CSGlyphsRequestBasicInfoReq::New() const {
  return new CSGlyphsRequestBasicInfoReq;
}

void CSGlyphsRequestBasicInfoReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGlyphsRequestBasicInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGlyphsRequestBasicInfoReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGlyphsRequestBasicInfoReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGlyphsRequestBasicInfoReq)
  return false;
#undef DO_
}

void CSGlyphsRequestBasicInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGlyphsRequestBasicInfoReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGlyphsRequestBasicInfoReq)
}

int CSGlyphsRequestBasicInfoReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGlyphsRequestBasicInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGlyphsRequestBasicInfoReq*>(&from));
}

void CSGlyphsRequestBasicInfoReq::MergeFrom(const CSGlyphsRequestBasicInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGlyphsRequestBasicInfoReq::CopyFrom(const CSGlyphsRequestBasicInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGlyphsRequestBasicInfoReq::IsInitialized() const {

  return true;
}

void CSGlyphsRequestBasicInfoReq::Swap(CSGlyphsRequestBasicInfoReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGlyphsRequestBasicInfoReq::GetTypeName() const {
  return "fgame.CSGlyphsRequestBasicInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int StuffInfo::kStuffIDFieldNumber;
const int StuffInfo::kCountFieldNumber;
#endif  // !_MSC_VER

StuffInfo::StuffInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.StuffInfo)
}

void StuffInfo::InitAsDefaultInstance() {
}

StuffInfo::StuffInfo(const StuffInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.StuffInfo)
}

void StuffInfo::SharedCtor() {
  _cached_size_ = 0;
  stuffid_ = 0;
  count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StuffInfo::~StuffInfo() {
  // @@protoc_insertion_point(destructor:fgame.StuffInfo)
  SharedDtor();
}

void StuffInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StuffInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StuffInfo& StuffInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Glyphs_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Glyphs_2eproto();
#endif
  return *default_instance_;
}

StuffInfo* StuffInfo::default_instance_ = NULL;

StuffInfo* StuffInfo::New() const {
  return new StuffInfo;
}

void StuffInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<StuffInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(stuffid_, count_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool StuffInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.StuffInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 stuffID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &stuffid_)));
          set_has_stuffid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_count;
        break;
      }

      // required int32 count = 2;
      case 2: {
        if (tag == 16) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.StuffInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.StuffInfo)
  return false;
#undef DO_
}

void StuffInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.StuffInfo)
  // required int32 stuffID = 1;
  if (has_stuffid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->stuffid(), output);
  }

  // required int32 count = 2;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->count(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.StuffInfo)
}

int StuffInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 stuffID = 1;
    if (has_stuffid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->stuffid());
    }

    // required int32 count = 2;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StuffInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StuffInfo*>(&from));
}

void StuffInfo::MergeFrom(const StuffInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_stuffid()) {
      set_stuffid(from.stuffid());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void StuffInfo::CopyFrom(const StuffInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StuffInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void StuffInfo::Swap(StuffInfo* other) {
  if (other != this) {
    std::swap(stuffid_, other->stuffid_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StuffInfo::GetTypeName() const {
  return "fgame.StuffInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGlyphsRequestBasicInfoResp::kStuffInfoFieldNumber;
#endif  // !_MSC_VER

CSGlyphsRequestBasicInfoResp::CSGlyphsRequestBasicInfoResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGlyphsRequestBasicInfoResp)
}

void CSGlyphsRequestBasicInfoResp::InitAsDefaultInstance() {
}

CSGlyphsRequestBasicInfoResp::CSGlyphsRequestBasicInfoResp(const CSGlyphsRequestBasicInfoResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGlyphsRequestBasicInfoResp)
}

void CSGlyphsRequestBasicInfoResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGlyphsRequestBasicInfoResp::~CSGlyphsRequestBasicInfoResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGlyphsRequestBasicInfoResp)
  SharedDtor();
}

void CSGlyphsRequestBasicInfoResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGlyphsRequestBasicInfoResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGlyphsRequestBasicInfoResp& CSGlyphsRequestBasicInfoResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Glyphs_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Glyphs_2eproto();
#endif
  return *default_instance_;
}

CSGlyphsRequestBasicInfoResp* CSGlyphsRequestBasicInfoResp::default_instance_ = NULL;

CSGlyphsRequestBasicInfoResp* CSGlyphsRequestBasicInfoResp::New() const {
  return new CSGlyphsRequestBasicInfoResp;
}

void CSGlyphsRequestBasicInfoResp::Clear() {
  stuffinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGlyphsRequestBasicInfoResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGlyphsRequestBasicInfoResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.StuffInfo stuffInfo = 1;
      case 1: {
        if (tag == 10) {
         parse_stuffInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_stuffinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_stuffInfo;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGlyphsRequestBasicInfoResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGlyphsRequestBasicInfoResp)
  return false;
#undef DO_
}

void CSGlyphsRequestBasicInfoResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGlyphsRequestBasicInfoResp)
  // repeated .fgame.StuffInfo stuffInfo = 1;
  for (int i = 0; i < this->stuffinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->stuffinfo(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGlyphsRequestBasicInfoResp)
}

int CSGlyphsRequestBasicInfoResp::ByteSize() const {
  int total_size = 0;

  // repeated .fgame.StuffInfo stuffInfo = 1;
  total_size += 1 * this->stuffinfo_size();
  for (int i = 0; i < this->stuffinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->stuffinfo(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGlyphsRequestBasicInfoResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGlyphsRequestBasicInfoResp*>(&from));
}

void CSGlyphsRequestBasicInfoResp::MergeFrom(const CSGlyphsRequestBasicInfoResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  stuffinfo_.MergeFrom(from.stuffinfo_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGlyphsRequestBasicInfoResp::CopyFrom(const CSGlyphsRequestBasicInfoResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGlyphsRequestBasicInfoResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->stuffinfo())) return false;
  return true;
}

void CSGlyphsRequestBasicInfoResp::Swap(CSGlyphsRequestBasicInfoResp* other) {
  if (other != this) {
    stuffinfo_.Swap(&other->stuffinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGlyphsRequestBasicInfoResp::GetTypeName() const {
  return "fgame.CSGlyphsRequestBasicInfoResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGlyphsActiveReq::kGlyphIDFieldNumber;
#endif  // !_MSC_VER

CSGlyphsActiveReq::CSGlyphsActiveReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGlyphsActiveReq)
}

void CSGlyphsActiveReq::InitAsDefaultInstance() {
}

CSGlyphsActiveReq::CSGlyphsActiveReq(const CSGlyphsActiveReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGlyphsActiveReq)
}

void CSGlyphsActiveReq::SharedCtor() {
  _cached_size_ = 0;
  glyphid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGlyphsActiveReq::~CSGlyphsActiveReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGlyphsActiveReq)
  SharedDtor();
}

void CSGlyphsActiveReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGlyphsActiveReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGlyphsActiveReq& CSGlyphsActiveReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Glyphs_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Glyphs_2eproto();
#endif
  return *default_instance_;
}

CSGlyphsActiveReq* CSGlyphsActiveReq::default_instance_ = NULL;

CSGlyphsActiveReq* CSGlyphsActiveReq::New() const {
  return new CSGlyphsActiveReq;
}

void CSGlyphsActiveReq::Clear() {
  glyphid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGlyphsActiveReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGlyphsActiveReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 glyphID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &glyphid_)));
          set_has_glyphid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGlyphsActiveReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGlyphsActiveReq)
  return false;
#undef DO_
}

void CSGlyphsActiveReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGlyphsActiveReq)
  // required int32 glyphID = 1;
  if (has_glyphid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->glyphid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGlyphsActiveReq)
}

int CSGlyphsActiveReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 glyphID = 1;
    if (has_glyphid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->glyphid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGlyphsActiveReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGlyphsActiveReq*>(&from));
}

void CSGlyphsActiveReq::MergeFrom(const CSGlyphsActiveReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_glyphid()) {
      set_glyphid(from.glyphid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGlyphsActiveReq::CopyFrom(const CSGlyphsActiveReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGlyphsActiveReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSGlyphsActiveReq::Swap(CSGlyphsActiveReq* other) {
  if (other != this) {
    std::swap(glyphid_, other->glyphid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGlyphsActiveReq::GetTypeName() const {
  return "fgame.CSGlyphsActiveReq";
}


// ===================================================================

bool CSGlyphsActiveResp_Status_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const CSGlyphsActiveResp_Status CSGlyphsActiveResp::OK;
const CSGlyphsActiveResp_Status CSGlyphsActiveResp::FAILED_ACTIVE;
const CSGlyphsActiveResp_Status CSGlyphsActiveResp::FAILED_CANNOT_ACTIVE;
const CSGlyphsActiveResp_Status CSGlyphsActiveResp::FAILED_NO_STUFF;
const CSGlyphsActiveResp_Status CSGlyphsActiveResp::FAILED_INVALID_ID;
const CSGlyphsActiveResp_Status CSGlyphsActiveResp::FAILED_VIP;
const CSGlyphsActiveResp_Status CSGlyphsActiveResp::FAILED_NOT_OPEN;
const CSGlyphsActiveResp_Status CSGlyphsActiveResp::FAILED_ERROR;
const CSGlyphsActiveResp_Status CSGlyphsActiveResp::Status_MIN;
const CSGlyphsActiveResp_Status CSGlyphsActiveResp::Status_MAX;
const int CSGlyphsActiveResp::Status_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int CSGlyphsActiveResp::kGlyphIDFieldNumber;
const int CSGlyphsActiveResp::kStatusFieldNumber;
#endif  // !_MSC_VER

CSGlyphsActiveResp::CSGlyphsActiveResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGlyphsActiveResp)
}

void CSGlyphsActiveResp::InitAsDefaultInstance() {
}

CSGlyphsActiveResp::CSGlyphsActiveResp(const CSGlyphsActiveResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGlyphsActiveResp)
}

void CSGlyphsActiveResp::SharedCtor() {
  _cached_size_ = 0;
  glyphid_ = 0;
  status_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGlyphsActiveResp::~CSGlyphsActiveResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGlyphsActiveResp)
  SharedDtor();
}

void CSGlyphsActiveResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGlyphsActiveResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGlyphsActiveResp& CSGlyphsActiveResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Glyphs_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Glyphs_2eproto();
#endif
  return *default_instance_;
}

CSGlyphsActiveResp* CSGlyphsActiveResp::default_instance_ = NULL;

CSGlyphsActiveResp* CSGlyphsActiveResp::New() const {
  return new CSGlyphsActiveResp;
}

void CSGlyphsActiveResp::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    glyphid_ = 0;
    status_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGlyphsActiveResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGlyphsActiveResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 glyphID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &glyphid_)));
          set_has_glyphid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // required .fgame.CSGlyphsActiveResp.Status status = 2;
      case 2: {
        if (tag == 16) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::fgame::CSGlyphsActiveResp_Status_IsValid(value)) {
            set_status(static_cast< ::fgame::CSGlyphsActiveResp_Status >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGlyphsActiveResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGlyphsActiveResp)
  return false;
#undef DO_
}

void CSGlyphsActiveResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGlyphsActiveResp)
  // required int32 glyphID = 1;
  if (has_glyphid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->glyphid(), output);
  }

  // required .fgame.CSGlyphsActiveResp.Status status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGlyphsActiveResp)
}

int CSGlyphsActiveResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 glyphID = 1;
    if (has_glyphid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->glyphid());
    }

    // required .fgame.CSGlyphsActiveResp.Status status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGlyphsActiveResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGlyphsActiveResp*>(&from));
}

void CSGlyphsActiveResp::MergeFrom(const CSGlyphsActiveResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_glyphid()) {
      set_glyphid(from.glyphid());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGlyphsActiveResp::CopyFrom(const CSGlyphsActiveResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGlyphsActiveResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSGlyphsActiveResp::Swap(CSGlyphsActiveResp* other) {
  if (other != this) {
    std::swap(glyphid_, other->glyphid_);
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGlyphsActiveResp::GetTypeName() const {
  return "fgame.CSGlyphsActiveResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGlyphsUpgradeReq::kGlyphIDFieldNumber;
#endif  // !_MSC_VER

CSGlyphsUpgradeReq::CSGlyphsUpgradeReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGlyphsUpgradeReq)
}

void CSGlyphsUpgradeReq::InitAsDefaultInstance() {
}

CSGlyphsUpgradeReq::CSGlyphsUpgradeReq(const CSGlyphsUpgradeReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGlyphsUpgradeReq)
}

void CSGlyphsUpgradeReq::SharedCtor() {
  _cached_size_ = 0;
  glyphid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGlyphsUpgradeReq::~CSGlyphsUpgradeReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGlyphsUpgradeReq)
  SharedDtor();
}

void CSGlyphsUpgradeReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGlyphsUpgradeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGlyphsUpgradeReq& CSGlyphsUpgradeReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Glyphs_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Glyphs_2eproto();
#endif
  return *default_instance_;
}

CSGlyphsUpgradeReq* CSGlyphsUpgradeReq::default_instance_ = NULL;

CSGlyphsUpgradeReq* CSGlyphsUpgradeReq::New() const {
  return new CSGlyphsUpgradeReq;
}

void CSGlyphsUpgradeReq::Clear() {
  glyphid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGlyphsUpgradeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGlyphsUpgradeReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 glyphID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &glyphid_)));
          set_has_glyphid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGlyphsUpgradeReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGlyphsUpgradeReq)
  return false;
#undef DO_
}

void CSGlyphsUpgradeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGlyphsUpgradeReq)
  // required int32 glyphID = 1;
  if (has_glyphid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->glyphid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGlyphsUpgradeReq)
}

int CSGlyphsUpgradeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 glyphID = 1;
    if (has_glyphid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->glyphid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGlyphsUpgradeReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGlyphsUpgradeReq*>(&from));
}

void CSGlyphsUpgradeReq::MergeFrom(const CSGlyphsUpgradeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_glyphid()) {
      set_glyphid(from.glyphid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGlyphsUpgradeReq::CopyFrom(const CSGlyphsUpgradeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGlyphsUpgradeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSGlyphsUpgradeReq::Swap(CSGlyphsUpgradeReq* other) {
  if (other != this) {
    std::swap(glyphid_, other->glyphid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGlyphsUpgradeReq::GetTypeName() const {
  return "fgame.CSGlyphsUpgradeReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGlyphsUpgradeResp::kGlyphIDFieldNumber;
const int CSGlyphsUpgradeResp::kLevelFieldNumber;
const int CSGlyphsUpgradeResp::kIsOkFieldNumber;
#endif  // !_MSC_VER

CSGlyphsUpgradeResp::CSGlyphsUpgradeResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGlyphsUpgradeResp)
}

void CSGlyphsUpgradeResp::InitAsDefaultInstance() {
}

CSGlyphsUpgradeResp::CSGlyphsUpgradeResp(const CSGlyphsUpgradeResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGlyphsUpgradeResp)
}

void CSGlyphsUpgradeResp::SharedCtor() {
  _cached_size_ = 0;
  glyphid_ = 0;
  level_ = 0;
  is_ok_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGlyphsUpgradeResp::~CSGlyphsUpgradeResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGlyphsUpgradeResp)
  SharedDtor();
}

void CSGlyphsUpgradeResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGlyphsUpgradeResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGlyphsUpgradeResp& CSGlyphsUpgradeResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Glyphs_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Glyphs_2eproto();
#endif
  return *default_instance_;
}

CSGlyphsUpgradeResp* CSGlyphsUpgradeResp::default_instance_ = NULL;

CSGlyphsUpgradeResp* CSGlyphsUpgradeResp::New() const {
  return new CSGlyphsUpgradeResp;
}

void CSGlyphsUpgradeResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSGlyphsUpgradeResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(glyphid_, is_ok_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGlyphsUpgradeResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGlyphsUpgradeResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 glyphID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &glyphid_)));
          set_has_glyphid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_level;
        break;
      }

      // required int32 level = 2;
      case 2: {
        if (tag == 16) {
         parse_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_is_ok;
        break;
      }

      // required bool is_ok = 3;
      case 3: {
        if (tag == 24) {
         parse_is_ok:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_ok_)));
          set_has_is_ok();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGlyphsUpgradeResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGlyphsUpgradeResp)
  return false;
#undef DO_
}

void CSGlyphsUpgradeResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGlyphsUpgradeResp)
  // required int32 glyphID = 1;
  if (has_glyphid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->glyphid(), output);
  }

  // required int32 level = 2;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->level(), output);
  }

  // required bool is_ok = 3;
  if (has_is_ok()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->is_ok(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGlyphsUpgradeResp)
}

int CSGlyphsUpgradeResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 glyphID = 1;
    if (has_glyphid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->glyphid());
    }

    // required int32 level = 2;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->level());
    }

    // required bool is_ok = 3;
    if (has_is_ok()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGlyphsUpgradeResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGlyphsUpgradeResp*>(&from));
}

void CSGlyphsUpgradeResp::MergeFrom(const CSGlyphsUpgradeResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_glyphid()) {
      set_glyphid(from.glyphid());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_is_ok()) {
      set_is_ok(from.is_ok());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGlyphsUpgradeResp::CopyFrom(const CSGlyphsUpgradeResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGlyphsUpgradeResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSGlyphsUpgradeResp::Swap(CSGlyphsUpgradeResp* other) {
  if (other != this) {
    std::swap(glyphid_, other->glyphid_);
    std::swap(level_, other->level_);
    std::swap(is_ok_, other->is_ok_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGlyphsUpgradeResp::GetTypeName() const {
  return "fgame.CSGlyphsUpgradeResp";
}


// ===================================================================

#ifndef _MSC_VER
const int PvpGlyphData::kGlyphIDFieldNumber;
const int PvpGlyphData::kMainDataFieldNumber;
const int PvpGlyphData::kSideDataFieldNumber;
const int PvpGlyphData::kSoulFieldNumber;
const int PvpGlyphData::kBuildLevelFieldNumber;
const int PvpGlyphData::kGlyphLevelFieldNumber;
#endif  // !_MSC_VER

PvpGlyphData::PvpGlyphData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.PvpGlyphData)
}

void PvpGlyphData::InitAsDefaultInstance() {
}

PvpGlyphData::PvpGlyphData(const PvpGlyphData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.PvpGlyphData)
}

void PvpGlyphData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  glyphid_ = 0;
  maindata_ = 0;
  sidedata_ = 0;
  soul_ = 0;
  buildlevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  glyphlevel_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PvpGlyphData::~PvpGlyphData() {
  // @@protoc_insertion_point(destructor:fgame.PvpGlyphData)
  SharedDtor();
}

void PvpGlyphData::SharedDtor() {
  if (buildlevel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete buildlevel_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PvpGlyphData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PvpGlyphData& PvpGlyphData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Glyphs_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Glyphs_2eproto();
#endif
  return *default_instance_;
}

PvpGlyphData* PvpGlyphData::default_instance_ = NULL;

PvpGlyphData* PvpGlyphData::New() const {
  return new PvpGlyphData;
}

void PvpGlyphData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PvpGlyphData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(glyphid_, soul_);
    if (has_buildlevel()) {
      if (buildlevel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        buildlevel_->clear();
      }
    }
    glyphlevel_ = 0;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PvpGlyphData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.PvpGlyphData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 glyphID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &glyphid_)));
          set_has_glyphid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_mainData;
        break;
      }

      // required int32 mainData = 2;
      case 2: {
        if (tag == 16) {
         parse_mainData:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &maindata_)));
          set_has_maindata();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_sideData;
        break;
      }

      // required int32 sideData = 3;
      case 3: {
        if (tag == 24) {
         parse_sideData:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sidedata_)));
          set_has_sidedata();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_soul;
        break;
      }

      // required int32 soul = 4;
      case 4: {
        if (tag == 32) {
         parse_soul:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &soul_)));
          set_has_soul();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_buildLevel;
        break;
      }

      // required string buildLevel = 5;
      case 5: {
        if (tag == 42) {
         parse_buildLevel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buildlevel()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_glyphLevel;
        break;
      }

      // required int32 glyphLevel = 6;
      case 6: {
        if (tag == 48) {
         parse_glyphLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &glyphlevel_)));
          set_has_glyphlevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.PvpGlyphData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.PvpGlyphData)
  return false;
#undef DO_
}

void PvpGlyphData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.PvpGlyphData)
  // required int32 glyphID = 1;
  if (has_glyphid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->glyphid(), output);
  }

  // required int32 mainData = 2;
  if (has_maindata()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->maindata(), output);
  }

  // required int32 sideData = 3;
  if (has_sidedata()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->sidedata(), output);
  }

  // required int32 soul = 4;
  if (has_soul()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->soul(), output);
  }

  // required string buildLevel = 5;
  if (has_buildlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->buildlevel(), output);
  }

  // required int32 glyphLevel = 6;
  if (has_glyphlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->glyphlevel(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.PvpGlyphData)
}

int PvpGlyphData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 glyphID = 1;
    if (has_glyphid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->glyphid());
    }

    // required int32 mainData = 2;
    if (has_maindata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->maindata());
    }

    // required int32 sideData = 3;
    if (has_sidedata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sidedata());
    }

    // required int32 soul = 4;
    if (has_soul()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->soul());
    }

    // required string buildLevel = 5;
    if (has_buildlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buildlevel());
    }

    // required int32 glyphLevel = 6;
    if (has_glyphlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->glyphlevel());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PvpGlyphData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PvpGlyphData*>(&from));
}

void PvpGlyphData::MergeFrom(const PvpGlyphData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_glyphid()) {
      set_glyphid(from.glyphid());
    }
    if (from.has_maindata()) {
      set_maindata(from.maindata());
    }
    if (from.has_sidedata()) {
      set_sidedata(from.sidedata());
    }
    if (from.has_soul()) {
      set_soul(from.soul());
    }
    if (from.has_buildlevel()) {
      set_buildlevel(from.buildlevel());
    }
    if (from.has_glyphlevel()) {
      set_glyphlevel(from.glyphlevel());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PvpGlyphData::CopyFrom(const PvpGlyphData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PvpGlyphData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void PvpGlyphData::Swap(PvpGlyphData* other) {
  if (other != this) {
    std::swap(glyphid_, other->glyphid_);
    std::swap(maindata_, other->maindata_);
    std::swap(sidedata_, other->sidedata_);
    std::swap(soul_, other->soul_);
    std::swap(buildlevel_, other->buildlevel_);
    std::swap(glyphlevel_, other->glyphlevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PvpGlyphData::GetTypeName() const {
  return "fgame.PvpGlyphData";
}


// ===================================================================

#ifndef _MSC_VER
const int PvpGlyphPlayer::kCampIDFieldNumber;
const int PvpGlyphPlayer::kPvpGlyphDataFieldNumber;
#endif  // !_MSC_VER

PvpGlyphPlayer::PvpGlyphPlayer()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.PvpGlyphPlayer)
}

void PvpGlyphPlayer::InitAsDefaultInstance() {
}

PvpGlyphPlayer::PvpGlyphPlayer(const PvpGlyphPlayer& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.PvpGlyphPlayer)
}

void PvpGlyphPlayer::SharedCtor() {
  _cached_size_ = 0;
  campid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PvpGlyphPlayer::~PvpGlyphPlayer() {
  // @@protoc_insertion_point(destructor:fgame.PvpGlyphPlayer)
  SharedDtor();
}

void PvpGlyphPlayer::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PvpGlyphPlayer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PvpGlyphPlayer& PvpGlyphPlayer::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Glyphs_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Glyphs_2eproto();
#endif
  return *default_instance_;
}

PvpGlyphPlayer* PvpGlyphPlayer::default_instance_ = NULL;

PvpGlyphPlayer* PvpGlyphPlayer::New() const {
  return new PvpGlyphPlayer;
}

void PvpGlyphPlayer::Clear() {
  campid_ = 0;
  pvpglyphdata_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PvpGlyphPlayer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.PvpGlyphPlayer)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 campID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &campid_)));
          set_has_campid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pvpGlyphData;
        break;
      }

      // repeated .fgame.PvpGlyphData pvpGlyphData = 2;
      case 2: {
        if (tag == 18) {
         parse_pvpGlyphData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_pvpglyphdata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pvpGlyphData;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.PvpGlyphPlayer)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.PvpGlyphPlayer)
  return false;
#undef DO_
}

void PvpGlyphPlayer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.PvpGlyphPlayer)
  // required int32 campID = 1;
  if (has_campid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->campid(), output);
  }

  // repeated .fgame.PvpGlyphData pvpGlyphData = 2;
  for (int i = 0; i < this->pvpglyphdata_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->pvpglyphdata(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.PvpGlyphPlayer)
}

int PvpGlyphPlayer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 campID = 1;
    if (has_campid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->campid());
    }

  }
  // repeated .fgame.PvpGlyphData pvpGlyphData = 2;
  total_size += 1 * this->pvpglyphdata_size();
  for (int i = 0; i < this->pvpglyphdata_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pvpglyphdata(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PvpGlyphPlayer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PvpGlyphPlayer*>(&from));
}

void PvpGlyphPlayer::MergeFrom(const PvpGlyphPlayer& from) {
  GOOGLE_CHECK_NE(&from, this);
  pvpglyphdata_.MergeFrom(from.pvpglyphdata_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_campid()) {
      set_campid(from.campid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PvpGlyphPlayer::CopyFrom(const PvpGlyphPlayer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PvpGlyphPlayer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->pvpglyphdata())) return false;
  return true;
}

void PvpGlyphPlayer::Swap(PvpGlyphPlayer* other) {
  if (other != this) {
    std::swap(campid_, other->campid_);
    pvpglyphdata_.Swap(&other->pvpglyphdata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PvpGlyphPlayer::GetTypeName() const {
  return "fgame.PvpGlyphPlayer";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGlyphsPvpInfoReq::kRoomIdFieldNumber;
#endif  // !_MSC_VER

CSGlyphsPvpInfoReq::CSGlyphsPvpInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGlyphsPvpInfoReq)
}

void CSGlyphsPvpInfoReq::InitAsDefaultInstance() {
}

CSGlyphsPvpInfoReq::CSGlyphsPvpInfoReq(const CSGlyphsPvpInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGlyphsPvpInfoReq)
}

void CSGlyphsPvpInfoReq::SharedCtor() {
  _cached_size_ = 0;
  roomid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGlyphsPvpInfoReq::~CSGlyphsPvpInfoReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGlyphsPvpInfoReq)
  SharedDtor();
}

void CSGlyphsPvpInfoReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGlyphsPvpInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGlyphsPvpInfoReq& CSGlyphsPvpInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Glyphs_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Glyphs_2eproto();
#endif
  return *default_instance_;
}

CSGlyphsPvpInfoReq* CSGlyphsPvpInfoReq::default_instance_ = NULL;

CSGlyphsPvpInfoReq* CSGlyphsPvpInfoReq::New() const {
  return new CSGlyphsPvpInfoReq;
}

void CSGlyphsPvpInfoReq::Clear() {
  roomid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGlyphsPvpInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGlyphsPvpInfoReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 roomId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGlyphsPvpInfoReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGlyphsPvpInfoReq)
  return false;
#undef DO_
}

void CSGlyphsPvpInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGlyphsPvpInfoReq)
  // required uint32 roomId = 1;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->roomid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGlyphsPvpInfoReq)
}

int CSGlyphsPvpInfoReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 roomId = 1;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGlyphsPvpInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGlyphsPvpInfoReq*>(&from));
}

void CSGlyphsPvpInfoReq::MergeFrom(const CSGlyphsPvpInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGlyphsPvpInfoReq::CopyFrom(const CSGlyphsPvpInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGlyphsPvpInfoReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSGlyphsPvpInfoReq::Swap(CSGlyphsPvpInfoReq* other) {
  if (other != this) {
    std::swap(roomid_, other->roomid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGlyphsPvpInfoReq::GetTypeName() const {
  return "fgame.CSGlyphsPvpInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGlyphsPvpInfoResp::kPvpGlyphPlayerFieldNumber;
#endif  // !_MSC_VER

CSGlyphsPvpInfoResp::CSGlyphsPvpInfoResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGlyphsPvpInfoResp)
}

void CSGlyphsPvpInfoResp::InitAsDefaultInstance() {
}

CSGlyphsPvpInfoResp::CSGlyphsPvpInfoResp(const CSGlyphsPvpInfoResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGlyphsPvpInfoResp)
}

void CSGlyphsPvpInfoResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGlyphsPvpInfoResp::~CSGlyphsPvpInfoResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGlyphsPvpInfoResp)
  SharedDtor();
}

void CSGlyphsPvpInfoResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGlyphsPvpInfoResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGlyphsPvpInfoResp& CSGlyphsPvpInfoResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Glyphs_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Glyphs_2eproto();
#endif
  return *default_instance_;
}

CSGlyphsPvpInfoResp* CSGlyphsPvpInfoResp::default_instance_ = NULL;

CSGlyphsPvpInfoResp* CSGlyphsPvpInfoResp::New() const {
  return new CSGlyphsPvpInfoResp;
}

void CSGlyphsPvpInfoResp::Clear() {
  pvpglyphplayer_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGlyphsPvpInfoResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGlyphsPvpInfoResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.PvpGlyphPlayer pvpGlyphPlayer = 1;
      case 1: {
        if (tag == 10) {
         parse_pvpGlyphPlayer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_pvpglyphplayer()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_pvpGlyphPlayer;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGlyphsPvpInfoResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGlyphsPvpInfoResp)
  return false;
#undef DO_
}

void CSGlyphsPvpInfoResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGlyphsPvpInfoResp)
  // repeated .fgame.PvpGlyphPlayer pvpGlyphPlayer = 1;
  for (int i = 0; i < this->pvpglyphplayer_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->pvpglyphplayer(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGlyphsPvpInfoResp)
}

int CSGlyphsPvpInfoResp::ByteSize() const {
  int total_size = 0;

  // repeated .fgame.PvpGlyphPlayer pvpGlyphPlayer = 1;
  total_size += 1 * this->pvpglyphplayer_size();
  for (int i = 0; i < this->pvpglyphplayer_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pvpglyphplayer(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGlyphsPvpInfoResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGlyphsPvpInfoResp*>(&from));
}

void CSGlyphsPvpInfoResp::MergeFrom(const CSGlyphsPvpInfoResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  pvpglyphplayer_.MergeFrom(from.pvpglyphplayer_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGlyphsPvpInfoResp::CopyFrom(const CSGlyphsPvpInfoResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGlyphsPvpInfoResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->pvpglyphplayer())) return false;
  return true;
}

void CSGlyphsPvpInfoResp::Swap(CSGlyphsPvpInfoResp* other) {
  if (other != this) {
    pvpglyphplayer_.Swap(&other->pvpglyphplayer_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGlyphsPvpInfoResp::GetTypeName() const {
  return "fgame.CSGlyphsPvpInfoResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSNotifyGlyphsUpdateReq::CSNotifyGlyphsUpdateReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSNotifyGlyphsUpdateReq)
}

void CSNotifyGlyphsUpdateReq::InitAsDefaultInstance() {
}

CSNotifyGlyphsUpdateReq::CSNotifyGlyphsUpdateReq(const CSNotifyGlyphsUpdateReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSNotifyGlyphsUpdateReq)
}

void CSNotifyGlyphsUpdateReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSNotifyGlyphsUpdateReq::~CSNotifyGlyphsUpdateReq() {
  // @@protoc_insertion_point(destructor:fgame.CSNotifyGlyphsUpdateReq)
  SharedDtor();
}

void CSNotifyGlyphsUpdateReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSNotifyGlyphsUpdateReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSNotifyGlyphsUpdateReq& CSNotifyGlyphsUpdateReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Glyphs_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Glyphs_2eproto();
#endif
  return *default_instance_;
}

CSNotifyGlyphsUpdateReq* CSNotifyGlyphsUpdateReq::default_instance_ = NULL;

CSNotifyGlyphsUpdateReq* CSNotifyGlyphsUpdateReq::New() const {
  return new CSNotifyGlyphsUpdateReq;
}

void CSNotifyGlyphsUpdateReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSNotifyGlyphsUpdateReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSNotifyGlyphsUpdateReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSNotifyGlyphsUpdateReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSNotifyGlyphsUpdateReq)
  return false;
#undef DO_
}

void CSNotifyGlyphsUpdateReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSNotifyGlyphsUpdateReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSNotifyGlyphsUpdateReq)
}

int CSNotifyGlyphsUpdateReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSNotifyGlyphsUpdateReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSNotifyGlyphsUpdateReq*>(&from));
}

void CSNotifyGlyphsUpdateReq::MergeFrom(const CSNotifyGlyphsUpdateReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSNotifyGlyphsUpdateReq::CopyFrom(const CSNotifyGlyphsUpdateReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSNotifyGlyphsUpdateReq::IsInitialized() const {

  return true;
}

void CSNotifyGlyphsUpdateReq::Swap(CSNotifyGlyphsUpdateReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSNotifyGlyphsUpdateReq::GetTypeName() const {
  return "fgame.CSNotifyGlyphsUpdateReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSNotifyGlyphsUpdateResp::kHaveUpdateFieldNumber;
#endif  // !_MSC_VER

CSNotifyGlyphsUpdateResp::CSNotifyGlyphsUpdateResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSNotifyGlyphsUpdateResp)
}

void CSNotifyGlyphsUpdateResp::InitAsDefaultInstance() {
}

CSNotifyGlyphsUpdateResp::CSNotifyGlyphsUpdateResp(const CSNotifyGlyphsUpdateResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSNotifyGlyphsUpdateResp)
}

void CSNotifyGlyphsUpdateResp::SharedCtor() {
  _cached_size_ = 0;
  haveupdate_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSNotifyGlyphsUpdateResp::~CSNotifyGlyphsUpdateResp() {
  // @@protoc_insertion_point(destructor:fgame.CSNotifyGlyphsUpdateResp)
  SharedDtor();
}

void CSNotifyGlyphsUpdateResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSNotifyGlyphsUpdateResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSNotifyGlyphsUpdateResp& CSNotifyGlyphsUpdateResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Glyphs_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Glyphs_2eproto();
#endif
  return *default_instance_;
}

CSNotifyGlyphsUpdateResp* CSNotifyGlyphsUpdateResp::default_instance_ = NULL;

CSNotifyGlyphsUpdateResp* CSNotifyGlyphsUpdateResp::New() const {
  return new CSNotifyGlyphsUpdateResp;
}

void CSNotifyGlyphsUpdateResp::Clear() {
  haveupdate_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSNotifyGlyphsUpdateResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSNotifyGlyphsUpdateResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool HaveUpdate = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &haveupdate_)));
          set_has_haveupdate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSNotifyGlyphsUpdateResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSNotifyGlyphsUpdateResp)
  return false;
#undef DO_
}

void CSNotifyGlyphsUpdateResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSNotifyGlyphsUpdateResp)
  // required bool HaveUpdate = 1;
  if (has_haveupdate()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->haveupdate(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSNotifyGlyphsUpdateResp)
}

int CSNotifyGlyphsUpdateResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool HaveUpdate = 1;
    if (has_haveupdate()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSNotifyGlyphsUpdateResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSNotifyGlyphsUpdateResp*>(&from));
}

void CSNotifyGlyphsUpdateResp::MergeFrom(const CSNotifyGlyphsUpdateResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_haveupdate()) {
      set_haveupdate(from.haveupdate());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSNotifyGlyphsUpdateResp::CopyFrom(const CSNotifyGlyphsUpdateResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSNotifyGlyphsUpdateResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSNotifyGlyphsUpdateResp::Swap(CSNotifyGlyphsUpdateResp* other) {
  if (other != this) {
    std::swap(haveupdate_, other->haveupdate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSNotifyGlyphsUpdateResp::GetTypeName() const {
  return "fgame.CSNotifyGlyphsUpdateResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSGlyphGuideReq::CSGlyphGuideReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGlyphGuideReq)
}

void CSGlyphGuideReq::InitAsDefaultInstance() {
}

CSGlyphGuideReq::CSGlyphGuideReq(const CSGlyphGuideReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGlyphGuideReq)
}

void CSGlyphGuideReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGlyphGuideReq::~CSGlyphGuideReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGlyphGuideReq)
  SharedDtor();
}

void CSGlyphGuideReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGlyphGuideReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGlyphGuideReq& CSGlyphGuideReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Glyphs_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Glyphs_2eproto();
#endif
  return *default_instance_;
}

CSGlyphGuideReq* CSGlyphGuideReq::default_instance_ = NULL;

CSGlyphGuideReq* CSGlyphGuideReq::New() const {
  return new CSGlyphGuideReq;
}

void CSGlyphGuideReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGlyphGuideReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGlyphGuideReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGlyphGuideReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGlyphGuideReq)
  return false;
#undef DO_
}

void CSGlyphGuideReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGlyphGuideReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGlyphGuideReq)
}

int CSGlyphGuideReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGlyphGuideReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGlyphGuideReq*>(&from));
}

void CSGlyphGuideReq::MergeFrom(const CSGlyphGuideReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGlyphGuideReq::CopyFrom(const CSGlyphGuideReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGlyphGuideReq::IsInitialized() const {

  return true;
}

void CSGlyphGuideReq::Swap(CSGlyphGuideReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGlyphGuideReq::GetTypeName() const {
  return "fgame.CSGlyphGuideReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGlyphGuideResp::kRetFieldNumber;
const int CSGlyphGuideResp::kGiftIDFieldNumber;
#endif  // !_MSC_VER

CSGlyphGuideResp::CSGlyphGuideResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGlyphGuideResp)
}

void CSGlyphGuideResp::InitAsDefaultInstance() {
}

CSGlyphGuideResp::CSGlyphGuideResp(const CSGlyphGuideResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGlyphGuideResp)
}

void CSGlyphGuideResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  giftid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGlyphGuideResp::~CSGlyphGuideResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGlyphGuideResp)
  SharedDtor();
}

void CSGlyphGuideResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGlyphGuideResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGlyphGuideResp& CSGlyphGuideResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Glyphs_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Glyphs_2eproto();
#endif
  return *default_instance_;
}

CSGlyphGuideResp* CSGlyphGuideResp::default_instance_ = NULL;

CSGlyphGuideResp* CSGlyphGuideResp::New() const {
  return new CSGlyphGuideResp;
}

void CSGlyphGuideResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSGlyphGuideResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ret_, giftid_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGlyphGuideResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGlyphGuideResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_GiftID;
        break;
      }

      // required uint32 GiftID = 2;
      case 2: {
        if (tag == 16) {
         parse_GiftID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &giftid_)));
          set_has_giftid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGlyphGuideResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGlyphGuideResp)
  return false;
#undef DO_
}

void CSGlyphGuideResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGlyphGuideResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // required uint32 GiftID = 2;
  if (has_giftid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->giftid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGlyphGuideResp)
}

int CSGlyphGuideResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // required uint32 GiftID = 2;
    if (has_giftid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->giftid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGlyphGuideResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGlyphGuideResp*>(&from));
}

void CSGlyphGuideResp::MergeFrom(const CSGlyphGuideResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_giftid()) {
      set_giftid(from.giftid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGlyphGuideResp::CopyFrom(const CSGlyphGuideResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGlyphGuideResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSGlyphGuideResp::Swap(CSGlyphGuideResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(giftid_, other->giftid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGlyphGuideResp::GetTypeName() const {
  return "fgame.CSGlyphGuideResp";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fgame

// @@protoc_insertion_point(global_scope)
