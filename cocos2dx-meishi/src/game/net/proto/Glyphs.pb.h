// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Glyphs.proto

#ifndef PROTOBUF_Glyphs_2eproto__INCLUDED
#define PROTOBUF_Glyphs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace fgame {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Glyphs_2eproto();
void protobuf_AssignDesc_Glyphs_2eproto();
void protobuf_ShutdownFile_Glyphs_2eproto();

class CSGlyphsRequestInfoReq;
class GlyphInfo;
class CSGlyphsRequestInfoResp;
class CSGlyphsRequestBasicInfoReq;
class StuffInfo;
class CSGlyphsRequestBasicInfoResp;
class CSGlyphsActiveReq;
class CSGlyphsActiveResp;
class CSGlyphsUpgradeReq;
class CSGlyphsUpgradeResp;
class PvpGlyphData;
class PvpGlyphPlayer;
class CSGlyphsPvpInfoReq;
class CSGlyphsPvpInfoResp;
class CSNotifyGlyphsUpdateReq;
class CSNotifyGlyphsUpdateResp;
class CSGlyphGuideReq;
class CSGlyphGuideResp;

enum GlyphInfo_Status {
  GlyphInfo_Status_NotOpen = 1,
  GlyphInfo_Status_CanActive = 2,
  GlyphInfo_Status_Active = 3,
  GlyphInfo_Status_LevelCan = 4,
  GlyphInfo_Status_VipCan = 5,
  GlyphInfo_Status_VipNot = 6
};
bool GlyphInfo_Status_IsValid(int value);
const GlyphInfo_Status GlyphInfo_Status_Status_MIN = GlyphInfo_Status_NotOpen;
const GlyphInfo_Status GlyphInfo_Status_Status_MAX = GlyphInfo_Status_VipNot;
const int GlyphInfo_Status_Status_ARRAYSIZE = GlyphInfo_Status_Status_MAX + 1;

enum CSGlyphsActiveResp_Status {
  CSGlyphsActiveResp_Status_OK = 1,
  CSGlyphsActiveResp_Status_FAILED_ACTIVE = 2,
  CSGlyphsActiveResp_Status_FAILED_CANNOT_ACTIVE = 3,
  CSGlyphsActiveResp_Status_FAILED_NO_STUFF = 4,
  CSGlyphsActiveResp_Status_FAILED_INVALID_ID = 5,
  CSGlyphsActiveResp_Status_FAILED_VIP = 6,
  CSGlyphsActiveResp_Status_FAILED_NOT_OPEN = 7,
  CSGlyphsActiveResp_Status_FAILED_ERROR = 8
};
bool CSGlyphsActiveResp_Status_IsValid(int value);
const CSGlyphsActiveResp_Status CSGlyphsActiveResp_Status_Status_MIN = CSGlyphsActiveResp_Status_OK;
const CSGlyphsActiveResp_Status CSGlyphsActiveResp_Status_Status_MAX = CSGlyphsActiveResp_Status_FAILED_ERROR;
const int CSGlyphsActiveResp_Status_Status_ARRAYSIZE = CSGlyphsActiveResp_Status_Status_MAX + 1;

// ===================================================================

class CSGlyphsRequestInfoReq : public ::google::protobuf::MessageLite {
 public:
  CSGlyphsRequestInfoReq();
  virtual ~CSGlyphsRequestInfoReq();

  CSGlyphsRequestInfoReq(const CSGlyphsRequestInfoReq& from);

  inline CSGlyphsRequestInfoReq& operator=(const CSGlyphsRequestInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGlyphsRequestInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGlyphsRequestInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGlyphsRequestInfoReq* other);

  // implements Message ----------------------------------------------

  CSGlyphsRequestInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGlyphsRequestInfoReq& from);
  void MergeFrom(const CSGlyphsRequestInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSGlyphsRequestInfoReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Glyphs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Glyphs_2eproto();
  #endif
  friend void protobuf_AssignDesc_Glyphs_2eproto();
  friend void protobuf_ShutdownFile_Glyphs_2eproto();

  void InitAsDefaultInstance();
  static CSGlyphsRequestInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class GlyphInfo : public ::google::protobuf::MessageLite {
 public:
  GlyphInfo();
  virtual ~GlyphInfo();

  GlyphInfo(const GlyphInfo& from);

  inline GlyphInfo& operator=(const GlyphInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GlyphInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GlyphInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GlyphInfo* other);

  // implements Message ----------------------------------------------

  GlyphInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GlyphInfo& from);
  void MergeFrom(const GlyphInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GlyphInfo_Status Status;
  static const Status NotOpen = GlyphInfo_Status_NotOpen;
  static const Status CanActive = GlyphInfo_Status_CanActive;
  static const Status Active = GlyphInfo_Status_Active;
  static const Status LevelCan = GlyphInfo_Status_LevelCan;
  static const Status VipCan = GlyphInfo_Status_VipCan;
  static const Status VipNot = GlyphInfo_Status_VipNot;
  static inline bool Status_IsValid(int value) {
    return GlyphInfo_Status_IsValid(value);
  }
  static const Status Status_MIN =
    GlyphInfo_Status_Status_MIN;
  static const Status Status_MAX =
    GlyphInfo_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    GlyphInfo_Status_Status_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required int32 glyphID = 1;
  inline bool has_glyphid() const;
  inline void clear_glyphid();
  static const int kGlyphIDFieldNumber = 1;
  inline ::google::protobuf::int32 glyphid() const;
  inline void set_glyphid(::google::protobuf::int32 value);

  // required int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required .fgame.GlyphInfo.Status status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::fgame::GlyphInfo_Status status() const;
  inline void set_status(::fgame::GlyphInfo_Status value);

  // @@protoc_insertion_point(class_scope:fgame.GlyphInfo)
 private:
  inline void set_has_glyphid();
  inline void clear_has_glyphid();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_status();
  inline void clear_has_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 glyphid_;
  ::google::protobuf::int32 level_;
  int status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Glyphs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Glyphs_2eproto();
  #endif
  friend void protobuf_AssignDesc_Glyphs_2eproto();
  friend void protobuf_ShutdownFile_Glyphs_2eproto();

  void InitAsDefaultInstance();
  static GlyphInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSGlyphsRequestInfoResp : public ::google::protobuf::MessageLite {
 public:
  CSGlyphsRequestInfoResp();
  virtual ~CSGlyphsRequestInfoResp();

  CSGlyphsRequestInfoResp(const CSGlyphsRequestInfoResp& from);

  inline CSGlyphsRequestInfoResp& operator=(const CSGlyphsRequestInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGlyphsRequestInfoResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGlyphsRequestInfoResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGlyphsRequestInfoResp* other);

  // implements Message ----------------------------------------------

  CSGlyphsRequestInfoResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGlyphsRequestInfoResp& from);
  void MergeFrom(const CSGlyphsRequestInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.GlyphInfo glyphData = 1;
  inline int glyphdata_size() const;
  inline void clear_glyphdata();
  static const int kGlyphDataFieldNumber = 1;
  inline const ::fgame::GlyphInfo& glyphdata(int index) const;
  inline ::fgame::GlyphInfo* mutable_glyphdata(int index);
  inline ::fgame::GlyphInfo* add_glyphdata();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::GlyphInfo >&
      glyphdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::GlyphInfo >*
      mutable_glyphdata();

  // @@protoc_insertion_point(class_scope:fgame.CSGlyphsRequestInfoResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::GlyphInfo > glyphdata_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Glyphs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Glyphs_2eproto();
  #endif
  friend void protobuf_AssignDesc_Glyphs_2eproto();
  friend void protobuf_ShutdownFile_Glyphs_2eproto();

  void InitAsDefaultInstance();
  static CSGlyphsRequestInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class CSGlyphsRequestBasicInfoReq : public ::google::protobuf::MessageLite {
 public:
  CSGlyphsRequestBasicInfoReq();
  virtual ~CSGlyphsRequestBasicInfoReq();

  CSGlyphsRequestBasicInfoReq(const CSGlyphsRequestBasicInfoReq& from);

  inline CSGlyphsRequestBasicInfoReq& operator=(const CSGlyphsRequestBasicInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGlyphsRequestBasicInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGlyphsRequestBasicInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGlyphsRequestBasicInfoReq* other);

  // implements Message ----------------------------------------------

  CSGlyphsRequestBasicInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGlyphsRequestBasicInfoReq& from);
  void MergeFrom(const CSGlyphsRequestBasicInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSGlyphsRequestBasicInfoReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Glyphs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Glyphs_2eproto();
  #endif
  friend void protobuf_AssignDesc_Glyphs_2eproto();
  friend void protobuf_ShutdownFile_Glyphs_2eproto();

  void InitAsDefaultInstance();
  static CSGlyphsRequestBasicInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class StuffInfo : public ::google::protobuf::MessageLite {
 public:
  StuffInfo();
  virtual ~StuffInfo();

  StuffInfo(const StuffInfo& from);

  inline StuffInfo& operator=(const StuffInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StuffInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StuffInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StuffInfo* other);

  // implements Message ----------------------------------------------

  StuffInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StuffInfo& from);
  void MergeFrom(const StuffInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 stuffID = 1;
  inline bool has_stuffid() const;
  inline void clear_stuffid();
  static const int kStuffIDFieldNumber = 1;
  inline ::google::protobuf::int32 stuffid() const;
  inline void set_stuffid(::google::protobuf::int32 value);

  // required int32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fgame.StuffInfo)
 private:
  inline void set_has_stuffid();
  inline void clear_has_stuffid();
  inline void set_has_count();
  inline void clear_has_count();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 stuffid_;
  ::google::protobuf::int32 count_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Glyphs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Glyphs_2eproto();
  #endif
  friend void protobuf_AssignDesc_Glyphs_2eproto();
  friend void protobuf_ShutdownFile_Glyphs_2eproto();

  void InitAsDefaultInstance();
  static StuffInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSGlyphsRequestBasicInfoResp : public ::google::protobuf::MessageLite {
 public:
  CSGlyphsRequestBasicInfoResp();
  virtual ~CSGlyphsRequestBasicInfoResp();

  CSGlyphsRequestBasicInfoResp(const CSGlyphsRequestBasicInfoResp& from);

  inline CSGlyphsRequestBasicInfoResp& operator=(const CSGlyphsRequestBasicInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGlyphsRequestBasicInfoResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGlyphsRequestBasicInfoResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGlyphsRequestBasicInfoResp* other);

  // implements Message ----------------------------------------------

  CSGlyphsRequestBasicInfoResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGlyphsRequestBasicInfoResp& from);
  void MergeFrom(const CSGlyphsRequestBasicInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.StuffInfo stuffInfo = 1;
  inline int stuffinfo_size() const;
  inline void clear_stuffinfo();
  static const int kStuffInfoFieldNumber = 1;
  inline const ::fgame::StuffInfo& stuffinfo(int index) const;
  inline ::fgame::StuffInfo* mutable_stuffinfo(int index);
  inline ::fgame::StuffInfo* add_stuffinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::StuffInfo >&
      stuffinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::StuffInfo >*
      mutable_stuffinfo();

  // @@protoc_insertion_point(class_scope:fgame.CSGlyphsRequestBasicInfoResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::StuffInfo > stuffinfo_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Glyphs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Glyphs_2eproto();
  #endif
  friend void protobuf_AssignDesc_Glyphs_2eproto();
  friend void protobuf_ShutdownFile_Glyphs_2eproto();

  void InitAsDefaultInstance();
  static CSGlyphsRequestBasicInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class CSGlyphsActiveReq : public ::google::protobuf::MessageLite {
 public:
  CSGlyphsActiveReq();
  virtual ~CSGlyphsActiveReq();

  CSGlyphsActiveReq(const CSGlyphsActiveReq& from);

  inline CSGlyphsActiveReq& operator=(const CSGlyphsActiveReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGlyphsActiveReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGlyphsActiveReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGlyphsActiveReq* other);

  // implements Message ----------------------------------------------

  CSGlyphsActiveReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGlyphsActiveReq& from);
  void MergeFrom(const CSGlyphsActiveReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 glyphID = 1;
  inline bool has_glyphid() const;
  inline void clear_glyphid();
  static const int kGlyphIDFieldNumber = 1;
  inline ::google::protobuf::int32 glyphid() const;
  inline void set_glyphid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGlyphsActiveReq)
 private:
  inline void set_has_glyphid();
  inline void clear_has_glyphid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 glyphid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Glyphs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Glyphs_2eproto();
  #endif
  friend void protobuf_AssignDesc_Glyphs_2eproto();
  friend void protobuf_ShutdownFile_Glyphs_2eproto();

  void InitAsDefaultInstance();
  static CSGlyphsActiveReq* default_instance_;
};
// -------------------------------------------------------------------

class CSGlyphsActiveResp : public ::google::protobuf::MessageLite {
 public:
  CSGlyphsActiveResp();
  virtual ~CSGlyphsActiveResp();

  CSGlyphsActiveResp(const CSGlyphsActiveResp& from);

  inline CSGlyphsActiveResp& operator=(const CSGlyphsActiveResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGlyphsActiveResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGlyphsActiveResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGlyphsActiveResp* other);

  // implements Message ----------------------------------------------

  CSGlyphsActiveResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGlyphsActiveResp& from);
  void MergeFrom(const CSGlyphsActiveResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CSGlyphsActiveResp_Status Status;
  static const Status OK = CSGlyphsActiveResp_Status_OK;
  static const Status FAILED_ACTIVE = CSGlyphsActiveResp_Status_FAILED_ACTIVE;
  static const Status FAILED_CANNOT_ACTIVE = CSGlyphsActiveResp_Status_FAILED_CANNOT_ACTIVE;
  static const Status FAILED_NO_STUFF = CSGlyphsActiveResp_Status_FAILED_NO_STUFF;
  static const Status FAILED_INVALID_ID = CSGlyphsActiveResp_Status_FAILED_INVALID_ID;
  static const Status FAILED_VIP = CSGlyphsActiveResp_Status_FAILED_VIP;
  static const Status FAILED_NOT_OPEN = CSGlyphsActiveResp_Status_FAILED_NOT_OPEN;
  static const Status FAILED_ERROR = CSGlyphsActiveResp_Status_FAILED_ERROR;
  static inline bool Status_IsValid(int value) {
    return CSGlyphsActiveResp_Status_IsValid(value);
  }
  static const Status Status_MIN =
    CSGlyphsActiveResp_Status_Status_MIN;
  static const Status Status_MAX =
    CSGlyphsActiveResp_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    CSGlyphsActiveResp_Status_Status_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required int32 glyphID = 1;
  inline bool has_glyphid() const;
  inline void clear_glyphid();
  static const int kGlyphIDFieldNumber = 1;
  inline ::google::protobuf::int32 glyphid() const;
  inline void set_glyphid(::google::protobuf::int32 value);

  // required .fgame.CSGlyphsActiveResp.Status status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fgame::CSGlyphsActiveResp_Status status() const;
  inline void set_status(::fgame::CSGlyphsActiveResp_Status value);

  // @@protoc_insertion_point(class_scope:fgame.CSGlyphsActiveResp)
 private:
  inline void set_has_glyphid();
  inline void clear_has_glyphid();
  inline void set_has_status();
  inline void clear_has_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 glyphid_;
  int status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Glyphs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Glyphs_2eproto();
  #endif
  friend void protobuf_AssignDesc_Glyphs_2eproto();
  friend void protobuf_ShutdownFile_Glyphs_2eproto();

  void InitAsDefaultInstance();
  static CSGlyphsActiveResp* default_instance_;
};
// -------------------------------------------------------------------

class CSGlyphsUpgradeReq : public ::google::protobuf::MessageLite {
 public:
  CSGlyphsUpgradeReq();
  virtual ~CSGlyphsUpgradeReq();

  CSGlyphsUpgradeReq(const CSGlyphsUpgradeReq& from);

  inline CSGlyphsUpgradeReq& operator=(const CSGlyphsUpgradeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGlyphsUpgradeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGlyphsUpgradeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGlyphsUpgradeReq* other);

  // implements Message ----------------------------------------------

  CSGlyphsUpgradeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGlyphsUpgradeReq& from);
  void MergeFrom(const CSGlyphsUpgradeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 glyphID = 1;
  inline bool has_glyphid() const;
  inline void clear_glyphid();
  static const int kGlyphIDFieldNumber = 1;
  inline ::google::protobuf::int32 glyphid() const;
  inline void set_glyphid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGlyphsUpgradeReq)
 private:
  inline void set_has_glyphid();
  inline void clear_has_glyphid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 glyphid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Glyphs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Glyphs_2eproto();
  #endif
  friend void protobuf_AssignDesc_Glyphs_2eproto();
  friend void protobuf_ShutdownFile_Glyphs_2eproto();

  void InitAsDefaultInstance();
  static CSGlyphsUpgradeReq* default_instance_;
};
// -------------------------------------------------------------------

class CSGlyphsUpgradeResp : public ::google::protobuf::MessageLite {
 public:
  CSGlyphsUpgradeResp();
  virtual ~CSGlyphsUpgradeResp();

  CSGlyphsUpgradeResp(const CSGlyphsUpgradeResp& from);

  inline CSGlyphsUpgradeResp& operator=(const CSGlyphsUpgradeResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGlyphsUpgradeResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGlyphsUpgradeResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGlyphsUpgradeResp* other);

  // implements Message ----------------------------------------------

  CSGlyphsUpgradeResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGlyphsUpgradeResp& from);
  void MergeFrom(const CSGlyphsUpgradeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 glyphID = 1;
  inline bool has_glyphid() const;
  inline void clear_glyphid();
  static const int kGlyphIDFieldNumber = 1;
  inline ::google::protobuf::int32 glyphid() const;
  inline void set_glyphid(::google::protobuf::int32 value);

  // required int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required bool is_ok = 3;
  inline bool has_is_ok() const;
  inline void clear_is_ok();
  static const int kIsOkFieldNumber = 3;
  inline bool is_ok() const;
  inline void set_is_ok(bool value);

  // @@protoc_insertion_point(class_scope:fgame.CSGlyphsUpgradeResp)
 private:
  inline void set_has_glyphid();
  inline void clear_has_glyphid();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_is_ok();
  inline void clear_has_is_ok();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 glyphid_;
  ::google::protobuf::int32 level_;
  bool is_ok_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Glyphs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Glyphs_2eproto();
  #endif
  friend void protobuf_AssignDesc_Glyphs_2eproto();
  friend void protobuf_ShutdownFile_Glyphs_2eproto();

  void InitAsDefaultInstance();
  static CSGlyphsUpgradeResp* default_instance_;
};
// -------------------------------------------------------------------

class PvpGlyphData : public ::google::protobuf::MessageLite {
 public:
  PvpGlyphData();
  virtual ~PvpGlyphData();

  PvpGlyphData(const PvpGlyphData& from);

  inline PvpGlyphData& operator=(const PvpGlyphData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PvpGlyphData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PvpGlyphData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PvpGlyphData* other);

  // implements Message ----------------------------------------------

  PvpGlyphData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PvpGlyphData& from);
  void MergeFrom(const PvpGlyphData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 glyphID = 1;
  inline bool has_glyphid() const;
  inline void clear_glyphid();
  static const int kGlyphIDFieldNumber = 1;
  inline ::google::protobuf::int32 glyphid() const;
  inline void set_glyphid(::google::protobuf::int32 value);

  // required int32 mainData = 2;
  inline bool has_maindata() const;
  inline void clear_maindata();
  static const int kMainDataFieldNumber = 2;
  inline ::google::protobuf::int32 maindata() const;
  inline void set_maindata(::google::protobuf::int32 value);

  // required int32 sideData = 3;
  inline bool has_sidedata() const;
  inline void clear_sidedata();
  static const int kSideDataFieldNumber = 3;
  inline ::google::protobuf::int32 sidedata() const;
  inline void set_sidedata(::google::protobuf::int32 value);

  // required int32 soul = 4;
  inline bool has_soul() const;
  inline void clear_soul();
  static const int kSoulFieldNumber = 4;
  inline ::google::protobuf::int32 soul() const;
  inline void set_soul(::google::protobuf::int32 value);

  // required string buildLevel = 5;
  inline bool has_buildlevel() const;
  inline void clear_buildlevel();
  static const int kBuildLevelFieldNumber = 5;
  inline const ::std::string& buildlevel() const;
  inline void set_buildlevel(const ::std::string& value);
  inline void set_buildlevel(const char* value);
  inline void set_buildlevel(const char* value, size_t size);
  inline ::std::string* mutable_buildlevel();
  inline ::std::string* release_buildlevel();
  inline void set_allocated_buildlevel(::std::string* buildlevel);

  // required int32 glyphLevel = 6;
  inline bool has_glyphlevel() const;
  inline void clear_glyphlevel();
  static const int kGlyphLevelFieldNumber = 6;
  inline ::google::protobuf::int32 glyphlevel() const;
  inline void set_glyphlevel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fgame.PvpGlyphData)
 private:
  inline void set_has_glyphid();
  inline void clear_has_glyphid();
  inline void set_has_maindata();
  inline void clear_has_maindata();
  inline void set_has_sidedata();
  inline void clear_has_sidedata();
  inline void set_has_soul();
  inline void clear_has_soul();
  inline void set_has_buildlevel();
  inline void clear_has_buildlevel();
  inline void set_has_glyphlevel();
  inline void clear_has_glyphlevel();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 glyphid_;
  ::google::protobuf::int32 maindata_;
  ::google::protobuf::int32 sidedata_;
  ::google::protobuf::int32 soul_;
  ::std::string* buildlevel_;
  ::google::protobuf::int32 glyphlevel_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Glyphs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Glyphs_2eproto();
  #endif
  friend void protobuf_AssignDesc_Glyphs_2eproto();
  friend void protobuf_ShutdownFile_Glyphs_2eproto();

  void InitAsDefaultInstance();
  static PvpGlyphData* default_instance_;
};
// -------------------------------------------------------------------

class PvpGlyphPlayer : public ::google::protobuf::MessageLite {
 public:
  PvpGlyphPlayer();
  virtual ~PvpGlyphPlayer();

  PvpGlyphPlayer(const PvpGlyphPlayer& from);

  inline PvpGlyphPlayer& operator=(const PvpGlyphPlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PvpGlyphPlayer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PvpGlyphPlayer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PvpGlyphPlayer* other);

  // implements Message ----------------------------------------------

  PvpGlyphPlayer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PvpGlyphPlayer& from);
  void MergeFrom(const PvpGlyphPlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 campID = 1;
  inline bool has_campid() const;
  inline void clear_campid();
  static const int kCampIDFieldNumber = 1;
  inline ::google::protobuf::int32 campid() const;
  inline void set_campid(::google::protobuf::int32 value);

  // repeated .fgame.PvpGlyphData pvpGlyphData = 2;
  inline int pvpglyphdata_size() const;
  inline void clear_pvpglyphdata();
  static const int kPvpGlyphDataFieldNumber = 2;
  inline const ::fgame::PvpGlyphData& pvpglyphdata(int index) const;
  inline ::fgame::PvpGlyphData* mutable_pvpglyphdata(int index);
  inline ::fgame::PvpGlyphData* add_pvpglyphdata();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::PvpGlyphData >&
      pvpglyphdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::PvpGlyphData >*
      mutable_pvpglyphdata();

  // @@protoc_insertion_point(class_scope:fgame.PvpGlyphPlayer)
 private:
  inline void set_has_campid();
  inline void clear_has_campid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::PvpGlyphData > pvpglyphdata_;
  ::google::protobuf::int32 campid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Glyphs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Glyphs_2eproto();
  #endif
  friend void protobuf_AssignDesc_Glyphs_2eproto();
  friend void protobuf_ShutdownFile_Glyphs_2eproto();

  void InitAsDefaultInstance();
  static PvpGlyphPlayer* default_instance_;
};
// -------------------------------------------------------------------

class CSGlyphsPvpInfoReq : public ::google::protobuf::MessageLite {
 public:
  CSGlyphsPvpInfoReq();
  virtual ~CSGlyphsPvpInfoReq();

  CSGlyphsPvpInfoReq(const CSGlyphsPvpInfoReq& from);

  inline CSGlyphsPvpInfoReq& operator=(const CSGlyphsPvpInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGlyphsPvpInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGlyphsPvpInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGlyphsPvpInfoReq* other);

  // implements Message ----------------------------------------------

  CSGlyphsPvpInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGlyphsPvpInfoReq& from);
  void MergeFrom(const CSGlyphsPvpInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGlyphsPvpInfoReq)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 roomid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Glyphs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Glyphs_2eproto();
  #endif
  friend void protobuf_AssignDesc_Glyphs_2eproto();
  friend void protobuf_ShutdownFile_Glyphs_2eproto();

  void InitAsDefaultInstance();
  static CSGlyphsPvpInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class CSGlyphsPvpInfoResp : public ::google::protobuf::MessageLite {
 public:
  CSGlyphsPvpInfoResp();
  virtual ~CSGlyphsPvpInfoResp();

  CSGlyphsPvpInfoResp(const CSGlyphsPvpInfoResp& from);

  inline CSGlyphsPvpInfoResp& operator=(const CSGlyphsPvpInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGlyphsPvpInfoResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGlyphsPvpInfoResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGlyphsPvpInfoResp* other);

  // implements Message ----------------------------------------------

  CSGlyphsPvpInfoResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGlyphsPvpInfoResp& from);
  void MergeFrom(const CSGlyphsPvpInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.PvpGlyphPlayer pvpGlyphPlayer = 1;
  inline int pvpglyphplayer_size() const;
  inline void clear_pvpglyphplayer();
  static const int kPvpGlyphPlayerFieldNumber = 1;
  inline const ::fgame::PvpGlyphPlayer& pvpglyphplayer(int index) const;
  inline ::fgame::PvpGlyphPlayer* mutable_pvpglyphplayer(int index);
  inline ::fgame::PvpGlyphPlayer* add_pvpglyphplayer();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::PvpGlyphPlayer >&
      pvpglyphplayer() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::PvpGlyphPlayer >*
      mutable_pvpglyphplayer();

  // @@protoc_insertion_point(class_scope:fgame.CSGlyphsPvpInfoResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::PvpGlyphPlayer > pvpglyphplayer_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Glyphs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Glyphs_2eproto();
  #endif
  friend void protobuf_AssignDesc_Glyphs_2eproto();
  friend void protobuf_ShutdownFile_Glyphs_2eproto();

  void InitAsDefaultInstance();
  static CSGlyphsPvpInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class CSNotifyGlyphsUpdateReq : public ::google::protobuf::MessageLite {
 public:
  CSNotifyGlyphsUpdateReq();
  virtual ~CSNotifyGlyphsUpdateReq();

  CSNotifyGlyphsUpdateReq(const CSNotifyGlyphsUpdateReq& from);

  inline CSNotifyGlyphsUpdateReq& operator=(const CSNotifyGlyphsUpdateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSNotifyGlyphsUpdateReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSNotifyGlyphsUpdateReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSNotifyGlyphsUpdateReq* other);

  // implements Message ----------------------------------------------

  CSNotifyGlyphsUpdateReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSNotifyGlyphsUpdateReq& from);
  void MergeFrom(const CSNotifyGlyphsUpdateReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSNotifyGlyphsUpdateReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Glyphs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Glyphs_2eproto();
  #endif
  friend void protobuf_AssignDesc_Glyphs_2eproto();
  friend void protobuf_ShutdownFile_Glyphs_2eproto();

  void InitAsDefaultInstance();
  static CSNotifyGlyphsUpdateReq* default_instance_;
};
// -------------------------------------------------------------------

class CSNotifyGlyphsUpdateResp : public ::google::protobuf::MessageLite {
 public:
  CSNotifyGlyphsUpdateResp();
  virtual ~CSNotifyGlyphsUpdateResp();

  CSNotifyGlyphsUpdateResp(const CSNotifyGlyphsUpdateResp& from);

  inline CSNotifyGlyphsUpdateResp& operator=(const CSNotifyGlyphsUpdateResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSNotifyGlyphsUpdateResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSNotifyGlyphsUpdateResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSNotifyGlyphsUpdateResp* other);

  // implements Message ----------------------------------------------

  CSNotifyGlyphsUpdateResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSNotifyGlyphsUpdateResp& from);
  void MergeFrom(const CSNotifyGlyphsUpdateResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool HaveUpdate = 1;
  inline bool has_haveupdate() const;
  inline void clear_haveupdate();
  static const int kHaveUpdateFieldNumber = 1;
  inline bool haveupdate() const;
  inline void set_haveupdate(bool value);

  // @@protoc_insertion_point(class_scope:fgame.CSNotifyGlyphsUpdateResp)
 private:
  inline void set_has_haveupdate();
  inline void clear_has_haveupdate();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool haveupdate_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Glyphs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Glyphs_2eproto();
  #endif
  friend void protobuf_AssignDesc_Glyphs_2eproto();
  friend void protobuf_ShutdownFile_Glyphs_2eproto();

  void InitAsDefaultInstance();
  static CSNotifyGlyphsUpdateResp* default_instance_;
};
// -------------------------------------------------------------------

class CSGlyphGuideReq : public ::google::protobuf::MessageLite {
 public:
  CSGlyphGuideReq();
  virtual ~CSGlyphGuideReq();

  CSGlyphGuideReq(const CSGlyphGuideReq& from);

  inline CSGlyphGuideReq& operator=(const CSGlyphGuideReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGlyphGuideReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGlyphGuideReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGlyphGuideReq* other);

  // implements Message ----------------------------------------------

  CSGlyphGuideReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGlyphGuideReq& from);
  void MergeFrom(const CSGlyphGuideReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSGlyphGuideReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Glyphs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Glyphs_2eproto();
  #endif
  friend void protobuf_AssignDesc_Glyphs_2eproto();
  friend void protobuf_ShutdownFile_Glyphs_2eproto();

  void InitAsDefaultInstance();
  static CSGlyphGuideReq* default_instance_;
};
// -------------------------------------------------------------------

class CSGlyphGuideResp : public ::google::protobuf::MessageLite {
 public:
  CSGlyphGuideResp();
  virtual ~CSGlyphGuideResp();

  CSGlyphGuideResp(const CSGlyphGuideResp& from);

  inline CSGlyphGuideResp& operator=(const CSGlyphGuideResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGlyphGuideResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGlyphGuideResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGlyphGuideResp* other);

  // implements Message ----------------------------------------------

  CSGlyphGuideResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGlyphGuideResp& from);
  void MergeFrom(const CSGlyphGuideResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required uint32 GiftID = 2;
  inline bool has_giftid() const;
  inline void clear_giftid();
  static const int kGiftIDFieldNumber = 2;
  inline ::google::protobuf::uint32 giftid() const;
  inline void set_giftid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGlyphGuideResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_giftid();
  inline void clear_has_giftid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 giftid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Glyphs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Glyphs_2eproto();
  #endif
  friend void protobuf_AssignDesc_Glyphs_2eproto();
  friend void protobuf_ShutdownFile_Glyphs_2eproto();

  void InitAsDefaultInstance();
  static CSGlyphGuideResp* default_instance_;
};
// ===================================================================


// ===================================================================

// CSGlyphsRequestInfoReq

// -------------------------------------------------------------------

// GlyphInfo

// required int32 glyphID = 1;
inline bool GlyphInfo::has_glyphid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GlyphInfo::set_has_glyphid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GlyphInfo::clear_has_glyphid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GlyphInfo::clear_glyphid() {
  glyphid_ = 0;
  clear_has_glyphid();
}
inline ::google::protobuf::int32 GlyphInfo::glyphid() const {
  // @@protoc_insertion_point(field_get:fgame.GlyphInfo.glyphID)
  return glyphid_;
}
inline void GlyphInfo::set_glyphid(::google::protobuf::int32 value) {
  set_has_glyphid();
  glyphid_ = value;
  // @@protoc_insertion_point(field_set:fgame.GlyphInfo.glyphID)
}

// required int32 level = 2;
inline bool GlyphInfo::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GlyphInfo::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GlyphInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GlyphInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 GlyphInfo::level() const {
  // @@protoc_insertion_point(field_get:fgame.GlyphInfo.level)
  return level_;
}
inline void GlyphInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:fgame.GlyphInfo.level)
}

// required .fgame.GlyphInfo.Status status = 3;
inline bool GlyphInfo::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GlyphInfo::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GlyphInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GlyphInfo::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::fgame::GlyphInfo_Status GlyphInfo::status() const {
  // @@protoc_insertion_point(field_get:fgame.GlyphInfo.status)
  return static_cast< ::fgame::GlyphInfo_Status >(status_);
}
inline void GlyphInfo::set_status(::fgame::GlyphInfo_Status value) {
  assert(::fgame::GlyphInfo_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:fgame.GlyphInfo.status)
}

// -------------------------------------------------------------------

// CSGlyphsRequestInfoResp

// repeated .fgame.GlyphInfo glyphData = 1;
inline int CSGlyphsRequestInfoResp::glyphdata_size() const {
  return glyphdata_.size();
}
inline void CSGlyphsRequestInfoResp::clear_glyphdata() {
  glyphdata_.Clear();
}
inline const ::fgame::GlyphInfo& CSGlyphsRequestInfoResp::glyphdata(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSGlyphsRequestInfoResp.glyphData)
  return glyphdata_.Get(index);
}
inline ::fgame::GlyphInfo* CSGlyphsRequestInfoResp::mutable_glyphdata(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSGlyphsRequestInfoResp.glyphData)
  return glyphdata_.Mutable(index);
}
inline ::fgame::GlyphInfo* CSGlyphsRequestInfoResp::add_glyphdata() {
  // @@protoc_insertion_point(field_add:fgame.CSGlyphsRequestInfoResp.glyphData)
  return glyphdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::GlyphInfo >&
CSGlyphsRequestInfoResp::glyphdata() const {
  // @@protoc_insertion_point(field_list:fgame.CSGlyphsRequestInfoResp.glyphData)
  return glyphdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::GlyphInfo >*
CSGlyphsRequestInfoResp::mutable_glyphdata() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSGlyphsRequestInfoResp.glyphData)
  return &glyphdata_;
}

// -------------------------------------------------------------------

// CSGlyphsRequestBasicInfoReq

// -------------------------------------------------------------------

// StuffInfo

// required int32 stuffID = 1;
inline bool StuffInfo::has_stuffid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StuffInfo::set_has_stuffid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StuffInfo::clear_has_stuffid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StuffInfo::clear_stuffid() {
  stuffid_ = 0;
  clear_has_stuffid();
}
inline ::google::protobuf::int32 StuffInfo::stuffid() const {
  // @@protoc_insertion_point(field_get:fgame.StuffInfo.stuffID)
  return stuffid_;
}
inline void StuffInfo::set_stuffid(::google::protobuf::int32 value) {
  set_has_stuffid();
  stuffid_ = value;
  // @@protoc_insertion_point(field_set:fgame.StuffInfo.stuffID)
}

// required int32 count = 2;
inline bool StuffInfo::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StuffInfo::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StuffInfo::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StuffInfo::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 StuffInfo::count() const {
  // @@protoc_insertion_point(field_get:fgame.StuffInfo.count)
  return count_;
}
inline void StuffInfo::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:fgame.StuffInfo.count)
}

// -------------------------------------------------------------------

// CSGlyphsRequestBasicInfoResp

// repeated .fgame.StuffInfo stuffInfo = 1;
inline int CSGlyphsRequestBasicInfoResp::stuffinfo_size() const {
  return stuffinfo_.size();
}
inline void CSGlyphsRequestBasicInfoResp::clear_stuffinfo() {
  stuffinfo_.Clear();
}
inline const ::fgame::StuffInfo& CSGlyphsRequestBasicInfoResp::stuffinfo(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSGlyphsRequestBasicInfoResp.stuffInfo)
  return stuffinfo_.Get(index);
}
inline ::fgame::StuffInfo* CSGlyphsRequestBasicInfoResp::mutable_stuffinfo(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSGlyphsRequestBasicInfoResp.stuffInfo)
  return stuffinfo_.Mutable(index);
}
inline ::fgame::StuffInfo* CSGlyphsRequestBasicInfoResp::add_stuffinfo() {
  // @@protoc_insertion_point(field_add:fgame.CSGlyphsRequestBasicInfoResp.stuffInfo)
  return stuffinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::StuffInfo >&
CSGlyphsRequestBasicInfoResp::stuffinfo() const {
  // @@protoc_insertion_point(field_list:fgame.CSGlyphsRequestBasicInfoResp.stuffInfo)
  return stuffinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::StuffInfo >*
CSGlyphsRequestBasicInfoResp::mutable_stuffinfo() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSGlyphsRequestBasicInfoResp.stuffInfo)
  return &stuffinfo_;
}

// -------------------------------------------------------------------

// CSGlyphsActiveReq

// required int32 glyphID = 1;
inline bool CSGlyphsActiveReq::has_glyphid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGlyphsActiveReq::set_has_glyphid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGlyphsActiveReq::clear_has_glyphid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGlyphsActiveReq::clear_glyphid() {
  glyphid_ = 0;
  clear_has_glyphid();
}
inline ::google::protobuf::int32 CSGlyphsActiveReq::glyphid() const {
  // @@protoc_insertion_point(field_get:fgame.CSGlyphsActiveReq.glyphID)
  return glyphid_;
}
inline void CSGlyphsActiveReq::set_glyphid(::google::protobuf::int32 value) {
  set_has_glyphid();
  glyphid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGlyphsActiveReq.glyphID)
}

// -------------------------------------------------------------------

// CSGlyphsActiveResp

// required int32 glyphID = 1;
inline bool CSGlyphsActiveResp::has_glyphid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGlyphsActiveResp::set_has_glyphid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGlyphsActiveResp::clear_has_glyphid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGlyphsActiveResp::clear_glyphid() {
  glyphid_ = 0;
  clear_has_glyphid();
}
inline ::google::protobuf::int32 CSGlyphsActiveResp::glyphid() const {
  // @@protoc_insertion_point(field_get:fgame.CSGlyphsActiveResp.glyphID)
  return glyphid_;
}
inline void CSGlyphsActiveResp::set_glyphid(::google::protobuf::int32 value) {
  set_has_glyphid();
  glyphid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGlyphsActiveResp.glyphID)
}

// required .fgame.CSGlyphsActiveResp.Status status = 2;
inline bool CSGlyphsActiveResp::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGlyphsActiveResp::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGlyphsActiveResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGlyphsActiveResp::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::fgame::CSGlyphsActiveResp_Status CSGlyphsActiveResp::status() const {
  // @@protoc_insertion_point(field_get:fgame.CSGlyphsActiveResp.status)
  return static_cast< ::fgame::CSGlyphsActiveResp_Status >(status_);
}
inline void CSGlyphsActiveResp::set_status(::fgame::CSGlyphsActiveResp_Status value) {
  assert(::fgame::CSGlyphsActiveResp_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGlyphsActiveResp.status)
}

// -------------------------------------------------------------------

// CSGlyphsUpgradeReq

// required int32 glyphID = 1;
inline bool CSGlyphsUpgradeReq::has_glyphid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGlyphsUpgradeReq::set_has_glyphid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGlyphsUpgradeReq::clear_has_glyphid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGlyphsUpgradeReq::clear_glyphid() {
  glyphid_ = 0;
  clear_has_glyphid();
}
inline ::google::protobuf::int32 CSGlyphsUpgradeReq::glyphid() const {
  // @@protoc_insertion_point(field_get:fgame.CSGlyphsUpgradeReq.glyphID)
  return glyphid_;
}
inline void CSGlyphsUpgradeReq::set_glyphid(::google::protobuf::int32 value) {
  set_has_glyphid();
  glyphid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGlyphsUpgradeReq.glyphID)
}

// -------------------------------------------------------------------

// CSGlyphsUpgradeResp

// required int32 glyphID = 1;
inline bool CSGlyphsUpgradeResp::has_glyphid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGlyphsUpgradeResp::set_has_glyphid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGlyphsUpgradeResp::clear_has_glyphid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGlyphsUpgradeResp::clear_glyphid() {
  glyphid_ = 0;
  clear_has_glyphid();
}
inline ::google::protobuf::int32 CSGlyphsUpgradeResp::glyphid() const {
  // @@protoc_insertion_point(field_get:fgame.CSGlyphsUpgradeResp.glyphID)
  return glyphid_;
}
inline void CSGlyphsUpgradeResp::set_glyphid(::google::protobuf::int32 value) {
  set_has_glyphid();
  glyphid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGlyphsUpgradeResp.glyphID)
}

// required int32 level = 2;
inline bool CSGlyphsUpgradeResp::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGlyphsUpgradeResp::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGlyphsUpgradeResp::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGlyphsUpgradeResp::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 CSGlyphsUpgradeResp::level() const {
  // @@protoc_insertion_point(field_get:fgame.CSGlyphsUpgradeResp.level)
  return level_;
}
inline void CSGlyphsUpgradeResp::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGlyphsUpgradeResp.level)
}

// required bool is_ok = 3;
inline bool CSGlyphsUpgradeResp::has_is_ok() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSGlyphsUpgradeResp::set_has_is_ok() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSGlyphsUpgradeResp::clear_has_is_ok() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSGlyphsUpgradeResp::clear_is_ok() {
  is_ok_ = false;
  clear_has_is_ok();
}
inline bool CSGlyphsUpgradeResp::is_ok() const {
  // @@protoc_insertion_point(field_get:fgame.CSGlyphsUpgradeResp.is_ok)
  return is_ok_;
}
inline void CSGlyphsUpgradeResp::set_is_ok(bool value) {
  set_has_is_ok();
  is_ok_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGlyphsUpgradeResp.is_ok)
}

// -------------------------------------------------------------------

// PvpGlyphData

// required int32 glyphID = 1;
inline bool PvpGlyphData::has_glyphid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpGlyphData::set_has_glyphid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpGlyphData::clear_has_glyphid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpGlyphData::clear_glyphid() {
  glyphid_ = 0;
  clear_has_glyphid();
}
inline ::google::protobuf::int32 PvpGlyphData::glyphid() const {
  // @@protoc_insertion_point(field_get:fgame.PvpGlyphData.glyphID)
  return glyphid_;
}
inline void PvpGlyphData::set_glyphid(::google::protobuf::int32 value) {
  set_has_glyphid();
  glyphid_ = value;
  // @@protoc_insertion_point(field_set:fgame.PvpGlyphData.glyphID)
}

// required int32 mainData = 2;
inline bool PvpGlyphData::has_maindata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpGlyphData::set_has_maindata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpGlyphData::clear_has_maindata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpGlyphData::clear_maindata() {
  maindata_ = 0;
  clear_has_maindata();
}
inline ::google::protobuf::int32 PvpGlyphData::maindata() const {
  // @@protoc_insertion_point(field_get:fgame.PvpGlyphData.mainData)
  return maindata_;
}
inline void PvpGlyphData::set_maindata(::google::protobuf::int32 value) {
  set_has_maindata();
  maindata_ = value;
  // @@protoc_insertion_point(field_set:fgame.PvpGlyphData.mainData)
}

// required int32 sideData = 3;
inline bool PvpGlyphData::has_sidedata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PvpGlyphData::set_has_sidedata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PvpGlyphData::clear_has_sidedata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PvpGlyphData::clear_sidedata() {
  sidedata_ = 0;
  clear_has_sidedata();
}
inline ::google::protobuf::int32 PvpGlyphData::sidedata() const {
  // @@protoc_insertion_point(field_get:fgame.PvpGlyphData.sideData)
  return sidedata_;
}
inline void PvpGlyphData::set_sidedata(::google::protobuf::int32 value) {
  set_has_sidedata();
  sidedata_ = value;
  // @@protoc_insertion_point(field_set:fgame.PvpGlyphData.sideData)
}

// required int32 soul = 4;
inline bool PvpGlyphData::has_soul() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PvpGlyphData::set_has_soul() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PvpGlyphData::clear_has_soul() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PvpGlyphData::clear_soul() {
  soul_ = 0;
  clear_has_soul();
}
inline ::google::protobuf::int32 PvpGlyphData::soul() const {
  // @@protoc_insertion_point(field_get:fgame.PvpGlyphData.soul)
  return soul_;
}
inline void PvpGlyphData::set_soul(::google::protobuf::int32 value) {
  set_has_soul();
  soul_ = value;
  // @@protoc_insertion_point(field_set:fgame.PvpGlyphData.soul)
}

// required string buildLevel = 5;
inline bool PvpGlyphData::has_buildlevel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PvpGlyphData::set_has_buildlevel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PvpGlyphData::clear_has_buildlevel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PvpGlyphData::clear_buildlevel() {
  if (buildlevel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buildlevel_->clear();
  }
  clear_has_buildlevel();
}
inline const ::std::string& PvpGlyphData::buildlevel() const {
  // @@protoc_insertion_point(field_get:fgame.PvpGlyphData.buildLevel)
  return *buildlevel_;
}
inline void PvpGlyphData::set_buildlevel(const ::std::string& value) {
  set_has_buildlevel();
  if (buildlevel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buildlevel_ = new ::std::string;
  }
  buildlevel_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.PvpGlyphData.buildLevel)
}
inline void PvpGlyphData::set_buildlevel(const char* value) {
  set_has_buildlevel();
  if (buildlevel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buildlevel_ = new ::std::string;
  }
  buildlevel_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.PvpGlyphData.buildLevel)
}
inline void PvpGlyphData::set_buildlevel(const char* value, size_t size) {
  set_has_buildlevel();
  if (buildlevel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buildlevel_ = new ::std::string;
  }
  buildlevel_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.PvpGlyphData.buildLevel)
}
inline ::std::string* PvpGlyphData::mutable_buildlevel() {
  set_has_buildlevel();
  if (buildlevel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buildlevel_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.PvpGlyphData.buildLevel)
  return buildlevel_;
}
inline ::std::string* PvpGlyphData::release_buildlevel() {
  clear_has_buildlevel();
  if (buildlevel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = buildlevel_;
    buildlevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PvpGlyphData::set_allocated_buildlevel(::std::string* buildlevel) {
  if (buildlevel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete buildlevel_;
  }
  if (buildlevel) {
    set_has_buildlevel();
    buildlevel_ = buildlevel;
  } else {
    clear_has_buildlevel();
    buildlevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.PvpGlyphData.buildLevel)
}

// required int32 glyphLevel = 6;
inline bool PvpGlyphData::has_glyphlevel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PvpGlyphData::set_has_glyphlevel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PvpGlyphData::clear_has_glyphlevel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PvpGlyphData::clear_glyphlevel() {
  glyphlevel_ = 0;
  clear_has_glyphlevel();
}
inline ::google::protobuf::int32 PvpGlyphData::glyphlevel() const {
  // @@protoc_insertion_point(field_get:fgame.PvpGlyphData.glyphLevel)
  return glyphlevel_;
}
inline void PvpGlyphData::set_glyphlevel(::google::protobuf::int32 value) {
  set_has_glyphlevel();
  glyphlevel_ = value;
  // @@protoc_insertion_point(field_set:fgame.PvpGlyphData.glyphLevel)
}

// -------------------------------------------------------------------

// PvpGlyphPlayer

// required int32 campID = 1;
inline bool PvpGlyphPlayer::has_campid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpGlyphPlayer::set_has_campid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpGlyphPlayer::clear_has_campid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpGlyphPlayer::clear_campid() {
  campid_ = 0;
  clear_has_campid();
}
inline ::google::protobuf::int32 PvpGlyphPlayer::campid() const {
  // @@protoc_insertion_point(field_get:fgame.PvpGlyphPlayer.campID)
  return campid_;
}
inline void PvpGlyphPlayer::set_campid(::google::protobuf::int32 value) {
  set_has_campid();
  campid_ = value;
  // @@protoc_insertion_point(field_set:fgame.PvpGlyphPlayer.campID)
}

// repeated .fgame.PvpGlyphData pvpGlyphData = 2;
inline int PvpGlyphPlayer::pvpglyphdata_size() const {
  return pvpglyphdata_.size();
}
inline void PvpGlyphPlayer::clear_pvpglyphdata() {
  pvpglyphdata_.Clear();
}
inline const ::fgame::PvpGlyphData& PvpGlyphPlayer::pvpglyphdata(int index) const {
  // @@protoc_insertion_point(field_get:fgame.PvpGlyphPlayer.pvpGlyphData)
  return pvpglyphdata_.Get(index);
}
inline ::fgame::PvpGlyphData* PvpGlyphPlayer::mutable_pvpglyphdata(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.PvpGlyphPlayer.pvpGlyphData)
  return pvpglyphdata_.Mutable(index);
}
inline ::fgame::PvpGlyphData* PvpGlyphPlayer::add_pvpglyphdata() {
  // @@protoc_insertion_point(field_add:fgame.PvpGlyphPlayer.pvpGlyphData)
  return pvpglyphdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::PvpGlyphData >&
PvpGlyphPlayer::pvpglyphdata() const {
  // @@protoc_insertion_point(field_list:fgame.PvpGlyphPlayer.pvpGlyphData)
  return pvpglyphdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::PvpGlyphData >*
PvpGlyphPlayer::mutable_pvpglyphdata() {
  // @@protoc_insertion_point(field_mutable_list:fgame.PvpGlyphPlayer.pvpGlyphData)
  return &pvpglyphdata_;
}

// -------------------------------------------------------------------

// CSGlyphsPvpInfoReq

// required uint32 roomId = 1;
inline bool CSGlyphsPvpInfoReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGlyphsPvpInfoReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGlyphsPvpInfoReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGlyphsPvpInfoReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSGlyphsPvpInfoReq::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSGlyphsPvpInfoReq.roomId)
  return roomid_;
}
inline void CSGlyphsPvpInfoReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGlyphsPvpInfoReq.roomId)
}

// -------------------------------------------------------------------

// CSGlyphsPvpInfoResp

// repeated .fgame.PvpGlyphPlayer pvpGlyphPlayer = 1;
inline int CSGlyphsPvpInfoResp::pvpglyphplayer_size() const {
  return pvpglyphplayer_.size();
}
inline void CSGlyphsPvpInfoResp::clear_pvpglyphplayer() {
  pvpglyphplayer_.Clear();
}
inline const ::fgame::PvpGlyphPlayer& CSGlyphsPvpInfoResp::pvpglyphplayer(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSGlyphsPvpInfoResp.pvpGlyphPlayer)
  return pvpglyphplayer_.Get(index);
}
inline ::fgame::PvpGlyphPlayer* CSGlyphsPvpInfoResp::mutable_pvpglyphplayer(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSGlyphsPvpInfoResp.pvpGlyphPlayer)
  return pvpglyphplayer_.Mutable(index);
}
inline ::fgame::PvpGlyphPlayer* CSGlyphsPvpInfoResp::add_pvpglyphplayer() {
  // @@protoc_insertion_point(field_add:fgame.CSGlyphsPvpInfoResp.pvpGlyphPlayer)
  return pvpglyphplayer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::PvpGlyphPlayer >&
CSGlyphsPvpInfoResp::pvpglyphplayer() const {
  // @@protoc_insertion_point(field_list:fgame.CSGlyphsPvpInfoResp.pvpGlyphPlayer)
  return pvpglyphplayer_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::PvpGlyphPlayer >*
CSGlyphsPvpInfoResp::mutable_pvpglyphplayer() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSGlyphsPvpInfoResp.pvpGlyphPlayer)
  return &pvpglyphplayer_;
}

// -------------------------------------------------------------------

// CSNotifyGlyphsUpdateReq

// -------------------------------------------------------------------

// CSNotifyGlyphsUpdateResp

// required bool HaveUpdate = 1;
inline bool CSNotifyGlyphsUpdateResp::has_haveupdate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSNotifyGlyphsUpdateResp::set_has_haveupdate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSNotifyGlyphsUpdateResp::clear_has_haveupdate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSNotifyGlyphsUpdateResp::clear_haveupdate() {
  haveupdate_ = false;
  clear_has_haveupdate();
}
inline bool CSNotifyGlyphsUpdateResp::haveupdate() const {
  // @@protoc_insertion_point(field_get:fgame.CSNotifyGlyphsUpdateResp.HaveUpdate)
  return haveupdate_;
}
inline void CSNotifyGlyphsUpdateResp::set_haveupdate(bool value) {
  set_has_haveupdate();
  haveupdate_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSNotifyGlyphsUpdateResp.HaveUpdate)
}

// -------------------------------------------------------------------

// CSGlyphGuideReq

// -------------------------------------------------------------------

// CSGlyphGuideResp

// required uint32 Ret = 1;
inline bool CSGlyphGuideResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGlyphGuideResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGlyphGuideResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGlyphGuideResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSGlyphGuideResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSGlyphGuideResp.Ret)
  return ret_;
}
inline void CSGlyphGuideResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGlyphGuideResp.Ret)
}

// required uint32 GiftID = 2;
inline bool CSGlyphGuideResp::has_giftid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGlyphGuideResp::set_has_giftid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGlyphGuideResp::clear_has_giftid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGlyphGuideResp::clear_giftid() {
  giftid_ = 0u;
  clear_has_giftid();
}
inline ::google::protobuf::uint32 CSGlyphGuideResp::giftid() const {
  // @@protoc_insertion_point(field_get:fgame.CSGlyphGuideResp.GiftID)
  return giftid_;
}
inline void CSGlyphGuideResp::set_giftid(::google::protobuf::uint32 value) {
  set_has_giftid();
  giftid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGlyphGuideResp.GiftID)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fgame

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Glyphs_2eproto__INCLUDED
