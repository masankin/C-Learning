// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MailData.proto

#ifndef PROTOBUF_MailData_2eproto__INCLUDED
#define PROTOBUF_MailData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace fgame {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MailData_2eproto();
void protobuf_AssignDesc_MailData_2eproto();
void protobuf_ShutdownFile_MailData_2eproto();

class DataMailInfo;
class DataMailInfoVec;
class DataMailUin;
class DataMail;

// ===================================================================

class DataMailInfo : public ::google::protobuf::MessageLite {
 public:
  DataMailInfo();
  virtual ~DataMailInfo();

  DataMailInfo(const DataMailInfo& from);

  inline DataMailInfo& operator=(const DataMailInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DataMailInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataMailInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataMailInfo* other);

  // implements Message ----------------------------------------------

  DataMailInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataMailInfo& from);
  void MergeFrom(const DataMailInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required string Title = 2;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 2;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // required string Content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // required string PlugIn = 4;
  inline bool has_plugin() const;
  inline void clear_plugin();
  static const int kPlugInFieldNumber = 4;
  inline const ::std::string& plugin() const;
  inline void set_plugin(const ::std::string& value);
  inline void set_plugin(const char* value);
  inline void set_plugin(const char* value, size_t size);
  inline ::std::string* mutable_plugin();
  inline ::std::string* release_plugin();
  inline void set_allocated_plugin(::std::string* plugin);

  // required uint32 SendTime = 5;
  inline bool has_sendtime() const;
  inline void clear_sendtime();
  static const int kSendTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 sendtime() const;
  inline void set_sendtime(::google::protobuf::uint32 value);

  // required uint32 OutDate = 6;
  inline bool has_outdate() const;
  inline void clear_outdate();
  static const int kOutDateFieldNumber = 6;
  inline ::google::protobuf::uint32 outdate() const;
  inline void set_outdate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.DataMailInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_plugin();
  inline void clear_has_plugin();
  inline void set_has_sendtime();
  inline void clear_has_sendtime();
  inline void set_has_outdate();
  inline void clear_has_outdate();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  ::std::string* content_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 sendtime_;
  ::std::string* plugin_;
  ::google::protobuf::uint32 outdate_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MailData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MailData_2eproto();
  #endif
  friend void protobuf_AssignDesc_MailData_2eproto();
  friend void protobuf_ShutdownFile_MailData_2eproto();

  void InitAsDefaultInstance();
  static DataMailInfo* default_instance_;
};
// -------------------------------------------------------------------

class DataMailInfoVec : public ::google::protobuf::MessageLite {
 public:
  DataMailInfoVec();
  virtual ~DataMailInfoVec();

  DataMailInfoVec(const DataMailInfoVec& from);

  inline DataMailInfoVec& operator=(const DataMailInfoVec& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DataMailInfoVec& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataMailInfoVec* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataMailInfoVec* other);

  // implements Message ----------------------------------------------

  DataMailInfoVec* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataMailInfoVec& from);
  void MergeFrom(const DataMailInfoVec& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.DataMailInfo MailInfo = 1;
  inline int mailinfo_size() const;
  inline void clear_mailinfo();
  static const int kMailInfoFieldNumber = 1;
  inline const ::fgame::DataMailInfo& mailinfo(int index) const;
  inline ::fgame::DataMailInfo* mutable_mailinfo(int index);
  inline ::fgame::DataMailInfo* add_mailinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::DataMailInfo >&
      mailinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::DataMailInfo >*
      mutable_mailinfo();

  // @@protoc_insertion_point(class_scope:fgame.DataMailInfoVec)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::DataMailInfo > mailinfo_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MailData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MailData_2eproto();
  #endif
  friend void protobuf_AssignDesc_MailData_2eproto();
  friend void protobuf_ShutdownFile_MailData_2eproto();

  void InitAsDefaultInstance();
  static DataMailInfoVec* default_instance_;
};
// -------------------------------------------------------------------

class DataMailUin : public ::google::protobuf::MessageLite {
 public:
  DataMailUin();
  virtual ~DataMailUin();

  DataMailUin(const DataMailUin& from);

  inline DataMailUin& operator=(const DataMailUin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DataMailUin& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataMailUin* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataMailUin* other);

  // implements Message ----------------------------------------------

  DataMailUin* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataMailUin& from);
  void MergeFrom(const DataMailUin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool NewMail = 1;
  inline bool has_newmail() const;
  inline void clear_newmail();
  static const int kNewMailFieldNumber = 1;
  inline bool newmail() const;
  inline void set_newmail(bool value);

  // required uint32 MailNO = 2;
  inline bool has_mailno() const;
  inline void clear_mailno();
  static const int kMailNOFieldNumber = 2;
  inline ::google::protobuf::uint32 mailno() const;
  inline void set_mailno(::google::protobuf::uint32 value);

  // optional .fgame.DataMailInfoVec MailInfoVec = 3;
  inline bool has_mailinfovec() const;
  inline void clear_mailinfovec();
  static const int kMailInfoVecFieldNumber = 3;
  inline const ::fgame::DataMailInfoVec& mailinfovec() const;
  inline ::fgame::DataMailInfoVec* mutable_mailinfovec();
  inline ::fgame::DataMailInfoVec* release_mailinfovec();
  inline void set_allocated_mailinfovec(::fgame::DataMailInfoVec* mailinfovec);

  // optional int32 uIn = 4;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUInFieldNumber = 4;
  inline ::google::protobuf::int32 uin() const;
  inline void set_uin(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fgame.DataMailUin)
 private:
  inline void set_has_newmail();
  inline void clear_has_newmail();
  inline void set_has_mailno();
  inline void clear_has_mailno();
  inline void set_has_mailinfovec();
  inline void clear_has_mailinfovec();
  inline void set_has_uin();
  inline void clear_has_uin();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool newmail_;
  ::google::protobuf::uint32 mailno_;
  ::fgame::DataMailInfoVec* mailinfovec_;
  ::google::protobuf::int32 uin_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MailData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MailData_2eproto();
  #endif
  friend void protobuf_AssignDesc_MailData_2eproto();
  friend void protobuf_ShutdownFile_MailData_2eproto();

  void InitAsDefaultInstance();
  static DataMailUin* default_instance_;
};
// -------------------------------------------------------------------

class DataMail : public ::google::protobuf::MessageLite {
 public:
  DataMail();
  virtual ~DataMail();

  DataMail(const DataMail& from);

  inline DataMail& operator=(const DataMail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DataMail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataMail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataMail* other);

  // implements Message ----------------------------------------------

  DataMail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataMail& from);
  void MergeFrom(const DataMail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.DataMailUin MailUinVec = 1;
  inline int mailuinvec_size() const;
  inline void clear_mailuinvec();
  static const int kMailUinVecFieldNumber = 1;
  inline const ::fgame::DataMailUin& mailuinvec(int index) const;
  inline ::fgame::DataMailUin* mutable_mailuinvec(int index);
  inline ::fgame::DataMailUin* add_mailuinvec();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::DataMailUin >&
      mailuinvec() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::DataMailUin >*
      mutable_mailuinvec();

  // @@protoc_insertion_point(class_scope:fgame.DataMail)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::DataMailUin > mailuinvec_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MailData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MailData_2eproto();
  #endif
  friend void protobuf_AssignDesc_MailData_2eproto();
  friend void protobuf_ShutdownFile_MailData_2eproto();

  void InitAsDefaultInstance();
  static DataMail* default_instance_;
};
// ===================================================================


// ===================================================================

// DataMailInfo

// required uint32 Id = 1;
inline bool DataMailInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataMailInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataMailInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataMailInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 DataMailInfo::id() const {
  // @@protoc_insertion_point(field_get:fgame.DataMailInfo.Id)
  return id_;
}
inline void DataMailInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.DataMailInfo.Id)
}

// required string Title = 2;
inline bool DataMailInfo::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataMailInfo::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataMailInfo::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataMailInfo::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& DataMailInfo::title() const {
  // @@protoc_insertion_point(field_get:fgame.DataMailInfo.Title)
  return *title_;
}
inline void DataMailInfo::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.DataMailInfo.Title)
}
inline void DataMailInfo::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.DataMailInfo.Title)
}
inline void DataMailInfo::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.DataMailInfo.Title)
}
inline ::std::string* DataMailInfo::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.DataMailInfo.Title)
  return title_;
}
inline ::std::string* DataMailInfo::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DataMailInfo::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.DataMailInfo.Title)
}

// required string Content = 3;
inline bool DataMailInfo::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataMailInfo::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataMailInfo::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataMailInfo::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& DataMailInfo::content() const {
  // @@protoc_insertion_point(field_get:fgame.DataMailInfo.Content)
  return *content_;
}
inline void DataMailInfo::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.DataMailInfo.Content)
}
inline void DataMailInfo::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.DataMailInfo.Content)
}
inline void DataMailInfo::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.DataMailInfo.Content)
}
inline ::std::string* DataMailInfo::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.DataMailInfo.Content)
  return content_;
}
inline ::std::string* DataMailInfo::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DataMailInfo::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.DataMailInfo.Content)
}

// required string PlugIn = 4;
inline bool DataMailInfo::has_plugin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataMailInfo::set_has_plugin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataMailInfo::clear_has_plugin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataMailInfo::clear_plugin() {
  if (plugin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    plugin_->clear();
  }
  clear_has_plugin();
}
inline const ::std::string& DataMailInfo::plugin() const {
  // @@protoc_insertion_point(field_get:fgame.DataMailInfo.PlugIn)
  return *plugin_;
}
inline void DataMailInfo::set_plugin(const ::std::string& value) {
  set_has_plugin();
  if (plugin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    plugin_ = new ::std::string;
  }
  plugin_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.DataMailInfo.PlugIn)
}
inline void DataMailInfo::set_plugin(const char* value) {
  set_has_plugin();
  if (plugin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    plugin_ = new ::std::string;
  }
  plugin_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.DataMailInfo.PlugIn)
}
inline void DataMailInfo::set_plugin(const char* value, size_t size) {
  set_has_plugin();
  if (plugin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    plugin_ = new ::std::string;
  }
  plugin_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.DataMailInfo.PlugIn)
}
inline ::std::string* DataMailInfo::mutable_plugin() {
  set_has_plugin();
  if (plugin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    plugin_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.DataMailInfo.PlugIn)
  return plugin_;
}
inline ::std::string* DataMailInfo::release_plugin() {
  clear_has_plugin();
  if (plugin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = plugin_;
    plugin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DataMailInfo::set_allocated_plugin(::std::string* plugin) {
  if (plugin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete plugin_;
  }
  if (plugin) {
    set_has_plugin();
    plugin_ = plugin;
  } else {
    clear_has_plugin();
    plugin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.DataMailInfo.PlugIn)
}

// required uint32 SendTime = 5;
inline bool DataMailInfo::has_sendtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataMailInfo::set_has_sendtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataMailInfo::clear_has_sendtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataMailInfo::clear_sendtime() {
  sendtime_ = 0u;
  clear_has_sendtime();
}
inline ::google::protobuf::uint32 DataMailInfo::sendtime() const {
  // @@protoc_insertion_point(field_get:fgame.DataMailInfo.SendTime)
  return sendtime_;
}
inline void DataMailInfo::set_sendtime(::google::protobuf::uint32 value) {
  set_has_sendtime();
  sendtime_ = value;
  // @@protoc_insertion_point(field_set:fgame.DataMailInfo.SendTime)
}

// required uint32 OutDate = 6;
inline bool DataMailInfo::has_outdate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataMailInfo::set_has_outdate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataMailInfo::clear_has_outdate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataMailInfo::clear_outdate() {
  outdate_ = 0u;
  clear_has_outdate();
}
inline ::google::protobuf::uint32 DataMailInfo::outdate() const {
  // @@protoc_insertion_point(field_get:fgame.DataMailInfo.OutDate)
  return outdate_;
}
inline void DataMailInfo::set_outdate(::google::protobuf::uint32 value) {
  set_has_outdate();
  outdate_ = value;
  // @@protoc_insertion_point(field_set:fgame.DataMailInfo.OutDate)
}

// -------------------------------------------------------------------

// DataMailInfoVec

// repeated .fgame.DataMailInfo MailInfo = 1;
inline int DataMailInfoVec::mailinfo_size() const {
  return mailinfo_.size();
}
inline void DataMailInfoVec::clear_mailinfo() {
  mailinfo_.Clear();
}
inline const ::fgame::DataMailInfo& DataMailInfoVec::mailinfo(int index) const {
  // @@protoc_insertion_point(field_get:fgame.DataMailInfoVec.MailInfo)
  return mailinfo_.Get(index);
}
inline ::fgame::DataMailInfo* DataMailInfoVec::mutable_mailinfo(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.DataMailInfoVec.MailInfo)
  return mailinfo_.Mutable(index);
}
inline ::fgame::DataMailInfo* DataMailInfoVec::add_mailinfo() {
  // @@protoc_insertion_point(field_add:fgame.DataMailInfoVec.MailInfo)
  return mailinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::DataMailInfo >&
DataMailInfoVec::mailinfo() const {
  // @@protoc_insertion_point(field_list:fgame.DataMailInfoVec.MailInfo)
  return mailinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::DataMailInfo >*
DataMailInfoVec::mutable_mailinfo() {
  // @@protoc_insertion_point(field_mutable_list:fgame.DataMailInfoVec.MailInfo)
  return &mailinfo_;
}

// -------------------------------------------------------------------

// DataMailUin

// required bool NewMail = 1;
inline bool DataMailUin::has_newmail() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataMailUin::set_has_newmail() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataMailUin::clear_has_newmail() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataMailUin::clear_newmail() {
  newmail_ = false;
  clear_has_newmail();
}
inline bool DataMailUin::newmail() const {
  // @@protoc_insertion_point(field_get:fgame.DataMailUin.NewMail)
  return newmail_;
}
inline void DataMailUin::set_newmail(bool value) {
  set_has_newmail();
  newmail_ = value;
  // @@protoc_insertion_point(field_set:fgame.DataMailUin.NewMail)
}

// required uint32 MailNO = 2;
inline bool DataMailUin::has_mailno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataMailUin::set_has_mailno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataMailUin::clear_has_mailno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataMailUin::clear_mailno() {
  mailno_ = 0u;
  clear_has_mailno();
}
inline ::google::protobuf::uint32 DataMailUin::mailno() const {
  // @@protoc_insertion_point(field_get:fgame.DataMailUin.MailNO)
  return mailno_;
}
inline void DataMailUin::set_mailno(::google::protobuf::uint32 value) {
  set_has_mailno();
  mailno_ = value;
  // @@protoc_insertion_point(field_set:fgame.DataMailUin.MailNO)
}

// optional .fgame.DataMailInfoVec MailInfoVec = 3;
inline bool DataMailUin::has_mailinfovec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataMailUin::set_has_mailinfovec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataMailUin::clear_has_mailinfovec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataMailUin::clear_mailinfovec() {
  if (mailinfovec_ != NULL) mailinfovec_->::fgame::DataMailInfoVec::Clear();
  clear_has_mailinfovec();
}
inline const ::fgame::DataMailInfoVec& DataMailUin::mailinfovec() const {
  // @@protoc_insertion_point(field_get:fgame.DataMailUin.MailInfoVec)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return mailinfovec_ != NULL ? *mailinfovec_ : *default_instance().mailinfovec_;
#else
  return mailinfovec_ != NULL ? *mailinfovec_ : *default_instance_->mailinfovec_;
#endif
}
inline ::fgame::DataMailInfoVec* DataMailUin::mutable_mailinfovec() {
  set_has_mailinfovec();
  if (mailinfovec_ == NULL) mailinfovec_ = new ::fgame::DataMailInfoVec;
  // @@protoc_insertion_point(field_mutable:fgame.DataMailUin.MailInfoVec)
  return mailinfovec_;
}
inline ::fgame::DataMailInfoVec* DataMailUin::release_mailinfovec() {
  clear_has_mailinfovec();
  ::fgame::DataMailInfoVec* temp = mailinfovec_;
  mailinfovec_ = NULL;
  return temp;
}
inline void DataMailUin::set_allocated_mailinfovec(::fgame::DataMailInfoVec* mailinfovec) {
  delete mailinfovec_;
  mailinfovec_ = mailinfovec;
  if (mailinfovec) {
    set_has_mailinfovec();
  } else {
    clear_has_mailinfovec();
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.DataMailUin.MailInfoVec)
}

// optional int32 uIn = 4;
inline bool DataMailUin::has_uin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataMailUin::set_has_uin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataMailUin::clear_has_uin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataMailUin::clear_uin() {
  uin_ = 0;
  clear_has_uin();
}
inline ::google::protobuf::int32 DataMailUin::uin() const {
  // @@protoc_insertion_point(field_get:fgame.DataMailUin.uIn)
  return uin_;
}
inline void DataMailUin::set_uin(::google::protobuf::int32 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.DataMailUin.uIn)
}

// -------------------------------------------------------------------

// DataMail

// repeated .fgame.DataMailUin MailUinVec = 1;
inline int DataMail::mailuinvec_size() const {
  return mailuinvec_.size();
}
inline void DataMail::clear_mailuinvec() {
  mailuinvec_.Clear();
}
inline const ::fgame::DataMailUin& DataMail::mailuinvec(int index) const {
  // @@protoc_insertion_point(field_get:fgame.DataMail.MailUinVec)
  return mailuinvec_.Get(index);
}
inline ::fgame::DataMailUin* DataMail::mutable_mailuinvec(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.DataMail.MailUinVec)
  return mailuinvec_.Mutable(index);
}
inline ::fgame::DataMailUin* DataMail::add_mailuinvec() {
  // @@protoc_insertion_point(field_add:fgame.DataMail.MailUinVec)
  return mailuinvec_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::DataMailUin >&
DataMail::mailuinvec() const {
  // @@protoc_insertion_point(field_list:fgame.DataMail.MailUinVec)
  return mailuinvec_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::DataMailUin >*
DataMail::mutable_mailuinvec() {
  // @@protoc_insertion_point(field_mutable_list:fgame.DataMail.MailUinVec)
  return &mailuinvec_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fgame

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MailData_2eproto__INCLUDED
