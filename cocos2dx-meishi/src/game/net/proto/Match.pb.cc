// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Match.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Match.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace fgame {

void protobuf_ShutdownFile_Match_2eproto() {
  delete CSGWGetMatchInfoReq::default_instance_;
  delete CSGWInitMatchInfo::default_instance_;
  delete BattleInfo::default_instance_;
  delete CSGWFinalMatchInfo::default_instance_;
  delete CSGWGetMatchInfoResp::default_instance_;
  delete CSGWMatchReq::default_instance_;
  delete GWPlayerInfo::default_instance_;
  delete CSGWMatchResp::default_instance_;
  delete CSGWMatchStopReq::default_instance_;
  delete CSGWMatchStopResp::default_instance_;
  delete CSGWGetRankReq::default_instance_;
  delete RankInfo::default_instance_;
  delete CSGWGetRankResp::default_instance_;
  delete CSGWBuyEnergyReq::default_instance_;
  delete CSGWBuyEnergyResp::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_Match_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_Match_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  CSGWGetMatchInfoReq::default_instance_ = new CSGWGetMatchInfoReq();
  CSGWInitMatchInfo::default_instance_ = new CSGWInitMatchInfo();
  BattleInfo::default_instance_ = new BattleInfo();
  CSGWFinalMatchInfo::default_instance_ = new CSGWFinalMatchInfo();
  CSGWGetMatchInfoResp::default_instance_ = new CSGWGetMatchInfoResp();
  CSGWMatchReq::default_instance_ = new CSGWMatchReq();
  GWPlayerInfo::default_instance_ = new GWPlayerInfo();
  CSGWMatchResp::default_instance_ = new CSGWMatchResp();
  CSGWMatchStopReq::default_instance_ = new CSGWMatchStopReq();
  CSGWMatchStopResp::default_instance_ = new CSGWMatchStopResp();
  CSGWGetRankReq::default_instance_ = new CSGWGetRankReq();
  RankInfo::default_instance_ = new RankInfo();
  CSGWGetRankResp::default_instance_ = new CSGWGetRankResp();
  CSGWBuyEnergyReq::default_instance_ = new CSGWBuyEnergyReq();
  CSGWBuyEnergyResp::default_instance_ = new CSGWBuyEnergyResp();
  CSGWGetMatchInfoReq::default_instance_->InitAsDefaultInstance();
  CSGWInitMatchInfo::default_instance_->InitAsDefaultInstance();
  BattleInfo::default_instance_->InitAsDefaultInstance();
  CSGWFinalMatchInfo::default_instance_->InitAsDefaultInstance();
  CSGWGetMatchInfoResp::default_instance_->InitAsDefaultInstance();
  CSGWMatchReq::default_instance_->InitAsDefaultInstance();
  GWPlayerInfo::default_instance_->InitAsDefaultInstance();
  CSGWMatchResp::default_instance_->InitAsDefaultInstance();
  CSGWMatchStopReq::default_instance_->InitAsDefaultInstance();
  CSGWMatchStopResp::default_instance_->InitAsDefaultInstance();
  CSGWGetRankReq::default_instance_->InitAsDefaultInstance();
  RankInfo::default_instance_->InitAsDefaultInstance();
  CSGWGetRankResp::default_instance_->InitAsDefaultInstance();
  CSGWBuyEnergyReq::default_instance_->InitAsDefaultInstance();
  CSGWBuyEnergyResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Match_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_Match_2eproto_once_);
void protobuf_AddDesc_Match_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_Match_2eproto_once_,
                 &protobuf_AddDesc_Match_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Match_2eproto {
  StaticDescriptorInitializer_Match_2eproto() {
    protobuf_AddDesc_Match_2eproto();
  }
} static_descriptor_initializer_Match_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSGWGetMatchInfoReq::CSGWGetMatchInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGWGetMatchInfoReq)
}

void CSGWGetMatchInfoReq::InitAsDefaultInstance() {
}

CSGWGetMatchInfoReq::CSGWGetMatchInfoReq(const CSGWGetMatchInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGWGetMatchInfoReq)
}

void CSGWGetMatchInfoReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGWGetMatchInfoReq::~CSGWGetMatchInfoReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGWGetMatchInfoReq)
  SharedDtor();
}

void CSGWGetMatchInfoReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGWGetMatchInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGWGetMatchInfoReq& CSGWGetMatchInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Match_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Match_2eproto();
#endif
  return *default_instance_;
}

CSGWGetMatchInfoReq* CSGWGetMatchInfoReq::default_instance_ = NULL;

CSGWGetMatchInfoReq* CSGWGetMatchInfoReq::New() const {
  return new CSGWGetMatchInfoReq;
}

void CSGWGetMatchInfoReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGWGetMatchInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGWGetMatchInfoReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGWGetMatchInfoReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGWGetMatchInfoReq)
  return false;
#undef DO_
}

void CSGWGetMatchInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGWGetMatchInfoReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGWGetMatchInfoReq)
}

int CSGWGetMatchInfoReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGWGetMatchInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGWGetMatchInfoReq*>(&from));
}

void CSGWGetMatchInfoReq::MergeFrom(const CSGWGetMatchInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGWGetMatchInfoReq::CopyFrom(const CSGWGetMatchInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGWGetMatchInfoReq::IsInitialized() const {

  return true;
}

void CSGWGetMatchInfoReq::Swap(CSGWGetMatchInfoReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGWGetMatchInfoReq::GetTypeName() const {
  return "fgame.CSGWGetMatchInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGWInitMatchInfo::kMatchScoreFieldNumber;
const int CSGWInitMatchInfo::kMatchRankFieldNumber;
const int CSGWInitMatchInfo::kMatchCountFieldNumber;
const int CSGWInitMatchInfo::kWinCountFieldNumber;
const int CSGWInitMatchInfo::kFinalMatchDayFieldNumber;
const int CSGWInitMatchInfo::kBaoziCountFieldNumber;
const int CSGWInitMatchInfo::kBuyCountFieldNumber;
const int CSGWInitMatchInfo::kStartTimeFieldNumber;
const int CSGWInitMatchInfo::kEndTimeFieldNumber;
const int CSGWInitMatchInfo::kMatchSeasonFieldNumber;
#endif  // !_MSC_VER

CSGWInitMatchInfo::CSGWInitMatchInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGWInitMatchInfo)
}

void CSGWInitMatchInfo::InitAsDefaultInstance() {
}

CSGWInitMatchInfo::CSGWInitMatchInfo(const CSGWInitMatchInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGWInitMatchInfo)
}

void CSGWInitMatchInfo::SharedCtor() {
  _cached_size_ = 0;
  matchscore_ = 0u;
  matchrank_ = 0u;
  matchcount_ = 0u;
  wincount_ = 0u;
  finalmatchday_ = 0u;
  baozicount_ = 0u;
  buycount_ = 0u;
  starttime_ = 0u;
  endtime_ = 0u;
  matchseason_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGWInitMatchInfo::~CSGWInitMatchInfo() {
  // @@protoc_insertion_point(destructor:fgame.CSGWInitMatchInfo)
  SharedDtor();
}

void CSGWInitMatchInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGWInitMatchInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGWInitMatchInfo& CSGWInitMatchInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Match_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Match_2eproto();
#endif
  return *default_instance_;
}

CSGWInitMatchInfo* CSGWInitMatchInfo::default_instance_ = NULL;

CSGWInitMatchInfo* CSGWInitMatchInfo::New() const {
  return new CSGWInitMatchInfo;
}

void CSGWInitMatchInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSGWInitMatchInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(matchscore_, starttime_);
  }
  ZR_(endtime_, matchseason_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGWInitMatchInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGWInitMatchInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 MatchScore = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &matchscore_)));
          set_has_matchscore();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_MatchRank;
        break;
      }

      // required uint32 MatchRank = 2;
      case 2: {
        if (tag == 16) {
         parse_MatchRank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &matchrank_)));
          set_has_matchrank();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_MatchCount;
        break;
      }

      // required uint32 MatchCount = 3;
      case 3: {
        if (tag == 24) {
         parse_MatchCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &matchcount_)));
          set_has_matchcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_WinCount;
        break;
      }

      // required uint32 WinCount = 4;
      case 4: {
        if (tag == 32) {
         parse_WinCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &wincount_)));
          set_has_wincount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_FinalMatchDay;
        break;
      }

      // required uint32 FinalMatchDay = 5;
      case 5: {
        if (tag == 40) {
         parse_FinalMatchDay:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &finalmatchday_)));
          set_has_finalmatchday();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_BaoziCount;
        break;
      }

      // required uint32 BaoziCount = 6;
      case 6: {
        if (tag == 48) {
         parse_BaoziCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &baozicount_)));
          set_has_baozicount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_BuyCount;
        break;
      }

      // required uint32 BuyCount = 7;
      case 7: {
        if (tag == 56) {
         parse_BuyCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buycount_)));
          set_has_buycount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_StartTime;
        break;
      }

      // required uint32 StartTime = 8;
      case 8: {
        if (tag == 64) {
         parse_StartTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &starttime_)));
          set_has_starttime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_EndTime;
        break;
      }

      // required uint32 EndTime = 9;
      case 9: {
        if (tag == 72) {
         parse_EndTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endtime_)));
          set_has_endtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_MatchSeason;
        break;
      }

      // required uint32 MatchSeason = 10;
      case 10: {
        if (tag == 80) {
         parse_MatchSeason:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &matchseason_)));
          set_has_matchseason();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGWInitMatchInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGWInitMatchInfo)
  return false;
#undef DO_
}

void CSGWInitMatchInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGWInitMatchInfo)
  // required uint32 MatchScore = 1;
  if (has_matchscore()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->matchscore(), output);
  }

  // required uint32 MatchRank = 2;
  if (has_matchrank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->matchrank(), output);
  }

  // required uint32 MatchCount = 3;
  if (has_matchcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->matchcount(), output);
  }

  // required uint32 WinCount = 4;
  if (has_wincount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->wincount(), output);
  }

  // required uint32 FinalMatchDay = 5;
  if (has_finalmatchday()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->finalmatchday(), output);
  }

  // required uint32 BaoziCount = 6;
  if (has_baozicount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->baozicount(), output);
  }

  // required uint32 BuyCount = 7;
  if (has_buycount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->buycount(), output);
  }

  // required uint32 StartTime = 8;
  if (has_starttime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->starttime(), output);
  }

  // required uint32 EndTime = 9;
  if (has_endtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->endtime(), output);
  }

  // required uint32 MatchSeason = 10;
  if (has_matchseason()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->matchseason(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGWInitMatchInfo)
}

int CSGWInitMatchInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 MatchScore = 1;
    if (has_matchscore()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->matchscore());
    }

    // required uint32 MatchRank = 2;
    if (has_matchrank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->matchrank());
    }

    // required uint32 MatchCount = 3;
    if (has_matchcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->matchcount());
    }

    // required uint32 WinCount = 4;
    if (has_wincount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->wincount());
    }

    // required uint32 FinalMatchDay = 5;
    if (has_finalmatchday()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->finalmatchday());
    }

    // required uint32 BaoziCount = 6;
    if (has_baozicount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->baozicount());
    }

    // required uint32 BuyCount = 7;
    if (has_buycount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buycount());
    }

    // required uint32 StartTime = 8;
    if (has_starttime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->starttime());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 EndTime = 9;
    if (has_endtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endtime());
    }

    // required uint32 MatchSeason = 10;
    if (has_matchseason()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->matchseason());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGWInitMatchInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGWInitMatchInfo*>(&from));
}

void CSGWInitMatchInfo::MergeFrom(const CSGWInitMatchInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_matchscore()) {
      set_matchscore(from.matchscore());
    }
    if (from.has_matchrank()) {
      set_matchrank(from.matchrank());
    }
    if (from.has_matchcount()) {
      set_matchcount(from.matchcount());
    }
    if (from.has_wincount()) {
      set_wincount(from.wincount());
    }
    if (from.has_finalmatchday()) {
      set_finalmatchday(from.finalmatchday());
    }
    if (from.has_baozicount()) {
      set_baozicount(from.baozicount());
    }
    if (from.has_buycount()) {
      set_buycount(from.buycount());
    }
    if (from.has_starttime()) {
      set_starttime(from.starttime());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_endtime()) {
      set_endtime(from.endtime());
    }
    if (from.has_matchseason()) {
      set_matchseason(from.matchseason());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGWInitMatchInfo::CopyFrom(const CSGWInitMatchInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGWInitMatchInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x000003ff) != 0x000003ff) return false;

  return true;
}

void CSGWInitMatchInfo::Swap(CSGWInitMatchInfo* other) {
  if (other != this) {
    std::swap(matchscore_, other->matchscore_);
    std::swap(matchrank_, other->matchrank_);
    std::swap(matchcount_, other->matchcount_);
    std::swap(wincount_, other->wincount_);
    std::swap(finalmatchday_, other->finalmatchday_);
    std::swap(baozicount_, other->baozicount_);
    std::swap(buycount_, other->buycount_);
    std::swap(starttime_, other->starttime_);
    std::swap(endtime_, other->endtime_);
    std::swap(matchseason_, other->matchseason_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGWInitMatchInfo::GetTypeName() const {
  return "fgame.CSGWInitMatchInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int BattleInfo::kPlayerNameAFieldNumber;
const int BattleInfo::kPlayerNameBFieldNumber;
#endif  // !_MSC_VER

BattleInfo::BattleInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.BattleInfo)
}

void BattleInfo::InitAsDefaultInstance() {
}

BattleInfo::BattleInfo(const BattleInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.BattleInfo)
}

void BattleInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  playernamea_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  playernameb_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleInfo::~BattleInfo() {
  // @@protoc_insertion_point(destructor:fgame.BattleInfo)
  SharedDtor();
}

void BattleInfo::SharedDtor() {
  if (playernamea_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete playernamea_;
  }
  if (playernameb_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete playernameb_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleInfo& BattleInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Match_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Match_2eproto();
#endif
  return *default_instance_;
}

BattleInfo* BattleInfo::default_instance_ = NULL;

BattleInfo* BattleInfo::New() const {
  return new BattleInfo;
}

void BattleInfo::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_playernamea()) {
      if (playernamea_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        playernamea_->clear();
      }
    }
    if (has_playernameb()) {
      if (playernameb_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        playernameb_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BattleInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.BattleInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string PlayerNameA = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_playernamea()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_PlayerNameB;
        break;
      }

      // required string PlayerNameB = 2;
      case 2: {
        if (tag == 18) {
         parse_PlayerNameB:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_playernameb()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.BattleInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.BattleInfo)
  return false;
#undef DO_
}

void BattleInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.BattleInfo)
  // required string PlayerNameA = 1;
  if (has_playernamea()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->playernamea(), output);
  }

  // required string PlayerNameB = 2;
  if (has_playernameb()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->playernameb(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.BattleInfo)
}

int BattleInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string PlayerNameA = 1;
    if (has_playernamea()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->playernamea());
    }

    // required string PlayerNameB = 2;
    if (has_playernameb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->playernameb());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleInfo*>(&from));
}

void BattleInfo::MergeFrom(const BattleInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_playernamea()) {
      set_playernamea(from.playernamea());
    }
    if (from.has_playernameb()) {
      set_playernameb(from.playernameb());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BattleInfo::CopyFrom(const BattleInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BattleInfo::Swap(BattleInfo* other) {
  if (other != this) {
    std::swap(playernamea_, other->playernamea_);
    std::swap(playernameb_, other->playernameb_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleInfo::GetTypeName() const {
  return "fgame.BattleInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGWFinalMatchInfo::kBattleListAFieldNumber;
const int CSGWFinalMatchInfo::kBattleListBFieldNumber;
const int CSGWFinalMatchInfo::kStartTimeFieldNumber;
const int CSGWFinalMatchInfo::kEndTimeFieldNumber;
#endif  // !_MSC_VER

CSGWFinalMatchInfo::CSGWFinalMatchInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGWFinalMatchInfo)
}

void CSGWFinalMatchInfo::InitAsDefaultInstance() {
}

CSGWFinalMatchInfo::CSGWFinalMatchInfo(const CSGWFinalMatchInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGWFinalMatchInfo)
}

void CSGWFinalMatchInfo::SharedCtor() {
  _cached_size_ = 0;
  starttime_ = 0u;
  endtime_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGWFinalMatchInfo::~CSGWFinalMatchInfo() {
  // @@protoc_insertion_point(destructor:fgame.CSGWFinalMatchInfo)
  SharedDtor();
}

void CSGWFinalMatchInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGWFinalMatchInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGWFinalMatchInfo& CSGWFinalMatchInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Match_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Match_2eproto();
#endif
  return *default_instance_;
}

CSGWFinalMatchInfo* CSGWFinalMatchInfo::default_instance_ = NULL;

CSGWFinalMatchInfo* CSGWFinalMatchInfo::New() const {
  return new CSGWFinalMatchInfo;
}

void CSGWFinalMatchInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSGWFinalMatchInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(starttime_, endtime_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  battlelista_.Clear();
  battlelistb_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGWFinalMatchInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGWFinalMatchInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.BattleInfo BattleListA = 1;
      case 1: {
        if (tag == 10) {
         parse_BattleListA:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_battlelista()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_BattleListA;
        if (input->ExpectTag(18)) goto parse_BattleListB;
        break;
      }

      // repeated .fgame.BattleInfo BattleListB = 2;
      case 2: {
        if (tag == 18) {
         parse_BattleListB:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_battlelistb()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_BattleListB;
        if (input->ExpectTag(24)) goto parse_StartTime;
        break;
      }

      // required uint32 StartTime = 3;
      case 3: {
        if (tag == 24) {
         parse_StartTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &starttime_)));
          set_has_starttime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_EndTime;
        break;
      }

      // required uint32 EndTime = 4;
      case 4: {
        if (tag == 32) {
         parse_EndTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endtime_)));
          set_has_endtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGWFinalMatchInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGWFinalMatchInfo)
  return false;
#undef DO_
}

void CSGWFinalMatchInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGWFinalMatchInfo)
  // repeated .fgame.BattleInfo BattleListA = 1;
  for (int i = 0; i < this->battlelista_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->battlelista(i), output);
  }

  // repeated .fgame.BattleInfo BattleListB = 2;
  for (int i = 0; i < this->battlelistb_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->battlelistb(i), output);
  }

  // required uint32 StartTime = 3;
  if (has_starttime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->starttime(), output);
  }

  // required uint32 EndTime = 4;
  if (has_endtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->endtime(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGWFinalMatchInfo)
}

int CSGWFinalMatchInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // required uint32 StartTime = 3;
    if (has_starttime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->starttime());
    }

    // required uint32 EndTime = 4;
    if (has_endtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endtime());
    }

  }
  // repeated .fgame.BattleInfo BattleListA = 1;
  total_size += 1 * this->battlelista_size();
  for (int i = 0; i < this->battlelista_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->battlelista(i));
  }

  // repeated .fgame.BattleInfo BattleListB = 2;
  total_size += 1 * this->battlelistb_size();
  for (int i = 0; i < this->battlelistb_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->battlelistb(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGWFinalMatchInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGWFinalMatchInfo*>(&from));
}

void CSGWFinalMatchInfo::MergeFrom(const CSGWFinalMatchInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  battlelista_.MergeFrom(from.battlelista_);
  battlelistb_.MergeFrom(from.battlelistb_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_starttime()) {
      set_starttime(from.starttime());
    }
    if (from.has_endtime()) {
      set_endtime(from.endtime());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGWFinalMatchInfo::CopyFrom(const CSGWFinalMatchInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGWFinalMatchInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000c) != 0x0000000c) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->battlelista())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->battlelistb())) return false;
  return true;
}

void CSGWFinalMatchInfo::Swap(CSGWFinalMatchInfo* other) {
  if (other != this) {
    battlelista_.Swap(&other->battlelista_);
    battlelistb_.Swap(&other->battlelistb_);
    std::swap(starttime_, other->starttime_);
    std::swap(endtime_, other->endtime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGWFinalMatchInfo::GetTypeName() const {
  return "fgame.CSGWFinalMatchInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGWGetMatchInfoResp::kMatchStateFieldNumber;
const int CSGWGetMatchInfoResp::kInitMatchInfoFieldNumber;
const int CSGWGetMatchInfoResp::kFinalMatchInfoFieldNumber;
#endif  // !_MSC_VER

CSGWGetMatchInfoResp::CSGWGetMatchInfoResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGWGetMatchInfoResp)
}

void CSGWGetMatchInfoResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  initmatchinfo_ = const_cast< ::fgame::CSGWInitMatchInfo*>(
      ::fgame::CSGWInitMatchInfo::internal_default_instance());
#else
  initmatchinfo_ = const_cast< ::fgame::CSGWInitMatchInfo*>(&::fgame::CSGWInitMatchInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  finalmatchinfo_ = const_cast< ::fgame::CSGWFinalMatchInfo*>(
      ::fgame::CSGWFinalMatchInfo::internal_default_instance());
#else
  finalmatchinfo_ = const_cast< ::fgame::CSGWFinalMatchInfo*>(&::fgame::CSGWFinalMatchInfo::default_instance());
#endif
}

CSGWGetMatchInfoResp::CSGWGetMatchInfoResp(const CSGWGetMatchInfoResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGWGetMatchInfoResp)
}

void CSGWGetMatchInfoResp::SharedCtor() {
  _cached_size_ = 0;
  matchstate_ = 0u;
  initmatchinfo_ = NULL;
  finalmatchinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGWGetMatchInfoResp::~CSGWGetMatchInfoResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGWGetMatchInfoResp)
  SharedDtor();
}

void CSGWGetMatchInfoResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete initmatchinfo_;
    delete finalmatchinfo_;
  }
}

void CSGWGetMatchInfoResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGWGetMatchInfoResp& CSGWGetMatchInfoResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Match_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Match_2eproto();
#endif
  return *default_instance_;
}

CSGWGetMatchInfoResp* CSGWGetMatchInfoResp::default_instance_ = NULL;

CSGWGetMatchInfoResp* CSGWGetMatchInfoResp::New() const {
  return new CSGWGetMatchInfoResp;
}

void CSGWGetMatchInfoResp::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    matchstate_ = 0u;
    if (has_initmatchinfo()) {
      if (initmatchinfo_ != NULL) initmatchinfo_->::fgame::CSGWInitMatchInfo::Clear();
    }
    if (has_finalmatchinfo()) {
      if (finalmatchinfo_ != NULL) finalmatchinfo_->::fgame::CSGWFinalMatchInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGWGetMatchInfoResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGWGetMatchInfoResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 MatchState = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &matchstate_)));
          set_has_matchstate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_InitMatchInfo;
        break;
      }

      // optional .fgame.CSGWInitMatchInfo InitMatchInfo = 2;
      case 2: {
        if (tag == 18) {
         parse_InitMatchInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_initmatchinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_FinalMatchInfo;
        break;
      }

      // optional .fgame.CSGWFinalMatchInfo FinalMatchInfo = 3;
      case 3: {
        if (tag == 26) {
         parse_FinalMatchInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_finalmatchinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGWGetMatchInfoResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGWGetMatchInfoResp)
  return false;
#undef DO_
}

void CSGWGetMatchInfoResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGWGetMatchInfoResp)
  // required uint32 MatchState = 1;
  if (has_matchstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->matchstate(), output);
  }

  // optional .fgame.CSGWInitMatchInfo InitMatchInfo = 2;
  if (has_initmatchinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->initmatchinfo(), output);
  }

  // optional .fgame.CSGWFinalMatchInfo FinalMatchInfo = 3;
  if (has_finalmatchinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->finalmatchinfo(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGWGetMatchInfoResp)
}

int CSGWGetMatchInfoResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 MatchState = 1;
    if (has_matchstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->matchstate());
    }

    // optional .fgame.CSGWInitMatchInfo InitMatchInfo = 2;
    if (has_initmatchinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->initmatchinfo());
    }

    // optional .fgame.CSGWFinalMatchInfo FinalMatchInfo = 3;
    if (has_finalmatchinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->finalmatchinfo());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGWGetMatchInfoResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGWGetMatchInfoResp*>(&from));
}

void CSGWGetMatchInfoResp::MergeFrom(const CSGWGetMatchInfoResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_matchstate()) {
      set_matchstate(from.matchstate());
    }
    if (from.has_initmatchinfo()) {
      mutable_initmatchinfo()->::fgame::CSGWInitMatchInfo::MergeFrom(from.initmatchinfo());
    }
    if (from.has_finalmatchinfo()) {
      mutable_finalmatchinfo()->::fgame::CSGWFinalMatchInfo::MergeFrom(from.finalmatchinfo());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGWGetMatchInfoResp::CopyFrom(const CSGWGetMatchInfoResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGWGetMatchInfoResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_initmatchinfo()) {
    if (!this->initmatchinfo().IsInitialized()) return false;
  }
  if (has_finalmatchinfo()) {
    if (!this->finalmatchinfo().IsInitialized()) return false;
  }
  return true;
}

void CSGWGetMatchInfoResp::Swap(CSGWGetMatchInfoResp* other) {
  if (other != this) {
    std::swap(matchstate_, other->matchstate_);
    std::swap(initmatchinfo_, other->initmatchinfo_);
    std::swap(finalmatchinfo_, other->finalmatchinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGWGetMatchInfoResp::GetTypeName() const {
  return "fgame.CSGWGetMatchInfoResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSGWMatchReq::CSGWMatchReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGWMatchReq)
}

void CSGWMatchReq::InitAsDefaultInstance() {
}

CSGWMatchReq::CSGWMatchReq(const CSGWMatchReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGWMatchReq)
}

void CSGWMatchReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGWMatchReq::~CSGWMatchReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGWMatchReq)
  SharedDtor();
}

void CSGWMatchReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGWMatchReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGWMatchReq& CSGWMatchReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Match_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Match_2eproto();
#endif
  return *default_instance_;
}

CSGWMatchReq* CSGWMatchReq::default_instance_ = NULL;

CSGWMatchReq* CSGWMatchReq::New() const {
  return new CSGWMatchReq;
}

void CSGWMatchReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGWMatchReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGWMatchReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGWMatchReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGWMatchReq)
  return false;
#undef DO_
}

void CSGWMatchReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGWMatchReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGWMatchReq)
}

int CSGWMatchReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGWMatchReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGWMatchReq*>(&from));
}

void CSGWMatchReq::MergeFrom(const CSGWMatchReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGWMatchReq::CopyFrom(const CSGWMatchReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGWMatchReq::IsInitialized() const {

  return true;
}

void CSGWMatchReq::Swap(CSGWMatchReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGWMatchReq::GetTypeName() const {
  return "fgame.CSGWMatchReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GWPlayerInfo::kUinFieldNumber;
const int GWPlayerInfo::kNameFieldNumber;
const int GWPlayerInfo::kIconFieldNumber;
const int GWPlayerInfo::kScoreFieldNumber;
const int GWPlayerInfo::kRankFieldNumber;
#endif  // !_MSC_VER

GWPlayerInfo::GWPlayerInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.GWPlayerInfo)
}

void GWPlayerInfo::InitAsDefaultInstance() {
}

GWPlayerInfo::GWPlayerInfo(const GWPlayerInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.GWPlayerInfo)
}

void GWPlayerInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  uin_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  score_ = 0u;
  rank_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GWPlayerInfo::~GWPlayerInfo() {
  // @@protoc_insertion_point(destructor:fgame.GWPlayerInfo)
  SharedDtor();
}

void GWPlayerInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GWPlayerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GWPlayerInfo& GWPlayerInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Match_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Match_2eproto();
#endif
  return *default_instance_;
}

GWPlayerInfo* GWPlayerInfo::default_instance_ = NULL;

GWPlayerInfo* GWPlayerInfo::New() const {
  return new GWPlayerInfo;
}

void GWPlayerInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GWPlayerInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(uin_, score_);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_icon()) {
      if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        icon_->clear();
      }
    }
    rank_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GWPlayerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.GWPlayerInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Name;
        break;
      }

      // required string Name = 2;
      case 2: {
        if (tag == 18) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_Icon;
        break;
      }

      // optional string Icon = 3;
      case 3: {
        if (tag == 26) {
         parse_Icon:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_icon()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Score;
        break;
      }

      // optional uint32 Score = 4;
      case 4: {
        if (tag == 32) {
         parse_Score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_Rank;
        break;
      }

      // optional uint32 Rank = 5;
      case 5: {
        if (tag == 40) {
         parse_Rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_)));
          set_has_rank();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.GWPlayerInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.GWPlayerInfo)
  return false;
#undef DO_
}

void GWPlayerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.GWPlayerInfo)
  // required uint32 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uin(), output);
  }

  // required string Name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional string Icon = 3;
  if (has_icon()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->icon(), output);
  }

  // optional uint32 Score = 4;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->score(), output);
  }

  // optional uint32 Rank = 5;
  if (has_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->rank(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.GWPlayerInfo)
}

int GWPlayerInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uin());
    }

    // required string Name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string Icon = 3;
    if (has_icon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->icon());
    }

    // optional uint32 Score = 4;
    if (has_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->score());
    }

    // optional uint32 Rank = 5;
    if (has_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GWPlayerInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GWPlayerInfo*>(&from));
}

void GWPlayerInfo::MergeFrom(const GWPlayerInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_icon()) {
      set_icon(from.icon());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
    if (from.has_rank()) {
      set_rank(from.rank());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GWPlayerInfo::CopyFrom(const GWPlayerInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GWPlayerInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GWPlayerInfo::Swap(GWPlayerInfo* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(name_, other->name_);
    std::swap(icon_, other->icon_);
    std::swap(score_, other->score_);
    std::swap(rank_, other->rank_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GWPlayerInfo::GetTypeName() const {
  return "fgame.GWPlayerInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGWMatchResp::kOpponentPlayerFieldNumber;
#endif  // !_MSC_VER

CSGWMatchResp::CSGWMatchResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGWMatchResp)
}

void CSGWMatchResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  opponentplayer_ = const_cast< ::fgame::GWPlayerInfo*>(
      ::fgame::GWPlayerInfo::internal_default_instance());
#else
  opponentplayer_ = const_cast< ::fgame::GWPlayerInfo*>(&::fgame::GWPlayerInfo::default_instance());
#endif
}

CSGWMatchResp::CSGWMatchResp(const CSGWMatchResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGWMatchResp)
}

void CSGWMatchResp::SharedCtor() {
  _cached_size_ = 0;
  opponentplayer_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGWMatchResp::~CSGWMatchResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGWMatchResp)
  SharedDtor();
}

void CSGWMatchResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete opponentplayer_;
  }
}

void CSGWMatchResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGWMatchResp& CSGWMatchResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Match_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Match_2eproto();
#endif
  return *default_instance_;
}

CSGWMatchResp* CSGWMatchResp::default_instance_ = NULL;

CSGWMatchResp* CSGWMatchResp::New() const {
  return new CSGWMatchResp;
}

void CSGWMatchResp::Clear() {
  if (has_opponentplayer()) {
    if (opponentplayer_ != NULL) opponentplayer_->::fgame::GWPlayerInfo::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGWMatchResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGWMatchResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .fgame.GWPlayerInfo OpponentPlayer = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_opponentplayer()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGWMatchResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGWMatchResp)
  return false;
#undef DO_
}

void CSGWMatchResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGWMatchResp)
  // required .fgame.GWPlayerInfo OpponentPlayer = 1;
  if (has_opponentplayer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->opponentplayer(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGWMatchResp)
}

int CSGWMatchResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .fgame.GWPlayerInfo OpponentPlayer = 1;
    if (has_opponentplayer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->opponentplayer());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGWMatchResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGWMatchResp*>(&from));
}

void CSGWMatchResp::MergeFrom(const CSGWMatchResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_opponentplayer()) {
      mutable_opponentplayer()->::fgame::GWPlayerInfo::MergeFrom(from.opponentplayer());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGWMatchResp::CopyFrom(const CSGWMatchResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGWMatchResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_opponentplayer()) {
    if (!this->opponentplayer().IsInitialized()) return false;
  }
  return true;
}

void CSGWMatchResp::Swap(CSGWMatchResp* other) {
  if (other != this) {
    std::swap(opponentplayer_, other->opponentplayer_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGWMatchResp::GetTypeName() const {
  return "fgame.CSGWMatchResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSGWMatchStopReq::CSGWMatchStopReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGWMatchStopReq)
}

void CSGWMatchStopReq::InitAsDefaultInstance() {
}

CSGWMatchStopReq::CSGWMatchStopReq(const CSGWMatchStopReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGWMatchStopReq)
}

void CSGWMatchStopReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGWMatchStopReq::~CSGWMatchStopReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGWMatchStopReq)
  SharedDtor();
}

void CSGWMatchStopReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGWMatchStopReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGWMatchStopReq& CSGWMatchStopReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Match_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Match_2eproto();
#endif
  return *default_instance_;
}

CSGWMatchStopReq* CSGWMatchStopReq::default_instance_ = NULL;

CSGWMatchStopReq* CSGWMatchStopReq::New() const {
  return new CSGWMatchStopReq;
}

void CSGWMatchStopReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGWMatchStopReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGWMatchStopReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGWMatchStopReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGWMatchStopReq)
  return false;
#undef DO_
}

void CSGWMatchStopReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGWMatchStopReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGWMatchStopReq)
}

int CSGWMatchStopReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGWMatchStopReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGWMatchStopReq*>(&from));
}

void CSGWMatchStopReq::MergeFrom(const CSGWMatchStopReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGWMatchStopReq::CopyFrom(const CSGWMatchStopReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGWMatchStopReq::IsInitialized() const {

  return true;
}

void CSGWMatchStopReq::Swap(CSGWMatchStopReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGWMatchStopReq::GetTypeName() const {
  return "fgame.CSGWMatchStopReq";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSGWMatchStopResp::CSGWMatchStopResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGWMatchStopResp)
}

void CSGWMatchStopResp::InitAsDefaultInstance() {
}

CSGWMatchStopResp::CSGWMatchStopResp(const CSGWMatchStopResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGWMatchStopResp)
}

void CSGWMatchStopResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGWMatchStopResp::~CSGWMatchStopResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGWMatchStopResp)
  SharedDtor();
}

void CSGWMatchStopResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGWMatchStopResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGWMatchStopResp& CSGWMatchStopResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Match_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Match_2eproto();
#endif
  return *default_instance_;
}

CSGWMatchStopResp* CSGWMatchStopResp::default_instance_ = NULL;

CSGWMatchStopResp* CSGWMatchStopResp::New() const {
  return new CSGWMatchStopResp;
}

void CSGWMatchStopResp::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGWMatchStopResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGWMatchStopResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGWMatchStopResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGWMatchStopResp)
  return false;
#undef DO_
}

void CSGWMatchStopResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGWMatchStopResp)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGWMatchStopResp)
}

int CSGWMatchStopResp::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGWMatchStopResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGWMatchStopResp*>(&from));
}

void CSGWMatchStopResp::MergeFrom(const CSGWMatchStopResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGWMatchStopResp::CopyFrom(const CSGWMatchStopResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGWMatchStopResp::IsInitialized() const {

  return true;
}

void CSGWMatchStopResp::Swap(CSGWMatchStopResp* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGWMatchStopResp::GetTypeName() const {
  return "fgame.CSGWMatchStopResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSGWGetRankReq::CSGWGetRankReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGWGetRankReq)
}

void CSGWGetRankReq::InitAsDefaultInstance() {
}

CSGWGetRankReq::CSGWGetRankReq(const CSGWGetRankReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGWGetRankReq)
}

void CSGWGetRankReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGWGetRankReq::~CSGWGetRankReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGWGetRankReq)
  SharedDtor();
}

void CSGWGetRankReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGWGetRankReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGWGetRankReq& CSGWGetRankReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Match_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Match_2eproto();
#endif
  return *default_instance_;
}

CSGWGetRankReq* CSGWGetRankReq::default_instance_ = NULL;

CSGWGetRankReq* CSGWGetRankReq::New() const {
  return new CSGWGetRankReq;
}

void CSGWGetRankReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGWGetRankReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGWGetRankReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGWGetRankReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGWGetRankReq)
  return false;
#undef DO_
}

void CSGWGetRankReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGWGetRankReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGWGetRankReq)
}

int CSGWGetRankReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGWGetRankReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGWGetRankReq*>(&from));
}

void CSGWGetRankReq::MergeFrom(const CSGWGetRankReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGWGetRankReq::CopyFrom(const CSGWGetRankReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGWGetRankReq::IsInitialized() const {

  return true;
}

void CSGWGetRankReq::Swap(CSGWGetRankReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGWGetRankReq::GetTypeName() const {
  return "fgame.CSGWGetRankReq";
}


// ===================================================================

#ifndef _MSC_VER
const int RankInfo::kUinFieldNumber;
const int RankInfo::kNameFieldNumber;
const int RankInfo::kRankFieldNumber;
const int RankInfo::kScoreFieldNumber;
const int RankInfo::kGameTimesFieldNumber;
const int RankInfo::kWinTimesFieldNumber;
const int RankInfo::kIconFieldNumber;
#endif  // !_MSC_VER

RankInfo::RankInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.RankInfo)
}

void RankInfo::InitAsDefaultInstance() {
}

RankInfo::RankInfo(const RankInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.RankInfo)
}

void RankInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  uin_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  rank_ = 0u;
  score_ = 0u;
  gametimes_ = 0u;
  wintimes_ = 0u;
  icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RankInfo::~RankInfo() {
  // @@protoc_insertion_point(destructor:fgame.RankInfo)
  SharedDtor();
}

void RankInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RankInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RankInfo& RankInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Match_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Match_2eproto();
#endif
  return *default_instance_;
}

RankInfo* RankInfo::default_instance_ = NULL;

RankInfo* RankInfo::New() const {
  return new RankInfo;
}

void RankInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RankInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(uin_, gametimes_);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    wintimes_ = 0u;
    if (has_icon()) {
      if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        icon_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RankInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.RankInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Name;
        break;
      }

      // required string Name = 2;
      case 2: {
        if (tag == 18) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Rank;
        break;
      }

      // required uint32 Rank = 3;
      case 3: {
        if (tag == 24) {
         parse_Rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_)));
          set_has_rank();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Score;
        break;
      }

      // required uint32 Score = 4;
      case 4: {
        if (tag == 32) {
         parse_Score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_GameTimes;
        break;
      }

      // required uint32 GameTimes = 5;
      case 5: {
        if (tag == 40) {
         parse_GameTimes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gametimes_)));
          set_has_gametimes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_WinTimes;
        break;
      }

      // required uint32 WinTimes = 6;
      case 6: {
        if (tag == 48) {
         parse_WinTimes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &wintimes_)));
          set_has_wintimes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_Icon;
        break;
      }

      // optional string Icon = 7;
      case 7: {
        if (tag == 58) {
         parse_Icon:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_icon()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.RankInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.RankInfo)
  return false;
#undef DO_
}

void RankInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.RankInfo)
  // required uint32 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uin(), output);
  }

  // required string Name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // required uint32 Rank = 3;
  if (has_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->rank(), output);
  }

  // required uint32 Score = 4;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->score(), output);
  }

  // required uint32 GameTimes = 5;
  if (has_gametimes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->gametimes(), output);
  }

  // required uint32 WinTimes = 6;
  if (has_wintimes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->wintimes(), output);
  }

  // optional string Icon = 7;
  if (has_icon()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->icon(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.RankInfo)
}

int RankInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uin());
    }

    // required string Name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required uint32 Rank = 3;
    if (has_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank());
    }

    // required uint32 Score = 4;
    if (has_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->score());
    }

    // required uint32 GameTimes = 5;
    if (has_gametimes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gametimes());
    }

    // required uint32 WinTimes = 6;
    if (has_wintimes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->wintimes());
    }

    // optional string Icon = 7;
    if (has_icon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->icon());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RankInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RankInfo*>(&from));
}

void RankInfo::MergeFrom(const RankInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_rank()) {
      set_rank(from.rank());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
    if (from.has_gametimes()) {
      set_gametimes(from.gametimes());
    }
    if (from.has_wintimes()) {
      set_wintimes(from.wintimes());
    }
    if (from.has_icon()) {
      set_icon(from.icon());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RankInfo::CopyFrom(const RankInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RankInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void RankInfo::Swap(RankInfo* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(name_, other->name_);
    std::swap(rank_, other->rank_);
    std::swap(score_, other->score_);
    std::swap(gametimes_, other->gametimes_);
    std::swap(wintimes_, other->wintimes_);
    std::swap(icon_, other->icon_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RankInfo::GetTypeName() const {
  return "fgame.RankInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGWGetRankResp::kListFieldNumber;
#endif  // !_MSC_VER

CSGWGetRankResp::CSGWGetRankResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGWGetRankResp)
}

void CSGWGetRankResp::InitAsDefaultInstance() {
}

CSGWGetRankResp::CSGWGetRankResp(const CSGWGetRankResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGWGetRankResp)
}

void CSGWGetRankResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGWGetRankResp::~CSGWGetRankResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGWGetRankResp)
  SharedDtor();
}

void CSGWGetRankResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGWGetRankResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGWGetRankResp& CSGWGetRankResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Match_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Match_2eproto();
#endif
  return *default_instance_;
}

CSGWGetRankResp* CSGWGetRankResp::default_instance_ = NULL;

CSGWGetRankResp* CSGWGetRankResp::New() const {
  return new CSGWGetRankResp;
}

void CSGWGetRankResp::Clear() {
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGWGetRankResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGWGetRankResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.RankInfo List = 1;
      case 1: {
        if (tag == 10) {
         parse_List:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_List;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGWGetRankResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGWGetRankResp)
  return false;
#undef DO_
}

void CSGWGetRankResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGWGetRankResp)
  // repeated .fgame.RankInfo List = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGWGetRankResp)
}

int CSGWGetRankResp::ByteSize() const {
  int total_size = 0;

  // repeated .fgame.RankInfo List = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGWGetRankResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGWGetRankResp*>(&from));
}

void CSGWGetRankResp::MergeFrom(const CSGWGetRankResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGWGetRankResp::CopyFrom(const CSGWGetRankResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGWGetRankResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->list())) return false;
  return true;
}

void CSGWGetRankResp::Swap(CSGWGetRankResp* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGWGetRankResp::GetTypeName() const {
  return "fgame.CSGWGetRankResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSGWBuyEnergyReq::CSGWBuyEnergyReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGWBuyEnergyReq)
}

void CSGWBuyEnergyReq::InitAsDefaultInstance() {
}

CSGWBuyEnergyReq::CSGWBuyEnergyReq(const CSGWBuyEnergyReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGWBuyEnergyReq)
}

void CSGWBuyEnergyReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGWBuyEnergyReq::~CSGWBuyEnergyReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGWBuyEnergyReq)
  SharedDtor();
}

void CSGWBuyEnergyReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGWBuyEnergyReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGWBuyEnergyReq& CSGWBuyEnergyReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Match_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Match_2eproto();
#endif
  return *default_instance_;
}

CSGWBuyEnergyReq* CSGWBuyEnergyReq::default_instance_ = NULL;

CSGWBuyEnergyReq* CSGWBuyEnergyReq::New() const {
  return new CSGWBuyEnergyReq;
}

void CSGWBuyEnergyReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGWBuyEnergyReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGWBuyEnergyReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGWBuyEnergyReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGWBuyEnergyReq)
  return false;
#undef DO_
}

void CSGWBuyEnergyReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGWBuyEnergyReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGWBuyEnergyReq)
}

int CSGWBuyEnergyReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGWBuyEnergyReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGWBuyEnergyReq*>(&from));
}

void CSGWBuyEnergyReq::MergeFrom(const CSGWBuyEnergyReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGWBuyEnergyReq::CopyFrom(const CSGWBuyEnergyReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGWBuyEnergyReq::IsInitialized() const {

  return true;
}

void CSGWBuyEnergyReq::Swap(CSGWBuyEnergyReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGWBuyEnergyReq::GetTypeName() const {
  return "fgame.CSGWBuyEnergyReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGWBuyEnergyResp::kEnergyFieldNumber;
const int CSGWBuyEnergyResp::kBuyTimesFieldNumber;
#endif  // !_MSC_VER

CSGWBuyEnergyResp::CSGWBuyEnergyResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGWBuyEnergyResp)
}

void CSGWBuyEnergyResp::InitAsDefaultInstance() {
}

CSGWBuyEnergyResp::CSGWBuyEnergyResp(const CSGWBuyEnergyResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGWBuyEnergyResp)
}

void CSGWBuyEnergyResp::SharedCtor() {
  _cached_size_ = 0;
  energy_ = 0u;
  buytimes_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGWBuyEnergyResp::~CSGWBuyEnergyResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGWBuyEnergyResp)
  SharedDtor();
}

void CSGWBuyEnergyResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGWBuyEnergyResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGWBuyEnergyResp& CSGWBuyEnergyResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Match_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Match_2eproto();
#endif
  return *default_instance_;
}

CSGWBuyEnergyResp* CSGWBuyEnergyResp::default_instance_ = NULL;

CSGWBuyEnergyResp* CSGWBuyEnergyResp::New() const {
  return new CSGWBuyEnergyResp;
}

void CSGWBuyEnergyResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSGWBuyEnergyResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(energy_, buytimes_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGWBuyEnergyResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGWBuyEnergyResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Energy = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &energy_)));
          set_has_energy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_BuyTimes;
        break;
      }

      // required uint32 BuyTimes = 2;
      case 2: {
        if (tag == 16) {
         parse_BuyTimes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buytimes_)));
          set_has_buytimes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGWBuyEnergyResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGWBuyEnergyResp)
  return false;
#undef DO_
}

void CSGWBuyEnergyResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGWBuyEnergyResp)
  // required uint32 Energy = 1;
  if (has_energy()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->energy(), output);
  }

  // required uint32 BuyTimes = 2;
  if (has_buytimes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->buytimes(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGWBuyEnergyResp)
}

int CSGWBuyEnergyResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Energy = 1;
    if (has_energy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->energy());
    }

    // required uint32 BuyTimes = 2;
    if (has_buytimes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buytimes());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGWBuyEnergyResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGWBuyEnergyResp*>(&from));
}

void CSGWBuyEnergyResp::MergeFrom(const CSGWBuyEnergyResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_energy()) {
      set_energy(from.energy());
    }
    if (from.has_buytimes()) {
      set_buytimes(from.buytimes());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGWBuyEnergyResp::CopyFrom(const CSGWBuyEnergyResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGWBuyEnergyResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSGWBuyEnergyResp::Swap(CSGWBuyEnergyResp* other) {
  if (other != this) {
    std::swap(energy_, other->energy_);
    std::swap(buytimes_, other->buytimes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGWBuyEnergyResp::GetTypeName() const {
  return "fgame.CSGWBuyEnergyResp";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fgame

// @@protoc_insertion_point(global_scope)
