// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Match.proto

#ifndef PROTOBUF_Match_2eproto__INCLUDED
#define PROTOBUF_Match_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace fgame {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Match_2eproto();
void protobuf_AssignDesc_Match_2eproto();
void protobuf_ShutdownFile_Match_2eproto();

class CSGWGetMatchInfoReq;
class CSGWInitMatchInfo;
class BattleInfo;
class CSGWFinalMatchInfo;
class CSGWGetMatchInfoResp;
class CSGWMatchReq;
class GWPlayerInfo;
class CSGWMatchResp;
class CSGWMatchStopReq;
class CSGWMatchStopResp;
class CSGWGetRankReq;
class RankInfo;
class CSGWGetRankResp;
class CSGWBuyEnergyReq;
class CSGWBuyEnergyResp;

// ===================================================================

class CSGWGetMatchInfoReq : public ::google::protobuf::MessageLite {
 public:
  CSGWGetMatchInfoReq();
  virtual ~CSGWGetMatchInfoReq();

  CSGWGetMatchInfoReq(const CSGWGetMatchInfoReq& from);

  inline CSGWGetMatchInfoReq& operator=(const CSGWGetMatchInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGWGetMatchInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGWGetMatchInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGWGetMatchInfoReq* other);

  // implements Message ----------------------------------------------

  CSGWGetMatchInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGWGetMatchInfoReq& from);
  void MergeFrom(const CSGWGetMatchInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSGWGetMatchInfoReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Match_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Match_2eproto();
  #endif
  friend void protobuf_AssignDesc_Match_2eproto();
  friend void protobuf_ShutdownFile_Match_2eproto();

  void InitAsDefaultInstance();
  static CSGWGetMatchInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class CSGWInitMatchInfo : public ::google::protobuf::MessageLite {
 public:
  CSGWInitMatchInfo();
  virtual ~CSGWInitMatchInfo();

  CSGWInitMatchInfo(const CSGWInitMatchInfo& from);

  inline CSGWInitMatchInfo& operator=(const CSGWInitMatchInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGWInitMatchInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGWInitMatchInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGWInitMatchInfo* other);

  // implements Message ----------------------------------------------

  CSGWInitMatchInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGWInitMatchInfo& from);
  void MergeFrom(const CSGWInitMatchInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 MatchScore = 1;
  inline bool has_matchscore() const;
  inline void clear_matchscore();
  static const int kMatchScoreFieldNumber = 1;
  inline ::google::protobuf::uint32 matchscore() const;
  inline void set_matchscore(::google::protobuf::uint32 value);

  // required uint32 MatchRank = 2;
  inline bool has_matchrank() const;
  inline void clear_matchrank();
  static const int kMatchRankFieldNumber = 2;
  inline ::google::protobuf::uint32 matchrank() const;
  inline void set_matchrank(::google::protobuf::uint32 value);

  // required uint32 MatchCount = 3;
  inline bool has_matchcount() const;
  inline void clear_matchcount();
  static const int kMatchCountFieldNumber = 3;
  inline ::google::protobuf::uint32 matchcount() const;
  inline void set_matchcount(::google::protobuf::uint32 value);

  // required uint32 WinCount = 4;
  inline bool has_wincount() const;
  inline void clear_wincount();
  static const int kWinCountFieldNumber = 4;
  inline ::google::protobuf::uint32 wincount() const;
  inline void set_wincount(::google::protobuf::uint32 value);

  // required uint32 FinalMatchDay = 5;
  inline bool has_finalmatchday() const;
  inline void clear_finalmatchday();
  static const int kFinalMatchDayFieldNumber = 5;
  inline ::google::protobuf::uint32 finalmatchday() const;
  inline void set_finalmatchday(::google::protobuf::uint32 value);

  // required uint32 BaoziCount = 6;
  inline bool has_baozicount() const;
  inline void clear_baozicount();
  static const int kBaoziCountFieldNumber = 6;
  inline ::google::protobuf::uint32 baozicount() const;
  inline void set_baozicount(::google::protobuf::uint32 value);

  // required uint32 BuyCount = 7;
  inline bool has_buycount() const;
  inline void clear_buycount();
  static const int kBuyCountFieldNumber = 7;
  inline ::google::protobuf::uint32 buycount() const;
  inline void set_buycount(::google::protobuf::uint32 value);

  // required uint32 StartTime = 8;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 8;
  inline ::google::protobuf::uint32 starttime() const;
  inline void set_starttime(::google::protobuf::uint32 value);

  // required uint32 EndTime = 9;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 9;
  inline ::google::protobuf::uint32 endtime() const;
  inline void set_endtime(::google::protobuf::uint32 value);

  // required uint32 MatchSeason = 10;
  inline bool has_matchseason() const;
  inline void clear_matchseason();
  static const int kMatchSeasonFieldNumber = 10;
  inline ::google::protobuf::uint32 matchseason() const;
  inline void set_matchseason(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGWInitMatchInfo)
 private:
  inline void set_has_matchscore();
  inline void clear_has_matchscore();
  inline void set_has_matchrank();
  inline void clear_has_matchrank();
  inline void set_has_matchcount();
  inline void clear_has_matchcount();
  inline void set_has_wincount();
  inline void clear_has_wincount();
  inline void set_has_finalmatchday();
  inline void clear_has_finalmatchday();
  inline void set_has_baozicount();
  inline void clear_has_baozicount();
  inline void set_has_buycount();
  inline void clear_has_buycount();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_matchseason();
  inline void clear_has_matchseason();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 matchscore_;
  ::google::protobuf::uint32 matchrank_;
  ::google::protobuf::uint32 matchcount_;
  ::google::protobuf::uint32 wincount_;
  ::google::protobuf::uint32 finalmatchday_;
  ::google::protobuf::uint32 baozicount_;
  ::google::protobuf::uint32 buycount_;
  ::google::protobuf::uint32 starttime_;
  ::google::protobuf::uint32 endtime_;
  ::google::protobuf::uint32 matchseason_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Match_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Match_2eproto();
  #endif
  friend void protobuf_AssignDesc_Match_2eproto();
  friend void protobuf_ShutdownFile_Match_2eproto();

  void InitAsDefaultInstance();
  static CSGWInitMatchInfo* default_instance_;
};
// -------------------------------------------------------------------

class BattleInfo : public ::google::protobuf::MessageLite {
 public:
  BattleInfo();
  virtual ~BattleInfo();

  BattleInfo(const BattleInfo& from);

  inline BattleInfo& operator=(const BattleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BattleInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleInfo* other);

  // implements Message ----------------------------------------------

  BattleInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleInfo& from);
  void MergeFrom(const BattleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string PlayerNameA = 1;
  inline bool has_playernamea() const;
  inline void clear_playernamea();
  static const int kPlayerNameAFieldNumber = 1;
  inline const ::std::string& playernamea() const;
  inline void set_playernamea(const ::std::string& value);
  inline void set_playernamea(const char* value);
  inline void set_playernamea(const char* value, size_t size);
  inline ::std::string* mutable_playernamea();
  inline ::std::string* release_playernamea();
  inline void set_allocated_playernamea(::std::string* playernamea);

  // required string PlayerNameB = 2;
  inline bool has_playernameb() const;
  inline void clear_playernameb();
  static const int kPlayerNameBFieldNumber = 2;
  inline const ::std::string& playernameb() const;
  inline void set_playernameb(const ::std::string& value);
  inline void set_playernameb(const char* value);
  inline void set_playernameb(const char* value, size_t size);
  inline ::std::string* mutable_playernameb();
  inline ::std::string* release_playernameb();
  inline void set_allocated_playernameb(::std::string* playernameb);

  // @@protoc_insertion_point(class_scope:fgame.BattleInfo)
 private:
  inline void set_has_playernamea();
  inline void clear_has_playernamea();
  inline void set_has_playernameb();
  inline void clear_has_playernameb();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* playernamea_;
  ::std::string* playernameb_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Match_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Match_2eproto();
  #endif
  friend void protobuf_AssignDesc_Match_2eproto();
  friend void protobuf_ShutdownFile_Match_2eproto();

  void InitAsDefaultInstance();
  static BattleInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSGWFinalMatchInfo : public ::google::protobuf::MessageLite {
 public:
  CSGWFinalMatchInfo();
  virtual ~CSGWFinalMatchInfo();

  CSGWFinalMatchInfo(const CSGWFinalMatchInfo& from);

  inline CSGWFinalMatchInfo& operator=(const CSGWFinalMatchInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGWFinalMatchInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGWFinalMatchInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGWFinalMatchInfo* other);

  // implements Message ----------------------------------------------

  CSGWFinalMatchInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGWFinalMatchInfo& from);
  void MergeFrom(const CSGWFinalMatchInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.BattleInfo BattleListA = 1;
  inline int battlelista_size() const;
  inline void clear_battlelista();
  static const int kBattleListAFieldNumber = 1;
  inline const ::fgame::BattleInfo& battlelista(int index) const;
  inline ::fgame::BattleInfo* mutable_battlelista(int index);
  inline ::fgame::BattleInfo* add_battlelista();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::BattleInfo >&
      battlelista() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::BattleInfo >*
      mutable_battlelista();

  // repeated .fgame.BattleInfo BattleListB = 2;
  inline int battlelistb_size() const;
  inline void clear_battlelistb();
  static const int kBattleListBFieldNumber = 2;
  inline const ::fgame::BattleInfo& battlelistb(int index) const;
  inline ::fgame::BattleInfo* mutable_battlelistb(int index);
  inline ::fgame::BattleInfo* add_battlelistb();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::BattleInfo >&
      battlelistb() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::BattleInfo >*
      mutable_battlelistb();

  // required uint32 StartTime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 starttime() const;
  inline void set_starttime(::google::protobuf::uint32 value);

  // required uint32 EndTime = 4;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 endtime() const;
  inline void set_endtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGWFinalMatchInfo)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::BattleInfo > battlelista_;
  ::google::protobuf::RepeatedPtrField< ::fgame::BattleInfo > battlelistb_;
  ::google::protobuf::uint32 starttime_;
  ::google::protobuf::uint32 endtime_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Match_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Match_2eproto();
  #endif
  friend void protobuf_AssignDesc_Match_2eproto();
  friend void protobuf_ShutdownFile_Match_2eproto();

  void InitAsDefaultInstance();
  static CSGWFinalMatchInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSGWGetMatchInfoResp : public ::google::protobuf::MessageLite {
 public:
  CSGWGetMatchInfoResp();
  virtual ~CSGWGetMatchInfoResp();

  CSGWGetMatchInfoResp(const CSGWGetMatchInfoResp& from);

  inline CSGWGetMatchInfoResp& operator=(const CSGWGetMatchInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGWGetMatchInfoResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGWGetMatchInfoResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGWGetMatchInfoResp* other);

  // implements Message ----------------------------------------------

  CSGWGetMatchInfoResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGWGetMatchInfoResp& from);
  void MergeFrom(const CSGWGetMatchInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 MatchState = 1;
  inline bool has_matchstate() const;
  inline void clear_matchstate();
  static const int kMatchStateFieldNumber = 1;
  inline ::google::protobuf::uint32 matchstate() const;
  inline void set_matchstate(::google::protobuf::uint32 value);

  // optional .fgame.CSGWInitMatchInfo InitMatchInfo = 2;
  inline bool has_initmatchinfo() const;
  inline void clear_initmatchinfo();
  static const int kInitMatchInfoFieldNumber = 2;
  inline const ::fgame::CSGWInitMatchInfo& initmatchinfo() const;
  inline ::fgame::CSGWInitMatchInfo* mutable_initmatchinfo();
  inline ::fgame::CSGWInitMatchInfo* release_initmatchinfo();
  inline void set_allocated_initmatchinfo(::fgame::CSGWInitMatchInfo* initmatchinfo);

  // optional .fgame.CSGWFinalMatchInfo FinalMatchInfo = 3;
  inline bool has_finalmatchinfo() const;
  inline void clear_finalmatchinfo();
  static const int kFinalMatchInfoFieldNumber = 3;
  inline const ::fgame::CSGWFinalMatchInfo& finalmatchinfo() const;
  inline ::fgame::CSGWFinalMatchInfo* mutable_finalmatchinfo();
  inline ::fgame::CSGWFinalMatchInfo* release_finalmatchinfo();
  inline void set_allocated_finalmatchinfo(::fgame::CSGWFinalMatchInfo* finalmatchinfo);

  // @@protoc_insertion_point(class_scope:fgame.CSGWGetMatchInfoResp)
 private:
  inline void set_has_matchstate();
  inline void clear_has_matchstate();
  inline void set_has_initmatchinfo();
  inline void clear_has_initmatchinfo();
  inline void set_has_finalmatchinfo();
  inline void clear_has_finalmatchinfo();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::fgame::CSGWInitMatchInfo* initmatchinfo_;
  ::fgame::CSGWFinalMatchInfo* finalmatchinfo_;
  ::google::protobuf::uint32 matchstate_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Match_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Match_2eproto();
  #endif
  friend void protobuf_AssignDesc_Match_2eproto();
  friend void protobuf_ShutdownFile_Match_2eproto();

  void InitAsDefaultInstance();
  static CSGWGetMatchInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class CSGWMatchReq : public ::google::protobuf::MessageLite {
 public:
  CSGWMatchReq();
  virtual ~CSGWMatchReq();

  CSGWMatchReq(const CSGWMatchReq& from);

  inline CSGWMatchReq& operator=(const CSGWMatchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGWMatchReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGWMatchReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGWMatchReq* other);

  // implements Message ----------------------------------------------

  CSGWMatchReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGWMatchReq& from);
  void MergeFrom(const CSGWMatchReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSGWMatchReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Match_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Match_2eproto();
  #endif
  friend void protobuf_AssignDesc_Match_2eproto();
  friend void protobuf_ShutdownFile_Match_2eproto();

  void InitAsDefaultInstance();
  static CSGWMatchReq* default_instance_;
};
// -------------------------------------------------------------------

class GWPlayerInfo : public ::google::protobuf::MessageLite {
 public:
  GWPlayerInfo();
  virtual ~GWPlayerInfo();

  GWPlayerInfo(const GWPlayerInfo& from);

  inline GWPlayerInfo& operator=(const GWPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GWPlayerInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GWPlayerInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GWPlayerInfo* other);

  // implements Message ----------------------------------------------

  GWPlayerInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GWPlayerInfo& from);
  void MergeFrom(const GWPlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint32 uin() const;
  inline void set_uin(::google::protobuf::uint32 value);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string Icon = 3;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 3;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // optional uint32 Score = 4;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 4;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // optional uint32 Rank = 5;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 5;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.GWPlayerInfo)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_rank();
  inline void clear_has_rank();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 uin_;
  ::google::protobuf::uint32 score_;
  ::std::string* icon_;
  ::google::protobuf::uint32 rank_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Match_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Match_2eproto();
  #endif
  friend void protobuf_AssignDesc_Match_2eproto();
  friend void protobuf_ShutdownFile_Match_2eproto();

  void InitAsDefaultInstance();
  static GWPlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSGWMatchResp : public ::google::protobuf::MessageLite {
 public:
  CSGWMatchResp();
  virtual ~CSGWMatchResp();

  CSGWMatchResp(const CSGWMatchResp& from);

  inline CSGWMatchResp& operator=(const CSGWMatchResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGWMatchResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGWMatchResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGWMatchResp* other);

  // implements Message ----------------------------------------------

  CSGWMatchResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGWMatchResp& from);
  void MergeFrom(const CSGWMatchResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .fgame.GWPlayerInfo OpponentPlayer = 1;
  inline bool has_opponentplayer() const;
  inline void clear_opponentplayer();
  static const int kOpponentPlayerFieldNumber = 1;
  inline const ::fgame::GWPlayerInfo& opponentplayer() const;
  inline ::fgame::GWPlayerInfo* mutable_opponentplayer();
  inline ::fgame::GWPlayerInfo* release_opponentplayer();
  inline void set_allocated_opponentplayer(::fgame::GWPlayerInfo* opponentplayer);

  // @@protoc_insertion_point(class_scope:fgame.CSGWMatchResp)
 private:
  inline void set_has_opponentplayer();
  inline void clear_has_opponentplayer();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::fgame::GWPlayerInfo* opponentplayer_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Match_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Match_2eproto();
  #endif
  friend void protobuf_AssignDesc_Match_2eproto();
  friend void protobuf_ShutdownFile_Match_2eproto();

  void InitAsDefaultInstance();
  static CSGWMatchResp* default_instance_;
};
// -------------------------------------------------------------------

class CSGWMatchStopReq : public ::google::protobuf::MessageLite {
 public:
  CSGWMatchStopReq();
  virtual ~CSGWMatchStopReq();

  CSGWMatchStopReq(const CSGWMatchStopReq& from);

  inline CSGWMatchStopReq& operator=(const CSGWMatchStopReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGWMatchStopReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGWMatchStopReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGWMatchStopReq* other);

  // implements Message ----------------------------------------------

  CSGWMatchStopReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGWMatchStopReq& from);
  void MergeFrom(const CSGWMatchStopReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSGWMatchStopReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Match_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Match_2eproto();
  #endif
  friend void protobuf_AssignDesc_Match_2eproto();
  friend void protobuf_ShutdownFile_Match_2eproto();

  void InitAsDefaultInstance();
  static CSGWMatchStopReq* default_instance_;
};
// -------------------------------------------------------------------

class CSGWMatchStopResp : public ::google::protobuf::MessageLite {
 public:
  CSGWMatchStopResp();
  virtual ~CSGWMatchStopResp();

  CSGWMatchStopResp(const CSGWMatchStopResp& from);

  inline CSGWMatchStopResp& operator=(const CSGWMatchStopResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGWMatchStopResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGWMatchStopResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGWMatchStopResp* other);

  // implements Message ----------------------------------------------

  CSGWMatchStopResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGWMatchStopResp& from);
  void MergeFrom(const CSGWMatchStopResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSGWMatchStopResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Match_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Match_2eproto();
  #endif
  friend void protobuf_AssignDesc_Match_2eproto();
  friend void protobuf_ShutdownFile_Match_2eproto();

  void InitAsDefaultInstance();
  static CSGWMatchStopResp* default_instance_;
};
// -------------------------------------------------------------------

class CSGWGetRankReq : public ::google::protobuf::MessageLite {
 public:
  CSGWGetRankReq();
  virtual ~CSGWGetRankReq();

  CSGWGetRankReq(const CSGWGetRankReq& from);

  inline CSGWGetRankReq& operator=(const CSGWGetRankReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGWGetRankReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGWGetRankReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGWGetRankReq* other);

  // implements Message ----------------------------------------------

  CSGWGetRankReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGWGetRankReq& from);
  void MergeFrom(const CSGWGetRankReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSGWGetRankReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Match_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Match_2eproto();
  #endif
  friend void protobuf_AssignDesc_Match_2eproto();
  friend void protobuf_ShutdownFile_Match_2eproto();

  void InitAsDefaultInstance();
  static CSGWGetRankReq* default_instance_;
};
// -------------------------------------------------------------------

class RankInfo : public ::google::protobuf::MessageLite {
 public:
  RankInfo();
  virtual ~RankInfo();

  RankInfo(const RankInfo& from);

  inline RankInfo& operator=(const RankInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RankInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RankInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RankInfo* other);

  // implements Message ----------------------------------------------

  RankInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RankInfo& from);
  void MergeFrom(const RankInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint32 uin() const;
  inline void set_uin(::google::protobuf::uint32 value);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 Rank = 3;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 3;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // required uint32 Score = 4;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 4;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // required uint32 GameTimes = 5;
  inline bool has_gametimes() const;
  inline void clear_gametimes();
  static const int kGameTimesFieldNumber = 5;
  inline ::google::protobuf::uint32 gametimes() const;
  inline void set_gametimes(::google::protobuf::uint32 value);

  // required uint32 WinTimes = 6;
  inline bool has_wintimes() const;
  inline void clear_wintimes();
  static const int kWinTimesFieldNumber = 6;
  inline ::google::protobuf::uint32 wintimes() const;
  inline void set_wintimes(::google::protobuf::uint32 value);

  // optional string Icon = 7;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 7;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // @@protoc_insertion_point(class_scope:fgame.RankInfo)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_gametimes();
  inline void clear_has_gametimes();
  inline void set_has_wintimes();
  inline void clear_has_wintimes();
  inline void set_has_icon();
  inline void clear_has_icon();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 uin_;
  ::google::protobuf::uint32 rank_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 gametimes_;
  ::std::string* icon_;
  ::google::protobuf::uint32 wintimes_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Match_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Match_2eproto();
  #endif
  friend void protobuf_AssignDesc_Match_2eproto();
  friend void protobuf_ShutdownFile_Match_2eproto();

  void InitAsDefaultInstance();
  static RankInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSGWGetRankResp : public ::google::protobuf::MessageLite {
 public:
  CSGWGetRankResp();
  virtual ~CSGWGetRankResp();

  CSGWGetRankResp(const CSGWGetRankResp& from);

  inline CSGWGetRankResp& operator=(const CSGWGetRankResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGWGetRankResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGWGetRankResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGWGetRankResp* other);

  // implements Message ----------------------------------------------

  CSGWGetRankResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGWGetRankResp& from);
  void MergeFrom(const CSGWGetRankResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.RankInfo List = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::fgame::RankInfo& list(int index) const;
  inline ::fgame::RankInfo* mutable_list(int index);
  inline ::fgame::RankInfo* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::RankInfo >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::RankInfo >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:fgame.CSGWGetRankResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::RankInfo > list_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Match_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Match_2eproto();
  #endif
  friend void protobuf_AssignDesc_Match_2eproto();
  friend void protobuf_ShutdownFile_Match_2eproto();

  void InitAsDefaultInstance();
  static CSGWGetRankResp* default_instance_;
};
// -------------------------------------------------------------------

class CSGWBuyEnergyReq : public ::google::protobuf::MessageLite {
 public:
  CSGWBuyEnergyReq();
  virtual ~CSGWBuyEnergyReq();

  CSGWBuyEnergyReq(const CSGWBuyEnergyReq& from);

  inline CSGWBuyEnergyReq& operator=(const CSGWBuyEnergyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGWBuyEnergyReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGWBuyEnergyReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGWBuyEnergyReq* other);

  // implements Message ----------------------------------------------

  CSGWBuyEnergyReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGWBuyEnergyReq& from);
  void MergeFrom(const CSGWBuyEnergyReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSGWBuyEnergyReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Match_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Match_2eproto();
  #endif
  friend void protobuf_AssignDesc_Match_2eproto();
  friend void protobuf_ShutdownFile_Match_2eproto();

  void InitAsDefaultInstance();
  static CSGWBuyEnergyReq* default_instance_;
};
// -------------------------------------------------------------------

class CSGWBuyEnergyResp : public ::google::protobuf::MessageLite {
 public:
  CSGWBuyEnergyResp();
  virtual ~CSGWBuyEnergyResp();

  CSGWBuyEnergyResp(const CSGWBuyEnergyResp& from);

  inline CSGWBuyEnergyResp& operator=(const CSGWBuyEnergyResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGWBuyEnergyResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGWBuyEnergyResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGWBuyEnergyResp* other);

  // implements Message ----------------------------------------------

  CSGWBuyEnergyResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGWBuyEnergyResp& from);
  void MergeFrom(const CSGWBuyEnergyResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Energy = 1;
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 1;
  inline ::google::protobuf::uint32 energy() const;
  inline void set_energy(::google::protobuf::uint32 value);

  // required uint32 BuyTimes = 2;
  inline bool has_buytimes() const;
  inline void clear_buytimes();
  static const int kBuyTimesFieldNumber = 2;
  inline ::google::protobuf::uint32 buytimes() const;
  inline void set_buytimes(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGWBuyEnergyResp)
 private:
  inline void set_has_energy();
  inline void clear_has_energy();
  inline void set_has_buytimes();
  inline void clear_has_buytimes();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 energy_;
  ::google::protobuf::uint32 buytimes_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Match_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Match_2eproto();
  #endif
  friend void protobuf_AssignDesc_Match_2eproto();
  friend void protobuf_ShutdownFile_Match_2eproto();

  void InitAsDefaultInstance();
  static CSGWBuyEnergyResp* default_instance_;
};
// ===================================================================


// ===================================================================

// CSGWGetMatchInfoReq

// -------------------------------------------------------------------

// CSGWInitMatchInfo

// required uint32 MatchScore = 1;
inline bool CSGWInitMatchInfo::has_matchscore() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGWInitMatchInfo::set_has_matchscore() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGWInitMatchInfo::clear_has_matchscore() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGWInitMatchInfo::clear_matchscore() {
  matchscore_ = 0u;
  clear_has_matchscore();
}
inline ::google::protobuf::uint32 CSGWInitMatchInfo::matchscore() const {
  // @@protoc_insertion_point(field_get:fgame.CSGWInitMatchInfo.MatchScore)
  return matchscore_;
}
inline void CSGWInitMatchInfo::set_matchscore(::google::protobuf::uint32 value) {
  set_has_matchscore();
  matchscore_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGWInitMatchInfo.MatchScore)
}

// required uint32 MatchRank = 2;
inline bool CSGWInitMatchInfo::has_matchrank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGWInitMatchInfo::set_has_matchrank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGWInitMatchInfo::clear_has_matchrank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGWInitMatchInfo::clear_matchrank() {
  matchrank_ = 0u;
  clear_has_matchrank();
}
inline ::google::protobuf::uint32 CSGWInitMatchInfo::matchrank() const {
  // @@protoc_insertion_point(field_get:fgame.CSGWInitMatchInfo.MatchRank)
  return matchrank_;
}
inline void CSGWInitMatchInfo::set_matchrank(::google::protobuf::uint32 value) {
  set_has_matchrank();
  matchrank_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGWInitMatchInfo.MatchRank)
}

// required uint32 MatchCount = 3;
inline bool CSGWInitMatchInfo::has_matchcount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSGWInitMatchInfo::set_has_matchcount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSGWInitMatchInfo::clear_has_matchcount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSGWInitMatchInfo::clear_matchcount() {
  matchcount_ = 0u;
  clear_has_matchcount();
}
inline ::google::protobuf::uint32 CSGWInitMatchInfo::matchcount() const {
  // @@protoc_insertion_point(field_get:fgame.CSGWInitMatchInfo.MatchCount)
  return matchcount_;
}
inline void CSGWInitMatchInfo::set_matchcount(::google::protobuf::uint32 value) {
  set_has_matchcount();
  matchcount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGWInitMatchInfo.MatchCount)
}

// required uint32 WinCount = 4;
inline bool CSGWInitMatchInfo::has_wincount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSGWInitMatchInfo::set_has_wincount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSGWInitMatchInfo::clear_has_wincount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSGWInitMatchInfo::clear_wincount() {
  wincount_ = 0u;
  clear_has_wincount();
}
inline ::google::protobuf::uint32 CSGWInitMatchInfo::wincount() const {
  // @@protoc_insertion_point(field_get:fgame.CSGWInitMatchInfo.WinCount)
  return wincount_;
}
inline void CSGWInitMatchInfo::set_wincount(::google::protobuf::uint32 value) {
  set_has_wincount();
  wincount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGWInitMatchInfo.WinCount)
}

// required uint32 FinalMatchDay = 5;
inline bool CSGWInitMatchInfo::has_finalmatchday() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSGWInitMatchInfo::set_has_finalmatchday() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSGWInitMatchInfo::clear_has_finalmatchday() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSGWInitMatchInfo::clear_finalmatchday() {
  finalmatchday_ = 0u;
  clear_has_finalmatchday();
}
inline ::google::protobuf::uint32 CSGWInitMatchInfo::finalmatchday() const {
  // @@protoc_insertion_point(field_get:fgame.CSGWInitMatchInfo.FinalMatchDay)
  return finalmatchday_;
}
inline void CSGWInitMatchInfo::set_finalmatchday(::google::protobuf::uint32 value) {
  set_has_finalmatchday();
  finalmatchday_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGWInitMatchInfo.FinalMatchDay)
}

// required uint32 BaoziCount = 6;
inline bool CSGWInitMatchInfo::has_baozicount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSGWInitMatchInfo::set_has_baozicount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSGWInitMatchInfo::clear_has_baozicount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSGWInitMatchInfo::clear_baozicount() {
  baozicount_ = 0u;
  clear_has_baozicount();
}
inline ::google::protobuf::uint32 CSGWInitMatchInfo::baozicount() const {
  // @@protoc_insertion_point(field_get:fgame.CSGWInitMatchInfo.BaoziCount)
  return baozicount_;
}
inline void CSGWInitMatchInfo::set_baozicount(::google::protobuf::uint32 value) {
  set_has_baozicount();
  baozicount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGWInitMatchInfo.BaoziCount)
}

// required uint32 BuyCount = 7;
inline bool CSGWInitMatchInfo::has_buycount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSGWInitMatchInfo::set_has_buycount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSGWInitMatchInfo::clear_has_buycount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSGWInitMatchInfo::clear_buycount() {
  buycount_ = 0u;
  clear_has_buycount();
}
inline ::google::protobuf::uint32 CSGWInitMatchInfo::buycount() const {
  // @@protoc_insertion_point(field_get:fgame.CSGWInitMatchInfo.BuyCount)
  return buycount_;
}
inline void CSGWInitMatchInfo::set_buycount(::google::protobuf::uint32 value) {
  set_has_buycount();
  buycount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGWInitMatchInfo.BuyCount)
}

// required uint32 StartTime = 8;
inline bool CSGWInitMatchInfo::has_starttime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSGWInitMatchInfo::set_has_starttime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSGWInitMatchInfo::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSGWInitMatchInfo::clear_starttime() {
  starttime_ = 0u;
  clear_has_starttime();
}
inline ::google::protobuf::uint32 CSGWInitMatchInfo::starttime() const {
  // @@protoc_insertion_point(field_get:fgame.CSGWInitMatchInfo.StartTime)
  return starttime_;
}
inline void CSGWInitMatchInfo::set_starttime(::google::protobuf::uint32 value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGWInitMatchInfo.StartTime)
}

// required uint32 EndTime = 9;
inline bool CSGWInitMatchInfo::has_endtime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSGWInitMatchInfo::set_has_endtime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSGWInitMatchInfo::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSGWInitMatchInfo::clear_endtime() {
  endtime_ = 0u;
  clear_has_endtime();
}
inline ::google::protobuf::uint32 CSGWInitMatchInfo::endtime() const {
  // @@protoc_insertion_point(field_get:fgame.CSGWInitMatchInfo.EndTime)
  return endtime_;
}
inline void CSGWInitMatchInfo::set_endtime(::google::protobuf::uint32 value) {
  set_has_endtime();
  endtime_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGWInitMatchInfo.EndTime)
}

// required uint32 MatchSeason = 10;
inline bool CSGWInitMatchInfo::has_matchseason() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSGWInitMatchInfo::set_has_matchseason() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSGWInitMatchInfo::clear_has_matchseason() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSGWInitMatchInfo::clear_matchseason() {
  matchseason_ = 0u;
  clear_has_matchseason();
}
inline ::google::protobuf::uint32 CSGWInitMatchInfo::matchseason() const {
  // @@protoc_insertion_point(field_get:fgame.CSGWInitMatchInfo.MatchSeason)
  return matchseason_;
}
inline void CSGWInitMatchInfo::set_matchseason(::google::protobuf::uint32 value) {
  set_has_matchseason();
  matchseason_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGWInitMatchInfo.MatchSeason)
}

// -------------------------------------------------------------------

// BattleInfo

// required string PlayerNameA = 1;
inline bool BattleInfo::has_playernamea() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleInfo::set_has_playernamea() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleInfo::clear_has_playernamea() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleInfo::clear_playernamea() {
  if (playernamea_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playernamea_->clear();
  }
  clear_has_playernamea();
}
inline const ::std::string& BattleInfo::playernamea() const {
  // @@protoc_insertion_point(field_get:fgame.BattleInfo.PlayerNameA)
  return *playernamea_;
}
inline void BattleInfo::set_playernamea(const ::std::string& value) {
  set_has_playernamea();
  if (playernamea_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playernamea_ = new ::std::string;
  }
  playernamea_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.BattleInfo.PlayerNameA)
}
inline void BattleInfo::set_playernamea(const char* value) {
  set_has_playernamea();
  if (playernamea_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playernamea_ = new ::std::string;
  }
  playernamea_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.BattleInfo.PlayerNameA)
}
inline void BattleInfo::set_playernamea(const char* value, size_t size) {
  set_has_playernamea();
  if (playernamea_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playernamea_ = new ::std::string;
  }
  playernamea_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.BattleInfo.PlayerNameA)
}
inline ::std::string* BattleInfo::mutable_playernamea() {
  set_has_playernamea();
  if (playernamea_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playernamea_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.BattleInfo.PlayerNameA)
  return playernamea_;
}
inline ::std::string* BattleInfo::release_playernamea() {
  clear_has_playernamea();
  if (playernamea_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = playernamea_;
    playernamea_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BattleInfo::set_allocated_playernamea(::std::string* playernamea) {
  if (playernamea_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete playernamea_;
  }
  if (playernamea) {
    set_has_playernamea();
    playernamea_ = playernamea;
  } else {
    clear_has_playernamea();
    playernamea_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.BattleInfo.PlayerNameA)
}

// required string PlayerNameB = 2;
inline bool BattleInfo::has_playernameb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleInfo::set_has_playernameb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleInfo::clear_has_playernameb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleInfo::clear_playernameb() {
  if (playernameb_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playernameb_->clear();
  }
  clear_has_playernameb();
}
inline const ::std::string& BattleInfo::playernameb() const {
  // @@protoc_insertion_point(field_get:fgame.BattleInfo.PlayerNameB)
  return *playernameb_;
}
inline void BattleInfo::set_playernameb(const ::std::string& value) {
  set_has_playernameb();
  if (playernameb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playernameb_ = new ::std::string;
  }
  playernameb_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.BattleInfo.PlayerNameB)
}
inline void BattleInfo::set_playernameb(const char* value) {
  set_has_playernameb();
  if (playernameb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playernameb_ = new ::std::string;
  }
  playernameb_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.BattleInfo.PlayerNameB)
}
inline void BattleInfo::set_playernameb(const char* value, size_t size) {
  set_has_playernameb();
  if (playernameb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playernameb_ = new ::std::string;
  }
  playernameb_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.BattleInfo.PlayerNameB)
}
inline ::std::string* BattleInfo::mutable_playernameb() {
  set_has_playernameb();
  if (playernameb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playernameb_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.BattleInfo.PlayerNameB)
  return playernameb_;
}
inline ::std::string* BattleInfo::release_playernameb() {
  clear_has_playernameb();
  if (playernameb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = playernameb_;
    playernameb_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BattleInfo::set_allocated_playernameb(::std::string* playernameb) {
  if (playernameb_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete playernameb_;
  }
  if (playernameb) {
    set_has_playernameb();
    playernameb_ = playernameb;
  } else {
    clear_has_playernameb();
    playernameb_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.BattleInfo.PlayerNameB)
}

// -------------------------------------------------------------------

// CSGWFinalMatchInfo

// repeated .fgame.BattleInfo BattleListA = 1;
inline int CSGWFinalMatchInfo::battlelista_size() const {
  return battlelista_.size();
}
inline void CSGWFinalMatchInfo::clear_battlelista() {
  battlelista_.Clear();
}
inline const ::fgame::BattleInfo& CSGWFinalMatchInfo::battlelista(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSGWFinalMatchInfo.BattleListA)
  return battlelista_.Get(index);
}
inline ::fgame::BattleInfo* CSGWFinalMatchInfo::mutable_battlelista(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSGWFinalMatchInfo.BattleListA)
  return battlelista_.Mutable(index);
}
inline ::fgame::BattleInfo* CSGWFinalMatchInfo::add_battlelista() {
  // @@protoc_insertion_point(field_add:fgame.CSGWFinalMatchInfo.BattleListA)
  return battlelista_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::BattleInfo >&
CSGWFinalMatchInfo::battlelista() const {
  // @@protoc_insertion_point(field_list:fgame.CSGWFinalMatchInfo.BattleListA)
  return battlelista_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::BattleInfo >*
CSGWFinalMatchInfo::mutable_battlelista() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSGWFinalMatchInfo.BattleListA)
  return &battlelista_;
}

// repeated .fgame.BattleInfo BattleListB = 2;
inline int CSGWFinalMatchInfo::battlelistb_size() const {
  return battlelistb_.size();
}
inline void CSGWFinalMatchInfo::clear_battlelistb() {
  battlelistb_.Clear();
}
inline const ::fgame::BattleInfo& CSGWFinalMatchInfo::battlelistb(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSGWFinalMatchInfo.BattleListB)
  return battlelistb_.Get(index);
}
inline ::fgame::BattleInfo* CSGWFinalMatchInfo::mutable_battlelistb(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSGWFinalMatchInfo.BattleListB)
  return battlelistb_.Mutable(index);
}
inline ::fgame::BattleInfo* CSGWFinalMatchInfo::add_battlelistb() {
  // @@protoc_insertion_point(field_add:fgame.CSGWFinalMatchInfo.BattleListB)
  return battlelistb_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::BattleInfo >&
CSGWFinalMatchInfo::battlelistb() const {
  // @@protoc_insertion_point(field_list:fgame.CSGWFinalMatchInfo.BattleListB)
  return battlelistb_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::BattleInfo >*
CSGWFinalMatchInfo::mutable_battlelistb() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSGWFinalMatchInfo.BattleListB)
  return &battlelistb_;
}

// required uint32 StartTime = 3;
inline bool CSGWFinalMatchInfo::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSGWFinalMatchInfo::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSGWFinalMatchInfo::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSGWFinalMatchInfo::clear_starttime() {
  starttime_ = 0u;
  clear_has_starttime();
}
inline ::google::protobuf::uint32 CSGWFinalMatchInfo::starttime() const {
  // @@protoc_insertion_point(field_get:fgame.CSGWFinalMatchInfo.StartTime)
  return starttime_;
}
inline void CSGWFinalMatchInfo::set_starttime(::google::protobuf::uint32 value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGWFinalMatchInfo.StartTime)
}

// required uint32 EndTime = 4;
inline bool CSGWFinalMatchInfo::has_endtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSGWFinalMatchInfo::set_has_endtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSGWFinalMatchInfo::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSGWFinalMatchInfo::clear_endtime() {
  endtime_ = 0u;
  clear_has_endtime();
}
inline ::google::protobuf::uint32 CSGWFinalMatchInfo::endtime() const {
  // @@protoc_insertion_point(field_get:fgame.CSGWFinalMatchInfo.EndTime)
  return endtime_;
}
inline void CSGWFinalMatchInfo::set_endtime(::google::protobuf::uint32 value) {
  set_has_endtime();
  endtime_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGWFinalMatchInfo.EndTime)
}

// -------------------------------------------------------------------

// CSGWGetMatchInfoResp

// required uint32 MatchState = 1;
inline bool CSGWGetMatchInfoResp::has_matchstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGWGetMatchInfoResp::set_has_matchstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGWGetMatchInfoResp::clear_has_matchstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGWGetMatchInfoResp::clear_matchstate() {
  matchstate_ = 0u;
  clear_has_matchstate();
}
inline ::google::protobuf::uint32 CSGWGetMatchInfoResp::matchstate() const {
  // @@protoc_insertion_point(field_get:fgame.CSGWGetMatchInfoResp.MatchState)
  return matchstate_;
}
inline void CSGWGetMatchInfoResp::set_matchstate(::google::protobuf::uint32 value) {
  set_has_matchstate();
  matchstate_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGWGetMatchInfoResp.MatchState)
}

// optional .fgame.CSGWInitMatchInfo InitMatchInfo = 2;
inline bool CSGWGetMatchInfoResp::has_initmatchinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGWGetMatchInfoResp::set_has_initmatchinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGWGetMatchInfoResp::clear_has_initmatchinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGWGetMatchInfoResp::clear_initmatchinfo() {
  if (initmatchinfo_ != NULL) initmatchinfo_->::fgame::CSGWInitMatchInfo::Clear();
  clear_has_initmatchinfo();
}
inline const ::fgame::CSGWInitMatchInfo& CSGWGetMatchInfoResp::initmatchinfo() const {
  // @@protoc_insertion_point(field_get:fgame.CSGWGetMatchInfoResp.InitMatchInfo)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return initmatchinfo_ != NULL ? *initmatchinfo_ : *default_instance().initmatchinfo_;
#else
  return initmatchinfo_ != NULL ? *initmatchinfo_ : *default_instance_->initmatchinfo_;
#endif
}
inline ::fgame::CSGWInitMatchInfo* CSGWGetMatchInfoResp::mutable_initmatchinfo() {
  set_has_initmatchinfo();
  if (initmatchinfo_ == NULL) initmatchinfo_ = new ::fgame::CSGWInitMatchInfo;
  // @@protoc_insertion_point(field_mutable:fgame.CSGWGetMatchInfoResp.InitMatchInfo)
  return initmatchinfo_;
}
inline ::fgame::CSGWInitMatchInfo* CSGWGetMatchInfoResp::release_initmatchinfo() {
  clear_has_initmatchinfo();
  ::fgame::CSGWInitMatchInfo* temp = initmatchinfo_;
  initmatchinfo_ = NULL;
  return temp;
}
inline void CSGWGetMatchInfoResp::set_allocated_initmatchinfo(::fgame::CSGWInitMatchInfo* initmatchinfo) {
  delete initmatchinfo_;
  initmatchinfo_ = initmatchinfo;
  if (initmatchinfo) {
    set_has_initmatchinfo();
  } else {
    clear_has_initmatchinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSGWGetMatchInfoResp.InitMatchInfo)
}

// optional .fgame.CSGWFinalMatchInfo FinalMatchInfo = 3;
inline bool CSGWGetMatchInfoResp::has_finalmatchinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSGWGetMatchInfoResp::set_has_finalmatchinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSGWGetMatchInfoResp::clear_has_finalmatchinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSGWGetMatchInfoResp::clear_finalmatchinfo() {
  if (finalmatchinfo_ != NULL) finalmatchinfo_->::fgame::CSGWFinalMatchInfo::Clear();
  clear_has_finalmatchinfo();
}
inline const ::fgame::CSGWFinalMatchInfo& CSGWGetMatchInfoResp::finalmatchinfo() const {
  // @@protoc_insertion_point(field_get:fgame.CSGWGetMatchInfoResp.FinalMatchInfo)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return finalmatchinfo_ != NULL ? *finalmatchinfo_ : *default_instance().finalmatchinfo_;
#else
  return finalmatchinfo_ != NULL ? *finalmatchinfo_ : *default_instance_->finalmatchinfo_;
#endif
}
inline ::fgame::CSGWFinalMatchInfo* CSGWGetMatchInfoResp::mutable_finalmatchinfo() {
  set_has_finalmatchinfo();
  if (finalmatchinfo_ == NULL) finalmatchinfo_ = new ::fgame::CSGWFinalMatchInfo;
  // @@protoc_insertion_point(field_mutable:fgame.CSGWGetMatchInfoResp.FinalMatchInfo)
  return finalmatchinfo_;
}
inline ::fgame::CSGWFinalMatchInfo* CSGWGetMatchInfoResp::release_finalmatchinfo() {
  clear_has_finalmatchinfo();
  ::fgame::CSGWFinalMatchInfo* temp = finalmatchinfo_;
  finalmatchinfo_ = NULL;
  return temp;
}
inline void CSGWGetMatchInfoResp::set_allocated_finalmatchinfo(::fgame::CSGWFinalMatchInfo* finalmatchinfo) {
  delete finalmatchinfo_;
  finalmatchinfo_ = finalmatchinfo;
  if (finalmatchinfo) {
    set_has_finalmatchinfo();
  } else {
    clear_has_finalmatchinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSGWGetMatchInfoResp.FinalMatchInfo)
}

// -------------------------------------------------------------------

// CSGWMatchReq

// -------------------------------------------------------------------

// GWPlayerInfo

// required uint32 Uin = 1;
inline bool GWPlayerInfo::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GWPlayerInfo::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GWPlayerInfo::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GWPlayerInfo::clear_uin() {
  uin_ = 0u;
  clear_has_uin();
}
inline ::google::protobuf::uint32 GWPlayerInfo::uin() const {
  // @@protoc_insertion_point(field_get:fgame.GWPlayerInfo.Uin)
  return uin_;
}
inline void GWPlayerInfo::set_uin(::google::protobuf::uint32 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.GWPlayerInfo.Uin)
}

// required string Name = 2;
inline bool GWPlayerInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GWPlayerInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GWPlayerInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GWPlayerInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GWPlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:fgame.GWPlayerInfo.Name)
  return *name_;
}
inline void GWPlayerInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.GWPlayerInfo.Name)
}
inline void GWPlayerInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.GWPlayerInfo.Name)
}
inline void GWPlayerInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.GWPlayerInfo.Name)
}
inline ::std::string* GWPlayerInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.GWPlayerInfo.Name)
  return name_;
}
inline ::std::string* GWPlayerInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GWPlayerInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.GWPlayerInfo.Name)
}

// optional string Icon = 3;
inline bool GWPlayerInfo::has_icon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GWPlayerInfo::set_has_icon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GWPlayerInfo::clear_has_icon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GWPlayerInfo::clear_icon() {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& GWPlayerInfo::icon() const {
  // @@protoc_insertion_point(field_get:fgame.GWPlayerInfo.Icon)
  return *icon_;
}
inline void GWPlayerInfo::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.GWPlayerInfo.Icon)
}
inline void GWPlayerInfo::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.GWPlayerInfo.Icon)
}
inline void GWPlayerInfo::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.GWPlayerInfo.Icon)
}
inline ::std::string* GWPlayerInfo::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.GWPlayerInfo.Icon)
  return icon_;
}
inline ::std::string* GWPlayerInfo::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GWPlayerInfo::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.GWPlayerInfo.Icon)
}

// optional uint32 Score = 4;
inline bool GWPlayerInfo::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GWPlayerInfo::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GWPlayerInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GWPlayerInfo::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 GWPlayerInfo::score() const {
  // @@protoc_insertion_point(field_get:fgame.GWPlayerInfo.Score)
  return score_;
}
inline void GWPlayerInfo::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:fgame.GWPlayerInfo.Score)
}

// optional uint32 Rank = 5;
inline bool GWPlayerInfo::has_rank() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GWPlayerInfo::set_has_rank() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GWPlayerInfo::clear_has_rank() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GWPlayerInfo::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 GWPlayerInfo::rank() const {
  // @@protoc_insertion_point(field_get:fgame.GWPlayerInfo.Rank)
  return rank_;
}
inline void GWPlayerInfo::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:fgame.GWPlayerInfo.Rank)
}

// -------------------------------------------------------------------

// CSGWMatchResp

// required .fgame.GWPlayerInfo OpponentPlayer = 1;
inline bool CSGWMatchResp::has_opponentplayer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGWMatchResp::set_has_opponentplayer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGWMatchResp::clear_has_opponentplayer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGWMatchResp::clear_opponentplayer() {
  if (opponentplayer_ != NULL) opponentplayer_->::fgame::GWPlayerInfo::Clear();
  clear_has_opponentplayer();
}
inline const ::fgame::GWPlayerInfo& CSGWMatchResp::opponentplayer() const {
  // @@protoc_insertion_point(field_get:fgame.CSGWMatchResp.OpponentPlayer)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return opponentplayer_ != NULL ? *opponentplayer_ : *default_instance().opponentplayer_;
#else
  return opponentplayer_ != NULL ? *opponentplayer_ : *default_instance_->opponentplayer_;
#endif
}
inline ::fgame::GWPlayerInfo* CSGWMatchResp::mutable_opponentplayer() {
  set_has_opponentplayer();
  if (opponentplayer_ == NULL) opponentplayer_ = new ::fgame::GWPlayerInfo;
  // @@protoc_insertion_point(field_mutable:fgame.CSGWMatchResp.OpponentPlayer)
  return opponentplayer_;
}
inline ::fgame::GWPlayerInfo* CSGWMatchResp::release_opponentplayer() {
  clear_has_opponentplayer();
  ::fgame::GWPlayerInfo* temp = opponentplayer_;
  opponentplayer_ = NULL;
  return temp;
}
inline void CSGWMatchResp::set_allocated_opponentplayer(::fgame::GWPlayerInfo* opponentplayer) {
  delete opponentplayer_;
  opponentplayer_ = opponentplayer;
  if (opponentplayer) {
    set_has_opponentplayer();
  } else {
    clear_has_opponentplayer();
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSGWMatchResp.OpponentPlayer)
}

// -------------------------------------------------------------------

// CSGWMatchStopReq

// -------------------------------------------------------------------

// CSGWMatchStopResp

// -------------------------------------------------------------------

// CSGWGetRankReq

// -------------------------------------------------------------------

// RankInfo

// required uint32 Uin = 1;
inline bool RankInfo::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RankInfo::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RankInfo::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RankInfo::clear_uin() {
  uin_ = 0u;
  clear_has_uin();
}
inline ::google::protobuf::uint32 RankInfo::uin() const {
  // @@protoc_insertion_point(field_get:fgame.RankInfo.Uin)
  return uin_;
}
inline void RankInfo::set_uin(::google::protobuf::uint32 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.RankInfo.Uin)
}

// required string Name = 2;
inline bool RankInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RankInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RankInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RankInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RankInfo::name() const {
  // @@protoc_insertion_point(field_get:fgame.RankInfo.Name)
  return *name_;
}
inline void RankInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.RankInfo.Name)
}
inline void RankInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.RankInfo.Name)
}
inline void RankInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.RankInfo.Name)
}
inline ::std::string* RankInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.RankInfo.Name)
  return name_;
}
inline ::std::string* RankInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RankInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.RankInfo.Name)
}

// required uint32 Rank = 3;
inline bool RankInfo::has_rank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RankInfo::set_has_rank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RankInfo::clear_has_rank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RankInfo::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 RankInfo::rank() const {
  // @@protoc_insertion_point(field_get:fgame.RankInfo.Rank)
  return rank_;
}
inline void RankInfo::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:fgame.RankInfo.Rank)
}

// required uint32 Score = 4;
inline bool RankInfo::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RankInfo::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RankInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RankInfo::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 RankInfo::score() const {
  // @@protoc_insertion_point(field_get:fgame.RankInfo.Score)
  return score_;
}
inline void RankInfo::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:fgame.RankInfo.Score)
}

// required uint32 GameTimes = 5;
inline bool RankInfo::has_gametimes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RankInfo::set_has_gametimes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RankInfo::clear_has_gametimes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RankInfo::clear_gametimes() {
  gametimes_ = 0u;
  clear_has_gametimes();
}
inline ::google::protobuf::uint32 RankInfo::gametimes() const {
  // @@protoc_insertion_point(field_get:fgame.RankInfo.GameTimes)
  return gametimes_;
}
inline void RankInfo::set_gametimes(::google::protobuf::uint32 value) {
  set_has_gametimes();
  gametimes_ = value;
  // @@protoc_insertion_point(field_set:fgame.RankInfo.GameTimes)
}

// required uint32 WinTimes = 6;
inline bool RankInfo::has_wintimes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RankInfo::set_has_wintimes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RankInfo::clear_has_wintimes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RankInfo::clear_wintimes() {
  wintimes_ = 0u;
  clear_has_wintimes();
}
inline ::google::protobuf::uint32 RankInfo::wintimes() const {
  // @@protoc_insertion_point(field_get:fgame.RankInfo.WinTimes)
  return wintimes_;
}
inline void RankInfo::set_wintimes(::google::protobuf::uint32 value) {
  set_has_wintimes();
  wintimes_ = value;
  // @@protoc_insertion_point(field_set:fgame.RankInfo.WinTimes)
}

// optional string Icon = 7;
inline bool RankInfo::has_icon() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RankInfo::set_has_icon() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RankInfo::clear_has_icon() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RankInfo::clear_icon() {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& RankInfo::icon() const {
  // @@protoc_insertion_point(field_get:fgame.RankInfo.Icon)
  return *icon_;
}
inline void RankInfo::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.RankInfo.Icon)
}
inline void RankInfo::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.RankInfo.Icon)
}
inline void RankInfo::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.RankInfo.Icon)
}
inline ::std::string* RankInfo::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.RankInfo.Icon)
  return icon_;
}
inline ::std::string* RankInfo::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RankInfo::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.RankInfo.Icon)
}

// -------------------------------------------------------------------

// CSGWGetRankResp

// repeated .fgame.RankInfo List = 1;
inline int CSGWGetRankResp::list_size() const {
  return list_.size();
}
inline void CSGWGetRankResp::clear_list() {
  list_.Clear();
}
inline const ::fgame::RankInfo& CSGWGetRankResp::list(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSGWGetRankResp.List)
  return list_.Get(index);
}
inline ::fgame::RankInfo* CSGWGetRankResp::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSGWGetRankResp.List)
  return list_.Mutable(index);
}
inline ::fgame::RankInfo* CSGWGetRankResp::add_list() {
  // @@protoc_insertion_point(field_add:fgame.CSGWGetRankResp.List)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::RankInfo >&
CSGWGetRankResp::list() const {
  // @@protoc_insertion_point(field_list:fgame.CSGWGetRankResp.List)
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::RankInfo >*
CSGWGetRankResp::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSGWGetRankResp.List)
  return &list_;
}

// -------------------------------------------------------------------

// CSGWBuyEnergyReq

// -------------------------------------------------------------------

// CSGWBuyEnergyResp

// required uint32 Energy = 1;
inline bool CSGWBuyEnergyResp::has_energy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGWBuyEnergyResp::set_has_energy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGWBuyEnergyResp::clear_has_energy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGWBuyEnergyResp::clear_energy() {
  energy_ = 0u;
  clear_has_energy();
}
inline ::google::protobuf::uint32 CSGWBuyEnergyResp::energy() const {
  // @@protoc_insertion_point(field_get:fgame.CSGWBuyEnergyResp.Energy)
  return energy_;
}
inline void CSGWBuyEnergyResp::set_energy(::google::protobuf::uint32 value) {
  set_has_energy();
  energy_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGWBuyEnergyResp.Energy)
}

// required uint32 BuyTimes = 2;
inline bool CSGWBuyEnergyResp::has_buytimes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGWBuyEnergyResp::set_has_buytimes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGWBuyEnergyResp::clear_has_buytimes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGWBuyEnergyResp::clear_buytimes() {
  buytimes_ = 0u;
  clear_has_buytimes();
}
inline ::google::protobuf::uint32 CSGWBuyEnergyResp::buytimes() const {
  // @@protoc_insertion_point(field_get:fgame.CSGWBuyEnergyResp.BuyTimes)
  return buytimes_;
}
inline void CSGWBuyEnergyResp::set_buytimes(::google::protobuf::uint32 value) {
  set_has_buytimes();
  buytimes_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGWBuyEnergyResp.BuyTimes)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fgame

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Match_2eproto__INCLUDED
