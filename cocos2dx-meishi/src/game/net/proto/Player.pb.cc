// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Player.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Player.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace fgame {

void protobuf_ShutdownFile_Player_2eproto() {
  delete PropertyUpdateData::default_instance_;
  delete CSQueryPlayerInfoReq::default_instance_;
  delete CSQueryPlayerInfoResp::default_instance_;
  delete CSShopGuideReq::default_instance_;
  delete CSShopGuideResp::default_instance_;
  delete CSTestAddDiamondReq::default_instance_;
  delete CSSetTitleReq::default_instance_;
  delete CSSetTitleResp::default_instance_;
  delete CSShopBuyReq::default_instance_;
  delete CSShopBuyResp::default_instance_;
  delete CSShopListReq::default_instance_;
  delete DiamondData::default_instance_;
  delete GiftData::default_instance_;
  delete CSShopListResp::default_instance_;
  delete ExchangeItemInfo::default_instance_;
  delete CSExchangeItemReq::default_instance_;
  delete CSExchangeItemResp::default_instance_;
  delete CSUpdateExchangeListReq::default_instance_;
  delete CSUpdateExchangeListResp::default_instance_;
  delete CSChangePlayerIconReq::default_instance_;
  delete CSChangePlayerIconResp::default_instance_;
  delete CSSetNewBieReq::default_instance_;
  delete CSSetNewBieResp::default_instance_;
  delete CSGetNewBieListReq::default_instance_;
  delete CSGetNewBieListResp::default_instance_;
  delete CSSetNewBieOssReq::default_instance_;
  delete CSSetNewBieOssResp::default_instance_;
  delete CSOpenBigStageReq::default_instance_;
  delete CSOpenBigStageResp::default_instance_;
  delete CSEnterPointReq::default_instance_;
  delete CSEnterPointResp::default_instance_;
  delete CSBuyITtemReq::default_instance_;
  delete CSBuyItemResp::default_instance_;
  delete CSUseItemReq::default_instance_;
  delete CSUseItemResp::default_instance_;
  delete CSBuyVipReq::default_instance_;
  delete CSVipTimeReq::default_instance_;
  delete CSBuyVipResp::default_instance_;
  delete CSPropertyUpdateResp::default_instance_;
  delete CSGetAchievementReq::default_instance_;
  delete CSGetAchievementInfo::default_instance_;
  delete CSGetAchievementResp::default_instance_;
  delete CSReceiveAchievementReq::default_instance_;
  delete CSReceiveAchievementResp::default_instance_;
  delete CSReceiveAchievementRewardReq::default_instance_;
  delete CSReceiveAchievementRewardResp::default_instance_;
  delete CSUpdateAchievementResp::default_instance_;
  delete CSSevenDaySignListReq::default_instance_;
  delete CSSevenDayGetList::default_instance_;
  delete CSSevenDaySignListResp::default_instance_;
  delete CSSevenDaySignReq::default_instance_;
  delete CSSevenDaySignResp::default_instance_;
  delete CSGetServerReq::default_instance_;
  delete CSGetServerResp::default_instance_;
  delete CSEnterServerReq::default_instance_;
  delete CSEnterServerResp::default_instance_;
  delete CSCanEnterReq::default_instance_;
  delete CSDirectEnterReq::default_instance_;
  delete CSDircetEnterResp::default_instance_;
  delete CSQueueReq::default_instance_;
  delete CSStreakWinValueReq::default_instance_;
  delete CSStreakWinValueResp::default_instance_;
  delete CSStreakWinGetReq::default_instance_;
  delete CSStreakWinGetResp::default_instance_;
  delete CSItem::default_instance_;
  delete CSSycPlayerInfoReq::default_instance_;
  delete CSTitleItem::default_instance_;
  delete CSSycPlayerInfoResp::default_instance_;
  delete CSSyncPlayerDataReq::default_instance_;
  delete CSSyncPlayerDataResp::default_instance_;
  delete CSGetPlayerDataReq::default_instance_;
  delete CSGetPlayerDataResp::default_instance_;
  delete CSNoticeReq::default_instance_;
  delete CSChangeNameReq::default_instance_;
  delete CSChangeNameResp::default_instance_;
  delete CSGMCmdReq::default_instance_;
  delete CSXinShouRecodeReq::default_instance_;
  delete CSXinShouRecodeResp::default_instance_;
  delete CSMission::default_instance_;
  delete CSMissionListReq::default_instance_;
  delete CSMissionListResp::default_instance_;
  delete CSMissionCompleteReq::default_instance_;
  delete CSMissionCompleteResp::default_instance_;
  delete CSMissionUpdateResp::default_instance_;
  delete CSBuyNewbieGiftReq::default_instance_;
  delete CSBuyNewbieGiftResp::default_instance_;
  delete CSMailInfo::default_instance_;
  delete CSGetMailReq::default_instance_;
  delete CSGetMailResp::default_instance_;
  delete CSDelMailReq::default_instance_;
  delete CSDelMailResp::default_instance_;
  delete CSNoticeMailReq::default_instance_;
  delete CSRechargeCallbackReq::default_instance_;
  delete CSRechargeCallbackResp::default_instance_;
  delete CSUseGiftCodeReq::default_instance_;
  delete CSUseGiftCodeResp::default_instance_;
  delete CheckPtData::default_instance_;
  delete CSSaveCheckPtDataReq::default_instance_;
  delete CSSaveCheckPtDataResp::default_instance_;
  delete CSRetriveCheckPtRewardReq::default_instance_;
  delete CSRetriveCheckPtRewardResp::default_instance_;
  delete CSGetCheckPtDataReq::default_instance_;
  delete ChapterData::default_instance_;
  delete CSGetCheckPtDataResp::default_instance_;
  delete CSChapterUnlockReq::default_instance_;
  delete CSChapterUnlockResp::default_instance_;
  delete CSGetChestReq::default_instance_;
  delete CSGetChestResp::default_instance_;
  delete CSPveNotifyReq::default_instance_;
  delete CSPveNotifyResp::default_instance_;
  delete CSPveCheckAwardReq::default_instance_;
  delete CSPveCheckAwardResp::default_instance_;
  delete CSPvePveRank::default_instance_;
  delete CSPveRankData::default_instance_;
  delete CSPveRankReq::default_instance_;
  delete CSPveRankResp::default_instance_;
  delete CSOpenChestResp::default_instance_;
  delete CSSetSignatureReq::default_instance_;
  delete CSSetSignatureResp::default_instance_;
  delete CSSetExtraInfoVisibleReq::default_instance_;
  delete CSSetExtraInfoVisibleResp::default_instance_;
  delete CSGetExtraInfoReq::default_instance_;
  delete CSGetExtraInfoResp::default_instance_;
  delete CSShareRewardGetResq::default_instance_;
  delete CSShareRewardGetReq::default_instance_;
  delete CSGetSevenGoalListReq::default_instance_;
  delete CSGetSevenGoalListResp::default_instance_;
  delete CSNoticeSevenGoalResp::default_instance_;
  delete CSRetriveSevenGoalReq::default_instance_;
  delete CSRetriveSevenGoalResp::default_instance_;
  delete CSTopRankReq::default_instance_;
  delete TopRankData::default_instance_;
  delete CSTopRankResp::default_instance_;
  delete CSTopRankTimeReq::default_instance_;
  delete CSTopRankTimeResp::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_Player_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_Player_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  PropertyUpdateData::default_instance_ = new PropertyUpdateData();
  CSQueryPlayerInfoReq::default_instance_ = new CSQueryPlayerInfoReq();
  CSQueryPlayerInfoResp::default_instance_ = new CSQueryPlayerInfoResp();
  CSShopGuideReq::default_instance_ = new CSShopGuideReq();
  CSShopGuideResp::default_instance_ = new CSShopGuideResp();
  CSTestAddDiamondReq::default_instance_ = new CSTestAddDiamondReq();
  CSSetTitleReq::default_instance_ = new CSSetTitleReq();
  CSSetTitleResp::default_instance_ = new CSSetTitleResp();
  CSShopBuyReq::default_instance_ = new CSShopBuyReq();
  CSShopBuyResp::default_instance_ = new CSShopBuyResp();
  CSShopListReq::default_instance_ = new CSShopListReq();
  DiamondData::default_instance_ = new DiamondData();
  GiftData::default_instance_ = new GiftData();
  CSShopListResp::default_instance_ = new CSShopListResp();
  ExchangeItemInfo::default_instance_ = new ExchangeItemInfo();
  CSExchangeItemReq::default_instance_ = new CSExchangeItemReq();
  CSExchangeItemResp::default_instance_ = new CSExchangeItemResp();
  CSUpdateExchangeListReq::default_instance_ = new CSUpdateExchangeListReq();
  CSUpdateExchangeListResp::default_instance_ = new CSUpdateExchangeListResp();
  CSChangePlayerIconReq::default_instance_ = new CSChangePlayerIconReq();
  CSChangePlayerIconResp::default_instance_ = new CSChangePlayerIconResp();
  CSSetNewBieReq::default_instance_ = new CSSetNewBieReq();
  CSSetNewBieResp::default_instance_ = new CSSetNewBieResp();
  CSGetNewBieListReq::default_instance_ = new CSGetNewBieListReq();
  CSGetNewBieListResp::default_instance_ = new CSGetNewBieListResp();
  CSSetNewBieOssReq::default_instance_ = new CSSetNewBieOssReq();
  CSSetNewBieOssResp::default_instance_ = new CSSetNewBieOssResp();
  CSOpenBigStageReq::default_instance_ = new CSOpenBigStageReq();
  CSOpenBigStageResp::default_instance_ = new CSOpenBigStageResp();
  CSEnterPointReq::default_instance_ = new CSEnterPointReq();
  CSEnterPointResp::default_instance_ = new CSEnterPointResp();
  CSBuyITtemReq::default_instance_ = new CSBuyITtemReq();
  CSBuyItemResp::default_instance_ = new CSBuyItemResp();
  CSUseItemReq::default_instance_ = new CSUseItemReq();
  CSUseItemResp::default_instance_ = new CSUseItemResp();
  CSBuyVipReq::default_instance_ = new CSBuyVipReq();
  CSVipTimeReq::default_instance_ = new CSVipTimeReq();
  CSBuyVipResp::default_instance_ = new CSBuyVipResp();
  CSPropertyUpdateResp::default_instance_ = new CSPropertyUpdateResp();
  CSGetAchievementReq::default_instance_ = new CSGetAchievementReq();
  CSGetAchievementInfo::default_instance_ = new CSGetAchievementInfo();
  CSGetAchievementResp::default_instance_ = new CSGetAchievementResp();
  CSReceiveAchievementReq::default_instance_ = new CSReceiveAchievementReq();
  CSReceiveAchievementResp::default_instance_ = new CSReceiveAchievementResp();
  CSReceiveAchievementRewardReq::default_instance_ = new CSReceiveAchievementRewardReq();
  CSReceiveAchievementRewardResp::default_instance_ = new CSReceiveAchievementRewardResp();
  CSUpdateAchievementResp::default_instance_ = new CSUpdateAchievementResp();
  CSSevenDaySignListReq::default_instance_ = new CSSevenDaySignListReq();
  CSSevenDayGetList::default_instance_ = new CSSevenDayGetList();
  CSSevenDaySignListResp::default_instance_ = new CSSevenDaySignListResp();
  CSSevenDaySignReq::default_instance_ = new CSSevenDaySignReq();
  CSSevenDaySignResp::default_instance_ = new CSSevenDaySignResp();
  CSGetServerReq::default_instance_ = new CSGetServerReq();
  CSGetServerResp::default_instance_ = new CSGetServerResp();
  CSEnterServerReq::default_instance_ = new CSEnterServerReq();
  CSEnterServerResp::default_instance_ = new CSEnterServerResp();
  CSCanEnterReq::default_instance_ = new CSCanEnterReq();
  CSDirectEnterReq::default_instance_ = new CSDirectEnterReq();
  CSDircetEnterResp::default_instance_ = new CSDircetEnterResp();
  CSQueueReq::default_instance_ = new CSQueueReq();
  CSStreakWinValueReq::default_instance_ = new CSStreakWinValueReq();
  CSStreakWinValueResp::default_instance_ = new CSStreakWinValueResp();
  CSStreakWinGetReq::default_instance_ = new CSStreakWinGetReq();
  CSStreakWinGetResp::default_instance_ = new CSStreakWinGetResp();
  CSItem::default_instance_ = new CSItem();
  CSSycPlayerInfoReq::default_instance_ = new CSSycPlayerInfoReq();
  CSTitleItem::default_instance_ = new CSTitleItem();
  CSSycPlayerInfoResp::default_instance_ = new CSSycPlayerInfoResp();
  CSSyncPlayerDataReq::default_instance_ = new CSSyncPlayerDataReq();
  CSSyncPlayerDataResp::default_instance_ = new CSSyncPlayerDataResp();
  CSGetPlayerDataReq::default_instance_ = new CSGetPlayerDataReq();
  CSGetPlayerDataResp::default_instance_ = new CSGetPlayerDataResp();
  CSNoticeReq::default_instance_ = new CSNoticeReq();
  CSChangeNameReq::default_instance_ = new CSChangeNameReq();
  CSChangeNameResp::default_instance_ = new CSChangeNameResp();
  CSGMCmdReq::default_instance_ = new CSGMCmdReq();
  CSXinShouRecodeReq::default_instance_ = new CSXinShouRecodeReq();
  CSXinShouRecodeResp::default_instance_ = new CSXinShouRecodeResp();
  CSMission::default_instance_ = new CSMission();
  CSMissionListReq::default_instance_ = new CSMissionListReq();
  CSMissionListResp::default_instance_ = new CSMissionListResp();
  CSMissionCompleteReq::default_instance_ = new CSMissionCompleteReq();
  CSMissionCompleteResp::default_instance_ = new CSMissionCompleteResp();
  CSMissionUpdateResp::default_instance_ = new CSMissionUpdateResp();
  CSBuyNewbieGiftReq::default_instance_ = new CSBuyNewbieGiftReq();
  CSBuyNewbieGiftResp::default_instance_ = new CSBuyNewbieGiftResp();
  CSMailInfo::default_instance_ = new CSMailInfo();
  CSGetMailReq::default_instance_ = new CSGetMailReq();
  CSGetMailResp::default_instance_ = new CSGetMailResp();
  CSDelMailReq::default_instance_ = new CSDelMailReq();
  CSDelMailResp::default_instance_ = new CSDelMailResp();
  CSNoticeMailReq::default_instance_ = new CSNoticeMailReq();
  CSRechargeCallbackReq::default_instance_ = new CSRechargeCallbackReq();
  CSRechargeCallbackResp::default_instance_ = new CSRechargeCallbackResp();
  CSUseGiftCodeReq::default_instance_ = new CSUseGiftCodeReq();
  CSUseGiftCodeResp::default_instance_ = new CSUseGiftCodeResp();
  CheckPtData::default_instance_ = new CheckPtData();
  CSSaveCheckPtDataReq::default_instance_ = new CSSaveCheckPtDataReq();
  CSSaveCheckPtDataResp::default_instance_ = new CSSaveCheckPtDataResp();
  CSRetriveCheckPtRewardReq::default_instance_ = new CSRetriveCheckPtRewardReq();
  CSRetriveCheckPtRewardResp::default_instance_ = new CSRetriveCheckPtRewardResp();
  CSGetCheckPtDataReq::default_instance_ = new CSGetCheckPtDataReq();
  ChapterData::default_instance_ = new ChapterData();
  CSGetCheckPtDataResp::default_instance_ = new CSGetCheckPtDataResp();
  CSChapterUnlockReq::default_instance_ = new CSChapterUnlockReq();
  CSChapterUnlockResp::default_instance_ = new CSChapterUnlockResp();
  CSGetChestReq::default_instance_ = new CSGetChestReq();
  CSGetChestResp::default_instance_ = new CSGetChestResp();
  CSPveNotifyReq::default_instance_ = new CSPveNotifyReq();
  CSPveNotifyResp::default_instance_ = new CSPveNotifyResp();
  CSPveCheckAwardReq::default_instance_ = new CSPveCheckAwardReq();
  CSPveCheckAwardResp::default_instance_ = new CSPveCheckAwardResp();
  CSPvePveRank::default_instance_ = new CSPvePveRank();
  CSPveRankData::default_instance_ = new CSPveRankData();
  CSPveRankReq::default_instance_ = new CSPveRankReq();
  CSPveRankResp::default_instance_ = new CSPveRankResp();
  CSOpenChestResp::default_instance_ = new CSOpenChestResp();
  CSSetSignatureReq::default_instance_ = new CSSetSignatureReq();
  CSSetSignatureResp::default_instance_ = new CSSetSignatureResp();
  CSSetExtraInfoVisibleReq::default_instance_ = new CSSetExtraInfoVisibleReq();
  CSSetExtraInfoVisibleResp::default_instance_ = new CSSetExtraInfoVisibleResp();
  CSGetExtraInfoReq::default_instance_ = new CSGetExtraInfoReq();
  CSGetExtraInfoResp::default_instance_ = new CSGetExtraInfoResp();
  CSShareRewardGetResq::default_instance_ = new CSShareRewardGetResq();
  CSShareRewardGetReq::default_instance_ = new CSShareRewardGetReq();
  CSGetSevenGoalListReq::default_instance_ = new CSGetSevenGoalListReq();
  CSGetSevenGoalListResp::default_instance_ = new CSGetSevenGoalListResp();
  CSNoticeSevenGoalResp::default_instance_ = new CSNoticeSevenGoalResp();
  CSRetriveSevenGoalReq::default_instance_ = new CSRetriveSevenGoalReq();
  CSRetriveSevenGoalResp::default_instance_ = new CSRetriveSevenGoalResp();
  CSTopRankReq::default_instance_ = new CSTopRankReq();
  TopRankData::default_instance_ = new TopRankData();
  CSTopRankResp::default_instance_ = new CSTopRankResp();
  CSTopRankTimeReq::default_instance_ = new CSTopRankTimeReq();
  CSTopRankTimeResp::default_instance_ = new CSTopRankTimeResp();
  PropertyUpdateData::default_instance_->InitAsDefaultInstance();
  CSQueryPlayerInfoReq::default_instance_->InitAsDefaultInstance();
  CSQueryPlayerInfoResp::default_instance_->InitAsDefaultInstance();
  CSShopGuideReq::default_instance_->InitAsDefaultInstance();
  CSShopGuideResp::default_instance_->InitAsDefaultInstance();
  CSTestAddDiamondReq::default_instance_->InitAsDefaultInstance();
  CSSetTitleReq::default_instance_->InitAsDefaultInstance();
  CSSetTitleResp::default_instance_->InitAsDefaultInstance();
  CSShopBuyReq::default_instance_->InitAsDefaultInstance();
  CSShopBuyResp::default_instance_->InitAsDefaultInstance();
  CSShopListReq::default_instance_->InitAsDefaultInstance();
  DiamondData::default_instance_->InitAsDefaultInstance();
  GiftData::default_instance_->InitAsDefaultInstance();
  CSShopListResp::default_instance_->InitAsDefaultInstance();
  ExchangeItemInfo::default_instance_->InitAsDefaultInstance();
  CSExchangeItemReq::default_instance_->InitAsDefaultInstance();
  CSExchangeItemResp::default_instance_->InitAsDefaultInstance();
  CSUpdateExchangeListReq::default_instance_->InitAsDefaultInstance();
  CSUpdateExchangeListResp::default_instance_->InitAsDefaultInstance();
  CSChangePlayerIconReq::default_instance_->InitAsDefaultInstance();
  CSChangePlayerIconResp::default_instance_->InitAsDefaultInstance();
  CSSetNewBieReq::default_instance_->InitAsDefaultInstance();
  CSSetNewBieResp::default_instance_->InitAsDefaultInstance();
  CSGetNewBieListReq::default_instance_->InitAsDefaultInstance();
  CSGetNewBieListResp::default_instance_->InitAsDefaultInstance();
  CSSetNewBieOssReq::default_instance_->InitAsDefaultInstance();
  CSSetNewBieOssResp::default_instance_->InitAsDefaultInstance();
  CSOpenBigStageReq::default_instance_->InitAsDefaultInstance();
  CSOpenBigStageResp::default_instance_->InitAsDefaultInstance();
  CSEnterPointReq::default_instance_->InitAsDefaultInstance();
  CSEnterPointResp::default_instance_->InitAsDefaultInstance();
  CSBuyITtemReq::default_instance_->InitAsDefaultInstance();
  CSBuyItemResp::default_instance_->InitAsDefaultInstance();
  CSUseItemReq::default_instance_->InitAsDefaultInstance();
  CSUseItemResp::default_instance_->InitAsDefaultInstance();
  CSBuyVipReq::default_instance_->InitAsDefaultInstance();
  CSVipTimeReq::default_instance_->InitAsDefaultInstance();
  CSBuyVipResp::default_instance_->InitAsDefaultInstance();
  CSPropertyUpdateResp::default_instance_->InitAsDefaultInstance();
  CSGetAchievementReq::default_instance_->InitAsDefaultInstance();
  CSGetAchievementInfo::default_instance_->InitAsDefaultInstance();
  CSGetAchievementResp::default_instance_->InitAsDefaultInstance();
  CSReceiveAchievementReq::default_instance_->InitAsDefaultInstance();
  CSReceiveAchievementResp::default_instance_->InitAsDefaultInstance();
  CSReceiveAchievementRewardReq::default_instance_->InitAsDefaultInstance();
  CSReceiveAchievementRewardResp::default_instance_->InitAsDefaultInstance();
  CSUpdateAchievementResp::default_instance_->InitAsDefaultInstance();
  CSSevenDaySignListReq::default_instance_->InitAsDefaultInstance();
  CSSevenDayGetList::default_instance_->InitAsDefaultInstance();
  CSSevenDaySignListResp::default_instance_->InitAsDefaultInstance();
  CSSevenDaySignReq::default_instance_->InitAsDefaultInstance();
  CSSevenDaySignResp::default_instance_->InitAsDefaultInstance();
  CSGetServerReq::default_instance_->InitAsDefaultInstance();
  CSGetServerResp::default_instance_->InitAsDefaultInstance();
  CSEnterServerReq::default_instance_->InitAsDefaultInstance();
  CSEnterServerResp::default_instance_->InitAsDefaultInstance();
  CSCanEnterReq::default_instance_->InitAsDefaultInstance();
  CSDirectEnterReq::default_instance_->InitAsDefaultInstance();
  CSDircetEnterResp::default_instance_->InitAsDefaultInstance();
  CSQueueReq::default_instance_->InitAsDefaultInstance();
  CSStreakWinValueReq::default_instance_->InitAsDefaultInstance();
  CSStreakWinValueResp::default_instance_->InitAsDefaultInstance();
  CSStreakWinGetReq::default_instance_->InitAsDefaultInstance();
  CSStreakWinGetResp::default_instance_->InitAsDefaultInstance();
  CSItem::default_instance_->InitAsDefaultInstance();
  CSSycPlayerInfoReq::default_instance_->InitAsDefaultInstance();
  CSTitleItem::default_instance_->InitAsDefaultInstance();
  CSSycPlayerInfoResp::default_instance_->InitAsDefaultInstance();
  CSSyncPlayerDataReq::default_instance_->InitAsDefaultInstance();
  CSSyncPlayerDataResp::default_instance_->InitAsDefaultInstance();
  CSGetPlayerDataReq::default_instance_->InitAsDefaultInstance();
  CSGetPlayerDataResp::default_instance_->InitAsDefaultInstance();
  CSNoticeReq::default_instance_->InitAsDefaultInstance();
  CSChangeNameReq::default_instance_->InitAsDefaultInstance();
  CSChangeNameResp::default_instance_->InitAsDefaultInstance();
  CSGMCmdReq::default_instance_->InitAsDefaultInstance();
  CSXinShouRecodeReq::default_instance_->InitAsDefaultInstance();
  CSXinShouRecodeResp::default_instance_->InitAsDefaultInstance();
  CSMission::default_instance_->InitAsDefaultInstance();
  CSMissionListReq::default_instance_->InitAsDefaultInstance();
  CSMissionListResp::default_instance_->InitAsDefaultInstance();
  CSMissionCompleteReq::default_instance_->InitAsDefaultInstance();
  CSMissionCompleteResp::default_instance_->InitAsDefaultInstance();
  CSMissionUpdateResp::default_instance_->InitAsDefaultInstance();
  CSBuyNewbieGiftReq::default_instance_->InitAsDefaultInstance();
  CSBuyNewbieGiftResp::default_instance_->InitAsDefaultInstance();
  CSMailInfo::default_instance_->InitAsDefaultInstance();
  CSGetMailReq::default_instance_->InitAsDefaultInstance();
  CSGetMailResp::default_instance_->InitAsDefaultInstance();
  CSDelMailReq::default_instance_->InitAsDefaultInstance();
  CSDelMailResp::default_instance_->InitAsDefaultInstance();
  CSNoticeMailReq::default_instance_->InitAsDefaultInstance();
  CSRechargeCallbackReq::default_instance_->InitAsDefaultInstance();
  CSRechargeCallbackResp::default_instance_->InitAsDefaultInstance();
  CSUseGiftCodeReq::default_instance_->InitAsDefaultInstance();
  CSUseGiftCodeResp::default_instance_->InitAsDefaultInstance();
  CheckPtData::default_instance_->InitAsDefaultInstance();
  CSSaveCheckPtDataReq::default_instance_->InitAsDefaultInstance();
  CSSaveCheckPtDataResp::default_instance_->InitAsDefaultInstance();
  CSRetriveCheckPtRewardReq::default_instance_->InitAsDefaultInstance();
  CSRetriveCheckPtRewardResp::default_instance_->InitAsDefaultInstance();
  CSGetCheckPtDataReq::default_instance_->InitAsDefaultInstance();
  ChapterData::default_instance_->InitAsDefaultInstance();
  CSGetCheckPtDataResp::default_instance_->InitAsDefaultInstance();
  CSChapterUnlockReq::default_instance_->InitAsDefaultInstance();
  CSChapterUnlockResp::default_instance_->InitAsDefaultInstance();
  CSGetChestReq::default_instance_->InitAsDefaultInstance();
  CSGetChestResp::default_instance_->InitAsDefaultInstance();
  CSPveNotifyReq::default_instance_->InitAsDefaultInstance();
  CSPveNotifyResp::default_instance_->InitAsDefaultInstance();
  CSPveCheckAwardReq::default_instance_->InitAsDefaultInstance();
  CSPveCheckAwardResp::default_instance_->InitAsDefaultInstance();
  CSPvePveRank::default_instance_->InitAsDefaultInstance();
  CSPveRankData::default_instance_->InitAsDefaultInstance();
  CSPveRankReq::default_instance_->InitAsDefaultInstance();
  CSPveRankResp::default_instance_->InitAsDefaultInstance();
  CSOpenChestResp::default_instance_->InitAsDefaultInstance();
  CSSetSignatureReq::default_instance_->InitAsDefaultInstance();
  CSSetSignatureResp::default_instance_->InitAsDefaultInstance();
  CSSetExtraInfoVisibleReq::default_instance_->InitAsDefaultInstance();
  CSSetExtraInfoVisibleResp::default_instance_->InitAsDefaultInstance();
  CSGetExtraInfoReq::default_instance_->InitAsDefaultInstance();
  CSGetExtraInfoResp::default_instance_->InitAsDefaultInstance();
  CSShareRewardGetResq::default_instance_->InitAsDefaultInstance();
  CSShareRewardGetReq::default_instance_->InitAsDefaultInstance();
  CSGetSevenGoalListReq::default_instance_->InitAsDefaultInstance();
  CSGetSevenGoalListResp::default_instance_->InitAsDefaultInstance();
  CSNoticeSevenGoalResp::default_instance_->InitAsDefaultInstance();
  CSRetriveSevenGoalReq::default_instance_->InitAsDefaultInstance();
  CSRetriveSevenGoalResp::default_instance_->InitAsDefaultInstance();
  CSTopRankReq::default_instance_->InitAsDefaultInstance();
  TopRankData::default_instance_->InitAsDefaultInstance();
  CSTopRankResp::default_instance_->InitAsDefaultInstance();
  CSTopRankTimeReq::default_instance_->InitAsDefaultInstance();
  CSTopRankTimeResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Player_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_Player_2eproto_once_);
void protobuf_AddDesc_Player_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_Player_2eproto_once_,
                 &protobuf_AddDesc_Player_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Player_2eproto {
  StaticDescriptorInitializer_Player_2eproto() {
    protobuf_AddDesc_Player_2eproto();
  }
} static_descriptor_initializer_Player_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int PropertyUpdateData::kUpTypeFieldNumber;
const int PropertyUpdateData::kValueFieldNumber;
const int PropertyUpdateData::kValue2FieldNumber;
const int PropertyUpdateData::kExtraFieldNumber;
const int PropertyUpdateData::kSrcFieldNumber;
#endif  // !_MSC_VER

PropertyUpdateData::PropertyUpdateData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.PropertyUpdateData)
}

void PropertyUpdateData::InitAsDefaultInstance() {
}

PropertyUpdateData::PropertyUpdateData(const PropertyUpdateData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.PropertyUpdateData)
}

void PropertyUpdateData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  uptype_ = 0u;
  value_ = 0u;
  value2_ = 0u;
  extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  src_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PropertyUpdateData::~PropertyUpdateData() {
  // @@protoc_insertion_point(destructor:fgame.PropertyUpdateData)
  SharedDtor();
}

void PropertyUpdateData::SharedDtor() {
  if (extra_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extra_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PropertyUpdateData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PropertyUpdateData& PropertyUpdateData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

PropertyUpdateData* PropertyUpdateData::default_instance_ = NULL;

PropertyUpdateData* PropertyUpdateData::New() const {
  return new PropertyUpdateData;
}

void PropertyUpdateData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PropertyUpdateData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(uptype_, value_);
    ZR_(value2_, src_);
    if (has_extra()) {
      if (extra_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        extra_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PropertyUpdateData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.PropertyUpdateData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 UpType = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uptype_)));
          set_has_uptype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Value;
        break;
      }

      // optional uint32 Value = 2;
      case 2: {
        if (tag == 16) {
         parse_Value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Value2;
        break;
      }

      // optional uint32 Value2 = 3;
      case 3: {
        if (tag == 24) {
         parse_Value2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value2_)));
          set_has_value2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_Extra;
        break;
      }

      // optional string Extra = 4;
      case 4: {
        if (tag == 34) {
         parse_Extra:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_extra()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_Src;
        break;
      }

      // optional uint32 Src = 5;
      case 5: {
        if (tag == 40) {
         parse_Src:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &src_)));
          set_has_src();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.PropertyUpdateData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.PropertyUpdateData)
  return false;
#undef DO_
}

void PropertyUpdateData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.PropertyUpdateData)
  // required uint32 UpType = 1;
  if (has_uptype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uptype(), output);
  }

  // optional uint32 Value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->value(), output);
  }

  // optional uint32 Value2 = 3;
  if (has_value2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->value2(), output);
  }

  // optional string Extra = 4;
  if (has_extra()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->extra(), output);
  }

  // optional uint32 Src = 5;
  if (has_src()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->src(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.PropertyUpdateData)
}

int PropertyUpdateData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 UpType = 1;
    if (has_uptype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uptype());
    }

    // optional uint32 Value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

    // optional uint32 Value2 = 3;
    if (has_value2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value2());
    }

    // optional string Extra = 4;
    if (has_extra()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->extra());
    }

    // optional uint32 Src = 5;
    if (has_src()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->src());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PropertyUpdateData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PropertyUpdateData*>(&from));
}

void PropertyUpdateData::MergeFrom(const PropertyUpdateData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uptype()) {
      set_uptype(from.uptype());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_value2()) {
      set_value2(from.value2());
    }
    if (from.has_extra()) {
      set_extra(from.extra());
    }
    if (from.has_src()) {
      set_src(from.src());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PropertyUpdateData::CopyFrom(const PropertyUpdateData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PropertyUpdateData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PropertyUpdateData::Swap(PropertyUpdateData* other) {
  if (other != this) {
    std::swap(uptype_, other->uptype_);
    std::swap(value_, other->value_);
    std::swap(value2_, other->value2_);
    std::swap(extra_, other->extra_);
    std::swap(src_, other->src_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PropertyUpdateData::GetTypeName() const {
  return "fgame.PropertyUpdateData";
}


// ===================================================================

#ifndef _MSC_VER
const int CSQueryPlayerInfoReq::kUinFieldNumber;
#endif  // !_MSC_VER

CSQueryPlayerInfoReq::CSQueryPlayerInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSQueryPlayerInfoReq)
}

void CSQueryPlayerInfoReq::InitAsDefaultInstance() {
}

CSQueryPlayerInfoReq::CSQueryPlayerInfoReq(const CSQueryPlayerInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSQueryPlayerInfoReq)
}

void CSQueryPlayerInfoReq::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSQueryPlayerInfoReq::~CSQueryPlayerInfoReq() {
  // @@protoc_insertion_point(destructor:fgame.CSQueryPlayerInfoReq)
  SharedDtor();
}

void CSQueryPlayerInfoReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSQueryPlayerInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSQueryPlayerInfoReq& CSQueryPlayerInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSQueryPlayerInfoReq* CSQueryPlayerInfoReq::default_instance_ = NULL;

CSQueryPlayerInfoReq* CSQueryPlayerInfoReq::New() const {
  return new CSQueryPlayerInfoReq;
}

void CSQueryPlayerInfoReq::Clear() {
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSQueryPlayerInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSQueryPlayerInfoReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSQueryPlayerInfoReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSQueryPlayerInfoReq)
  return false;
#undef DO_
}

void CSQueryPlayerInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSQueryPlayerInfoReq)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSQueryPlayerInfoReq)
}

int CSQueryPlayerInfoReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSQueryPlayerInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSQueryPlayerInfoReq*>(&from));
}

void CSQueryPlayerInfoReq::MergeFrom(const CSQueryPlayerInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSQueryPlayerInfoReq::CopyFrom(const CSQueryPlayerInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSQueryPlayerInfoReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSQueryPlayerInfoReq::Swap(CSQueryPlayerInfoReq* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSQueryPlayerInfoReq::GetTypeName() const {
  return "fgame.CSQueryPlayerInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSQueryPlayerInfoResp::kUinFieldNumber;
const int CSQueryPlayerInfoResp::kNameFieldNumber;
const int CSQueryPlayerInfoResp::kIconFieldNumber;
const int CSQueryPlayerInfoResp::kTitleFieldNumber;
const int CSQueryPlayerInfoResp::kLevelFieldNumber;
const int CSQueryPlayerInfoResp::kScoreFieldNumber;
const int CSQueryPlayerInfoResp::kWinRateFieldNumber;
const int CSQueryPlayerInfoResp::kGroupFieldNumber;
const int CSQueryPlayerInfoResp::kRankFieldNumber;
const int CSQueryPlayerInfoResp::kExpLevelFieldNumber;
const int CSQueryPlayerInfoResp::kExpFieldNumber;
const int CSQueryPlayerInfoResp::kGlyphsLevelFieldNumber;
const int CSQueryPlayerInfoResp::kMaxCheckPointFieldNumber;
const int CSQueryPlayerInfoResp::kSignatureFieldNumber;
const int CSQueryPlayerInfoResp::kVipLevelFieldNumber;
const int CSQueryPlayerInfoResp::kVisibleFieldNumber;
const int CSQueryPlayerInfoResp::kAreaFieldNumber;
#endif  // !_MSC_VER

CSQueryPlayerInfoResp::CSQueryPlayerInfoResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSQueryPlayerInfoResp)
}

void CSQueryPlayerInfoResp::InitAsDefaultInstance() {
}

CSQueryPlayerInfoResp::CSQueryPlayerInfoResp(const CSQueryPlayerInfoResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSQueryPlayerInfoResp)
}

void CSQueryPlayerInfoResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  title_ = GOOGLE_ULONGLONG(0);
  level_ = 0u;
  score_ = 0u;
  winrate_ = 0;
  group_ = 0u;
  rank_ = 0u;
  explevel_ = 0u;
  exp_ = 0u;
  glyphslevel_ = 0u;
  maxcheckpoint_ = 0u;
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  viplevel_ = 0u;
  visible_ = false;
  area_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSQueryPlayerInfoResp::~CSQueryPlayerInfoResp() {
  // @@protoc_insertion_point(destructor:fgame.CSQueryPlayerInfoResp)
  SharedDtor();
}

void CSQueryPlayerInfoResp::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_;
  }
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSQueryPlayerInfoResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSQueryPlayerInfoResp& CSQueryPlayerInfoResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSQueryPlayerInfoResp* CSQueryPlayerInfoResp::default_instance_ = NULL;

CSQueryPlayerInfoResp* CSQueryPlayerInfoResp::New() const {
  return new CSQueryPlayerInfoResp;
}

void CSQueryPlayerInfoResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSQueryPlayerInfoResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(title_, group_);
    uin_ = GOOGLE_ULONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_icon()) {
      if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        icon_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 65280) {
    ZR_(rank_, glyphslevel_);
    ZR_(maxcheckpoint_, visible_);
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        signature_->clear();
      }
    }
  }
  area_ = 0u;

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSQueryPlayerInfoResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSQueryPlayerInfoResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Name;
        break;
      }

      // required string Name = 2;
      case 2: {
        if (tag == 18) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_Icon;
        break;
      }

      // optional string Icon = 3;
      case 3: {
        if (tag == 26) {
         parse_Icon:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_icon()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Title;
        break;
      }

      // optional uint64 Title = 4;
      case 4: {
        if (tag == 32) {
         parse_Title:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &title_)));
          set_has_title();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_Level;
        break;
      }

      // optional uint32 Level = 5;
      case 5: {
        if (tag == 40) {
         parse_Level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_Score;
        break;
      }

      // optional uint32 Score = 6;
      case 6: {
        if (tag == 48) {
         parse_Score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_WinRate;
        break;
      }

      // optional float WinRate = 7;
      case 7: {
        if (tag == 61) {
         parse_WinRate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &winrate_)));
          set_has_winrate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_Group;
        break;
      }

      // optional uint32 Group = 8;
      case 8: {
        if (tag == 64) {
         parse_Group:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_)));
          set_has_group();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_Rank;
        break;
      }

      // optional uint32 Rank = 9;
      case 9: {
        if (tag == 72) {
         parse_Rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_)));
          set_has_rank();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_ExpLevel;
        break;
      }

      // optional uint32 ExpLevel = 10;
      case 10: {
        if (tag == 80) {
         parse_ExpLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &explevel_)));
          set_has_explevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_Exp;
        break;
      }

      // optional uint32 Exp = 11;
      case 11: {
        if (tag == 88) {
         parse_Exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_GlyphsLevel;
        break;
      }

      // optional uint32 GlyphsLevel = 12;
      case 12: {
        if (tag == 96) {
         parse_GlyphsLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &glyphslevel_)));
          set_has_glyphslevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_MaxCheckPoint;
        break;
      }

      // optional uint32 MaxCheckPoint = 13;
      case 13: {
        if (tag == 104) {
         parse_MaxCheckPoint:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &maxcheckpoint_)));
          set_has_maxcheckpoint();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_Signature;
        break;
      }

      // optional string Signature = 14;
      case 14: {
        if (tag == 114) {
         parse_Signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_VipLevel;
        break;
      }

      // optional uint32 VipLevel = 15;
      case 15: {
        if (tag == 120) {
         parse_VipLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &viplevel_)));
          set_has_viplevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_Visible;
        break;
      }

      // optional bool Visible = 16;
      case 16: {
        if (tag == 128) {
         parse_Visible:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &visible_)));
          set_has_visible();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_Area;
        break;
      }

      // optional uint32 Area = 17;
      case 17: {
        if (tag == 136) {
         parse_Area:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &area_)));
          set_has_area();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSQueryPlayerInfoResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSQueryPlayerInfoResp)
  return false;
#undef DO_
}

void CSQueryPlayerInfoResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSQueryPlayerInfoResp)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  // required string Name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional string Icon = 3;
  if (has_icon()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->icon(), output);
  }

  // optional uint64 Title = 4;
  if (has_title()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->title(), output);
  }

  // optional uint32 Level = 5;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->level(), output);
  }

  // optional uint32 Score = 6;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->score(), output);
  }

  // optional float WinRate = 7;
  if (has_winrate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->winrate(), output);
  }

  // optional uint32 Group = 8;
  if (has_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->group(), output);
  }

  // optional uint32 Rank = 9;
  if (has_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->rank(), output);
  }

  // optional uint32 ExpLevel = 10;
  if (has_explevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->explevel(), output);
  }

  // optional uint32 Exp = 11;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->exp(), output);
  }

  // optional uint32 GlyphsLevel = 12;
  if (has_glyphslevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->glyphslevel(), output);
  }

  // optional uint32 MaxCheckPoint = 13;
  if (has_maxcheckpoint()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->maxcheckpoint(), output);
  }

  // optional string Signature = 14;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      14, this->signature(), output);
  }

  // optional uint32 VipLevel = 15;
  if (has_viplevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->viplevel(), output);
  }

  // optional bool Visible = 16;
  if (has_visible()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(16, this->visible(), output);
  }

  // optional uint32 Area = 17;
  if (has_area()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(17, this->area(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSQueryPlayerInfoResp)
}

int CSQueryPlayerInfoResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

    // required string Name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string Icon = 3;
    if (has_icon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->icon());
    }

    // optional uint64 Title = 4;
    if (has_title()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->title());
    }

    // optional uint32 Level = 5;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->level());
    }

    // optional uint32 Score = 6;
    if (has_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->score());
    }

    // optional float WinRate = 7;
    if (has_winrate()) {
      total_size += 1 + 4;
    }

    // optional uint32 Group = 8;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 Rank = 9;
    if (has_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank());
    }

    // optional uint32 ExpLevel = 10;
    if (has_explevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->explevel());
    }

    // optional uint32 Exp = 11;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->exp());
    }

    // optional uint32 GlyphsLevel = 12;
    if (has_glyphslevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->glyphslevel());
    }

    // optional uint32 MaxCheckPoint = 13;
    if (has_maxcheckpoint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->maxcheckpoint());
    }

    // optional string Signature = 14;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->signature());
    }

    // optional uint32 VipLevel = 15;
    if (has_viplevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->viplevel());
    }

    // optional bool Visible = 16;
    if (has_visible()) {
      total_size += 2 + 1;
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional uint32 Area = 17;
    if (has_area()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->area());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSQueryPlayerInfoResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSQueryPlayerInfoResp*>(&from));
}

void CSQueryPlayerInfoResp::MergeFrom(const CSQueryPlayerInfoResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_icon()) {
      set_icon(from.icon());
    }
    if (from.has_title()) {
      set_title(from.title());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
    if (from.has_winrate()) {
      set_winrate(from.winrate());
    }
    if (from.has_group()) {
      set_group(from.group());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_rank()) {
      set_rank(from.rank());
    }
    if (from.has_explevel()) {
      set_explevel(from.explevel());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
    if (from.has_glyphslevel()) {
      set_glyphslevel(from.glyphslevel());
    }
    if (from.has_maxcheckpoint()) {
      set_maxcheckpoint(from.maxcheckpoint());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
    if (from.has_viplevel()) {
      set_viplevel(from.viplevel());
    }
    if (from.has_visible()) {
      set_visible(from.visible());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_area()) {
      set_area(from.area());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSQueryPlayerInfoResp::CopyFrom(const CSQueryPlayerInfoResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSQueryPlayerInfoResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSQueryPlayerInfoResp::Swap(CSQueryPlayerInfoResp* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(name_, other->name_);
    std::swap(icon_, other->icon_);
    std::swap(title_, other->title_);
    std::swap(level_, other->level_);
    std::swap(score_, other->score_);
    std::swap(winrate_, other->winrate_);
    std::swap(group_, other->group_);
    std::swap(rank_, other->rank_);
    std::swap(explevel_, other->explevel_);
    std::swap(exp_, other->exp_);
    std::swap(glyphslevel_, other->glyphslevel_);
    std::swap(maxcheckpoint_, other->maxcheckpoint_);
    std::swap(signature_, other->signature_);
    std::swap(viplevel_, other->viplevel_);
    std::swap(visible_, other->visible_);
    std::swap(area_, other->area_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSQueryPlayerInfoResp::GetTypeName() const {
  return "fgame.CSQueryPlayerInfoResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSShopGuideReq::kDiamondFieldNumber;
#endif  // !_MSC_VER

CSShopGuideReq::CSShopGuideReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSShopGuideReq)
}

void CSShopGuideReq::InitAsDefaultInstance() {
}

CSShopGuideReq::CSShopGuideReq(const CSShopGuideReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSShopGuideReq)
}

void CSShopGuideReq::SharedCtor() {
  _cached_size_ = 0;
  diamond_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSShopGuideReq::~CSShopGuideReq() {
  // @@protoc_insertion_point(destructor:fgame.CSShopGuideReq)
  SharedDtor();
}

void CSShopGuideReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSShopGuideReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSShopGuideReq& CSShopGuideReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSShopGuideReq* CSShopGuideReq::default_instance_ = NULL;

CSShopGuideReq* CSShopGuideReq::New() const {
  return new CSShopGuideReq;
}

void CSShopGuideReq::Clear() {
  diamond_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSShopGuideReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSShopGuideReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Diamond = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &diamond_)));
          set_has_diamond();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSShopGuideReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSShopGuideReq)
  return false;
#undef DO_
}

void CSShopGuideReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSShopGuideReq)
  // required uint32 Diamond = 1;
  if (has_diamond()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->diamond(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSShopGuideReq)
}

int CSShopGuideReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Diamond = 1;
    if (has_diamond()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->diamond());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSShopGuideReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSShopGuideReq*>(&from));
}

void CSShopGuideReq::MergeFrom(const CSShopGuideReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_diamond()) {
      set_diamond(from.diamond());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSShopGuideReq::CopyFrom(const CSShopGuideReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSShopGuideReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSShopGuideReq::Swap(CSShopGuideReq* other) {
  if (other != this) {
    std::swap(diamond_, other->diamond_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSShopGuideReq::GetTypeName() const {
  return "fgame.CSShopGuideReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSShopGuideResp::kRetFieldNumber;
const int CSShopGuideResp::kDiamondFieldNumber;
#endif  // !_MSC_VER

CSShopGuideResp::CSShopGuideResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSShopGuideResp)
}

void CSShopGuideResp::InitAsDefaultInstance() {
}

CSShopGuideResp::CSShopGuideResp(const CSShopGuideResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSShopGuideResp)
}

void CSShopGuideResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  diamond_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSShopGuideResp::~CSShopGuideResp() {
  // @@protoc_insertion_point(destructor:fgame.CSShopGuideResp)
  SharedDtor();
}

void CSShopGuideResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSShopGuideResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSShopGuideResp& CSShopGuideResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSShopGuideResp* CSShopGuideResp::default_instance_ = NULL;

CSShopGuideResp* CSShopGuideResp::New() const {
  return new CSShopGuideResp;
}

void CSShopGuideResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSShopGuideResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ret_, diamond_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSShopGuideResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSShopGuideResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Diamond;
        break;
      }

      // required uint32 Diamond = 2;
      case 2: {
        if (tag == 16) {
         parse_Diamond:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &diamond_)));
          set_has_diamond();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSShopGuideResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSShopGuideResp)
  return false;
#undef DO_
}

void CSShopGuideResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSShopGuideResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // required uint32 Diamond = 2;
  if (has_diamond()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->diamond(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSShopGuideResp)
}

int CSShopGuideResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // required uint32 Diamond = 2;
    if (has_diamond()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->diamond());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSShopGuideResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSShopGuideResp*>(&from));
}

void CSShopGuideResp::MergeFrom(const CSShopGuideResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_diamond()) {
      set_diamond(from.diamond());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSShopGuideResp::CopyFrom(const CSShopGuideResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSShopGuideResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSShopGuideResp::Swap(CSShopGuideResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(diamond_, other->diamond_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSShopGuideResp::GetTypeName() const {
  return "fgame.CSShopGuideResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSTestAddDiamondReq::kDiamondFieldNumber;
#endif  // !_MSC_VER

CSTestAddDiamondReq::CSTestAddDiamondReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSTestAddDiamondReq)
}

void CSTestAddDiamondReq::InitAsDefaultInstance() {
}

CSTestAddDiamondReq::CSTestAddDiamondReq(const CSTestAddDiamondReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSTestAddDiamondReq)
}

void CSTestAddDiamondReq::SharedCtor() {
  _cached_size_ = 0;
  diamond_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSTestAddDiamondReq::~CSTestAddDiamondReq() {
  // @@protoc_insertion_point(destructor:fgame.CSTestAddDiamondReq)
  SharedDtor();
}

void CSTestAddDiamondReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSTestAddDiamondReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSTestAddDiamondReq& CSTestAddDiamondReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSTestAddDiamondReq* CSTestAddDiamondReq::default_instance_ = NULL;

CSTestAddDiamondReq* CSTestAddDiamondReq::New() const {
  return new CSTestAddDiamondReq;
}

void CSTestAddDiamondReq::Clear() {
  diamond_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSTestAddDiamondReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSTestAddDiamondReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Diamond = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &diamond_)));
          set_has_diamond();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSTestAddDiamondReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSTestAddDiamondReq)
  return false;
#undef DO_
}

void CSTestAddDiamondReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSTestAddDiamondReq)
  // required uint32 Diamond = 1;
  if (has_diamond()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->diamond(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSTestAddDiamondReq)
}

int CSTestAddDiamondReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Diamond = 1;
    if (has_diamond()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->diamond());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSTestAddDiamondReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSTestAddDiamondReq*>(&from));
}

void CSTestAddDiamondReq::MergeFrom(const CSTestAddDiamondReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_diamond()) {
      set_diamond(from.diamond());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSTestAddDiamondReq::CopyFrom(const CSTestAddDiamondReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSTestAddDiamondReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSTestAddDiamondReq::Swap(CSTestAddDiamondReq* other) {
  if (other != this) {
    std::swap(diamond_, other->diamond_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSTestAddDiamondReq::GetTypeName() const {
  return "fgame.CSTestAddDiamondReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSetTitleReq::kTitleFieldNumber;
#endif  // !_MSC_VER

CSSetTitleReq::CSSetTitleReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSetTitleReq)
}

void CSSetTitleReq::InitAsDefaultInstance() {
}

CSSetTitleReq::CSSetTitleReq(const CSSetTitleReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSetTitleReq)
}

void CSSetTitleReq::SharedCtor() {
  _cached_size_ = 0;
  title_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSetTitleReq::~CSSetTitleReq() {
  // @@protoc_insertion_point(destructor:fgame.CSSetTitleReq)
  SharedDtor();
}

void CSSetTitleReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSetTitleReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSetTitleReq& CSSetTitleReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSetTitleReq* CSSetTitleReq::default_instance_ = NULL;

CSSetTitleReq* CSSetTitleReq::New() const {
  return new CSSetTitleReq;
}

void CSSetTitleReq::Clear() {
  title_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSetTitleReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSetTitleReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Title = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &title_)));
          set_has_title();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSetTitleReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSetTitleReq)
  return false;
#undef DO_
}

void CSSetTitleReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSetTitleReq)
  // required uint32 Title = 1;
  if (has_title()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->title(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSetTitleReq)
}

int CSSetTitleReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Title = 1;
    if (has_title()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->title());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSetTitleReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSetTitleReq*>(&from));
}

void CSSetTitleReq::MergeFrom(const CSSetTitleReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_title()) {
      set_title(from.title());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSetTitleReq::CopyFrom(const CSSetTitleReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSetTitleReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSSetTitleReq::Swap(CSSetTitleReq* other) {
  if (other != this) {
    std::swap(title_, other->title_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSetTitleReq::GetTypeName() const {
  return "fgame.CSSetTitleReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSetTitleResp::kTitleFieldNumber;
#endif  // !_MSC_VER

CSSetTitleResp::CSSetTitleResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSetTitleResp)
}

void CSSetTitleResp::InitAsDefaultInstance() {
}

CSSetTitleResp::CSSetTitleResp(const CSSetTitleResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSetTitleResp)
}

void CSSetTitleResp::SharedCtor() {
  _cached_size_ = 0;
  title_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSetTitleResp::~CSSetTitleResp() {
  // @@protoc_insertion_point(destructor:fgame.CSSetTitleResp)
  SharedDtor();
}

void CSSetTitleResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSetTitleResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSetTitleResp& CSSetTitleResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSetTitleResp* CSSetTitleResp::default_instance_ = NULL;

CSSetTitleResp* CSSetTitleResp::New() const {
  return new CSSetTitleResp;
}

void CSSetTitleResp::Clear() {
  title_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSetTitleResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSetTitleResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Title = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &title_)));
          set_has_title();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSetTitleResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSetTitleResp)
  return false;
#undef DO_
}

void CSSetTitleResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSetTitleResp)
  // required uint32 Title = 1;
  if (has_title()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->title(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSetTitleResp)
}

int CSSetTitleResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Title = 1;
    if (has_title()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->title());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSetTitleResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSetTitleResp*>(&from));
}

void CSSetTitleResp::MergeFrom(const CSSetTitleResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_title()) {
      set_title(from.title());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSetTitleResp::CopyFrom(const CSSetTitleResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSetTitleResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSSetTitleResp::Swap(CSSetTitleResp* other) {
  if (other != this) {
    std::swap(title_, other->title_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSetTitleResp::GetTypeName() const {
  return "fgame.CSSetTitleResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSShopBuyReq::kShopIdFieldNumber;
#endif  // !_MSC_VER

CSShopBuyReq::CSShopBuyReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSShopBuyReq)
}

void CSShopBuyReq::InitAsDefaultInstance() {
}

CSShopBuyReq::CSShopBuyReq(const CSShopBuyReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSShopBuyReq)
}

void CSShopBuyReq::SharedCtor() {
  _cached_size_ = 0;
  shopid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSShopBuyReq::~CSShopBuyReq() {
  // @@protoc_insertion_point(destructor:fgame.CSShopBuyReq)
  SharedDtor();
}

void CSShopBuyReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSShopBuyReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSShopBuyReq& CSShopBuyReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSShopBuyReq* CSShopBuyReq::default_instance_ = NULL;

CSShopBuyReq* CSShopBuyReq::New() const {
  return new CSShopBuyReq;
}

void CSShopBuyReq::Clear() {
  shopid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSShopBuyReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSShopBuyReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ShopId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shopid_)));
          set_has_shopid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSShopBuyReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSShopBuyReq)
  return false;
#undef DO_
}

void CSShopBuyReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSShopBuyReq)
  // required uint32 ShopId = 1;
  if (has_shopid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->shopid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSShopBuyReq)
}

int CSShopBuyReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ShopId = 1;
    if (has_shopid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shopid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSShopBuyReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSShopBuyReq*>(&from));
}

void CSShopBuyReq::MergeFrom(const CSShopBuyReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_shopid()) {
      set_shopid(from.shopid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSShopBuyReq::CopyFrom(const CSShopBuyReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSShopBuyReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSShopBuyReq::Swap(CSShopBuyReq* other) {
  if (other != this) {
    std::swap(shopid_, other->shopid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSShopBuyReq::GetTypeName() const {
  return "fgame.CSShopBuyReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSShopBuyResp::kShopIdFieldNumber;
#endif  // !_MSC_VER

CSShopBuyResp::CSShopBuyResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSShopBuyResp)
}

void CSShopBuyResp::InitAsDefaultInstance() {
}

CSShopBuyResp::CSShopBuyResp(const CSShopBuyResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSShopBuyResp)
}

void CSShopBuyResp::SharedCtor() {
  _cached_size_ = 0;
  shopid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSShopBuyResp::~CSShopBuyResp() {
  // @@protoc_insertion_point(destructor:fgame.CSShopBuyResp)
  SharedDtor();
}

void CSShopBuyResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSShopBuyResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSShopBuyResp& CSShopBuyResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSShopBuyResp* CSShopBuyResp::default_instance_ = NULL;

CSShopBuyResp* CSShopBuyResp::New() const {
  return new CSShopBuyResp;
}

void CSShopBuyResp::Clear() {
  shopid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSShopBuyResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSShopBuyResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ShopId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shopid_)));
          set_has_shopid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSShopBuyResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSShopBuyResp)
  return false;
#undef DO_
}

void CSShopBuyResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSShopBuyResp)
  // required uint32 ShopId = 1;
  if (has_shopid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->shopid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSShopBuyResp)
}

int CSShopBuyResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ShopId = 1;
    if (has_shopid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shopid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSShopBuyResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSShopBuyResp*>(&from));
}

void CSShopBuyResp::MergeFrom(const CSShopBuyResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_shopid()) {
      set_shopid(from.shopid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSShopBuyResp::CopyFrom(const CSShopBuyResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSShopBuyResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSShopBuyResp::Swap(CSShopBuyResp* other) {
  if (other != this) {
    std::swap(shopid_, other->shopid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSShopBuyResp::GetTypeName() const {
  return "fgame.CSShopBuyResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSShopListReq::CSShopListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSShopListReq)
}

void CSShopListReq::InitAsDefaultInstance() {
}

CSShopListReq::CSShopListReq(const CSShopListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSShopListReq)
}

void CSShopListReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSShopListReq::~CSShopListReq() {
  // @@protoc_insertion_point(destructor:fgame.CSShopListReq)
  SharedDtor();
}

void CSShopListReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSShopListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSShopListReq& CSShopListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSShopListReq* CSShopListReq::default_instance_ = NULL;

CSShopListReq* CSShopListReq::New() const {
  return new CSShopListReq;
}

void CSShopListReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSShopListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSShopListReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSShopListReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSShopListReq)
  return false;
#undef DO_
}

void CSShopListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSShopListReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSShopListReq)
}

int CSShopListReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSShopListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSShopListReq*>(&from));
}

void CSShopListReq::MergeFrom(const CSShopListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSShopListReq::CopyFrom(const CSShopListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSShopListReq::IsInitialized() const {

  return true;
}

void CSShopListReq::Swap(CSShopListReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSShopListReq::GetTypeName() const {
  return "fgame.CSShopListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int DiamondData::kShopIdFieldNumber;
const int DiamondData::kFirstFieldNumber;
#endif  // !_MSC_VER

DiamondData::DiamondData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.DiamondData)
}

void DiamondData::InitAsDefaultInstance() {
}

DiamondData::DiamondData(const DiamondData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.DiamondData)
}

void DiamondData::SharedCtor() {
  _cached_size_ = 0;
  shopid_ = 0u;
  first_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DiamondData::~DiamondData() {
  // @@protoc_insertion_point(destructor:fgame.DiamondData)
  SharedDtor();
}

void DiamondData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DiamondData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DiamondData& DiamondData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

DiamondData* DiamondData::default_instance_ = NULL;

DiamondData* DiamondData::New() const {
  return new DiamondData;
}

void DiamondData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<DiamondData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(shopid_, first_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool DiamondData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.DiamondData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ShopId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shopid_)));
          set_has_shopid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_First;
        break;
      }

      // optional bool First = 2;
      case 2: {
        if (tag == 16) {
         parse_First:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &first_)));
          set_has_first();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.DiamondData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.DiamondData)
  return false;
#undef DO_
}

void DiamondData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.DiamondData)
  // required uint32 ShopId = 1;
  if (has_shopid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->shopid(), output);
  }

  // optional bool First = 2;
  if (has_first()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->first(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.DiamondData)
}

int DiamondData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ShopId = 1;
    if (has_shopid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shopid());
    }

    // optional bool First = 2;
    if (has_first()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DiamondData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DiamondData*>(&from));
}

void DiamondData::MergeFrom(const DiamondData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_shopid()) {
      set_shopid(from.shopid());
    }
    if (from.has_first()) {
      set_first(from.first());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void DiamondData::CopyFrom(const DiamondData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DiamondData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DiamondData::Swap(DiamondData* other) {
  if (other != this) {
    std::swap(shopid_, other->shopid_);
    std::swap(first_, other->first_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DiamondData::GetTypeName() const {
  return "fgame.DiamondData";
}


// ===================================================================

#ifndef _MSC_VER
const int GiftData::kShopIdFieldNumber;
const int GiftData::kGiftIdFieldNumber;
const int GiftData::kStartTimeFieldNumber;
const int GiftData::kEndTimeFieldNumber;
const int GiftData::kLeftCountFieldNumber;
const int GiftData::kGiftNameFieldNumber;
const int GiftData::kDiscountFieldNumber;
const int GiftData::kPriceFieldNumber;
const int GiftData::kGiftIconFieldNumber;
#endif  // !_MSC_VER

GiftData::GiftData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.GiftData)
}

void GiftData::InitAsDefaultInstance() {
}

GiftData::GiftData(const GiftData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.GiftData)
}

void GiftData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  shopid_ = 0u;
  giftid_ = 0u;
  starttime_ = 0u;
  endtime_ = 0u;
  leftcount_ = 0u;
  giftname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  discount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  price_ = 0u;
  gifticon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GiftData::~GiftData() {
  // @@protoc_insertion_point(destructor:fgame.GiftData)
  SharedDtor();
}

void GiftData::SharedDtor() {
  if (giftname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete giftname_;
  }
  if (discount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete discount_;
  }
  if (gifticon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gifticon_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GiftData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GiftData& GiftData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

GiftData* GiftData::default_instance_ = NULL;

GiftData* GiftData::New() const {
  return new GiftData;
}

void GiftData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GiftData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(shopid_, endtime_);
    ZR_(leftcount_, price_);
    if (has_giftname()) {
      if (giftname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        giftname_->clear();
      }
    }
    if (has_discount()) {
      if (discount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        discount_->clear();
      }
    }
  }
  if (has_gifticon()) {
    if (gifticon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      gifticon_->clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GiftData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.GiftData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ShopId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shopid_)));
          set_has_shopid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_GiftId;
        break;
      }

      // required uint32 GiftId = 2;
      case 2: {
        if (tag == 16) {
         parse_GiftId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &giftid_)));
          set_has_giftid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_StartTime;
        break;
      }

      // required uint32 StartTime = 3;
      case 3: {
        if (tag == 24) {
         parse_StartTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &starttime_)));
          set_has_starttime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_EndTime;
        break;
      }

      // required uint32 EndTime = 4;
      case 4: {
        if (tag == 32) {
         parse_EndTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endtime_)));
          set_has_endtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_LeftCount;
        break;
      }

      // required uint32 LeftCount = 5;
      case 5: {
        if (tag == 40) {
         parse_LeftCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &leftcount_)));
          set_has_leftcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_GiftName;
        break;
      }

      // required string GiftName = 6;
      case 6: {
        if (tag == 50) {
         parse_GiftName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_giftname()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_Discount;
        break;
      }

      // optional string Discount = 7;
      case 7: {
        if (tag == 58) {
         parse_Discount:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_discount()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_Price;
        break;
      }

      // optional uint32 Price = 8;
      case 8: {
        if (tag == 64) {
         parse_Price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &price_)));
          set_has_price();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_GiftIcon;
        break;
      }

      // required string GiftIcon = 9;
      case 9: {
        if (tag == 74) {
         parse_GiftIcon:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gifticon()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.GiftData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.GiftData)
  return false;
#undef DO_
}

void GiftData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.GiftData)
  // required uint32 ShopId = 1;
  if (has_shopid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->shopid(), output);
  }

  // required uint32 GiftId = 2;
  if (has_giftid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->giftid(), output);
  }

  // required uint32 StartTime = 3;
  if (has_starttime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->starttime(), output);
  }

  // required uint32 EndTime = 4;
  if (has_endtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->endtime(), output);
  }

  // required uint32 LeftCount = 5;
  if (has_leftcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->leftcount(), output);
  }

  // required string GiftName = 6;
  if (has_giftname()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->giftname(), output);
  }

  // optional string Discount = 7;
  if (has_discount()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->discount(), output);
  }

  // optional uint32 Price = 8;
  if (has_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->price(), output);
  }

  // required string GiftIcon = 9;
  if (has_gifticon()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->gifticon(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.GiftData)
}

int GiftData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ShopId = 1;
    if (has_shopid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shopid());
    }

    // required uint32 GiftId = 2;
    if (has_giftid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->giftid());
    }

    // required uint32 StartTime = 3;
    if (has_starttime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->starttime());
    }

    // required uint32 EndTime = 4;
    if (has_endtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endtime());
    }

    // required uint32 LeftCount = 5;
    if (has_leftcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->leftcount());
    }

    // required string GiftName = 6;
    if (has_giftname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->giftname());
    }

    // optional string Discount = 7;
    if (has_discount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->discount());
    }

    // optional uint32 Price = 8;
    if (has_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->price());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required string GiftIcon = 9;
    if (has_gifticon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->gifticon());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GiftData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GiftData*>(&from));
}

void GiftData::MergeFrom(const GiftData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_shopid()) {
      set_shopid(from.shopid());
    }
    if (from.has_giftid()) {
      set_giftid(from.giftid());
    }
    if (from.has_starttime()) {
      set_starttime(from.starttime());
    }
    if (from.has_endtime()) {
      set_endtime(from.endtime());
    }
    if (from.has_leftcount()) {
      set_leftcount(from.leftcount());
    }
    if (from.has_giftname()) {
      set_giftname(from.giftname());
    }
    if (from.has_discount()) {
      set_discount(from.discount());
    }
    if (from.has_price()) {
      set_price(from.price());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_gifticon()) {
      set_gifticon(from.gifticon());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GiftData::CopyFrom(const GiftData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GiftData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000013f) != 0x0000013f) return false;

  return true;
}

void GiftData::Swap(GiftData* other) {
  if (other != this) {
    std::swap(shopid_, other->shopid_);
    std::swap(giftid_, other->giftid_);
    std::swap(starttime_, other->starttime_);
    std::swap(endtime_, other->endtime_);
    std::swap(leftcount_, other->leftcount_);
    std::swap(giftname_, other->giftname_);
    std::swap(discount_, other->discount_);
    std::swap(price_, other->price_);
    std::swap(gifticon_, other->gifticon_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GiftData::GetTypeName() const {
  return "fgame.GiftData";
}


// ===================================================================

#ifndef _MSC_VER
const int CSShopListResp::kDiamondListFieldNumber;
const int CSShopListResp::kGiftListFieldNumber;
#endif  // !_MSC_VER

CSShopListResp::CSShopListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSShopListResp)
}

void CSShopListResp::InitAsDefaultInstance() {
}

CSShopListResp::CSShopListResp(const CSShopListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSShopListResp)
}

void CSShopListResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSShopListResp::~CSShopListResp() {
  // @@protoc_insertion_point(destructor:fgame.CSShopListResp)
  SharedDtor();
}

void CSShopListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSShopListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSShopListResp& CSShopListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSShopListResp* CSShopListResp::default_instance_ = NULL;

CSShopListResp* CSShopListResp::New() const {
  return new CSShopListResp;
}

void CSShopListResp::Clear() {
  diamondlist_.Clear();
  giftlist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSShopListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSShopListResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.DiamondData diamondList = 1;
      case 1: {
        if (tag == 10) {
         parse_diamondList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_diamondlist()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_diamondList;
        if (input->ExpectTag(18)) goto parse_giftList;
        break;
      }

      // repeated .fgame.GiftData giftList = 2;
      case 2: {
        if (tag == 18) {
         parse_giftList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_giftlist()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_giftList;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSShopListResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSShopListResp)
  return false;
#undef DO_
}

void CSShopListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSShopListResp)
  // repeated .fgame.DiamondData diamondList = 1;
  for (int i = 0; i < this->diamondlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->diamondlist(i), output);
  }

  // repeated .fgame.GiftData giftList = 2;
  for (int i = 0; i < this->giftlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->giftlist(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSShopListResp)
}

int CSShopListResp::ByteSize() const {
  int total_size = 0;

  // repeated .fgame.DiamondData diamondList = 1;
  total_size += 1 * this->diamondlist_size();
  for (int i = 0; i < this->diamondlist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->diamondlist(i));
  }

  // repeated .fgame.GiftData giftList = 2;
  total_size += 1 * this->giftlist_size();
  for (int i = 0; i < this->giftlist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->giftlist(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSShopListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSShopListResp*>(&from));
}

void CSShopListResp::MergeFrom(const CSShopListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  diamondlist_.MergeFrom(from.diamondlist_);
  giftlist_.MergeFrom(from.giftlist_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSShopListResp::CopyFrom(const CSShopListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSShopListResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->diamondlist())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->giftlist())) return false;
  return true;
}

void CSShopListResp::Swap(CSShopListResp* other) {
  if (other != this) {
    diamondlist_.Swap(&other->diamondlist_);
    giftlist_.Swap(&other->giftlist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSShopListResp::GetTypeName() const {
  return "fgame.CSShopListResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ExchangeItemInfo::kItemIdFieldNumber;
const int ExchangeItemInfo::kBuyLeftCountFieldNumber;
const int ExchangeItemInfo::kRefreshTimeFieldNumber;
#endif  // !_MSC_VER

ExchangeItemInfo::ExchangeItemInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.ExchangeItemInfo)
}

void ExchangeItemInfo::InitAsDefaultInstance() {
}

ExchangeItemInfo::ExchangeItemInfo(const ExchangeItemInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.ExchangeItemInfo)
}

void ExchangeItemInfo::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0u;
  buyleftcount_ = 0u;
  refreshtime_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExchangeItemInfo::~ExchangeItemInfo() {
  // @@protoc_insertion_point(destructor:fgame.ExchangeItemInfo)
  SharedDtor();
}

void ExchangeItemInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ExchangeItemInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ExchangeItemInfo& ExchangeItemInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

ExchangeItemInfo* ExchangeItemInfo::default_instance_ = NULL;

ExchangeItemInfo* ExchangeItemInfo::New() const {
  return new ExchangeItemInfo;
}

void ExchangeItemInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ExchangeItemInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(itemid_, refreshtime_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ExchangeItemInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.ExchangeItemInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ItemId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_BuyLeftCount;
        break;
      }

      // required uint32 BuyLeftCount = 2;
      case 2: {
        if (tag == 16) {
         parse_BuyLeftCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buyleftcount_)));
          set_has_buyleftcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_RefreshTime;
        break;
      }

      // required uint32 RefreshTime = 3;
      case 3: {
        if (tag == 24) {
         parse_RefreshTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &refreshtime_)));
          set_has_refreshtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.ExchangeItemInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.ExchangeItemInfo)
  return false;
#undef DO_
}

void ExchangeItemInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.ExchangeItemInfo)
  // required uint32 ItemId = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->itemid(), output);
  }

  // required uint32 BuyLeftCount = 2;
  if (has_buyleftcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->buyleftcount(), output);
  }

  // required uint32 RefreshTime = 3;
  if (has_refreshtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->refreshtime(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.ExchangeItemInfo)
}

int ExchangeItemInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ItemId = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemid());
    }

    // required uint32 BuyLeftCount = 2;
    if (has_buyleftcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buyleftcount());
    }

    // required uint32 RefreshTime = 3;
    if (has_refreshtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->refreshtime());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExchangeItemInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ExchangeItemInfo*>(&from));
}

void ExchangeItemInfo::MergeFrom(const ExchangeItemInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_buyleftcount()) {
      set_buyleftcount(from.buyleftcount());
    }
    if (from.has_refreshtime()) {
      set_refreshtime(from.refreshtime());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ExchangeItemInfo::CopyFrom(const ExchangeItemInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExchangeItemInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void ExchangeItemInfo::Swap(ExchangeItemInfo* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(buyleftcount_, other->buyleftcount_);
    std::swap(refreshtime_, other->refreshtime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ExchangeItemInfo::GetTypeName() const {
  return "fgame.ExchangeItemInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSExchangeItemReq::kItemIdFieldNumber;
#endif  // !_MSC_VER

CSExchangeItemReq::CSExchangeItemReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSExchangeItemReq)
}

void CSExchangeItemReq::InitAsDefaultInstance() {
}

CSExchangeItemReq::CSExchangeItemReq(const CSExchangeItemReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSExchangeItemReq)
}

void CSExchangeItemReq::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSExchangeItemReq::~CSExchangeItemReq() {
  // @@protoc_insertion_point(destructor:fgame.CSExchangeItemReq)
  SharedDtor();
}

void CSExchangeItemReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSExchangeItemReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSExchangeItemReq& CSExchangeItemReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSExchangeItemReq* CSExchangeItemReq::default_instance_ = NULL;

CSExchangeItemReq* CSExchangeItemReq::New() const {
  return new CSExchangeItemReq;
}

void CSExchangeItemReq::Clear() {
  itemid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSExchangeItemReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSExchangeItemReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ItemId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSExchangeItemReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSExchangeItemReq)
  return false;
#undef DO_
}

void CSExchangeItemReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSExchangeItemReq)
  // required uint32 ItemId = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->itemid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSExchangeItemReq)
}

int CSExchangeItemReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ItemId = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSExchangeItemReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSExchangeItemReq*>(&from));
}

void CSExchangeItemReq::MergeFrom(const CSExchangeItemReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSExchangeItemReq::CopyFrom(const CSExchangeItemReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSExchangeItemReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSExchangeItemReq::Swap(CSExchangeItemReq* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSExchangeItemReq::GetTypeName() const {
  return "fgame.CSExchangeItemReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSExchangeItemResp::kExchangeItemFieldNumber;
const int CSExchangeItemResp::kHonorCountFieldNumber;
const int CSExchangeItemResp::kRetFieldNumber;
#endif  // !_MSC_VER

CSExchangeItemResp::CSExchangeItemResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSExchangeItemResp)
}

void CSExchangeItemResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  exchangeitem_ = const_cast< ::fgame::ExchangeItemInfo*>(
      ::fgame::ExchangeItemInfo::internal_default_instance());
#else
  exchangeitem_ = const_cast< ::fgame::ExchangeItemInfo*>(&::fgame::ExchangeItemInfo::default_instance());
#endif
}

CSExchangeItemResp::CSExchangeItemResp(const CSExchangeItemResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSExchangeItemResp)
}

void CSExchangeItemResp::SharedCtor() {
  _cached_size_ = 0;
  exchangeitem_ = NULL;
  honorcount_ = 0u;
  ret_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSExchangeItemResp::~CSExchangeItemResp() {
  // @@protoc_insertion_point(destructor:fgame.CSExchangeItemResp)
  SharedDtor();
}

void CSExchangeItemResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete exchangeitem_;
  }
}

void CSExchangeItemResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSExchangeItemResp& CSExchangeItemResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSExchangeItemResp* CSExchangeItemResp::default_instance_ = NULL;

CSExchangeItemResp* CSExchangeItemResp::New() const {
  return new CSExchangeItemResp;
}

void CSExchangeItemResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSExchangeItemResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(honorcount_, ret_);
    if (has_exchangeitem()) {
      if (exchangeitem_ != NULL) exchangeitem_->::fgame::ExchangeItemInfo::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSExchangeItemResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSExchangeItemResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .fgame.ExchangeItemInfo ExchangeItem = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exchangeitem()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_HonorCount;
        break;
      }

      // required uint32 HonorCount = 2;
      case 2: {
        if (tag == 16) {
         parse_HonorCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &honorcount_)));
          set_has_honorcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Ret;
        break;
      }

      // required uint32 Ret = 3;
      case 3: {
        if (tag == 24) {
         parse_Ret:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSExchangeItemResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSExchangeItemResp)
  return false;
#undef DO_
}

void CSExchangeItemResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSExchangeItemResp)
  // required .fgame.ExchangeItemInfo ExchangeItem = 1;
  if (has_exchangeitem()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->exchangeitem(), output);
  }

  // required uint32 HonorCount = 2;
  if (has_honorcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->honorcount(), output);
  }

  // required uint32 Ret = 3;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->ret(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSExchangeItemResp)
}

int CSExchangeItemResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .fgame.ExchangeItemInfo ExchangeItem = 1;
    if (has_exchangeitem()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exchangeitem());
    }

    // required uint32 HonorCount = 2;
    if (has_honorcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->honorcount());
    }

    // required uint32 Ret = 3;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSExchangeItemResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSExchangeItemResp*>(&from));
}

void CSExchangeItemResp::MergeFrom(const CSExchangeItemResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_exchangeitem()) {
      mutable_exchangeitem()->::fgame::ExchangeItemInfo::MergeFrom(from.exchangeitem());
    }
    if (from.has_honorcount()) {
      set_honorcount(from.honorcount());
    }
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSExchangeItemResp::CopyFrom(const CSExchangeItemResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSExchangeItemResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_exchangeitem()) {
    if (!this->exchangeitem().IsInitialized()) return false;
  }
  return true;
}

void CSExchangeItemResp::Swap(CSExchangeItemResp* other) {
  if (other != this) {
    std::swap(exchangeitem_, other->exchangeitem_);
    std::swap(honorcount_, other->honorcount_);
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSExchangeItemResp::GetTypeName() const {
  return "fgame.CSExchangeItemResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSUpdateExchangeListReq::CSUpdateExchangeListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSUpdateExchangeListReq)
}

void CSUpdateExchangeListReq::InitAsDefaultInstance() {
}

CSUpdateExchangeListReq::CSUpdateExchangeListReq(const CSUpdateExchangeListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSUpdateExchangeListReq)
}

void CSUpdateExchangeListReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSUpdateExchangeListReq::~CSUpdateExchangeListReq() {
  // @@protoc_insertion_point(destructor:fgame.CSUpdateExchangeListReq)
  SharedDtor();
}

void CSUpdateExchangeListReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSUpdateExchangeListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSUpdateExchangeListReq& CSUpdateExchangeListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSUpdateExchangeListReq* CSUpdateExchangeListReq::default_instance_ = NULL;

CSUpdateExchangeListReq* CSUpdateExchangeListReq::New() const {
  return new CSUpdateExchangeListReq;
}

void CSUpdateExchangeListReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSUpdateExchangeListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSUpdateExchangeListReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSUpdateExchangeListReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSUpdateExchangeListReq)
  return false;
#undef DO_
}

void CSUpdateExchangeListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSUpdateExchangeListReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSUpdateExchangeListReq)
}

int CSUpdateExchangeListReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSUpdateExchangeListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSUpdateExchangeListReq*>(&from));
}

void CSUpdateExchangeListReq::MergeFrom(const CSUpdateExchangeListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSUpdateExchangeListReq::CopyFrom(const CSUpdateExchangeListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSUpdateExchangeListReq::IsInitialized() const {

  return true;
}

void CSUpdateExchangeListReq::Swap(CSUpdateExchangeListReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSUpdateExchangeListReq::GetTypeName() const {
  return "fgame.CSUpdateExchangeListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSUpdateExchangeListResp::kExchangeItemFieldNumber;
const int CSUpdateExchangeListResp::kHonorCountFieldNumber;
#endif  // !_MSC_VER

CSUpdateExchangeListResp::CSUpdateExchangeListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSUpdateExchangeListResp)
}

void CSUpdateExchangeListResp::InitAsDefaultInstance() {
}

CSUpdateExchangeListResp::CSUpdateExchangeListResp(const CSUpdateExchangeListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSUpdateExchangeListResp)
}

void CSUpdateExchangeListResp::SharedCtor() {
  _cached_size_ = 0;
  honorcount_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSUpdateExchangeListResp::~CSUpdateExchangeListResp() {
  // @@protoc_insertion_point(destructor:fgame.CSUpdateExchangeListResp)
  SharedDtor();
}

void CSUpdateExchangeListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSUpdateExchangeListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSUpdateExchangeListResp& CSUpdateExchangeListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSUpdateExchangeListResp* CSUpdateExchangeListResp::default_instance_ = NULL;

CSUpdateExchangeListResp* CSUpdateExchangeListResp::New() const {
  return new CSUpdateExchangeListResp;
}

void CSUpdateExchangeListResp::Clear() {
  honorcount_ = 0u;
  exchangeitem_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSUpdateExchangeListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSUpdateExchangeListResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.ExchangeItemInfo ExchangeItem = 1;
      case 1: {
        if (tag == 10) {
         parse_ExchangeItem:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_exchangeitem()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_ExchangeItem;
        if (input->ExpectTag(16)) goto parse_HonorCount;
        break;
      }

      // required uint32 HonorCount = 2;
      case 2: {
        if (tag == 16) {
         parse_HonorCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &honorcount_)));
          set_has_honorcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSUpdateExchangeListResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSUpdateExchangeListResp)
  return false;
#undef DO_
}

void CSUpdateExchangeListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSUpdateExchangeListResp)
  // repeated .fgame.ExchangeItemInfo ExchangeItem = 1;
  for (int i = 0; i < this->exchangeitem_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->exchangeitem(i), output);
  }

  // required uint32 HonorCount = 2;
  if (has_honorcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->honorcount(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSUpdateExchangeListResp)
}

int CSUpdateExchangeListResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required uint32 HonorCount = 2;
    if (has_honorcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->honorcount());
    }

  }
  // repeated .fgame.ExchangeItemInfo ExchangeItem = 1;
  total_size += 1 * this->exchangeitem_size();
  for (int i = 0; i < this->exchangeitem_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->exchangeitem(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSUpdateExchangeListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSUpdateExchangeListResp*>(&from));
}

void CSUpdateExchangeListResp::MergeFrom(const CSUpdateExchangeListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  exchangeitem_.MergeFrom(from.exchangeitem_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_honorcount()) {
      set_honorcount(from.honorcount());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSUpdateExchangeListResp::CopyFrom(const CSUpdateExchangeListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSUpdateExchangeListResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->exchangeitem())) return false;
  return true;
}

void CSUpdateExchangeListResp::Swap(CSUpdateExchangeListResp* other) {
  if (other != this) {
    exchangeitem_.Swap(&other->exchangeitem_);
    std::swap(honorcount_, other->honorcount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSUpdateExchangeListResp::GetTypeName() const {
  return "fgame.CSUpdateExchangeListResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSChangePlayerIconReq::kIconIdFieldNumber;
#endif  // !_MSC_VER

CSChangePlayerIconReq::CSChangePlayerIconReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSChangePlayerIconReq)
}

void CSChangePlayerIconReq::InitAsDefaultInstance() {
}

CSChangePlayerIconReq::CSChangePlayerIconReq(const CSChangePlayerIconReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSChangePlayerIconReq)
}

void CSChangePlayerIconReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  iconid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSChangePlayerIconReq::~CSChangePlayerIconReq() {
  // @@protoc_insertion_point(destructor:fgame.CSChangePlayerIconReq)
  SharedDtor();
}

void CSChangePlayerIconReq::SharedDtor() {
  if (iconid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete iconid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSChangePlayerIconReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSChangePlayerIconReq& CSChangePlayerIconReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSChangePlayerIconReq* CSChangePlayerIconReq::default_instance_ = NULL;

CSChangePlayerIconReq* CSChangePlayerIconReq::New() const {
  return new CSChangePlayerIconReq;
}

void CSChangePlayerIconReq::Clear() {
  if (has_iconid()) {
    if (iconid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      iconid_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSChangePlayerIconReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSChangePlayerIconReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string IconId = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_iconid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSChangePlayerIconReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSChangePlayerIconReq)
  return false;
#undef DO_
}

void CSChangePlayerIconReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSChangePlayerIconReq)
  // required string IconId = 1;
  if (has_iconid()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->iconid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSChangePlayerIconReq)
}

int CSChangePlayerIconReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string IconId = 1;
    if (has_iconid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->iconid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSChangePlayerIconReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSChangePlayerIconReq*>(&from));
}

void CSChangePlayerIconReq::MergeFrom(const CSChangePlayerIconReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_iconid()) {
      set_iconid(from.iconid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSChangePlayerIconReq::CopyFrom(const CSChangePlayerIconReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSChangePlayerIconReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSChangePlayerIconReq::Swap(CSChangePlayerIconReq* other) {
  if (other != this) {
    std::swap(iconid_, other->iconid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSChangePlayerIconReq::GetTypeName() const {
  return "fgame.CSChangePlayerIconReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSChangePlayerIconResp::kRetFieldNumber;
const int CSChangePlayerIconResp::kIconIdFieldNumber;
#endif  // !_MSC_VER

CSChangePlayerIconResp::CSChangePlayerIconResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSChangePlayerIconResp)
}

void CSChangePlayerIconResp::InitAsDefaultInstance() {
}

CSChangePlayerIconResp::CSChangePlayerIconResp(const CSChangePlayerIconResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSChangePlayerIconResp)
}

void CSChangePlayerIconResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ret_ = 0u;
  iconid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSChangePlayerIconResp::~CSChangePlayerIconResp() {
  // @@protoc_insertion_point(destructor:fgame.CSChangePlayerIconResp)
  SharedDtor();
}

void CSChangePlayerIconResp::SharedDtor() {
  if (iconid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete iconid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSChangePlayerIconResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSChangePlayerIconResp& CSChangePlayerIconResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSChangePlayerIconResp* CSChangePlayerIconResp::default_instance_ = NULL;

CSChangePlayerIconResp* CSChangePlayerIconResp::New() const {
  return new CSChangePlayerIconResp;
}

void CSChangePlayerIconResp::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    ret_ = 0u;
    if (has_iconid()) {
      if (iconid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        iconid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSChangePlayerIconResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSChangePlayerIconResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_IconId;
        break;
      }

      // required string IconId = 2;
      case 2: {
        if (tag == 18) {
         parse_IconId:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_iconid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSChangePlayerIconResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSChangePlayerIconResp)
  return false;
#undef DO_
}

void CSChangePlayerIconResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSChangePlayerIconResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // required string IconId = 2;
  if (has_iconid()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->iconid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSChangePlayerIconResp)
}

int CSChangePlayerIconResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // required string IconId = 2;
    if (has_iconid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->iconid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSChangePlayerIconResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSChangePlayerIconResp*>(&from));
}

void CSChangePlayerIconResp::MergeFrom(const CSChangePlayerIconResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_iconid()) {
      set_iconid(from.iconid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSChangePlayerIconResp::CopyFrom(const CSChangePlayerIconResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSChangePlayerIconResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSChangePlayerIconResp::Swap(CSChangePlayerIconResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(iconid_, other->iconid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSChangePlayerIconResp::GetTypeName() const {
  return "fgame.CSChangePlayerIconResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSetNewBieReq::kNewBieIdFieldNumber;
const int CSSetNewBieReq::kIsCompleteFieldNumber;
#endif  // !_MSC_VER

CSSetNewBieReq::CSSetNewBieReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSetNewBieReq)
}

void CSSetNewBieReq::InitAsDefaultInstance() {
}

CSSetNewBieReq::CSSetNewBieReq(const CSSetNewBieReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSetNewBieReq)
}

void CSSetNewBieReq::SharedCtor() {
  _cached_size_ = 0;
  iscomplete_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSetNewBieReq::~CSSetNewBieReq() {
  // @@protoc_insertion_point(destructor:fgame.CSSetNewBieReq)
  SharedDtor();
}

void CSSetNewBieReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSetNewBieReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSetNewBieReq& CSSetNewBieReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSetNewBieReq* CSSetNewBieReq::default_instance_ = NULL;

CSSetNewBieReq* CSSetNewBieReq::New() const {
  return new CSSetNewBieReq;
}

void CSSetNewBieReq::Clear() {
  iscomplete_ = false;
  newbieid_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSetNewBieReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSetNewBieReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 NewBieId = 1;
      case 1: {
        if (tag == 8) {
         parse_NewBieId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_newbieid())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_newbieid())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_NewBieId;
        if (input->ExpectTag(16)) goto parse_isComplete;
        break;
      }

      // optional bool isComplete = 2;
      case 2: {
        if (tag == 16) {
         parse_isComplete:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &iscomplete_)));
          set_has_iscomplete();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSetNewBieReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSetNewBieReq)
  return false;
#undef DO_
}

void CSSetNewBieReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSetNewBieReq)
  // repeated uint32 NewBieId = 1;
  for (int i = 0; i < this->newbieid_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->newbieid(i), output);
  }

  // optional bool isComplete = 2;
  if (has_iscomplete()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->iscomplete(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSetNewBieReq)
}

int CSSetNewBieReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional bool isComplete = 2;
    if (has_iscomplete()) {
      total_size += 1 + 1;
    }

  }
  // repeated uint32 NewBieId = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->newbieid_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->newbieid(i));
    }
    total_size += 1 * this->newbieid_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSetNewBieReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSetNewBieReq*>(&from));
}

void CSSetNewBieReq::MergeFrom(const CSSetNewBieReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  newbieid_.MergeFrom(from.newbieid_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_iscomplete()) {
      set_iscomplete(from.iscomplete());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSetNewBieReq::CopyFrom(const CSSetNewBieReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSetNewBieReq::IsInitialized() const {

  return true;
}

void CSSetNewBieReq::Swap(CSSetNewBieReq* other) {
  if (other != this) {
    newbieid_.Swap(&other->newbieid_);
    std::swap(iscomplete_, other->iscomplete_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSetNewBieReq::GetTypeName() const {
  return "fgame.CSSetNewBieReq";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSSetNewBieResp::CSSetNewBieResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSetNewBieResp)
}

void CSSetNewBieResp::InitAsDefaultInstance() {
}

CSSetNewBieResp::CSSetNewBieResp(const CSSetNewBieResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSetNewBieResp)
}

void CSSetNewBieResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSetNewBieResp::~CSSetNewBieResp() {
  // @@protoc_insertion_point(destructor:fgame.CSSetNewBieResp)
  SharedDtor();
}

void CSSetNewBieResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSetNewBieResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSetNewBieResp& CSSetNewBieResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSetNewBieResp* CSSetNewBieResp::default_instance_ = NULL;

CSSetNewBieResp* CSSetNewBieResp::New() const {
  return new CSSetNewBieResp;
}

void CSSetNewBieResp::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSetNewBieResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSetNewBieResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSetNewBieResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSetNewBieResp)
  return false;
#undef DO_
}

void CSSetNewBieResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSetNewBieResp)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSetNewBieResp)
}

int CSSetNewBieResp::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSetNewBieResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSetNewBieResp*>(&from));
}

void CSSetNewBieResp::MergeFrom(const CSSetNewBieResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSetNewBieResp::CopyFrom(const CSSetNewBieResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSetNewBieResp::IsInitialized() const {

  return true;
}

void CSSetNewBieResp::Swap(CSSetNewBieResp* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSetNewBieResp::GetTypeName() const {
  return "fgame.CSSetNewBieResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSGetNewBieListReq::CSGetNewBieListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetNewBieListReq)
}

void CSGetNewBieListReq::InitAsDefaultInstance() {
}

CSGetNewBieListReq::CSGetNewBieListReq(const CSGetNewBieListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetNewBieListReq)
}

void CSGetNewBieListReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetNewBieListReq::~CSGetNewBieListReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGetNewBieListReq)
  SharedDtor();
}

void CSGetNewBieListReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetNewBieListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetNewBieListReq& CSGetNewBieListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetNewBieListReq* CSGetNewBieListReq::default_instance_ = NULL;

CSGetNewBieListReq* CSGetNewBieListReq::New() const {
  return new CSGetNewBieListReq;
}

void CSGetNewBieListReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetNewBieListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetNewBieListReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetNewBieListReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetNewBieListReq)
  return false;
#undef DO_
}

void CSGetNewBieListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetNewBieListReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetNewBieListReq)
}

int CSGetNewBieListReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetNewBieListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetNewBieListReq*>(&from));
}

void CSGetNewBieListReq::MergeFrom(const CSGetNewBieListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetNewBieListReq::CopyFrom(const CSGetNewBieListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetNewBieListReq::IsInitialized() const {

  return true;
}

void CSGetNewBieListReq::Swap(CSGetNewBieListReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetNewBieListReq::GetTypeName() const {
  return "fgame.CSGetNewBieListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGetNewBieListResp::kIsCompleteFieldNumber;
const int CSGetNewBieListResp::kNewBieIdsFieldNumber;
#endif  // !_MSC_VER

CSGetNewBieListResp::CSGetNewBieListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetNewBieListResp)
}

void CSGetNewBieListResp::InitAsDefaultInstance() {
}

CSGetNewBieListResp::CSGetNewBieListResp(const CSGetNewBieListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetNewBieListResp)
}

void CSGetNewBieListResp::SharedCtor() {
  _cached_size_ = 0;
  iscomplete_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetNewBieListResp::~CSGetNewBieListResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGetNewBieListResp)
  SharedDtor();
}

void CSGetNewBieListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetNewBieListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetNewBieListResp& CSGetNewBieListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetNewBieListResp* CSGetNewBieListResp::default_instance_ = NULL;

CSGetNewBieListResp* CSGetNewBieListResp::New() const {
  return new CSGetNewBieListResp;
}

void CSGetNewBieListResp::Clear() {
  iscomplete_ = false;
  newbieids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetNewBieListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetNewBieListResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool isComplete = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &iscomplete_)));
          set_has_iscomplete();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_NewBieIds;
        break;
      }

      // repeated uint32 NewBieIds = 2;
      case 2: {
        if (tag == 16) {
         parse_NewBieIds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_newbieids())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_newbieids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_NewBieIds;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetNewBieListResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetNewBieListResp)
  return false;
#undef DO_
}

void CSGetNewBieListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetNewBieListResp)
  // required bool isComplete = 1;
  if (has_iscomplete()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->iscomplete(), output);
  }

  // repeated uint32 NewBieIds = 2;
  for (int i = 0; i < this->newbieids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->newbieids(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetNewBieListResp)
}

int CSGetNewBieListResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool isComplete = 1;
    if (has_iscomplete()) {
      total_size += 1 + 1;
    }

  }
  // repeated uint32 NewBieIds = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->newbieids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->newbieids(i));
    }
    total_size += 1 * this->newbieids_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetNewBieListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetNewBieListResp*>(&from));
}

void CSGetNewBieListResp::MergeFrom(const CSGetNewBieListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  newbieids_.MergeFrom(from.newbieids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_iscomplete()) {
      set_iscomplete(from.iscomplete());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetNewBieListResp::CopyFrom(const CSGetNewBieListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetNewBieListResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSGetNewBieListResp::Swap(CSGetNewBieListResp* other) {
  if (other != this) {
    std::swap(iscomplete_, other->iscomplete_);
    newbieids_.Swap(&other->newbieids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetNewBieListResp::GetTypeName() const {
  return "fgame.CSGetNewBieListResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSetNewBieOssReq::kNewBieIdFieldNumber;
#endif  // !_MSC_VER

CSSetNewBieOssReq::CSSetNewBieOssReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSetNewBieOssReq)
}

void CSSetNewBieOssReq::InitAsDefaultInstance() {
}

CSSetNewBieOssReq::CSSetNewBieOssReq(const CSSetNewBieOssReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSetNewBieOssReq)
}

void CSSetNewBieOssReq::SharedCtor() {
  _cached_size_ = 0;
  newbieid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSetNewBieOssReq::~CSSetNewBieOssReq() {
  // @@protoc_insertion_point(destructor:fgame.CSSetNewBieOssReq)
  SharedDtor();
}

void CSSetNewBieOssReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSetNewBieOssReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSetNewBieOssReq& CSSetNewBieOssReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSetNewBieOssReq* CSSetNewBieOssReq::default_instance_ = NULL;

CSSetNewBieOssReq* CSSetNewBieOssReq::New() const {
  return new CSSetNewBieOssReq;
}

void CSSetNewBieOssReq::Clear() {
  newbieid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSetNewBieOssReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSetNewBieOssReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 NewBieId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &newbieid_)));
          set_has_newbieid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSetNewBieOssReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSetNewBieOssReq)
  return false;
#undef DO_
}

void CSSetNewBieOssReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSetNewBieOssReq)
  // required uint32 NewBieId = 1;
  if (has_newbieid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->newbieid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSetNewBieOssReq)
}

int CSSetNewBieOssReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 NewBieId = 1;
    if (has_newbieid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->newbieid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSetNewBieOssReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSetNewBieOssReq*>(&from));
}

void CSSetNewBieOssReq::MergeFrom(const CSSetNewBieOssReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_newbieid()) {
      set_newbieid(from.newbieid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSetNewBieOssReq::CopyFrom(const CSSetNewBieOssReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSetNewBieOssReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSSetNewBieOssReq::Swap(CSSetNewBieOssReq* other) {
  if (other != this) {
    std::swap(newbieid_, other->newbieid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSetNewBieOssReq::GetTypeName() const {
  return "fgame.CSSetNewBieOssReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSetNewBieOssResp::kNewBieIdFieldNumber;
#endif  // !_MSC_VER

CSSetNewBieOssResp::CSSetNewBieOssResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSetNewBieOssResp)
}

void CSSetNewBieOssResp::InitAsDefaultInstance() {
}

CSSetNewBieOssResp::CSSetNewBieOssResp(const CSSetNewBieOssResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSetNewBieOssResp)
}

void CSSetNewBieOssResp::SharedCtor() {
  _cached_size_ = 0;
  newbieid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSetNewBieOssResp::~CSSetNewBieOssResp() {
  // @@protoc_insertion_point(destructor:fgame.CSSetNewBieOssResp)
  SharedDtor();
}

void CSSetNewBieOssResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSetNewBieOssResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSetNewBieOssResp& CSSetNewBieOssResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSetNewBieOssResp* CSSetNewBieOssResp::default_instance_ = NULL;

CSSetNewBieOssResp* CSSetNewBieOssResp::New() const {
  return new CSSetNewBieOssResp;
}

void CSSetNewBieOssResp::Clear() {
  newbieid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSetNewBieOssResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSetNewBieOssResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 NewBieId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &newbieid_)));
          set_has_newbieid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSetNewBieOssResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSetNewBieOssResp)
  return false;
#undef DO_
}

void CSSetNewBieOssResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSetNewBieOssResp)
  // required uint32 NewBieId = 1;
  if (has_newbieid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->newbieid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSetNewBieOssResp)
}

int CSSetNewBieOssResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 NewBieId = 1;
    if (has_newbieid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->newbieid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSetNewBieOssResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSetNewBieOssResp*>(&from));
}

void CSSetNewBieOssResp::MergeFrom(const CSSetNewBieOssResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_newbieid()) {
      set_newbieid(from.newbieid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSetNewBieOssResp::CopyFrom(const CSSetNewBieOssResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSetNewBieOssResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSSetNewBieOssResp::Swap(CSSetNewBieOssResp* other) {
  if (other != this) {
    std::swap(newbieid_, other->newbieid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSetNewBieOssResp::GetTypeName() const {
  return "fgame.CSSetNewBieOssResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSOpenBigStageReq::kPointIdFieldNumber;
#endif  // !_MSC_VER

CSOpenBigStageReq::CSOpenBigStageReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSOpenBigStageReq)
}

void CSOpenBigStageReq::InitAsDefaultInstance() {
}

CSOpenBigStageReq::CSOpenBigStageReq(const CSOpenBigStageReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSOpenBigStageReq)
}

void CSOpenBigStageReq::SharedCtor() {
  _cached_size_ = 0;
  pointid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSOpenBigStageReq::~CSOpenBigStageReq() {
  // @@protoc_insertion_point(destructor:fgame.CSOpenBigStageReq)
  SharedDtor();
}

void CSOpenBigStageReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSOpenBigStageReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSOpenBigStageReq& CSOpenBigStageReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSOpenBigStageReq* CSOpenBigStageReq::default_instance_ = NULL;

CSOpenBigStageReq* CSOpenBigStageReq::New() const {
  return new CSOpenBigStageReq;
}

void CSOpenBigStageReq::Clear() {
  pointid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSOpenBigStageReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSOpenBigStageReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 PointId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pointid_)));
          set_has_pointid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSOpenBigStageReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSOpenBigStageReq)
  return false;
#undef DO_
}

void CSOpenBigStageReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSOpenBigStageReq)
  // required uint32 PointId = 1;
  if (has_pointid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->pointid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSOpenBigStageReq)
}

int CSOpenBigStageReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 PointId = 1;
    if (has_pointid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pointid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSOpenBigStageReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSOpenBigStageReq*>(&from));
}

void CSOpenBigStageReq::MergeFrom(const CSOpenBigStageReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pointid()) {
      set_pointid(from.pointid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSOpenBigStageReq::CopyFrom(const CSOpenBigStageReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOpenBigStageReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSOpenBigStageReq::Swap(CSOpenBigStageReq* other) {
  if (other != this) {
    std::swap(pointid_, other->pointid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSOpenBigStageReq::GetTypeName() const {
  return "fgame.CSOpenBigStageReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSOpenBigStageResp::kRetFieldNumber;
const int CSOpenBigStageResp::kPointIdFieldNumber;
#endif  // !_MSC_VER

CSOpenBigStageResp::CSOpenBigStageResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSOpenBigStageResp)
}

void CSOpenBigStageResp::InitAsDefaultInstance() {
}

CSOpenBigStageResp::CSOpenBigStageResp(const CSOpenBigStageResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSOpenBigStageResp)
}

void CSOpenBigStageResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  pointid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSOpenBigStageResp::~CSOpenBigStageResp() {
  // @@protoc_insertion_point(destructor:fgame.CSOpenBigStageResp)
  SharedDtor();
}

void CSOpenBigStageResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSOpenBigStageResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSOpenBigStageResp& CSOpenBigStageResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSOpenBigStageResp* CSOpenBigStageResp::default_instance_ = NULL;

CSOpenBigStageResp* CSOpenBigStageResp::New() const {
  return new CSOpenBigStageResp;
}

void CSOpenBigStageResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSOpenBigStageResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ret_, pointid_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSOpenBigStageResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSOpenBigStageResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_PointId;
        break;
      }

      // required uint32 PointId = 2;
      case 2: {
        if (tag == 16) {
         parse_PointId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pointid_)));
          set_has_pointid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSOpenBigStageResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSOpenBigStageResp)
  return false;
#undef DO_
}

void CSOpenBigStageResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSOpenBigStageResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // required uint32 PointId = 2;
  if (has_pointid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->pointid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSOpenBigStageResp)
}

int CSOpenBigStageResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // required uint32 PointId = 2;
    if (has_pointid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pointid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSOpenBigStageResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSOpenBigStageResp*>(&from));
}

void CSOpenBigStageResp::MergeFrom(const CSOpenBigStageResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_pointid()) {
      set_pointid(from.pointid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSOpenBigStageResp::CopyFrom(const CSOpenBigStageResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOpenBigStageResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSOpenBigStageResp::Swap(CSOpenBigStageResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(pointid_, other->pointid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSOpenBigStageResp::GetTypeName() const {
  return "fgame.CSOpenBigStageResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSEnterPointReq::kPointIdFieldNumber;
#endif  // !_MSC_VER

CSEnterPointReq::CSEnterPointReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSEnterPointReq)
}

void CSEnterPointReq::InitAsDefaultInstance() {
}

CSEnterPointReq::CSEnterPointReq(const CSEnterPointReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSEnterPointReq)
}

void CSEnterPointReq::SharedCtor() {
  _cached_size_ = 0;
  pointid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSEnterPointReq::~CSEnterPointReq() {
  // @@protoc_insertion_point(destructor:fgame.CSEnterPointReq)
  SharedDtor();
}

void CSEnterPointReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSEnterPointReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSEnterPointReq& CSEnterPointReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSEnterPointReq* CSEnterPointReq::default_instance_ = NULL;

CSEnterPointReq* CSEnterPointReq::New() const {
  return new CSEnterPointReq;
}

void CSEnterPointReq::Clear() {
  pointid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSEnterPointReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSEnterPointReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 PointId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pointid_)));
          set_has_pointid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSEnterPointReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSEnterPointReq)
  return false;
#undef DO_
}

void CSEnterPointReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSEnterPointReq)
  // required uint32 PointId = 1;
  if (has_pointid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->pointid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSEnterPointReq)
}

int CSEnterPointReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 PointId = 1;
    if (has_pointid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pointid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSEnterPointReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSEnterPointReq*>(&from));
}

void CSEnterPointReq::MergeFrom(const CSEnterPointReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pointid()) {
      set_pointid(from.pointid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSEnterPointReq::CopyFrom(const CSEnterPointReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSEnterPointReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSEnterPointReq::Swap(CSEnterPointReq* other) {
  if (other != this) {
    std::swap(pointid_, other->pointid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSEnterPointReq::GetTypeName() const {
  return "fgame.CSEnterPointReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSEnterPointResp::kPointIdFieldNumber;
const int CSEnterPointResp::kRetFieldNumber;
#endif  // !_MSC_VER

CSEnterPointResp::CSEnterPointResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSEnterPointResp)
}

void CSEnterPointResp::InitAsDefaultInstance() {
}

CSEnterPointResp::CSEnterPointResp(const CSEnterPointResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSEnterPointResp)
}

void CSEnterPointResp::SharedCtor() {
  _cached_size_ = 0;
  pointid_ = 0u;
  ret_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSEnterPointResp::~CSEnterPointResp() {
  // @@protoc_insertion_point(destructor:fgame.CSEnterPointResp)
  SharedDtor();
}

void CSEnterPointResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSEnterPointResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSEnterPointResp& CSEnterPointResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSEnterPointResp* CSEnterPointResp::default_instance_ = NULL;

CSEnterPointResp* CSEnterPointResp::New() const {
  return new CSEnterPointResp;
}

void CSEnterPointResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSEnterPointResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(pointid_, ret_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSEnterPointResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSEnterPointResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 PointId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pointid_)));
          set_has_pointid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Ret;
        break;
      }

      // required bool Ret = 2;
      case 2: {
        if (tag == 16) {
         parse_Ret:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSEnterPointResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSEnterPointResp)
  return false;
#undef DO_
}

void CSEnterPointResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSEnterPointResp)
  // required uint32 PointId = 1;
  if (has_pointid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->pointid(), output);
  }

  // required bool Ret = 2;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->ret(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSEnterPointResp)
}

int CSEnterPointResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 PointId = 1;
    if (has_pointid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pointid());
    }

    // required bool Ret = 2;
    if (has_ret()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSEnterPointResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSEnterPointResp*>(&from));
}

void CSEnterPointResp::MergeFrom(const CSEnterPointResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pointid()) {
      set_pointid(from.pointid());
    }
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSEnterPointResp::CopyFrom(const CSEnterPointResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSEnterPointResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSEnterPointResp::Swap(CSEnterPointResp* other) {
  if (other != this) {
    std::swap(pointid_, other->pointid_);
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSEnterPointResp::GetTypeName() const {
  return "fgame.CSEnterPointResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSBuyITtemReq::kItemIdFieldNumber;
const int CSBuyITtemReq::kPriceFieldNumber;
const int CSBuyITtemReq::kCountFieldNumber;
const int CSBuyITtemReq::kFromFieldNumber;
#endif  // !_MSC_VER

CSBuyITtemReq::CSBuyITtemReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSBuyITtemReq)
}

void CSBuyITtemReq::InitAsDefaultInstance() {
}

CSBuyITtemReq::CSBuyITtemReq(const CSBuyITtemReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSBuyITtemReq)
}

void CSBuyITtemReq::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0u;
  price_ = 0u;
  count_ = 0u;
  from_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSBuyITtemReq::~CSBuyITtemReq() {
  // @@protoc_insertion_point(destructor:fgame.CSBuyITtemReq)
  SharedDtor();
}

void CSBuyITtemReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSBuyITtemReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSBuyITtemReq& CSBuyITtemReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSBuyITtemReq* CSBuyITtemReq::default_instance_ = NULL;

CSBuyITtemReq* CSBuyITtemReq::New() const {
  return new CSBuyITtemReq;
}

void CSBuyITtemReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSBuyITtemReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(itemid_, from_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSBuyITtemReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSBuyITtemReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ItemId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Price;
        break;
      }

      // required uint32 Price = 2;
      case 2: {
        if (tag == 16) {
         parse_Price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &price_)));
          set_has_price();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Count;
        break;
      }

      // required uint32 Count = 3;
      case 3: {
        if (tag == 24) {
         parse_Count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_From;
        break;
      }

      // required uint32 From = 4;
      case 4: {
        if (tag == 32) {
         parse_From:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_)));
          set_has_from();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSBuyITtemReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSBuyITtemReq)
  return false;
#undef DO_
}

void CSBuyITtemReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSBuyITtemReq)
  // required uint32 ItemId = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->itemid(), output);
  }

  // required uint32 Price = 2;
  if (has_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->price(), output);
  }

  // required uint32 Count = 3;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->count(), output);
  }

  // required uint32 From = 4;
  if (has_from()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->from(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSBuyITtemReq)
}

int CSBuyITtemReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ItemId = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemid());
    }

    // required uint32 Price = 2;
    if (has_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->price());
    }

    // required uint32 Count = 3;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

    // required uint32 From = 4;
    if (has_from()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSBuyITtemReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSBuyITtemReq*>(&from));
}

void CSBuyITtemReq::MergeFrom(const CSBuyITtemReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_price()) {
      set_price(from.price());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_from()) {
      set_from(from.from());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSBuyITtemReq::CopyFrom(const CSBuyITtemReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSBuyITtemReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void CSBuyITtemReq::Swap(CSBuyITtemReq* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(price_, other->price_);
    std::swap(count_, other->count_);
    std::swap(from_, other->from_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSBuyITtemReq::GetTypeName() const {
  return "fgame.CSBuyITtemReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSBuyItemResp::kRetFieldNumber;
const int CSBuyItemResp::kItemIdFieldNumber;
const int CSBuyItemResp::kCountFieldNumber;
const int CSBuyItemResp::kPriceFieldNumber;
#endif  // !_MSC_VER

CSBuyItemResp::CSBuyItemResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSBuyItemResp)
}

void CSBuyItemResp::InitAsDefaultInstance() {
}

CSBuyItemResp::CSBuyItemResp(const CSBuyItemResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSBuyItemResp)
}

void CSBuyItemResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  itemid_ = 0u;
  count_ = 0u;
  price_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSBuyItemResp::~CSBuyItemResp() {
  // @@protoc_insertion_point(destructor:fgame.CSBuyItemResp)
  SharedDtor();
}

void CSBuyItemResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSBuyItemResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSBuyItemResp& CSBuyItemResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSBuyItemResp* CSBuyItemResp::default_instance_ = NULL;

CSBuyItemResp* CSBuyItemResp::New() const {
  return new CSBuyItemResp;
}

void CSBuyItemResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSBuyItemResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ret_, price_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSBuyItemResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSBuyItemResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ItemId;
        break;
      }

      // required uint32 ItemId = 2;
      case 2: {
        if (tag == 16) {
         parse_ItemId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Count;
        break;
      }

      // required uint32 Count = 3;
      case 3: {
        if (tag == 24) {
         parse_Count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Price;
        break;
      }

      // required uint32 Price = 4;
      case 4: {
        if (tag == 32) {
         parse_Price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &price_)));
          set_has_price();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSBuyItemResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSBuyItemResp)
  return false;
#undef DO_
}

void CSBuyItemResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSBuyItemResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // required uint32 ItemId = 2;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->itemid(), output);
  }

  // required uint32 Count = 3;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->count(), output);
  }

  // required uint32 Price = 4;
  if (has_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->price(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSBuyItemResp)
}

int CSBuyItemResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // required uint32 ItemId = 2;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemid());
    }

    // required uint32 Count = 3;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

    // required uint32 Price = 4;
    if (has_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->price());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSBuyItemResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSBuyItemResp*>(&from));
}

void CSBuyItemResp::MergeFrom(const CSBuyItemResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_price()) {
      set_price(from.price());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSBuyItemResp::CopyFrom(const CSBuyItemResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSBuyItemResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void CSBuyItemResp::Swap(CSBuyItemResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(itemid_, other->itemid_);
    std::swap(count_, other->count_);
    std::swap(price_, other->price_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSBuyItemResp::GetTypeName() const {
  return "fgame.CSBuyItemResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSUseItemReq::kItemIdFieldNumber;
const int CSUseItemReq::kCountFieldNumber;
#endif  // !_MSC_VER

CSUseItemReq::CSUseItemReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSUseItemReq)
}

void CSUseItemReq::InitAsDefaultInstance() {
}

CSUseItemReq::CSUseItemReq(const CSUseItemReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSUseItemReq)
}

void CSUseItemReq::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0u;
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSUseItemReq::~CSUseItemReq() {
  // @@protoc_insertion_point(destructor:fgame.CSUseItemReq)
  SharedDtor();
}

void CSUseItemReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSUseItemReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSUseItemReq& CSUseItemReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSUseItemReq* CSUseItemReq::default_instance_ = NULL;

CSUseItemReq* CSUseItemReq::New() const {
  return new CSUseItemReq;
}

void CSUseItemReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSUseItemReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(itemid_, count_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSUseItemReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSUseItemReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ItemId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Count;
        break;
      }

      // required uint32 Count = 2;
      case 2: {
        if (tag == 16) {
         parse_Count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSUseItemReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSUseItemReq)
  return false;
#undef DO_
}

void CSUseItemReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSUseItemReq)
  // required uint32 ItemId = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->itemid(), output);
  }

  // required uint32 Count = 2;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->count(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSUseItemReq)
}

int CSUseItemReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ItemId = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemid());
    }

    // required uint32 Count = 2;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSUseItemReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSUseItemReq*>(&from));
}

void CSUseItemReq::MergeFrom(const CSUseItemReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSUseItemReq::CopyFrom(const CSUseItemReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSUseItemReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSUseItemReq::Swap(CSUseItemReq* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSUseItemReq::GetTypeName() const {
  return "fgame.CSUseItemReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSUseItemResp::kRetFieldNumber;
const int CSUseItemResp::kItemIdFieldNumber;
#endif  // !_MSC_VER

CSUseItemResp::CSUseItemResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSUseItemResp)
}

void CSUseItemResp::InitAsDefaultInstance() {
}

CSUseItemResp::CSUseItemResp(const CSUseItemResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSUseItemResp)
}

void CSUseItemResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  itemid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSUseItemResp::~CSUseItemResp() {
  // @@protoc_insertion_point(destructor:fgame.CSUseItemResp)
  SharedDtor();
}

void CSUseItemResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSUseItemResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSUseItemResp& CSUseItemResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSUseItemResp* CSUseItemResp::default_instance_ = NULL;

CSUseItemResp* CSUseItemResp::New() const {
  return new CSUseItemResp;
}

void CSUseItemResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSUseItemResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ret_, itemid_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSUseItemResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSUseItemResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ItemId;
        break;
      }

      // required uint32 ItemId = 2;
      case 2: {
        if (tag == 16) {
         parse_ItemId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSUseItemResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSUseItemResp)
  return false;
#undef DO_
}

void CSUseItemResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSUseItemResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // required uint32 ItemId = 2;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->itemid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSUseItemResp)
}

int CSUseItemResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // required uint32 ItemId = 2;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSUseItemResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSUseItemResp*>(&from));
}

void CSUseItemResp::MergeFrom(const CSUseItemResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSUseItemResp::CopyFrom(const CSUseItemResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSUseItemResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSUseItemResp::Swap(CSUseItemResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(itemid_, other->itemid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSUseItemResp::GetTypeName() const {
  return "fgame.CSUseItemResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSBuyVipReq::kVipLevelFieldNumber;
const int CSBuyVipReq::kPriceFieldNumber;
const int CSBuyVipReq::kPaymentFieldNumber;
const int CSBuyVipReq::kTimeTypeFieldNumber;
#endif  // !_MSC_VER

CSBuyVipReq::CSBuyVipReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSBuyVipReq)
}

void CSBuyVipReq::InitAsDefaultInstance() {
}

CSBuyVipReq::CSBuyVipReq(const CSBuyVipReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSBuyVipReq)
}

void CSBuyVipReq::SharedCtor() {
  _cached_size_ = 0;
  viplevel_ = 0u;
  price_ = 0u;
  payment_ = 0u;
  timetype_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSBuyVipReq::~CSBuyVipReq() {
  // @@protoc_insertion_point(destructor:fgame.CSBuyVipReq)
  SharedDtor();
}

void CSBuyVipReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSBuyVipReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSBuyVipReq& CSBuyVipReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSBuyVipReq* CSBuyVipReq::default_instance_ = NULL;

CSBuyVipReq* CSBuyVipReq::New() const {
  return new CSBuyVipReq;
}

void CSBuyVipReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSBuyVipReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(viplevel_, timetype_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSBuyVipReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSBuyVipReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 VipLevel = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &viplevel_)));
          set_has_viplevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Price;
        break;
      }

      // required uint32 Price = 2;
      case 2: {
        if (tag == 16) {
         parse_Price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &price_)));
          set_has_price();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Payment;
        break;
      }

      // required uint32 Payment = 3;
      case 3: {
        if (tag == 24) {
         parse_Payment:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &payment_)));
          set_has_payment();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_TimeType;
        break;
      }

      // required uint32 TimeType = 4;
      case 4: {
        if (tag == 32) {
         parse_TimeType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timetype_)));
          set_has_timetype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSBuyVipReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSBuyVipReq)
  return false;
#undef DO_
}

void CSBuyVipReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSBuyVipReq)
  // required uint32 VipLevel = 1;
  if (has_viplevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->viplevel(), output);
  }

  // required uint32 Price = 2;
  if (has_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->price(), output);
  }

  // required uint32 Payment = 3;
  if (has_payment()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->payment(), output);
  }

  // required uint32 TimeType = 4;
  if (has_timetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->timetype(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSBuyVipReq)
}

int CSBuyVipReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 VipLevel = 1;
    if (has_viplevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->viplevel());
    }

    // required uint32 Price = 2;
    if (has_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->price());
    }

    // required uint32 Payment = 3;
    if (has_payment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->payment());
    }

    // required uint32 TimeType = 4;
    if (has_timetype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->timetype());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSBuyVipReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSBuyVipReq*>(&from));
}

void CSBuyVipReq::MergeFrom(const CSBuyVipReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_viplevel()) {
      set_viplevel(from.viplevel());
    }
    if (from.has_price()) {
      set_price(from.price());
    }
    if (from.has_payment()) {
      set_payment(from.payment());
    }
    if (from.has_timetype()) {
      set_timetype(from.timetype());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSBuyVipReq::CopyFrom(const CSBuyVipReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSBuyVipReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void CSBuyVipReq::Swap(CSBuyVipReq* other) {
  if (other != this) {
    std::swap(viplevel_, other->viplevel_);
    std::swap(price_, other->price_);
    std::swap(payment_, other->payment_);
    std::swap(timetype_, other->timetype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSBuyVipReq::GetTypeName() const {
  return "fgame.CSBuyVipReq";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSVipTimeReq::CSVipTimeReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSVipTimeReq)
}

void CSVipTimeReq::InitAsDefaultInstance() {
}

CSVipTimeReq::CSVipTimeReq(const CSVipTimeReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSVipTimeReq)
}

void CSVipTimeReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSVipTimeReq::~CSVipTimeReq() {
  // @@protoc_insertion_point(destructor:fgame.CSVipTimeReq)
  SharedDtor();
}

void CSVipTimeReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSVipTimeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSVipTimeReq& CSVipTimeReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSVipTimeReq* CSVipTimeReq::default_instance_ = NULL;

CSVipTimeReq* CSVipTimeReq::New() const {
  return new CSVipTimeReq;
}

void CSVipTimeReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSVipTimeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSVipTimeReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSVipTimeReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSVipTimeReq)
  return false;
#undef DO_
}

void CSVipTimeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSVipTimeReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSVipTimeReq)
}

int CSVipTimeReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSVipTimeReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSVipTimeReq*>(&from));
}

void CSVipTimeReq::MergeFrom(const CSVipTimeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSVipTimeReq::CopyFrom(const CSVipTimeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVipTimeReq::IsInitialized() const {

  return true;
}

void CSVipTimeReq::Swap(CSVipTimeReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSVipTimeReq::GetTypeName() const {
  return "fgame.CSVipTimeReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSBuyVipResp::kVipLevelFieldNumber;
const int CSBuyVipResp::kRemainTimeFieldNumber;
const int CSBuyVipResp::kTypeFieldNumber;
#endif  // !_MSC_VER

CSBuyVipResp::CSBuyVipResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSBuyVipResp)
}

void CSBuyVipResp::InitAsDefaultInstance() {
}

CSBuyVipResp::CSBuyVipResp(const CSBuyVipResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSBuyVipResp)
}

void CSBuyVipResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  viplevel_ = 0u;
  remaintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSBuyVipResp::~CSBuyVipResp() {
  // @@protoc_insertion_point(destructor:fgame.CSBuyVipResp)
  SharedDtor();
}

void CSBuyVipResp::SharedDtor() {
  if (remaintime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remaintime_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSBuyVipResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSBuyVipResp& CSBuyVipResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSBuyVipResp* CSBuyVipResp::default_instance_ = NULL;

CSBuyVipResp* CSBuyVipResp::New() const {
  return new CSBuyVipResp;
}

void CSBuyVipResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSBuyVipResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(viplevel_, type_);
    if (has_remaintime()) {
      if (remaintime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        remaintime_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSBuyVipResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSBuyVipResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 VipLevel = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &viplevel_)));
          set_has_viplevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_RemainTime;
        break;
      }

      // optional string RemainTime = 2;
      case 2: {
        if (tag == 18) {
         parse_RemainTime:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_remaintime()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Type;
        break;
      }

      // optional uint32 Type = 3;
      case 3: {
        if (tag == 24) {
         parse_Type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSBuyVipResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSBuyVipResp)
  return false;
#undef DO_
}

void CSBuyVipResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSBuyVipResp)
  // optional uint32 VipLevel = 1;
  if (has_viplevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->viplevel(), output);
  }

  // optional string RemainTime = 2;
  if (has_remaintime()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->remaintime(), output);
  }

  // optional uint32 Type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSBuyVipResp)
}

int CSBuyVipResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 VipLevel = 1;
    if (has_viplevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->viplevel());
    }

    // optional string RemainTime = 2;
    if (has_remaintime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->remaintime());
    }

    // optional uint32 Type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSBuyVipResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSBuyVipResp*>(&from));
}

void CSBuyVipResp::MergeFrom(const CSBuyVipResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_viplevel()) {
      set_viplevel(from.viplevel());
    }
    if (from.has_remaintime()) {
      set_remaintime(from.remaintime());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSBuyVipResp::CopyFrom(const CSBuyVipResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSBuyVipResp::IsInitialized() const {

  return true;
}

void CSBuyVipResp::Swap(CSBuyVipResp* other) {
  if (other != this) {
    std::swap(viplevel_, other->viplevel_);
    std::swap(remaintime_, other->remaintime_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSBuyVipResp::GetTypeName() const {
  return "fgame.CSBuyVipResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPropertyUpdateResp::kUpdateDataFieldNumber;
#endif  // !_MSC_VER

CSPropertyUpdateResp::CSPropertyUpdateResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPropertyUpdateResp)
}

void CSPropertyUpdateResp::InitAsDefaultInstance() {
}

CSPropertyUpdateResp::CSPropertyUpdateResp(const CSPropertyUpdateResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPropertyUpdateResp)
}

void CSPropertyUpdateResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPropertyUpdateResp::~CSPropertyUpdateResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPropertyUpdateResp)
  SharedDtor();
}

void CSPropertyUpdateResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPropertyUpdateResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPropertyUpdateResp& CSPropertyUpdateResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSPropertyUpdateResp* CSPropertyUpdateResp::default_instance_ = NULL;

CSPropertyUpdateResp* CSPropertyUpdateResp::New() const {
  return new CSPropertyUpdateResp;
}

void CSPropertyUpdateResp::Clear() {
  updatedata_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPropertyUpdateResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPropertyUpdateResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.PropertyUpdateData UpdateData = 1;
      case 1: {
        if (tag == 10) {
         parse_UpdateData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_updatedata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_UpdateData;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPropertyUpdateResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPropertyUpdateResp)
  return false;
#undef DO_
}

void CSPropertyUpdateResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPropertyUpdateResp)
  // repeated .fgame.PropertyUpdateData UpdateData = 1;
  for (int i = 0; i < this->updatedata_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->updatedata(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPropertyUpdateResp)
}

int CSPropertyUpdateResp::ByteSize() const {
  int total_size = 0;

  // repeated .fgame.PropertyUpdateData UpdateData = 1;
  total_size += 1 * this->updatedata_size();
  for (int i = 0; i < this->updatedata_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->updatedata(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPropertyUpdateResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPropertyUpdateResp*>(&from));
}

void CSPropertyUpdateResp::MergeFrom(const CSPropertyUpdateResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  updatedata_.MergeFrom(from.updatedata_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPropertyUpdateResp::CopyFrom(const CSPropertyUpdateResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPropertyUpdateResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->updatedata())) return false;
  return true;
}

void CSPropertyUpdateResp::Swap(CSPropertyUpdateResp* other) {
  if (other != this) {
    updatedata_.Swap(&other->updatedata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPropertyUpdateResp::GetTypeName() const {
  return "fgame.CSPropertyUpdateResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSGetAchievementReq::CSGetAchievementReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetAchievementReq)
}

void CSGetAchievementReq::InitAsDefaultInstance() {
}

CSGetAchievementReq::CSGetAchievementReq(const CSGetAchievementReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetAchievementReq)
}

void CSGetAchievementReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetAchievementReq::~CSGetAchievementReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGetAchievementReq)
  SharedDtor();
}

void CSGetAchievementReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetAchievementReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetAchievementReq& CSGetAchievementReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetAchievementReq* CSGetAchievementReq::default_instance_ = NULL;

CSGetAchievementReq* CSGetAchievementReq::New() const {
  return new CSGetAchievementReq;
}

void CSGetAchievementReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetAchievementReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetAchievementReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetAchievementReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetAchievementReq)
  return false;
#undef DO_
}

void CSGetAchievementReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetAchievementReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetAchievementReq)
}

int CSGetAchievementReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetAchievementReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetAchievementReq*>(&from));
}

void CSGetAchievementReq::MergeFrom(const CSGetAchievementReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetAchievementReq::CopyFrom(const CSGetAchievementReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetAchievementReq::IsInitialized() const {

  return true;
}

void CSGetAchievementReq::Swap(CSGetAchievementReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetAchievementReq::GetTypeName() const {
  return "fgame.CSGetAchievementReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGetAchievementInfo::kIdFieldNumber;
const int CSGetAchievementInfo::kStatusFieldNumber;
const int CSGetAchievementInfo::kReceivePlayerCountFieldNumber;
const int CSGetAchievementInfo::kCompleteCountFieldNumber;
#endif  // !_MSC_VER

CSGetAchievementInfo::CSGetAchievementInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetAchievementInfo)
}

void CSGetAchievementInfo::InitAsDefaultInstance() {
}

CSGetAchievementInfo::CSGetAchievementInfo(const CSGetAchievementInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetAchievementInfo)
}

void CSGetAchievementInfo::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  status_ = 0u;
  receiveplayercount_ = 0u;
  completecount_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetAchievementInfo::~CSGetAchievementInfo() {
  // @@protoc_insertion_point(destructor:fgame.CSGetAchievementInfo)
  SharedDtor();
}

void CSGetAchievementInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetAchievementInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetAchievementInfo& CSGetAchievementInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetAchievementInfo* CSGetAchievementInfo::default_instance_ = NULL;

CSGetAchievementInfo* CSGetAchievementInfo::New() const {
  return new CSGetAchievementInfo;
}

void CSGetAchievementInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSGetAchievementInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, receiveplayercount_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetAchievementInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetAchievementInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Status;
        break;
      }

      // required uint32 Status = 2;
      case 2: {
        if (tag == 16) {
         parse_Status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_ReceivePlayerCount;
        break;
      }

      // required uint32 ReceivePlayerCount = 3;
      case 3: {
        if (tag == 24) {
         parse_ReceivePlayerCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &receiveplayercount_)));
          set_has_receiveplayercount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_CompleteCount;
        break;
      }

      // optional uint64 CompleteCount = 4;
      case 4: {
        if (tag == 32) {
         parse_CompleteCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &completecount_)));
          set_has_completecount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetAchievementInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetAchievementInfo)
  return false;
#undef DO_
}

void CSGetAchievementInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetAchievementInfo)
  // required uint32 Id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 Status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->status(), output);
  }

  // required uint32 ReceivePlayerCount = 3;
  if (has_receiveplayercount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->receiveplayercount(), output);
  }

  // optional uint64 CompleteCount = 4;
  if (has_completecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->completecount(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetAchievementInfo)
}

int CSGetAchievementInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 Status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->status());
    }

    // required uint32 ReceivePlayerCount = 3;
    if (has_receiveplayercount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->receiveplayercount());
    }

    // optional uint64 CompleteCount = 4;
    if (has_completecount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->completecount());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetAchievementInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetAchievementInfo*>(&from));
}

void CSGetAchievementInfo::MergeFrom(const CSGetAchievementInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_receiveplayercount()) {
      set_receiveplayercount(from.receiveplayercount());
    }
    if (from.has_completecount()) {
      set_completecount(from.completecount());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetAchievementInfo::CopyFrom(const CSGetAchievementInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetAchievementInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSGetAchievementInfo::Swap(CSGetAchievementInfo* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(status_, other->status_);
    std::swap(receiveplayercount_, other->receiveplayercount_);
    std::swap(completecount_, other->completecount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetAchievementInfo::GetTypeName() const {
  return "fgame.CSGetAchievementInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGetAchievementResp::kDataFieldNumber;
const int CSGetAchievementResp::kAchievementPointCountFieldNumber;
const int CSGetAchievementResp::kAchievementLevelFieldNumber;
#endif  // !_MSC_VER

CSGetAchievementResp::CSGetAchievementResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetAchievementResp)
}

void CSGetAchievementResp::InitAsDefaultInstance() {
}

CSGetAchievementResp::CSGetAchievementResp(const CSGetAchievementResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetAchievementResp)
}

void CSGetAchievementResp::SharedCtor() {
  _cached_size_ = 0;
  achievementpointcount_ = 0u;
  achievementlevel_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetAchievementResp::~CSGetAchievementResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGetAchievementResp)
  SharedDtor();
}

void CSGetAchievementResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetAchievementResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetAchievementResp& CSGetAchievementResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetAchievementResp* CSGetAchievementResp::default_instance_ = NULL;

CSGetAchievementResp* CSGetAchievementResp::New() const {
  return new CSGetAchievementResp;
}

void CSGetAchievementResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSGetAchievementResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(achievementpointcount_, achievementlevel_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetAchievementResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetAchievementResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.CSGetAchievementInfo Data = 1;
      case 1: {
        if (tag == 10) {
         parse_Data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_Data;
        if (input->ExpectTag(16)) goto parse_AchievementPointCount;
        break;
      }

      // required uint32 AchievementPointCount = 2;
      case 2: {
        if (tag == 16) {
         parse_AchievementPointCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &achievementpointcount_)));
          set_has_achievementpointcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_AchievementLevel;
        break;
      }

      // required uint32 AchievementLevel = 3;
      case 3: {
        if (tag == 24) {
         parse_AchievementLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &achievementlevel_)));
          set_has_achievementlevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetAchievementResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetAchievementResp)
  return false;
#undef DO_
}

void CSGetAchievementResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetAchievementResp)
  // repeated .fgame.CSGetAchievementInfo Data = 1;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->data(i), output);
  }

  // required uint32 AchievementPointCount = 2;
  if (has_achievementpointcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->achievementpointcount(), output);
  }

  // required uint32 AchievementLevel = 3;
  if (has_achievementlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->achievementlevel(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetAchievementResp)
}

int CSGetAchievementResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required uint32 AchievementPointCount = 2;
    if (has_achievementpointcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->achievementpointcount());
    }

    // required uint32 AchievementLevel = 3;
    if (has_achievementlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->achievementlevel());
    }

  }
  // repeated .fgame.CSGetAchievementInfo Data = 1;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetAchievementResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetAchievementResp*>(&from));
}

void CSGetAchievementResp::MergeFrom(const CSGetAchievementResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_achievementpointcount()) {
      set_achievementpointcount(from.achievementpointcount());
    }
    if (from.has_achievementlevel()) {
      set_achievementlevel(from.achievementlevel());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetAchievementResp::CopyFrom(const CSGetAchievementResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetAchievementResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->data())) return false;
  return true;
}

void CSGetAchievementResp::Swap(CSGetAchievementResp* other) {
  if (other != this) {
    data_.Swap(&other->data_);
    std::swap(achievementpointcount_, other->achievementpointcount_);
    std::swap(achievementlevel_, other->achievementlevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetAchievementResp::GetTypeName() const {
  return "fgame.CSGetAchievementResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSReceiveAchievementReq::kAchievementIdFieldNumber;
#endif  // !_MSC_VER

CSReceiveAchievementReq::CSReceiveAchievementReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSReceiveAchievementReq)
}

void CSReceiveAchievementReq::InitAsDefaultInstance() {
}

CSReceiveAchievementReq::CSReceiveAchievementReq(const CSReceiveAchievementReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSReceiveAchievementReq)
}

void CSReceiveAchievementReq::SharedCtor() {
  _cached_size_ = 0;
  achievementid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSReceiveAchievementReq::~CSReceiveAchievementReq() {
  // @@protoc_insertion_point(destructor:fgame.CSReceiveAchievementReq)
  SharedDtor();
}

void CSReceiveAchievementReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSReceiveAchievementReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSReceiveAchievementReq& CSReceiveAchievementReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSReceiveAchievementReq* CSReceiveAchievementReq::default_instance_ = NULL;

CSReceiveAchievementReq* CSReceiveAchievementReq::New() const {
  return new CSReceiveAchievementReq;
}

void CSReceiveAchievementReq::Clear() {
  achievementid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSReceiveAchievementReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSReceiveAchievementReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 AchievementId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &achievementid_)));
          set_has_achievementid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSReceiveAchievementReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSReceiveAchievementReq)
  return false;
#undef DO_
}

void CSReceiveAchievementReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSReceiveAchievementReq)
  // required uint32 AchievementId = 1;
  if (has_achievementid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->achievementid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSReceiveAchievementReq)
}

int CSReceiveAchievementReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 AchievementId = 1;
    if (has_achievementid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->achievementid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSReceiveAchievementReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSReceiveAchievementReq*>(&from));
}

void CSReceiveAchievementReq::MergeFrom(const CSReceiveAchievementReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_achievementid()) {
      set_achievementid(from.achievementid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSReceiveAchievementReq::CopyFrom(const CSReceiveAchievementReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSReceiveAchievementReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSReceiveAchievementReq::Swap(CSReceiveAchievementReq* other) {
  if (other != this) {
    std::swap(achievementid_, other->achievementid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSReceiveAchievementReq::GetTypeName() const {
  return "fgame.CSReceiveAchievementReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSReceiveAchievementResp::kRetFieldNumber;
const int CSReceiveAchievementResp::kAchievementIdFieldNumber;
#endif  // !_MSC_VER

CSReceiveAchievementResp::CSReceiveAchievementResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSReceiveAchievementResp)
}

void CSReceiveAchievementResp::InitAsDefaultInstance() {
}

CSReceiveAchievementResp::CSReceiveAchievementResp(const CSReceiveAchievementResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSReceiveAchievementResp)
}

void CSReceiveAchievementResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  achievementid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSReceiveAchievementResp::~CSReceiveAchievementResp() {
  // @@protoc_insertion_point(destructor:fgame.CSReceiveAchievementResp)
  SharedDtor();
}

void CSReceiveAchievementResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSReceiveAchievementResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSReceiveAchievementResp& CSReceiveAchievementResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSReceiveAchievementResp* CSReceiveAchievementResp::default_instance_ = NULL;

CSReceiveAchievementResp* CSReceiveAchievementResp::New() const {
  return new CSReceiveAchievementResp;
}

void CSReceiveAchievementResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSReceiveAchievementResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ret_, achievementid_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSReceiveAchievementResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSReceiveAchievementResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_AchievementId;
        break;
      }

      // required uint32 AchievementId = 2;
      case 2: {
        if (tag == 16) {
         parse_AchievementId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &achievementid_)));
          set_has_achievementid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSReceiveAchievementResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSReceiveAchievementResp)
  return false;
#undef DO_
}

void CSReceiveAchievementResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSReceiveAchievementResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // required uint32 AchievementId = 2;
  if (has_achievementid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->achievementid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSReceiveAchievementResp)
}

int CSReceiveAchievementResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // required uint32 AchievementId = 2;
    if (has_achievementid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->achievementid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSReceiveAchievementResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSReceiveAchievementResp*>(&from));
}

void CSReceiveAchievementResp::MergeFrom(const CSReceiveAchievementResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_achievementid()) {
      set_achievementid(from.achievementid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSReceiveAchievementResp::CopyFrom(const CSReceiveAchievementResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSReceiveAchievementResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSReceiveAchievementResp::Swap(CSReceiveAchievementResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(achievementid_, other->achievementid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSReceiveAchievementResp::GetTypeName() const {
  return "fgame.CSReceiveAchievementResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSReceiveAchievementRewardReq::kAchievementLevelFieldNumber;
#endif  // !_MSC_VER

CSReceiveAchievementRewardReq::CSReceiveAchievementRewardReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSReceiveAchievementRewardReq)
}

void CSReceiveAchievementRewardReq::InitAsDefaultInstance() {
}

CSReceiveAchievementRewardReq::CSReceiveAchievementRewardReq(const CSReceiveAchievementRewardReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSReceiveAchievementRewardReq)
}

void CSReceiveAchievementRewardReq::SharedCtor() {
  _cached_size_ = 0;
  achievementlevel_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSReceiveAchievementRewardReq::~CSReceiveAchievementRewardReq() {
  // @@protoc_insertion_point(destructor:fgame.CSReceiveAchievementRewardReq)
  SharedDtor();
}

void CSReceiveAchievementRewardReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSReceiveAchievementRewardReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSReceiveAchievementRewardReq& CSReceiveAchievementRewardReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSReceiveAchievementRewardReq* CSReceiveAchievementRewardReq::default_instance_ = NULL;

CSReceiveAchievementRewardReq* CSReceiveAchievementRewardReq::New() const {
  return new CSReceiveAchievementRewardReq;
}

void CSReceiveAchievementRewardReq::Clear() {
  achievementlevel_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSReceiveAchievementRewardReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSReceiveAchievementRewardReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 AchievementLevel = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &achievementlevel_)));
          set_has_achievementlevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSReceiveAchievementRewardReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSReceiveAchievementRewardReq)
  return false;
#undef DO_
}

void CSReceiveAchievementRewardReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSReceiveAchievementRewardReq)
  // required uint32 AchievementLevel = 1;
  if (has_achievementlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->achievementlevel(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSReceiveAchievementRewardReq)
}

int CSReceiveAchievementRewardReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 AchievementLevel = 1;
    if (has_achievementlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->achievementlevel());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSReceiveAchievementRewardReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSReceiveAchievementRewardReq*>(&from));
}

void CSReceiveAchievementRewardReq::MergeFrom(const CSReceiveAchievementRewardReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_achievementlevel()) {
      set_achievementlevel(from.achievementlevel());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSReceiveAchievementRewardReq::CopyFrom(const CSReceiveAchievementRewardReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSReceiveAchievementRewardReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSReceiveAchievementRewardReq::Swap(CSReceiveAchievementRewardReq* other) {
  if (other != this) {
    std::swap(achievementlevel_, other->achievementlevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSReceiveAchievementRewardReq::GetTypeName() const {
  return "fgame.CSReceiveAchievementRewardReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSReceiveAchievementRewardResp::kRetFieldNumber;
const int CSReceiveAchievementRewardResp::kAchievementLevelFieldNumber;
#endif  // !_MSC_VER

CSReceiveAchievementRewardResp::CSReceiveAchievementRewardResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSReceiveAchievementRewardResp)
}

void CSReceiveAchievementRewardResp::InitAsDefaultInstance() {
}

CSReceiveAchievementRewardResp::CSReceiveAchievementRewardResp(const CSReceiveAchievementRewardResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSReceiveAchievementRewardResp)
}

void CSReceiveAchievementRewardResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  achievementlevel_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSReceiveAchievementRewardResp::~CSReceiveAchievementRewardResp() {
  // @@protoc_insertion_point(destructor:fgame.CSReceiveAchievementRewardResp)
  SharedDtor();
}

void CSReceiveAchievementRewardResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSReceiveAchievementRewardResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSReceiveAchievementRewardResp& CSReceiveAchievementRewardResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSReceiveAchievementRewardResp* CSReceiveAchievementRewardResp::default_instance_ = NULL;

CSReceiveAchievementRewardResp* CSReceiveAchievementRewardResp::New() const {
  return new CSReceiveAchievementRewardResp;
}

void CSReceiveAchievementRewardResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSReceiveAchievementRewardResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ret_, achievementlevel_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSReceiveAchievementRewardResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSReceiveAchievementRewardResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_AchievementLevel;
        break;
      }

      // required uint32 AchievementLevel = 2;
      case 2: {
        if (tag == 16) {
         parse_AchievementLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &achievementlevel_)));
          set_has_achievementlevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSReceiveAchievementRewardResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSReceiveAchievementRewardResp)
  return false;
#undef DO_
}

void CSReceiveAchievementRewardResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSReceiveAchievementRewardResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // required uint32 AchievementLevel = 2;
  if (has_achievementlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->achievementlevel(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSReceiveAchievementRewardResp)
}

int CSReceiveAchievementRewardResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // required uint32 AchievementLevel = 2;
    if (has_achievementlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->achievementlevel());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSReceiveAchievementRewardResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSReceiveAchievementRewardResp*>(&from));
}

void CSReceiveAchievementRewardResp::MergeFrom(const CSReceiveAchievementRewardResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_achievementlevel()) {
      set_achievementlevel(from.achievementlevel());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSReceiveAchievementRewardResp::CopyFrom(const CSReceiveAchievementRewardResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSReceiveAchievementRewardResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSReceiveAchievementRewardResp::Swap(CSReceiveAchievementRewardResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(achievementlevel_, other->achievementlevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSReceiveAchievementRewardResp::GetTypeName() const {
  return "fgame.CSReceiveAchievementRewardResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSUpdateAchievementResp::kListIdsFieldNumber;
#endif  // !_MSC_VER

CSUpdateAchievementResp::CSUpdateAchievementResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSUpdateAchievementResp)
}

void CSUpdateAchievementResp::InitAsDefaultInstance() {
}

CSUpdateAchievementResp::CSUpdateAchievementResp(const CSUpdateAchievementResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSUpdateAchievementResp)
}

void CSUpdateAchievementResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSUpdateAchievementResp::~CSUpdateAchievementResp() {
  // @@protoc_insertion_point(destructor:fgame.CSUpdateAchievementResp)
  SharedDtor();
}

void CSUpdateAchievementResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSUpdateAchievementResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSUpdateAchievementResp& CSUpdateAchievementResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSUpdateAchievementResp* CSUpdateAchievementResp::default_instance_ = NULL;

CSUpdateAchievementResp* CSUpdateAchievementResp::New() const {
  return new CSUpdateAchievementResp;
}

void CSUpdateAchievementResp::Clear() {
  listids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSUpdateAchievementResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSUpdateAchievementResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 ListIds = 1;
      case 1: {
        if (tag == 8) {
         parse_ListIds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_listids())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_listids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_ListIds;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSUpdateAchievementResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSUpdateAchievementResp)
  return false;
#undef DO_
}

void CSUpdateAchievementResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSUpdateAchievementResp)
  // repeated uint32 ListIds = 1;
  for (int i = 0; i < this->listids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->listids(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSUpdateAchievementResp)
}

int CSUpdateAchievementResp::ByteSize() const {
  int total_size = 0;

  // repeated uint32 ListIds = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->listids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->listids(i));
    }
    total_size += 1 * this->listids_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSUpdateAchievementResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSUpdateAchievementResp*>(&from));
}

void CSUpdateAchievementResp::MergeFrom(const CSUpdateAchievementResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  listids_.MergeFrom(from.listids_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSUpdateAchievementResp::CopyFrom(const CSUpdateAchievementResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSUpdateAchievementResp::IsInitialized() const {

  return true;
}

void CSUpdateAchievementResp::Swap(CSUpdateAchievementResp* other) {
  if (other != this) {
    listids_.Swap(&other->listids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSUpdateAchievementResp::GetTypeName() const {
  return "fgame.CSUpdateAchievementResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSSevenDaySignListReq::CSSevenDaySignListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSevenDaySignListReq)
}

void CSSevenDaySignListReq::InitAsDefaultInstance() {
}

CSSevenDaySignListReq::CSSevenDaySignListReq(const CSSevenDaySignListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSevenDaySignListReq)
}

void CSSevenDaySignListReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSevenDaySignListReq::~CSSevenDaySignListReq() {
  // @@protoc_insertion_point(destructor:fgame.CSSevenDaySignListReq)
  SharedDtor();
}

void CSSevenDaySignListReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSevenDaySignListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSevenDaySignListReq& CSSevenDaySignListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSevenDaySignListReq* CSSevenDaySignListReq::default_instance_ = NULL;

CSSevenDaySignListReq* CSSevenDaySignListReq::New() const {
  return new CSSevenDaySignListReq;
}

void CSSevenDaySignListReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSevenDaySignListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSevenDaySignListReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSevenDaySignListReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSevenDaySignListReq)
  return false;
#undef DO_
}

void CSSevenDaySignListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSevenDaySignListReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSevenDaySignListReq)
}

int CSSevenDaySignListReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSevenDaySignListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSevenDaySignListReq*>(&from));
}

void CSSevenDaySignListReq::MergeFrom(const CSSevenDaySignListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSevenDaySignListReq::CopyFrom(const CSSevenDaySignListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSevenDaySignListReq::IsInitialized() const {

  return true;
}

void CSSevenDaySignListReq::Swap(CSSevenDaySignListReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSevenDaySignListReq::GetTypeName() const {
  return "fgame.CSSevenDaySignListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSevenDayGetList::kIsGetFieldNumber;
const int CSSevenDayGetList::kIsNewGiftFieldNumber;
#endif  // !_MSC_VER

CSSevenDayGetList::CSSevenDayGetList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSevenDayGetList)
}

void CSSevenDayGetList::InitAsDefaultInstance() {
}

CSSevenDayGetList::CSSevenDayGetList(const CSSevenDayGetList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSevenDayGetList)
}

void CSSevenDayGetList::SharedCtor() {
  _cached_size_ = 0;
  isget_ = false;
  isnewgift_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSevenDayGetList::~CSSevenDayGetList() {
  // @@protoc_insertion_point(destructor:fgame.CSSevenDayGetList)
  SharedDtor();
}

void CSSevenDayGetList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSevenDayGetList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSevenDayGetList& CSSevenDayGetList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSevenDayGetList* CSSevenDayGetList::default_instance_ = NULL;

CSSevenDayGetList* CSSevenDayGetList::New() const {
  return new CSSevenDayGetList;
}

void CSSevenDayGetList::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSSevenDayGetList*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(isget_, isnewgift_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSevenDayGetList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSevenDayGetList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool isGet = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isget_)));
          set_has_isget();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_isNewGift;
        break;
      }

      // required bool isNewGift = 2;
      case 2: {
        if (tag == 16) {
         parse_isNewGift:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isnewgift_)));
          set_has_isnewgift();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSevenDayGetList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSevenDayGetList)
  return false;
#undef DO_
}

void CSSevenDayGetList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSevenDayGetList)
  // required bool isGet = 1;
  if (has_isget()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->isget(), output);
  }

  // required bool isNewGift = 2;
  if (has_isnewgift()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->isnewgift(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSevenDayGetList)
}

int CSSevenDayGetList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool isGet = 1;
    if (has_isget()) {
      total_size += 1 + 1;
    }

    // required bool isNewGift = 2;
    if (has_isnewgift()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSevenDayGetList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSevenDayGetList*>(&from));
}

void CSSevenDayGetList::MergeFrom(const CSSevenDayGetList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_isget()) {
      set_isget(from.isget());
    }
    if (from.has_isnewgift()) {
      set_isnewgift(from.isnewgift());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSevenDayGetList::CopyFrom(const CSSevenDayGetList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSevenDayGetList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSSevenDayGetList::Swap(CSSevenDayGetList* other) {
  if (other != this) {
    std::swap(isget_, other->isget_);
    std::swap(isnewgift_, other->isnewgift_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSevenDayGetList::GetTypeName() const {
  return "fgame.CSSevenDayGetList";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSevenDaySignListResp::kNowDayFieldNumber;
const int CSSevenDaySignListResp::kGetListFieldNumber;
#endif  // !_MSC_VER

CSSevenDaySignListResp::CSSevenDaySignListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSevenDaySignListResp)
}

void CSSevenDaySignListResp::InitAsDefaultInstance() {
}

CSSevenDaySignListResp::CSSevenDaySignListResp(const CSSevenDaySignListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSevenDaySignListResp)
}

void CSSevenDaySignListResp::SharedCtor() {
  _cached_size_ = 0;
  nowday_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSevenDaySignListResp::~CSSevenDaySignListResp() {
  // @@protoc_insertion_point(destructor:fgame.CSSevenDaySignListResp)
  SharedDtor();
}

void CSSevenDaySignListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSevenDaySignListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSevenDaySignListResp& CSSevenDaySignListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSevenDaySignListResp* CSSevenDaySignListResp::default_instance_ = NULL;

CSSevenDaySignListResp* CSSevenDaySignListResp::New() const {
  return new CSSevenDaySignListResp;
}

void CSSevenDaySignListResp::Clear() {
  nowday_ = 0u;
  getlist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSevenDaySignListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSevenDaySignListResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 nowDay = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nowday_)));
          set_has_nowday();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_getList;
        break;
      }

      // repeated .fgame.CSSevenDayGetList getList = 2;
      case 2: {
        if (tag == 18) {
         parse_getList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_getlist()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_getList;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSevenDaySignListResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSevenDaySignListResp)
  return false;
#undef DO_
}

void CSSevenDaySignListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSevenDaySignListResp)
  // required uint32 nowDay = 1;
  if (has_nowday()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->nowday(), output);
  }

  // repeated .fgame.CSSevenDayGetList getList = 2;
  for (int i = 0; i < this->getlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->getlist(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSevenDaySignListResp)
}

int CSSevenDaySignListResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 nowDay = 1;
    if (has_nowday()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nowday());
    }

  }
  // repeated .fgame.CSSevenDayGetList getList = 2;
  total_size += 1 * this->getlist_size();
  for (int i = 0; i < this->getlist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->getlist(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSevenDaySignListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSevenDaySignListResp*>(&from));
}

void CSSevenDaySignListResp::MergeFrom(const CSSevenDaySignListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  getlist_.MergeFrom(from.getlist_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nowday()) {
      set_nowday(from.nowday());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSevenDaySignListResp::CopyFrom(const CSSevenDaySignListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSevenDaySignListResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->getlist())) return false;
  return true;
}

void CSSevenDaySignListResp::Swap(CSSevenDaySignListResp* other) {
  if (other != this) {
    std::swap(nowday_, other->nowday_);
    getlist_.Swap(&other->getlist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSevenDaySignListResp::GetTypeName() const {
  return "fgame.CSSevenDaySignListResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSSevenDaySignReq::CSSevenDaySignReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSevenDaySignReq)
}

void CSSevenDaySignReq::InitAsDefaultInstance() {
}

CSSevenDaySignReq::CSSevenDaySignReq(const CSSevenDaySignReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSevenDaySignReq)
}

void CSSevenDaySignReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSevenDaySignReq::~CSSevenDaySignReq() {
  // @@protoc_insertion_point(destructor:fgame.CSSevenDaySignReq)
  SharedDtor();
}

void CSSevenDaySignReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSevenDaySignReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSevenDaySignReq& CSSevenDaySignReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSevenDaySignReq* CSSevenDaySignReq::default_instance_ = NULL;

CSSevenDaySignReq* CSSevenDaySignReq::New() const {
  return new CSSevenDaySignReq;
}

void CSSevenDaySignReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSevenDaySignReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSevenDaySignReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSevenDaySignReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSevenDaySignReq)
  return false;
#undef DO_
}

void CSSevenDaySignReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSevenDaySignReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSevenDaySignReq)
}

int CSSevenDaySignReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSevenDaySignReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSevenDaySignReq*>(&from));
}

void CSSevenDaySignReq::MergeFrom(const CSSevenDaySignReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSevenDaySignReq::CopyFrom(const CSSevenDaySignReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSevenDaySignReq::IsInitialized() const {

  return true;
}

void CSSevenDaySignReq::Swap(CSSevenDaySignReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSevenDaySignReq::GetTypeName() const {
  return "fgame.CSSevenDaySignReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSevenDaySignResp::kGiftIdFieldNumber;
#endif  // !_MSC_VER

CSSevenDaySignResp::CSSevenDaySignResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSevenDaySignResp)
}

void CSSevenDaySignResp::InitAsDefaultInstance() {
}

CSSevenDaySignResp::CSSevenDaySignResp(const CSSevenDaySignResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSevenDaySignResp)
}

void CSSevenDaySignResp::SharedCtor() {
  _cached_size_ = 0;
  giftid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSevenDaySignResp::~CSSevenDaySignResp() {
  // @@protoc_insertion_point(destructor:fgame.CSSevenDaySignResp)
  SharedDtor();
}

void CSSevenDaySignResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSevenDaySignResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSevenDaySignResp& CSSevenDaySignResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSevenDaySignResp* CSSevenDaySignResp::default_instance_ = NULL;

CSSevenDaySignResp* CSSevenDaySignResp::New() const {
  return new CSSevenDaySignResp;
}

void CSSevenDaySignResp::Clear() {
  giftid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSevenDaySignResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSevenDaySignResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 giftId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &giftid_)));
          set_has_giftid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSevenDaySignResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSevenDaySignResp)
  return false;
#undef DO_
}

void CSSevenDaySignResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSevenDaySignResp)
  // required uint32 giftId = 1;
  if (has_giftid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->giftid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSevenDaySignResp)
}

int CSSevenDaySignResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 giftId = 1;
    if (has_giftid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->giftid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSevenDaySignResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSevenDaySignResp*>(&from));
}

void CSSevenDaySignResp::MergeFrom(const CSSevenDaySignResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_giftid()) {
      set_giftid(from.giftid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSevenDaySignResp::CopyFrom(const CSSevenDaySignResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSevenDaySignResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSSevenDaySignResp::Swap(CSSevenDaySignResp* other) {
  if (other != this) {
    std::swap(giftid_, other->giftid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSevenDaySignResp::GetTypeName() const {
  return "fgame.CSSevenDaySignResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGetServerReq::kOpenIdFieldNumber;
const int CSGetServerReq::kLastTsFieldNumber;
const int CSGetServerReq::kGameServerNameFieldNumber;
const int CSGetServerReq::kUinFieldNumber;
const int CSGetServerReq::kVersionFieldNumber;
#endif  // !_MSC_VER

CSGetServerReq::CSGetServerReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetServerReq)
}

void CSGetServerReq::InitAsDefaultInstance() {
}

CSGetServerReq::CSGetServerReq(const CSGetServerReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetServerReq)
}

void CSGetServerReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  lastts_ = 0u;
  gameservername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uin_ = GOOGLE_ULONGLONG(0);
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetServerReq::~CSGetServerReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGetServerReq)
  SharedDtor();
}

void CSGetServerReq::SharedDtor() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (gameservername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gameservername_;
  }
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetServerReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetServerReq& CSGetServerReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetServerReq* CSGetServerReq::default_instance_ = NULL;

CSGetServerReq* CSGetServerReq::New() const {
  return new CSGetServerReq;
}

void CSGetServerReq::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    if (has_openid()) {
      if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        openid_->clear();
      }
    }
    lastts_ = 0u;
    if (has_gameservername()) {
      if (gameservername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        gameservername_->clear();
      }
    }
    uin_ = GOOGLE_ULONGLONG(0);
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        version_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetServerReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetServerReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string OpenId = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_openid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_LastTs;
        break;
      }

      // optional uint32 LastTs = 2;
      case 2: {
        if (tag == 16) {
         parse_LastTs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lastts_)));
          set_has_lastts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_GameServerName;
        break;
      }

      // optional string GameServerName = 3;
      case 3: {
        if (tag == 26) {
         parse_GameServerName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gameservername()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Uin;
        break;
      }

      // optional uint64 Uin = 4;
      case 4: {
        if (tag == 32) {
         parse_Uin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_Version;
        break;
      }

      // optional string Version = 5;
      case 5: {
        if (tag == 42) {
         parse_Version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetServerReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetServerReq)
  return false;
#undef DO_
}

void CSGetServerReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetServerReq)
  // required string OpenId = 1;
  if (has_openid()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->openid(), output);
  }

  // optional uint32 LastTs = 2;
  if (has_lastts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->lastts(), output);
  }

  // optional string GameServerName = 3;
  if (has_gameservername()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->gameservername(), output);
  }

  // optional uint64 Uin = 4;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->uin(), output);
  }

  // optional string Version = 5;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->version(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetServerReq)
}

int CSGetServerReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string OpenId = 1;
    if (has_openid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->openid());
    }

    // optional uint32 LastTs = 2;
    if (has_lastts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lastts());
    }

    // optional string GameServerName = 3;
    if (has_gameservername()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->gameservername());
    }

    // optional uint64 Uin = 4;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

    // optional string Version = 5;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetServerReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetServerReq*>(&from));
}

void CSGetServerReq::MergeFrom(const CSGetServerReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_openid()) {
      set_openid(from.openid());
    }
    if (from.has_lastts()) {
      set_lastts(from.lastts());
    }
    if (from.has_gameservername()) {
      set_gameservername(from.gameservername());
    }
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetServerReq::CopyFrom(const CSGetServerReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetServerReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSGetServerReq::Swap(CSGetServerReq* other) {
  if (other != this) {
    std::swap(openid_, other->openid_);
    std::swap(lastts_, other->lastts_);
    std::swap(gameservername_, other->gameservername_);
    std::swap(uin_, other->uin_);
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetServerReq::GetTypeName() const {
  return "fgame.CSGetServerReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGetServerResp::kLoginServerFieldNumber;
const int CSGetServerResp::kGameServerFieldNumber;
const int CSGetServerResp::kGameServerNameFieldNumber;
const int CSGetServerResp::kWhiteUpdateFieldNumber;
#endif  // !_MSC_VER

CSGetServerResp::CSGetServerResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetServerResp)
}

void CSGetServerResp::InitAsDefaultInstance() {
}

CSGetServerResp::CSGetServerResp(const CSGetServerResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetServerResp)
}

void CSGetServerResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  loginserver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gameserver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gameservername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  whiteupdate_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetServerResp::~CSGetServerResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGetServerResp)
  SharedDtor();
}

void CSGetServerResp::SharedDtor() {
  if (loginserver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete loginserver_;
  }
  if (gameserver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gameserver_;
  }
  if (gameservername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gameservername_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetServerResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetServerResp& CSGetServerResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetServerResp* CSGetServerResp::default_instance_ = NULL;

CSGetServerResp* CSGetServerResp::New() const {
  return new CSGetServerResp;
}

void CSGetServerResp::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_loginserver()) {
      if (loginserver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        loginserver_->clear();
      }
    }
    if (has_gameserver()) {
      if (gameserver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        gameserver_->clear();
      }
    }
    if (has_gameservername()) {
      if (gameservername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        gameservername_->clear();
      }
    }
    whiteupdate_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetServerResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetServerResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string LoginServer = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_loginserver()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_GameServer;
        break;
      }

      // optional string GameServer = 2;
      case 2: {
        if (tag == 18) {
         parse_GameServer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gameserver()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_GameServerName;
        break;
      }

      // optional string GameServerName = 3;
      case 3: {
        if (tag == 26) {
         parse_GameServerName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gameservername()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_WhiteUpdate;
        break;
      }

      // optional uint32 WhiteUpdate = 4;
      case 4: {
        if (tag == 32) {
         parse_WhiteUpdate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &whiteupdate_)));
          set_has_whiteupdate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetServerResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetServerResp)
  return false;
#undef DO_
}

void CSGetServerResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetServerResp)
  // required string LoginServer = 1;
  if (has_loginserver()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->loginserver(), output);
  }

  // optional string GameServer = 2;
  if (has_gameserver()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->gameserver(), output);
  }

  // optional string GameServerName = 3;
  if (has_gameservername()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->gameservername(), output);
  }

  // optional uint32 WhiteUpdate = 4;
  if (has_whiteupdate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->whiteupdate(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetServerResp)
}

int CSGetServerResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string LoginServer = 1;
    if (has_loginserver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->loginserver());
    }

    // optional string GameServer = 2;
    if (has_gameserver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->gameserver());
    }

    // optional string GameServerName = 3;
    if (has_gameservername()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->gameservername());
    }

    // optional uint32 WhiteUpdate = 4;
    if (has_whiteupdate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->whiteupdate());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetServerResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetServerResp*>(&from));
}

void CSGetServerResp::MergeFrom(const CSGetServerResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_loginserver()) {
      set_loginserver(from.loginserver());
    }
    if (from.has_gameserver()) {
      set_gameserver(from.gameserver());
    }
    if (from.has_gameservername()) {
      set_gameservername(from.gameservername());
    }
    if (from.has_whiteupdate()) {
      set_whiteupdate(from.whiteupdate());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetServerResp::CopyFrom(const CSGetServerResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetServerResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSGetServerResp::Swap(CSGetServerResp* other) {
  if (other != this) {
    std::swap(loginserver_, other->loginserver_);
    std::swap(gameserver_, other->gameserver_);
    std::swap(gameservername_, other->gameservername_);
    std::swap(whiteupdate_, other->whiteupdate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetServerResp::GetTypeName() const {
  return "fgame.CSGetServerResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSEnterServerReq::kUinFieldNumber;
const int CSEnterServerReq::kOpenIdFieldNumber;
const int CSEnterServerReq::kRetryFieldNumber;
const int CSEnterServerReq::kIMEIFieldNumber;
const int CSEnterServerReq::kVersionFieldNumber;
#endif  // !_MSC_VER

CSEnterServerReq::CSEnterServerReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSEnterServerReq)
}

void CSEnterServerReq::InitAsDefaultInstance() {
}

CSEnterServerReq::CSEnterServerReq(const CSEnterServerReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSEnterServerReq)
}

void CSEnterServerReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  retry_ = 0u;
  imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSEnterServerReq::~CSEnterServerReq() {
  // @@protoc_insertion_point(destructor:fgame.CSEnterServerReq)
  SharedDtor();
}

void CSEnterServerReq::SharedDtor() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imei_;
  }
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSEnterServerReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSEnterServerReq& CSEnterServerReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSEnterServerReq* CSEnterServerReq::default_instance_ = NULL;

CSEnterServerReq* CSEnterServerReq::New() const {
  return new CSEnterServerReq;
}

void CSEnterServerReq::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    uin_ = GOOGLE_ULONGLONG(0);
    if (has_openid()) {
      if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        openid_->clear();
      }
    }
    retry_ = 0u;
    if (has_imei()) {
      if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        imei_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        version_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSEnterServerReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSEnterServerReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_OpenId;
        break;
      }

      // required string OpenId = 2;
      case 2: {
        if (tag == 18) {
         parse_OpenId:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_openid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Retry;
        break;
      }

      // required uint32 Retry = 3;
      case 3: {
        if (tag == 24) {
         parse_Retry:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &retry_)));
          set_has_retry();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_IMEI;
        break;
      }

      // optional string IMEI = 4;
      case 4: {
        if (tag == 34) {
         parse_IMEI:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_imei()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_Version;
        break;
      }

      // optional string Version = 5;
      case 5: {
        if (tag == 42) {
         parse_Version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSEnterServerReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSEnterServerReq)
  return false;
#undef DO_
}

void CSEnterServerReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSEnterServerReq)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  // required string OpenId = 2;
  if (has_openid()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->openid(), output);
  }

  // required uint32 Retry = 3;
  if (has_retry()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->retry(), output);
  }

  // optional string IMEI = 4;
  if (has_imei()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->imei(), output);
  }

  // optional string Version = 5;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->version(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSEnterServerReq)
}

int CSEnterServerReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

    // required string OpenId = 2;
    if (has_openid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->openid());
    }

    // required uint32 Retry = 3;
    if (has_retry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->retry());
    }

    // optional string IMEI = 4;
    if (has_imei()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->imei());
    }

    // optional string Version = 5;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSEnterServerReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSEnterServerReq*>(&from));
}

void CSEnterServerReq::MergeFrom(const CSEnterServerReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_openid()) {
      set_openid(from.openid());
    }
    if (from.has_retry()) {
      set_retry(from.retry());
    }
    if (from.has_imei()) {
      set_imei(from.imei());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSEnterServerReq::CopyFrom(const CSEnterServerReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSEnterServerReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSEnterServerReq::Swap(CSEnterServerReq* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(openid_, other->openid_);
    std::swap(retry_, other->retry_);
    std::swap(imei_, other->imei_);
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSEnterServerReq::GetTypeName() const {
  return "fgame.CSEnterServerReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSEnterServerResp::kOverloadFieldNumber;
const int CSEnterServerResp::kForceExitFieldNumber;
const int CSEnterServerResp::kWaitNumFieldNumber;
const int CSEnterServerResp::kGameServerNameFieldNumber;
const int CSEnterServerResp::kTsFieldNumber;
#endif  // !_MSC_VER

CSEnterServerResp::CSEnterServerResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSEnterServerResp)
}

void CSEnterServerResp::InitAsDefaultInstance() {
}

CSEnterServerResp::CSEnterServerResp(const CSEnterServerResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSEnterServerResp)
}

void CSEnterServerResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  overload_ = 0u;
  forceexit_ = 0u;
  wait_num_ = 0u;
  gameservername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ts_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSEnterServerResp::~CSEnterServerResp() {
  // @@protoc_insertion_point(destructor:fgame.CSEnterServerResp)
  SharedDtor();
}

void CSEnterServerResp::SharedDtor() {
  if (gameservername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gameservername_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSEnterServerResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSEnterServerResp& CSEnterServerResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSEnterServerResp* CSEnterServerResp::default_instance_ = NULL;

CSEnterServerResp* CSEnterServerResp::New() const {
  return new CSEnterServerResp;
}

void CSEnterServerResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSEnterServerResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(overload_, forceexit_);
    ZR_(wait_num_, ts_);
    if (has_gameservername()) {
      if (gameservername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        gameservername_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSEnterServerResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSEnterServerResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Overload = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &overload_)));
          set_has_overload();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ForceExit;
        break;
      }

      // optional uint32 ForceExit = 2;
      case 2: {
        if (tag == 16) {
         parse_ForceExit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &forceexit_)));
          set_has_forceexit();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Wait_Num;
        break;
      }

      // optional uint32 Wait_Num = 3;
      case 3: {
        if (tag == 24) {
         parse_Wait_Num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &wait_num_)));
          set_has_wait_num();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_GameServerName;
        break;
      }

      // optional string GameServerName = 4;
      case 4: {
        if (tag == 34) {
         parse_GameServerName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gameservername()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_Ts;
        break;
      }

      // optional uint32 Ts = 5;
      case 5: {
        if (tag == 40) {
         parse_Ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSEnterServerResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSEnterServerResp)
  return false;
#undef DO_
}

void CSEnterServerResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSEnterServerResp)
  // required uint32 Overload = 1;
  if (has_overload()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->overload(), output);
  }

  // optional uint32 ForceExit = 2;
  if (has_forceexit()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->forceexit(), output);
  }

  // optional uint32 Wait_Num = 3;
  if (has_wait_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->wait_num(), output);
  }

  // optional string GameServerName = 4;
  if (has_gameservername()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->gameservername(), output);
  }

  // optional uint32 Ts = 5;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->ts(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSEnterServerResp)
}

int CSEnterServerResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Overload = 1;
    if (has_overload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->overload());
    }

    // optional uint32 ForceExit = 2;
    if (has_forceexit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->forceexit());
    }

    // optional uint32 Wait_Num = 3;
    if (has_wait_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->wait_num());
    }

    // optional string GameServerName = 4;
    if (has_gameservername()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->gameservername());
    }

    // optional uint32 Ts = 5;
    if (has_ts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ts());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSEnterServerResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSEnterServerResp*>(&from));
}

void CSEnterServerResp::MergeFrom(const CSEnterServerResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_overload()) {
      set_overload(from.overload());
    }
    if (from.has_forceexit()) {
      set_forceexit(from.forceexit());
    }
    if (from.has_wait_num()) {
      set_wait_num(from.wait_num());
    }
    if (from.has_gameservername()) {
      set_gameservername(from.gameservername());
    }
    if (from.has_ts()) {
      set_ts(from.ts());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSEnterServerResp::CopyFrom(const CSEnterServerResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSEnterServerResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSEnterServerResp::Swap(CSEnterServerResp* other) {
  if (other != this) {
    std::swap(overload_, other->overload_);
    std::swap(forceexit_, other->forceexit_);
    std::swap(wait_num_, other->wait_num_);
    std::swap(gameservername_, other->gameservername_);
    std::swap(ts_, other->ts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSEnterServerResp::GetTypeName() const {
  return "fgame.CSEnterServerResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSCanEnterReq::kUinFieldNumber;
#endif  // !_MSC_VER

CSCanEnterReq::CSCanEnterReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSCanEnterReq)
}

void CSCanEnterReq::InitAsDefaultInstance() {
}

CSCanEnterReq::CSCanEnterReq(const CSCanEnterReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSCanEnterReq)
}

void CSCanEnterReq::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSCanEnterReq::~CSCanEnterReq() {
  // @@protoc_insertion_point(destructor:fgame.CSCanEnterReq)
  SharedDtor();
}

void CSCanEnterReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSCanEnterReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSCanEnterReq& CSCanEnterReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSCanEnterReq* CSCanEnterReq::default_instance_ = NULL;

CSCanEnterReq* CSCanEnterReq::New() const {
  return new CSCanEnterReq;
}

void CSCanEnterReq::Clear() {
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSCanEnterReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSCanEnterReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSCanEnterReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSCanEnterReq)
  return false;
#undef DO_
}

void CSCanEnterReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSCanEnterReq)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSCanEnterReq)
}

int CSCanEnterReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSCanEnterReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSCanEnterReq*>(&from));
}

void CSCanEnterReq::MergeFrom(const CSCanEnterReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSCanEnterReq::CopyFrom(const CSCanEnterReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSCanEnterReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSCanEnterReq::Swap(CSCanEnterReq* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSCanEnterReq::GetTypeName() const {
  return "fgame.CSCanEnterReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDirectEnterReq::kUinFieldNumber;
#endif  // !_MSC_VER

CSDirectEnterReq::CSDirectEnterReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSDirectEnterReq)
}

void CSDirectEnterReq::InitAsDefaultInstance() {
}

CSDirectEnterReq::CSDirectEnterReq(const CSDirectEnterReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSDirectEnterReq)
}

void CSDirectEnterReq::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDirectEnterReq::~CSDirectEnterReq() {
  // @@protoc_insertion_point(destructor:fgame.CSDirectEnterReq)
  SharedDtor();
}

void CSDirectEnterReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSDirectEnterReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDirectEnterReq& CSDirectEnterReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSDirectEnterReq* CSDirectEnterReq::default_instance_ = NULL;

CSDirectEnterReq* CSDirectEnterReq::New() const {
  return new CSDirectEnterReq;
}

void CSDirectEnterReq::Clear() {
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSDirectEnterReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSDirectEnterReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSDirectEnterReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSDirectEnterReq)
  return false;
#undef DO_
}

void CSDirectEnterReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSDirectEnterReq)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSDirectEnterReq)
}

int CSDirectEnterReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDirectEnterReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDirectEnterReq*>(&from));
}

void CSDirectEnterReq::MergeFrom(const CSDirectEnterReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSDirectEnterReq::CopyFrom(const CSDirectEnterReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDirectEnterReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSDirectEnterReq::Swap(CSDirectEnterReq* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDirectEnterReq::GetTypeName() const {
  return "fgame.CSDirectEnterReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDircetEnterResp::kRetFieldNumber;
#endif  // !_MSC_VER

CSDircetEnterResp::CSDircetEnterResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSDircetEnterResp)
}

void CSDircetEnterResp::InitAsDefaultInstance() {
}

CSDircetEnterResp::CSDircetEnterResp(const CSDircetEnterResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSDircetEnterResp)
}

void CSDircetEnterResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDircetEnterResp::~CSDircetEnterResp() {
  // @@protoc_insertion_point(destructor:fgame.CSDircetEnterResp)
  SharedDtor();
}

void CSDircetEnterResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSDircetEnterResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDircetEnterResp& CSDircetEnterResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSDircetEnterResp* CSDircetEnterResp::default_instance_ = NULL;

CSDircetEnterResp* CSDircetEnterResp::New() const {
  return new CSDircetEnterResp;
}

void CSDircetEnterResp::Clear() {
  ret_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSDircetEnterResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSDircetEnterResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSDircetEnterResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSDircetEnterResp)
  return false;
#undef DO_
}

void CSDircetEnterResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSDircetEnterResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSDircetEnterResp)
}

int CSDircetEnterResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDircetEnterResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDircetEnterResp*>(&from));
}

void CSDircetEnterResp::MergeFrom(const CSDircetEnterResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSDircetEnterResp::CopyFrom(const CSDircetEnterResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDircetEnterResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSDircetEnterResp::Swap(CSDircetEnterResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDircetEnterResp::GetTypeName() const {
  return "fgame.CSDircetEnterResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSQueueReq::kUinFieldNumber;
const int CSQueueReq::kRemainNumFieldNumber;
#endif  // !_MSC_VER

CSQueueReq::CSQueueReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSQueueReq)
}

void CSQueueReq::InitAsDefaultInstance() {
}

CSQueueReq::CSQueueReq(const CSQueueReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSQueueReq)
}

void CSQueueReq::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  remain_num_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSQueueReq::~CSQueueReq() {
  // @@protoc_insertion_point(destructor:fgame.CSQueueReq)
  SharedDtor();
}

void CSQueueReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSQueueReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSQueueReq& CSQueueReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSQueueReq* CSQueueReq::default_instance_ = NULL;

CSQueueReq* CSQueueReq::New() const {
  return new CSQueueReq;
}

void CSQueueReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSQueueReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(uin_, remain_num_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSQueueReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSQueueReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Remain_Num;
        break;
      }

      // required uint32 Remain_Num = 2;
      case 2: {
        if (tag == 16) {
         parse_Remain_Num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &remain_num_)));
          set_has_remain_num();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSQueueReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSQueueReq)
  return false;
#undef DO_
}

void CSQueueReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSQueueReq)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  // required uint32 Remain_Num = 2;
  if (has_remain_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->remain_num(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSQueueReq)
}

int CSQueueReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

    // required uint32 Remain_Num = 2;
    if (has_remain_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->remain_num());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSQueueReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSQueueReq*>(&from));
}

void CSQueueReq::MergeFrom(const CSQueueReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_remain_num()) {
      set_remain_num(from.remain_num());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSQueueReq::CopyFrom(const CSQueueReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSQueueReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSQueueReq::Swap(CSQueueReq* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(remain_num_, other->remain_num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSQueueReq::GetTypeName() const {
  return "fgame.CSQueueReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSStreakWinValueReq::kUinFieldNumber;
#endif  // !_MSC_VER

CSStreakWinValueReq::CSStreakWinValueReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSStreakWinValueReq)
}

void CSStreakWinValueReq::InitAsDefaultInstance() {
}

CSStreakWinValueReq::CSStreakWinValueReq(const CSStreakWinValueReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSStreakWinValueReq)
}

void CSStreakWinValueReq::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSStreakWinValueReq::~CSStreakWinValueReq() {
  // @@protoc_insertion_point(destructor:fgame.CSStreakWinValueReq)
  SharedDtor();
}

void CSStreakWinValueReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSStreakWinValueReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSStreakWinValueReq& CSStreakWinValueReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSStreakWinValueReq* CSStreakWinValueReq::default_instance_ = NULL;

CSStreakWinValueReq* CSStreakWinValueReq::New() const {
  return new CSStreakWinValueReq;
}

void CSStreakWinValueReq::Clear() {
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSStreakWinValueReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSStreakWinValueReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSStreakWinValueReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSStreakWinValueReq)
  return false;
#undef DO_
}

void CSStreakWinValueReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSStreakWinValueReq)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSStreakWinValueReq)
}

int CSStreakWinValueReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSStreakWinValueReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSStreakWinValueReq*>(&from));
}

void CSStreakWinValueReq::MergeFrom(const CSStreakWinValueReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSStreakWinValueReq::CopyFrom(const CSStreakWinValueReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSStreakWinValueReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSStreakWinValueReq::Swap(CSStreakWinValueReq* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSStreakWinValueReq::GetTypeName() const {
  return "fgame.CSStreakWinValueReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSStreakWinValueResp::kRetFieldNumber;
const int CSStreakWinValueResp::kStreakWinValueFieldNumber;
const int CSStreakWinValueResp::kGetWinValueFieldNumber;
#endif  // !_MSC_VER

CSStreakWinValueResp::CSStreakWinValueResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSStreakWinValueResp)
}

void CSStreakWinValueResp::InitAsDefaultInstance() {
}

CSStreakWinValueResp::CSStreakWinValueResp(const CSStreakWinValueResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSStreakWinValueResp)
}

void CSStreakWinValueResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  streakwinvalue_ = 0u;
  getwinvalue_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSStreakWinValueResp::~CSStreakWinValueResp() {
  // @@protoc_insertion_point(destructor:fgame.CSStreakWinValueResp)
  SharedDtor();
}

void CSStreakWinValueResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSStreakWinValueResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSStreakWinValueResp& CSStreakWinValueResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSStreakWinValueResp* CSStreakWinValueResp::default_instance_ = NULL;

CSStreakWinValueResp* CSStreakWinValueResp::New() const {
  return new CSStreakWinValueResp;
}

void CSStreakWinValueResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSStreakWinValueResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ret_, getwinvalue_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSStreakWinValueResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSStreakWinValueResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_StreakWinValue;
        break;
      }

      // required uint32 StreakWinValue = 2;
      case 2: {
        if (tag == 16) {
         parse_StreakWinValue:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &streakwinvalue_)));
          set_has_streakwinvalue();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_GetWinValue;
        break;
      }

      // optional uint32 GetWinValue = 3;
      case 3: {
        if (tag == 24) {
         parse_GetWinValue:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &getwinvalue_)));
          set_has_getwinvalue();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSStreakWinValueResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSStreakWinValueResp)
  return false;
#undef DO_
}

void CSStreakWinValueResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSStreakWinValueResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // required uint32 StreakWinValue = 2;
  if (has_streakwinvalue()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->streakwinvalue(), output);
  }

  // optional uint32 GetWinValue = 3;
  if (has_getwinvalue()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->getwinvalue(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSStreakWinValueResp)
}

int CSStreakWinValueResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // required uint32 StreakWinValue = 2;
    if (has_streakwinvalue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->streakwinvalue());
    }

    // optional uint32 GetWinValue = 3;
    if (has_getwinvalue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->getwinvalue());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSStreakWinValueResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSStreakWinValueResp*>(&from));
}

void CSStreakWinValueResp::MergeFrom(const CSStreakWinValueResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_streakwinvalue()) {
      set_streakwinvalue(from.streakwinvalue());
    }
    if (from.has_getwinvalue()) {
      set_getwinvalue(from.getwinvalue());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSStreakWinValueResp::CopyFrom(const CSStreakWinValueResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSStreakWinValueResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSStreakWinValueResp::Swap(CSStreakWinValueResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(streakwinvalue_, other->streakwinvalue_);
    std::swap(getwinvalue_, other->getwinvalue_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSStreakWinValueResp::GetTypeName() const {
  return "fgame.CSStreakWinValueResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSStreakWinGetReq::kStreakWinValueFieldNumber;
#endif  // !_MSC_VER

CSStreakWinGetReq::CSStreakWinGetReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSStreakWinGetReq)
}

void CSStreakWinGetReq::InitAsDefaultInstance() {
}

CSStreakWinGetReq::CSStreakWinGetReq(const CSStreakWinGetReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSStreakWinGetReq)
}

void CSStreakWinGetReq::SharedCtor() {
  _cached_size_ = 0;
  streakwinvalue_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSStreakWinGetReq::~CSStreakWinGetReq() {
  // @@protoc_insertion_point(destructor:fgame.CSStreakWinGetReq)
  SharedDtor();
}

void CSStreakWinGetReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSStreakWinGetReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSStreakWinGetReq& CSStreakWinGetReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSStreakWinGetReq* CSStreakWinGetReq::default_instance_ = NULL;

CSStreakWinGetReq* CSStreakWinGetReq::New() const {
  return new CSStreakWinGetReq;
}

void CSStreakWinGetReq::Clear() {
  streakwinvalue_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSStreakWinGetReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSStreakWinGetReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 StreakWinValue = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &streakwinvalue_)));
          set_has_streakwinvalue();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSStreakWinGetReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSStreakWinGetReq)
  return false;
#undef DO_
}

void CSStreakWinGetReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSStreakWinGetReq)
  // required uint32 StreakWinValue = 1;
  if (has_streakwinvalue()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->streakwinvalue(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSStreakWinGetReq)
}

int CSStreakWinGetReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 StreakWinValue = 1;
    if (has_streakwinvalue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->streakwinvalue());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSStreakWinGetReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSStreakWinGetReq*>(&from));
}

void CSStreakWinGetReq::MergeFrom(const CSStreakWinGetReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_streakwinvalue()) {
      set_streakwinvalue(from.streakwinvalue());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSStreakWinGetReq::CopyFrom(const CSStreakWinGetReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSStreakWinGetReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSStreakWinGetReq::Swap(CSStreakWinGetReq* other) {
  if (other != this) {
    std::swap(streakwinvalue_, other->streakwinvalue_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSStreakWinGetReq::GetTypeName() const {
  return "fgame.CSStreakWinGetReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSStreakWinGetResp::kRetFieldNumber;
const int CSStreakWinGetResp::kDiamondValueFieldNumber;
#endif  // !_MSC_VER

CSStreakWinGetResp::CSStreakWinGetResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSStreakWinGetResp)
}

void CSStreakWinGetResp::InitAsDefaultInstance() {
}

CSStreakWinGetResp::CSStreakWinGetResp(const CSStreakWinGetResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSStreakWinGetResp)
}

void CSStreakWinGetResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  diamondvalue_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSStreakWinGetResp::~CSStreakWinGetResp() {
  // @@protoc_insertion_point(destructor:fgame.CSStreakWinGetResp)
  SharedDtor();
}

void CSStreakWinGetResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSStreakWinGetResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSStreakWinGetResp& CSStreakWinGetResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSStreakWinGetResp* CSStreakWinGetResp::default_instance_ = NULL;

CSStreakWinGetResp* CSStreakWinGetResp::New() const {
  return new CSStreakWinGetResp;
}

void CSStreakWinGetResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSStreakWinGetResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ret_, diamondvalue_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSStreakWinGetResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSStreakWinGetResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_DiamondValue;
        break;
      }

      // required uint32 DiamondValue = 2;
      case 2: {
        if (tag == 16) {
         parse_DiamondValue:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &diamondvalue_)));
          set_has_diamondvalue();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSStreakWinGetResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSStreakWinGetResp)
  return false;
#undef DO_
}

void CSStreakWinGetResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSStreakWinGetResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // required uint32 DiamondValue = 2;
  if (has_diamondvalue()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->diamondvalue(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSStreakWinGetResp)
}

int CSStreakWinGetResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // required uint32 DiamondValue = 2;
    if (has_diamondvalue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->diamondvalue());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSStreakWinGetResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSStreakWinGetResp*>(&from));
}

void CSStreakWinGetResp::MergeFrom(const CSStreakWinGetResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_diamondvalue()) {
      set_diamondvalue(from.diamondvalue());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSStreakWinGetResp::CopyFrom(const CSStreakWinGetResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSStreakWinGetResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSStreakWinGetResp::Swap(CSStreakWinGetResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(diamondvalue_, other->diamondvalue_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSStreakWinGetResp::GetTypeName() const {
  return "fgame.CSStreakWinGetResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSItem::kItemIdFieldNumber;
const int CSItem::kCountFieldNumber;
#endif  // !_MSC_VER

CSItem::CSItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSItem)
}

void CSItem::InitAsDefaultInstance() {
}

CSItem::CSItem(const CSItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSItem)
}

void CSItem::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0u;
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSItem::~CSItem() {
  // @@protoc_insertion_point(destructor:fgame.CSItem)
  SharedDtor();
}

void CSItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSItem& CSItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSItem* CSItem::default_instance_ = NULL;

CSItem* CSItem::New() const {
  return new CSItem;
}

void CSItem::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSItem*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(itemid_, count_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSItem)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ItemId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Count;
        break;
      }

      // required uint32 Count = 2;
      case 2: {
        if (tag == 16) {
         parse_Count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSItem)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSItem)
  return false;
#undef DO_
}

void CSItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSItem)
  // required uint32 ItemId = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->itemid(), output);
  }

  // required uint32 Count = 2;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->count(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSItem)
}

int CSItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ItemId = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemid());
    }

    // required uint32 Count = 2;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSItem*>(&from));
}

void CSItem::MergeFrom(const CSItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSItem::CopyFrom(const CSItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSItem::Swap(CSItem* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSItem::GetTypeName() const {
  return "fgame.CSItem";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSSycPlayerInfoReq::CSSycPlayerInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSycPlayerInfoReq)
}

void CSSycPlayerInfoReq::InitAsDefaultInstance() {
}

CSSycPlayerInfoReq::CSSycPlayerInfoReq(const CSSycPlayerInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSycPlayerInfoReq)
}

void CSSycPlayerInfoReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSycPlayerInfoReq::~CSSycPlayerInfoReq() {
  // @@protoc_insertion_point(destructor:fgame.CSSycPlayerInfoReq)
  SharedDtor();
}

void CSSycPlayerInfoReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSycPlayerInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSycPlayerInfoReq& CSSycPlayerInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSycPlayerInfoReq* CSSycPlayerInfoReq::default_instance_ = NULL;

CSSycPlayerInfoReq* CSSycPlayerInfoReq::New() const {
  return new CSSycPlayerInfoReq;
}

void CSSycPlayerInfoReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSycPlayerInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSycPlayerInfoReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSycPlayerInfoReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSycPlayerInfoReq)
  return false;
#undef DO_
}

void CSSycPlayerInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSycPlayerInfoReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSycPlayerInfoReq)
}

int CSSycPlayerInfoReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSycPlayerInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSycPlayerInfoReq*>(&from));
}

void CSSycPlayerInfoReq::MergeFrom(const CSSycPlayerInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSycPlayerInfoReq::CopyFrom(const CSSycPlayerInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSycPlayerInfoReq::IsInitialized() const {

  return true;
}

void CSSycPlayerInfoReq::Swap(CSSycPlayerInfoReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSycPlayerInfoReq::GetTypeName() const {
  return "fgame.CSSycPlayerInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSTitleItem::kTypeFieldNumber;
const int CSTitleItem::kTimeFieldNumber;
#endif  // !_MSC_VER

CSTitleItem::CSTitleItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSTitleItem)
}

void CSTitleItem::InitAsDefaultInstance() {
}

CSTitleItem::CSTitleItem(const CSTitleItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSTitleItem)
}

void CSTitleItem::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  time_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSTitleItem::~CSTitleItem() {
  // @@protoc_insertion_point(destructor:fgame.CSTitleItem)
  SharedDtor();
}

void CSTitleItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSTitleItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSTitleItem& CSTitleItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSTitleItem* CSTitleItem::default_instance_ = NULL;

CSTitleItem* CSTitleItem::New() const {
  return new CSTitleItem;
}

void CSTitleItem::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSTitleItem*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(type_, time_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSTitleItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSTitleItem)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Time;
        break;
      }

      // required uint32 Time = 2;
      case 2: {
        if (tag == 16) {
         parse_Time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSTitleItem)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSTitleItem)
  return false;
#undef DO_
}

void CSTitleItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSTitleItem)
  // required uint32 Type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  // required uint32 Time = 2;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSTitleItem)
}

int CSTitleItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required uint32 Time = 2;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSTitleItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSTitleItem*>(&from));
}

void CSTitleItem::MergeFrom(const CSTitleItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSTitleItem::CopyFrom(const CSTitleItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSTitleItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSTitleItem::Swap(CSTitleItem* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSTitleItem::GetTypeName() const {
  return "fgame.CSTitleItem";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSycPlayerInfoResp::kPlayerTitleFieldNumber;
const int CSSycPlayerInfoResp::kEnergyFieldNumber;
const int CSSycPlayerInfoResp::kNameFieldNumber;
const int CSSycPlayerInfoResp::kChangeNameCountFieldNumber;
const int CSSycPlayerInfoResp::kEnergyBuyCountFieldNumber;
const int CSSycPlayerInfoResp::kDiamondFieldNumber;
const int CSSycPlayerInfoResp::kIconIdFieldNumber;
const int CSSycPlayerInfoResp::kEnergySlotFieldNumber;
const int CSSycPlayerInfoResp::kPowerFieldNumber;
const int CSSycPlayerInfoResp::kPowerSlotFieldNumber;
const int CSSycPlayerInfoResp::kItemsFieldNumber;
const int CSSycPlayerInfoResp::kMonthCardDaysFieldNumber;
const int CSSycPlayerInfoResp::kShopGuideFieldNumber;
const int CSSycPlayerInfoResp::kTitleListFieldNumber;
const int CSSycPlayerInfoResp::kRoomTicketFieldNumber;
const int CSSycPlayerInfoResp::kVipLevelFieldNumber;
const int CSSycPlayerInfoResp::kRemainTimeFieldNumber;
const int CSSycPlayerInfoResp::kExpLevelFieldNumber;
const int CSSycPlayerInfoResp::kExpFieldNumber;
const int CSSycPlayerInfoResp::kTitleItemsFieldNumber;
const int CSSycPlayerInfoResp::kRankFieldNumber;
const int CSSycPlayerInfoResp::kWinRateFieldNumber;
const int CSSycPlayerInfoResp::kScoreFieldNumber;
const int CSSycPlayerInfoResp::kAchievementLevelFieldNumber;
const int CSSycPlayerInfoResp::kHonorCountFieldNumber;
const int CSSycPlayerInfoResp::kPvpRoundFieldNumber;
const int CSSycPlayerInfoResp::kAddExpFieldNumber;
const int CSSycPlayerInfoResp::kGlyphGuideFieldNumber;
const int CSSycPlayerInfoResp::kChatFreeCountFieldNumber;
const int CSSycPlayerInfoResp::kTimeLeftFieldNumber;
const int CSSycPlayerInfoResp::kAreaFieldNumber;
#endif  // !_MSC_VER

CSSycPlayerInfoResp::CSSycPlayerInfoResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSycPlayerInfoResp)
}

void CSSycPlayerInfoResp::InitAsDefaultInstance() {
}

CSSycPlayerInfoResp::CSSycPlayerInfoResp(const CSSycPlayerInfoResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSycPlayerInfoResp)
}

void CSSycPlayerInfoResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  playertitle_ = 0u;
  energy_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  changenamecount_ = 0u;
  energybuycount_ = 0u;
  diamond_ = 0u;
  iconid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  energyslot_ = 0u;
  power_ = 0u;
  powerslot_ = 0u;
  monthcarddays_ = 0u;
  shopguide_ = 0u;
  roomticket_ = 0u;
  viplevel_ = 0u;
  remaintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  explevel_ = 0u;
  exp_ = 0u;
  rank_ = 0u;
  winrate_ = 0;
  score_ = 0u;
  achievementlevel_ = 0u;
  honorcount_ = 0u;
  pvpround_ = 0u;
  addexp_ = 0u;
  glyphguide_ = 0u;
  chatfreecount_ = 0u;
  timeleft_ = 0u;
  area_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSycPlayerInfoResp::~CSSycPlayerInfoResp() {
  // @@protoc_insertion_point(destructor:fgame.CSSycPlayerInfoResp)
  SharedDtor();
}

void CSSycPlayerInfoResp::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (iconid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete iconid_;
  }
  if (remaintime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remaintime_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSycPlayerInfoResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSycPlayerInfoResp& CSSycPlayerInfoResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSycPlayerInfoResp* CSSycPlayerInfoResp::default_instance_ = NULL;

CSSycPlayerInfoResp* CSSycPlayerInfoResp::New() const {
  return new CSSycPlayerInfoResp;
}

void CSSycPlayerInfoResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSSycPlayerInfoResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(playertitle_, energy_);
    ZR_(changenamecount_, energybuycount_);
    ZR_(diamond_, energyslot_);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_iconid()) {
      if (iconid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        iconid_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 56064) {
    ZR_(power_, powerslot_);
    ZR_(monthcarddays_, shopguide_);
    ZR_(roomticket_, viplevel_);
  }
  if (_has_bits_[16 / 32] & 16187392) {
    ZR_(explevel_, exp_);
    ZR_(rank_, achievementlevel_);
    if (has_remaintime()) {
      if (remaintime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        remaintime_->clear();
      }
    }
  }
  if (_has_bits_[24 / 32] & 2130706432) {
    ZR_(honorcount_, area_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  items_.Clear();
  titlelist_.Clear();
  titleitems_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSycPlayerInfoResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSycPlayerInfoResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 PlayerTitle = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &playertitle_)));
          set_has_playertitle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Energy;
        break;
      }

      // required uint32 Energy = 2;
      case 2: {
        if (tag == 16) {
         parse_Energy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &energy_)));
          set_has_energy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_Name;
        break;
      }

      // optional string Name = 3;
      case 3: {
        if (tag == 26) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_ChangeNameCount;
        break;
      }

      // optional uint32 ChangeNameCount = 4;
      case 4: {
        if (tag == 32) {
         parse_ChangeNameCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &changenamecount_)));
          set_has_changenamecount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_EnergyBuyCount;
        break;
      }

      // optional uint32 EnergyBuyCount = 5;
      case 5: {
        if (tag == 40) {
         parse_EnergyBuyCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &energybuycount_)));
          set_has_energybuycount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_Diamond;
        break;
      }

      // optional uint32 Diamond = 6;
      case 6: {
        if (tag == 48) {
         parse_Diamond:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &diamond_)));
          set_has_diamond();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_IconId;
        break;
      }

      // optional string IconId = 7;
      case 7: {
        if (tag == 58) {
         parse_IconId:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_iconid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_EnergySlot;
        break;
      }

      // optional uint32 EnergySlot = 8;
      case 8: {
        if (tag == 64) {
         parse_EnergySlot:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &energyslot_)));
          set_has_energyslot();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_Power;
        break;
      }

      // optional uint32 Power = 9;
      case 9: {
        if (tag == 72) {
         parse_Power:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &power_)));
          set_has_power();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_PowerSlot;
        break;
      }

      // optional uint32 PowerSlot = 10;
      case 10: {
        if (tag == 80) {
         parse_PowerSlot:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &powerslot_)));
          set_has_powerslot();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_Items;
        break;
      }

      // repeated .fgame.CSItem Items = 11;
      case 11: {
        if (tag == 90) {
         parse_Items:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_items()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_Items;
        if (input->ExpectTag(96)) goto parse_MonthCardDays;
        break;
      }

      // optional uint32 MonthCardDays = 12;
      case 12: {
        if (tag == 96) {
         parse_MonthCardDays:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &monthcarddays_)));
          set_has_monthcarddays();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_ShopGuide;
        break;
      }

      // optional uint32 ShopGuide = 13;
      case 13: {
        if (tag == 104) {
         parse_ShopGuide:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shopguide_)));
          set_has_shopguide();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_TitleList;
        break;
      }

      // repeated uint32 TitleList = 14;
      case 14: {
        if (tag == 112) {
         parse_TitleList:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 112, input, this->mutable_titlelist())));
        } else if (tag == 114) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_titlelist())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_TitleList;
        if (input->ExpectTag(120)) goto parse_RoomTicket;
        break;
      }

      // optional uint32 RoomTicket = 15;
      case 15: {
        if (tag == 120) {
         parse_RoomTicket:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomticket_)));
          set_has_roomticket();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_VipLevel;
        break;
      }

      // optional uint32 VipLevel = 16;
      case 16: {
        if (tag == 128) {
         parse_VipLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &viplevel_)));
          set_has_viplevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(138)) goto parse_RemainTime;
        break;
      }

      // optional string RemainTime = 17;
      case 17: {
        if (tag == 138) {
         parse_RemainTime:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_remaintime()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_ExpLevel;
        break;
      }

      // optional uint32 ExpLevel = 18;
      case 18: {
        if (tag == 144) {
         parse_ExpLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &explevel_)));
          set_has_explevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(152)) goto parse_Exp;
        break;
      }

      // optional uint32 Exp = 19;
      case 19: {
        if (tag == 152) {
         parse_Exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_TitleItems;
        break;
      }

      // repeated .fgame.CSTitleItem TitleItems = 20;
      case 20: {
        if (tag == 162) {
         parse_TitleItems:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_titleitems()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_TitleItems;
        if (input->ExpectTag(168)) goto parse_Rank;
        break;
      }

      // optional uint32 Rank = 21;
      case 21: {
        if (tag == 168) {
         parse_Rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_)));
          set_has_rank();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(181)) goto parse_WinRate;
        break;
      }

      // optional float WinRate = 22;
      case 22: {
        if (tag == 181) {
         parse_WinRate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &winrate_)));
          set_has_winrate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(184)) goto parse_Score;
        break;
      }

      // optional uint32 Score = 23;
      case 23: {
        if (tag == 184) {
         parse_Score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(192)) goto parse_AchievementLevel;
        break;
      }

      // optional uint32 AchievementLevel = 24;
      case 24: {
        if (tag == 192) {
         parse_AchievementLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &achievementlevel_)));
          set_has_achievementlevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(200)) goto parse_HonorCount;
        break;
      }

      // optional uint32 HonorCount = 25;
      case 25: {
        if (tag == 200) {
         parse_HonorCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &honorcount_)));
          set_has_honorcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(208)) goto parse_PvpRound;
        break;
      }

      // optional uint32 PvpRound = 26;
      case 26: {
        if (tag == 208) {
         parse_PvpRound:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pvpround_)));
          set_has_pvpround();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(216)) goto parse_AddExp;
        break;
      }

      // optional uint32 AddExp = 27;
      case 27: {
        if (tag == 216) {
         parse_AddExp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &addexp_)));
          set_has_addexp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(224)) goto parse_GlyphGuide;
        break;
      }

      // optional uint32 GlyphGuide = 28;
      case 28: {
        if (tag == 224) {
         parse_GlyphGuide:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &glyphguide_)));
          set_has_glyphguide();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(232)) goto parse_ChatFreeCount;
        break;
      }

      // optional uint32 ChatFreeCount = 29;
      case 29: {
        if (tag == 232) {
         parse_ChatFreeCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chatfreecount_)));
          set_has_chatfreecount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(240)) goto parse_TimeLeft;
        break;
      }

      // optional uint32 TimeLeft = 30;
      case 30: {
        if (tag == 240) {
         parse_TimeLeft:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timeleft_)));
          set_has_timeleft();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(248)) goto parse_Area;
        break;
      }

      // optional uint32 Area = 31;
      case 31: {
        if (tag == 248) {
         parse_Area:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &area_)));
          set_has_area();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSycPlayerInfoResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSycPlayerInfoResp)
  return false;
#undef DO_
}

void CSSycPlayerInfoResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSycPlayerInfoResp)
  // required uint32 PlayerTitle = 1;
  if (has_playertitle()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->playertitle(), output);
  }

  // required uint32 Energy = 2;
  if (has_energy()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->energy(), output);
  }

  // optional string Name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // optional uint32 ChangeNameCount = 4;
  if (has_changenamecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->changenamecount(), output);
  }

  // optional uint32 EnergyBuyCount = 5;
  if (has_energybuycount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->energybuycount(), output);
  }

  // optional uint32 Diamond = 6;
  if (has_diamond()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->diamond(), output);
  }

  // optional string IconId = 7;
  if (has_iconid()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->iconid(), output);
  }

  // optional uint32 EnergySlot = 8;
  if (has_energyslot()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->energyslot(), output);
  }

  // optional uint32 Power = 9;
  if (has_power()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->power(), output);
  }

  // optional uint32 PowerSlot = 10;
  if (has_powerslot()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->powerslot(), output);
  }

  // repeated .fgame.CSItem Items = 11;
  for (int i = 0; i < this->items_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->items(i), output);
  }

  // optional uint32 MonthCardDays = 12;
  if (has_monthcarddays()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->monthcarddays(), output);
  }

  // optional uint32 ShopGuide = 13;
  if (has_shopguide()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->shopguide(), output);
  }

  // repeated uint32 TitleList = 14;
  for (int i = 0; i < this->titlelist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      14, this->titlelist(i), output);
  }

  // optional uint32 RoomTicket = 15;
  if (has_roomticket()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->roomticket(), output);
  }

  // optional uint32 VipLevel = 16;
  if (has_viplevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(16, this->viplevel(), output);
  }

  // optional string RemainTime = 17;
  if (has_remaintime()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      17, this->remaintime(), output);
  }

  // optional uint32 ExpLevel = 18;
  if (has_explevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(18, this->explevel(), output);
  }

  // optional uint32 Exp = 19;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(19, this->exp(), output);
  }

  // repeated .fgame.CSTitleItem TitleItems = 20;
  for (int i = 0; i < this->titleitems_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      20, this->titleitems(i), output);
  }

  // optional uint32 Rank = 21;
  if (has_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(21, this->rank(), output);
  }

  // optional float WinRate = 22;
  if (has_winrate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(22, this->winrate(), output);
  }

  // optional uint32 Score = 23;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(23, this->score(), output);
  }

  // optional uint32 AchievementLevel = 24;
  if (has_achievementlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(24, this->achievementlevel(), output);
  }

  // optional uint32 HonorCount = 25;
  if (has_honorcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(25, this->honorcount(), output);
  }

  // optional uint32 PvpRound = 26;
  if (has_pvpround()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(26, this->pvpround(), output);
  }

  // optional uint32 AddExp = 27;
  if (has_addexp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(27, this->addexp(), output);
  }

  // optional uint32 GlyphGuide = 28;
  if (has_glyphguide()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(28, this->glyphguide(), output);
  }

  // optional uint32 ChatFreeCount = 29;
  if (has_chatfreecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(29, this->chatfreecount(), output);
  }

  // optional uint32 TimeLeft = 30;
  if (has_timeleft()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(30, this->timeleft(), output);
  }

  // optional uint32 Area = 31;
  if (has_area()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(31, this->area(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSycPlayerInfoResp)
}

int CSSycPlayerInfoResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 PlayerTitle = 1;
    if (has_playertitle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->playertitle());
    }

    // required uint32 Energy = 2;
    if (has_energy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->energy());
    }

    // optional string Name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional uint32 ChangeNameCount = 4;
    if (has_changenamecount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->changenamecount());
    }

    // optional uint32 EnergyBuyCount = 5;
    if (has_energybuycount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->energybuycount());
    }

    // optional uint32 Diamond = 6;
    if (has_diamond()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->diamond());
    }

    // optional string IconId = 7;
    if (has_iconid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->iconid());
    }

    // optional uint32 EnergySlot = 8;
    if (has_energyslot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->energyslot());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 Power = 9;
    if (has_power()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->power());
    }

    // optional uint32 PowerSlot = 10;
    if (has_powerslot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->powerslot());
    }

    // optional uint32 MonthCardDays = 12;
    if (has_monthcarddays()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->monthcarddays());
    }

    // optional uint32 ShopGuide = 13;
    if (has_shopguide()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shopguide());
    }

    // optional uint32 RoomTicket = 15;
    if (has_roomticket()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomticket());
    }

    // optional uint32 VipLevel = 16;
    if (has_viplevel()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->viplevel());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional string RemainTime = 17;
    if (has_remaintime()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->remaintime());
    }

    // optional uint32 ExpLevel = 18;
    if (has_explevel()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->explevel());
    }

    // optional uint32 Exp = 19;
    if (has_exp()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->exp());
    }

    // optional uint32 Rank = 21;
    if (has_rank()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank());
    }

    // optional float WinRate = 22;
    if (has_winrate()) {
      total_size += 2 + 4;
    }

    // optional uint32 Score = 23;
    if (has_score()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->score());
    }

    // optional uint32 AchievementLevel = 24;
    if (has_achievementlevel()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->achievementlevel());
    }

  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional uint32 HonorCount = 25;
    if (has_honorcount()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->honorcount());
    }

    // optional uint32 PvpRound = 26;
    if (has_pvpround()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pvpround());
    }

    // optional uint32 AddExp = 27;
    if (has_addexp()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->addexp());
    }

    // optional uint32 GlyphGuide = 28;
    if (has_glyphguide()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->glyphguide());
    }

    // optional uint32 ChatFreeCount = 29;
    if (has_chatfreecount()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chatfreecount());
    }

    // optional uint32 TimeLeft = 30;
    if (has_timeleft()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->timeleft());
    }

    // optional uint32 Area = 31;
    if (has_area()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->area());
    }

  }
  // repeated .fgame.CSItem Items = 11;
  total_size += 1 * this->items_size();
  for (int i = 0; i < this->items_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->items(i));
  }

  // repeated uint32 TitleList = 14;
  {
    int data_size = 0;
    for (int i = 0; i < this->titlelist_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->titlelist(i));
    }
    total_size += 1 * this->titlelist_size() + data_size;
  }

  // repeated .fgame.CSTitleItem TitleItems = 20;
  total_size += 2 * this->titleitems_size();
  for (int i = 0; i < this->titleitems_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->titleitems(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSycPlayerInfoResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSycPlayerInfoResp*>(&from));
}

void CSSycPlayerInfoResp::MergeFrom(const CSSycPlayerInfoResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  items_.MergeFrom(from.items_);
  titlelist_.MergeFrom(from.titlelist_);
  titleitems_.MergeFrom(from.titleitems_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_playertitle()) {
      set_playertitle(from.playertitle());
    }
    if (from.has_energy()) {
      set_energy(from.energy());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_changenamecount()) {
      set_changenamecount(from.changenamecount());
    }
    if (from.has_energybuycount()) {
      set_energybuycount(from.energybuycount());
    }
    if (from.has_diamond()) {
      set_diamond(from.diamond());
    }
    if (from.has_iconid()) {
      set_iconid(from.iconid());
    }
    if (from.has_energyslot()) {
      set_energyslot(from.energyslot());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_power()) {
      set_power(from.power());
    }
    if (from.has_powerslot()) {
      set_powerslot(from.powerslot());
    }
    if (from.has_monthcarddays()) {
      set_monthcarddays(from.monthcarddays());
    }
    if (from.has_shopguide()) {
      set_shopguide(from.shopguide());
    }
    if (from.has_roomticket()) {
      set_roomticket(from.roomticket());
    }
    if (from.has_viplevel()) {
      set_viplevel(from.viplevel());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_remaintime()) {
      set_remaintime(from.remaintime());
    }
    if (from.has_explevel()) {
      set_explevel(from.explevel());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
    if (from.has_rank()) {
      set_rank(from.rank());
    }
    if (from.has_winrate()) {
      set_winrate(from.winrate());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
    if (from.has_achievementlevel()) {
      set_achievementlevel(from.achievementlevel());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_honorcount()) {
      set_honorcount(from.honorcount());
    }
    if (from.has_pvpround()) {
      set_pvpround(from.pvpround());
    }
    if (from.has_addexp()) {
      set_addexp(from.addexp());
    }
    if (from.has_glyphguide()) {
      set_glyphguide(from.glyphguide());
    }
    if (from.has_chatfreecount()) {
      set_chatfreecount(from.chatfreecount());
    }
    if (from.has_timeleft()) {
      set_timeleft(from.timeleft());
    }
    if (from.has_area()) {
      set_area(from.area());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSycPlayerInfoResp::CopyFrom(const CSSycPlayerInfoResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSycPlayerInfoResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->items())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->titleitems())) return false;
  return true;
}

void CSSycPlayerInfoResp::Swap(CSSycPlayerInfoResp* other) {
  if (other != this) {
    std::swap(playertitle_, other->playertitle_);
    std::swap(energy_, other->energy_);
    std::swap(name_, other->name_);
    std::swap(changenamecount_, other->changenamecount_);
    std::swap(energybuycount_, other->energybuycount_);
    std::swap(diamond_, other->diamond_);
    std::swap(iconid_, other->iconid_);
    std::swap(energyslot_, other->energyslot_);
    std::swap(power_, other->power_);
    std::swap(powerslot_, other->powerslot_);
    items_.Swap(&other->items_);
    std::swap(monthcarddays_, other->monthcarddays_);
    std::swap(shopguide_, other->shopguide_);
    titlelist_.Swap(&other->titlelist_);
    std::swap(roomticket_, other->roomticket_);
    std::swap(viplevel_, other->viplevel_);
    std::swap(remaintime_, other->remaintime_);
    std::swap(explevel_, other->explevel_);
    std::swap(exp_, other->exp_);
    titleitems_.Swap(&other->titleitems_);
    std::swap(rank_, other->rank_);
    std::swap(winrate_, other->winrate_);
    std::swap(score_, other->score_);
    std::swap(achievementlevel_, other->achievementlevel_);
    std::swap(honorcount_, other->honorcount_);
    std::swap(pvpround_, other->pvpround_);
    std::swap(addexp_, other->addexp_);
    std::swap(glyphguide_, other->glyphguide_);
    std::swap(chatfreecount_, other->chatfreecount_);
    std::swap(timeleft_, other->timeleft_);
    std::swap(area_, other->area_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSycPlayerInfoResp::GetTypeName() const {
  return "fgame.CSSycPlayerInfoResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSyncPlayerDataReq::kPlayerDataFieldNumber;
#endif  // !_MSC_VER

CSSyncPlayerDataReq::CSSyncPlayerDataReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSyncPlayerDataReq)
}

void CSSyncPlayerDataReq::InitAsDefaultInstance() {
}

CSSyncPlayerDataReq::CSSyncPlayerDataReq(const CSSyncPlayerDataReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSyncPlayerDataReq)
}

void CSSyncPlayerDataReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  playerdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSyncPlayerDataReq::~CSSyncPlayerDataReq() {
  // @@protoc_insertion_point(destructor:fgame.CSSyncPlayerDataReq)
  SharedDtor();
}

void CSSyncPlayerDataReq::SharedDtor() {
  if (playerdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete playerdata_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSyncPlayerDataReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSyncPlayerDataReq& CSSyncPlayerDataReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSyncPlayerDataReq* CSSyncPlayerDataReq::default_instance_ = NULL;

CSSyncPlayerDataReq* CSSyncPlayerDataReq::New() const {
  return new CSSyncPlayerDataReq;
}

void CSSyncPlayerDataReq::Clear() {
  if (has_playerdata()) {
    if (playerdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      playerdata_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSyncPlayerDataReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSyncPlayerDataReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string PlayerData = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_playerdata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSyncPlayerDataReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSyncPlayerDataReq)
  return false;
#undef DO_
}

void CSSyncPlayerDataReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSyncPlayerDataReq)
  // required string PlayerData = 1;
  if (has_playerdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->playerdata(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSyncPlayerDataReq)
}

int CSSyncPlayerDataReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string PlayerData = 1;
    if (has_playerdata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->playerdata());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSyncPlayerDataReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSyncPlayerDataReq*>(&from));
}

void CSSyncPlayerDataReq::MergeFrom(const CSSyncPlayerDataReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_playerdata()) {
      set_playerdata(from.playerdata());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSyncPlayerDataReq::CopyFrom(const CSSyncPlayerDataReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSyncPlayerDataReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSSyncPlayerDataReq::Swap(CSSyncPlayerDataReq* other) {
  if (other != this) {
    std::swap(playerdata_, other->playerdata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSyncPlayerDataReq::GetTypeName() const {
  return "fgame.CSSyncPlayerDataReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSyncPlayerDataResp::kRetFieldNumber;
#endif  // !_MSC_VER

CSSyncPlayerDataResp::CSSyncPlayerDataResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSyncPlayerDataResp)
}

void CSSyncPlayerDataResp::InitAsDefaultInstance() {
}

CSSyncPlayerDataResp::CSSyncPlayerDataResp(const CSSyncPlayerDataResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSyncPlayerDataResp)
}

void CSSyncPlayerDataResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSyncPlayerDataResp::~CSSyncPlayerDataResp() {
  // @@protoc_insertion_point(destructor:fgame.CSSyncPlayerDataResp)
  SharedDtor();
}

void CSSyncPlayerDataResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSyncPlayerDataResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSyncPlayerDataResp& CSSyncPlayerDataResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSyncPlayerDataResp* CSSyncPlayerDataResp::default_instance_ = NULL;

CSSyncPlayerDataResp* CSSyncPlayerDataResp::New() const {
  return new CSSyncPlayerDataResp;
}

void CSSyncPlayerDataResp::Clear() {
  ret_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSyncPlayerDataResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSyncPlayerDataResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSyncPlayerDataResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSyncPlayerDataResp)
  return false;
#undef DO_
}

void CSSyncPlayerDataResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSyncPlayerDataResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSyncPlayerDataResp)
}

int CSSyncPlayerDataResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSyncPlayerDataResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSyncPlayerDataResp*>(&from));
}

void CSSyncPlayerDataResp::MergeFrom(const CSSyncPlayerDataResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSyncPlayerDataResp::CopyFrom(const CSSyncPlayerDataResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSyncPlayerDataResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSSyncPlayerDataResp::Swap(CSSyncPlayerDataResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSyncPlayerDataResp::GetTypeName() const {
  return "fgame.CSSyncPlayerDataResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSGetPlayerDataReq::CSGetPlayerDataReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetPlayerDataReq)
}

void CSGetPlayerDataReq::InitAsDefaultInstance() {
}

CSGetPlayerDataReq::CSGetPlayerDataReq(const CSGetPlayerDataReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetPlayerDataReq)
}

void CSGetPlayerDataReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetPlayerDataReq::~CSGetPlayerDataReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGetPlayerDataReq)
  SharedDtor();
}

void CSGetPlayerDataReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetPlayerDataReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetPlayerDataReq& CSGetPlayerDataReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetPlayerDataReq* CSGetPlayerDataReq::default_instance_ = NULL;

CSGetPlayerDataReq* CSGetPlayerDataReq::New() const {
  return new CSGetPlayerDataReq;
}

void CSGetPlayerDataReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetPlayerDataReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetPlayerDataReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetPlayerDataReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetPlayerDataReq)
  return false;
#undef DO_
}

void CSGetPlayerDataReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetPlayerDataReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetPlayerDataReq)
}

int CSGetPlayerDataReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetPlayerDataReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetPlayerDataReq*>(&from));
}

void CSGetPlayerDataReq::MergeFrom(const CSGetPlayerDataReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetPlayerDataReq::CopyFrom(const CSGetPlayerDataReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetPlayerDataReq::IsInitialized() const {

  return true;
}

void CSGetPlayerDataReq::Swap(CSGetPlayerDataReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetPlayerDataReq::GetTypeName() const {
  return "fgame.CSGetPlayerDataReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGetPlayerDataResp::kRetFieldNumber;
const int CSGetPlayerDataResp::kPlayerDataFieldNumber;
#endif  // !_MSC_VER

CSGetPlayerDataResp::CSGetPlayerDataResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetPlayerDataResp)
}

void CSGetPlayerDataResp::InitAsDefaultInstance() {
}

CSGetPlayerDataResp::CSGetPlayerDataResp(const CSGetPlayerDataResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetPlayerDataResp)
}

void CSGetPlayerDataResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ret_ = 0u;
  playerdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetPlayerDataResp::~CSGetPlayerDataResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGetPlayerDataResp)
  SharedDtor();
}

void CSGetPlayerDataResp::SharedDtor() {
  if (playerdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete playerdata_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetPlayerDataResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetPlayerDataResp& CSGetPlayerDataResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetPlayerDataResp* CSGetPlayerDataResp::default_instance_ = NULL;

CSGetPlayerDataResp* CSGetPlayerDataResp::New() const {
  return new CSGetPlayerDataResp;
}

void CSGetPlayerDataResp::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    ret_ = 0u;
    if (has_playerdata()) {
      if (playerdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        playerdata_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetPlayerDataResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetPlayerDataResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_PlayerData;
        break;
      }

      // required string PlayerData = 2;
      case 2: {
        if (tag == 18) {
         parse_PlayerData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_playerdata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetPlayerDataResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetPlayerDataResp)
  return false;
#undef DO_
}

void CSGetPlayerDataResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetPlayerDataResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // required string PlayerData = 2;
  if (has_playerdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->playerdata(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetPlayerDataResp)
}

int CSGetPlayerDataResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // required string PlayerData = 2;
    if (has_playerdata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->playerdata());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetPlayerDataResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetPlayerDataResp*>(&from));
}

void CSGetPlayerDataResp::MergeFrom(const CSGetPlayerDataResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_playerdata()) {
      set_playerdata(from.playerdata());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetPlayerDataResp::CopyFrom(const CSGetPlayerDataResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetPlayerDataResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSGetPlayerDataResp::Swap(CSGetPlayerDataResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(playerdata_, other->playerdata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetPlayerDataResp::GetTypeName() const {
  return "fgame.CSGetPlayerDataResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSNoticeReq::kNoticeTypeFieldNumber;
const int CSNoticeReq::kSeriousFieldNumber;
const int CSNoticeReq::kContentFieldNumber;
const int CSNoticeReq::kTitleFieldNumber;
const int CSNoticeReq::kCountFieldNumber;
const int CSNoticeReq::kTimeGapFieldNumber;
#endif  // !_MSC_VER

CSNoticeReq::CSNoticeReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSNoticeReq)
}

void CSNoticeReq::InitAsDefaultInstance() {
}

CSNoticeReq::CSNoticeReq(const CSNoticeReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSNoticeReq)
}

void CSNoticeReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  noticetype_ = 0u;
  serious_ = 0u;
  content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  count_ = 0u;
  timegap_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSNoticeReq::~CSNoticeReq() {
  // @@protoc_insertion_point(destructor:fgame.CSNoticeReq)
  SharedDtor();
}

void CSNoticeReq::SharedDtor() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSNoticeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSNoticeReq& CSNoticeReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSNoticeReq* CSNoticeReq::default_instance_ = NULL;

CSNoticeReq* CSNoticeReq::New() const {
  return new CSNoticeReq;
}

void CSNoticeReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSNoticeReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(noticetype_, serious_);
    ZR_(count_, timegap_);
    if (has_content()) {
      if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        content_->clear();
      }
    }
    if (has_title()) {
      if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        title_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSNoticeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSNoticeReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 NoticeType = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &noticetype_)));
          set_has_noticetype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Serious;
        break;
      }

      // required uint32 Serious = 2;
      case 2: {
        if (tag == 16) {
         parse_Serious:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serious_)));
          set_has_serious();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_Content;
        break;
      }

      // required string Content = 3;
      case 3: {
        if (tag == 26) {
         parse_Content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_content()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_Title;
        break;
      }

      // optional string Title = 4;
      case 4: {
        if (tag == 34) {
         parse_Title:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_title()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_Count;
        break;
      }

      // optional uint32 Count = 5;
      case 5: {
        if (tag == 40) {
         parse_Count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_TimeGap;
        break;
      }

      // optional uint32 TimeGap = 6;
      case 6: {
        if (tag == 48) {
         parse_TimeGap:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timegap_)));
          set_has_timegap();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSNoticeReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSNoticeReq)
  return false;
#undef DO_
}

void CSNoticeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSNoticeReq)
  // required uint32 NoticeType = 1;
  if (has_noticetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->noticetype(), output);
  }

  // required uint32 Serious = 2;
  if (has_serious()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->serious(), output);
  }

  // required string Content = 3;
  if (has_content()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->content(), output);
  }

  // optional string Title = 4;
  if (has_title()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->title(), output);
  }

  // optional uint32 Count = 5;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->count(), output);
  }

  // optional uint32 TimeGap = 6;
  if (has_timegap()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->timegap(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSNoticeReq)
}

int CSNoticeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 NoticeType = 1;
    if (has_noticetype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->noticetype());
    }

    // required uint32 Serious = 2;
    if (has_serious()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serious());
    }

    // required string Content = 3;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->content());
    }

    // optional string Title = 4;
    if (has_title()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->title());
    }

    // optional uint32 Count = 5;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

    // optional uint32 TimeGap = 6;
    if (has_timegap()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->timegap());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSNoticeReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSNoticeReq*>(&from));
}

void CSNoticeReq::MergeFrom(const CSNoticeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_noticetype()) {
      set_noticetype(from.noticetype());
    }
    if (from.has_serious()) {
      set_serious(from.serious());
    }
    if (from.has_content()) {
      set_content(from.content());
    }
    if (from.has_title()) {
      set_title(from.title());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_timegap()) {
      set_timegap(from.timegap());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSNoticeReq::CopyFrom(const CSNoticeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSNoticeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSNoticeReq::Swap(CSNoticeReq* other) {
  if (other != this) {
    std::swap(noticetype_, other->noticetype_);
    std::swap(serious_, other->serious_);
    std::swap(content_, other->content_);
    std::swap(title_, other->title_);
    std::swap(count_, other->count_);
    std::swap(timegap_, other->timegap_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSNoticeReq::GetTypeName() const {
  return "fgame.CSNoticeReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSChangeNameReq::kNameFieldNumber;
const int CSChangeNameReq::kAreaFieldNumber;
#endif  // !_MSC_VER

CSChangeNameReq::CSChangeNameReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSChangeNameReq)
}

void CSChangeNameReq::InitAsDefaultInstance() {
}

CSChangeNameReq::CSChangeNameReq(const CSChangeNameReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSChangeNameReq)
}

void CSChangeNameReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  area_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSChangeNameReq::~CSChangeNameReq() {
  // @@protoc_insertion_point(destructor:fgame.CSChangeNameReq)
  SharedDtor();
}

void CSChangeNameReq::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSChangeNameReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSChangeNameReq& CSChangeNameReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSChangeNameReq* CSChangeNameReq::default_instance_ = NULL;

CSChangeNameReq* CSChangeNameReq::New() const {
  return new CSChangeNameReq;
}

void CSChangeNameReq::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    area_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSChangeNameReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSChangeNameReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string Name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Area;
        break;
      }

      // optional uint32 Area = 2;
      case 2: {
        if (tag == 16) {
         parse_Area:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &area_)));
          set_has_area();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSChangeNameReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSChangeNameReq)
  return false;
#undef DO_
}

void CSChangeNameReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSChangeNameReq)
  // optional string Name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional uint32 Area = 2;
  if (has_area()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->area(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSChangeNameReq)
}

int CSChangeNameReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string Name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional uint32 Area = 2;
    if (has_area()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->area());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSChangeNameReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSChangeNameReq*>(&from));
}

void CSChangeNameReq::MergeFrom(const CSChangeNameReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_area()) {
      set_area(from.area());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSChangeNameReq::CopyFrom(const CSChangeNameReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSChangeNameReq::IsInitialized() const {

  return true;
}

void CSChangeNameReq::Swap(CSChangeNameReq* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(area_, other->area_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSChangeNameReq::GetTypeName() const {
  return "fgame.CSChangeNameReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSChangeNameResp::kRetFieldNumber;
#endif  // !_MSC_VER

CSChangeNameResp::CSChangeNameResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSChangeNameResp)
}

void CSChangeNameResp::InitAsDefaultInstance() {
}

CSChangeNameResp::CSChangeNameResp(const CSChangeNameResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSChangeNameResp)
}

void CSChangeNameResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSChangeNameResp::~CSChangeNameResp() {
  // @@protoc_insertion_point(destructor:fgame.CSChangeNameResp)
  SharedDtor();
}

void CSChangeNameResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSChangeNameResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSChangeNameResp& CSChangeNameResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSChangeNameResp* CSChangeNameResp::default_instance_ = NULL;

CSChangeNameResp* CSChangeNameResp::New() const {
  return new CSChangeNameResp;
}

void CSChangeNameResp::Clear() {
  ret_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSChangeNameResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSChangeNameResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSChangeNameResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSChangeNameResp)
  return false;
#undef DO_
}

void CSChangeNameResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSChangeNameResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSChangeNameResp)
}

int CSChangeNameResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSChangeNameResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSChangeNameResp*>(&from));
}

void CSChangeNameResp::MergeFrom(const CSChangeNameResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSChangeNameResp::CopyFrom(const CSChangeNameResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSChangeNameResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSChangeNameResp::Swap(CSChangeNameResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSChangeNameResp::GetTypeName() const {
  return "fgame.CSChangeNameResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGMCmdReq::kGMTypeFieldNumber;
const int CSGMCmdReq::kValueFieldNumber;
#endif  // !_MSC_VER

CSGMCmdReq::CSGMCmdReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGMCmdReq)
}

void CSGMCmdReq::InitAsDefaultInstance() {
}

CSGMCmdReq::CSGMCmdReq(const CSGMCmdReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGMCmdReq)
}

void CSGMCmdReq::SharedCtor() {
  _cached_size_ = 0;
  gmtype_ = 0u;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGMCmdReq::~CSGMCmdReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGMCmdReq)
  SharedDtor();
}

void CSGMCmdReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGMCmdReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGMCmdReq& CSGMCmdReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGMCmdReq* CSGMCmdReq::default_instance_ = NULL;

CSGMCmdReq* CSGMCmdReq::New() const {
  return new CSGMCmdReq;
}

void CSGMCmdReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSGMCmdReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(gmtype_, value_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGMCmdReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGMCmdReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 GMType = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gmtype_)));
          set_has_gmtype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Value;
        break;
      }

      // optional uint32 Value = 2;
      case 2: {
        if (tag == 16) {
         parse_Value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGMCmdReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGMCmdReq)
  return false;
#undef DO_
}

void CSGMCmdReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGMCmdReq)
  // required uint32 GMType = 1;
  if (has_gmtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->gmtype(), output);
  }

  // optional uint32 Value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->value(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGMCmdReq)
}

int CSGMCmdReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 GMType = 1;
    if (has_gmtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gmtype());
    }

    // optional uint32 Value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGMCmdReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGMCmdReq*>(&from));
}

void CSGMCmdReq::MergeFrom(const CSGMCmdReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gmtype()) {
      set_gmtype(from.gmtype());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGMCmdReq::CopyFrom(const CSGMCmdReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGMCmdReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSGMCmdReq::Swap(CSGMCmdReq* other) {
  if (other != this) {
    std::swap(gmtype_, other->gmtype_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGMCmdReq::GetTypeName() const {
  return "fgame.CSGMCmdReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSXinShouRecodeReq::kIdFieldNumber;
#endif  // !_MSC_VER

CSXinShouRecodeReq::CSXinShouRecodeReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSXinShouRecodeReq)
}

void CSXinShouRecodeReq::InitAsDefaultInstance() {
}

CSXinShouRecodeReq::CSXinShouRecodeReq(const CSXinShouRecodeReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSXinShouRecodeReq)
}

void CSXinShouRecodeReq::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSXinShouRecodeReq::~CSXinShouRecodeReq() {
  // @@protoc_insertion_point(destructor:fgame.CSXinShouRecodeReq)
  SharedDtor();
}

void CSXinShouRecodeReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSXinShouRecodeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSXinShouRecodeReq& CSXinShouRecodeReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSXinShouRecodeReq* CSXinShouRecodeReq::default_instance_ = NULL;

CSXinShouRecodeReq* CSXinShouRecodeReq::New() const {
  return new CSXinShouRecodeReq;
}

void CSXinShouRecodeReq::Clear() {
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSXinShouRecodeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSXinShouRecodeReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSXinShouRecodeReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSXinShouRecodeReq)
  return false;
#undef DO_
}

void CSXinShouRecodeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSXinShouRecodeReq)
  // required uint32 Id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSXinShouRecodeReq)
}

int CSXinShouRecodeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSXinShouRecodeReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSXinShouRecodeReq*>(&from));
}

void CSXinShouRecodeReq::MergeFrom(const CSXinShouRecodeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSXinShouRecodeReq::CopyFrom(const CSXinShouRecodeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSXinShouRecodeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSXinShouRecodeReq::Swap(CSXinShouRecodeReq* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSXinShouRecodeReq::GetTypeName() const {
  return "fgame.CSXinShouRecodeReq";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSXinShouRecodeResp::CSXinShouRecodeResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSXinShouRecodeResp)
}

void CSXinShouRecodeResp::InitAsDefaultInstance() {
}

CSXinShouRecodeResp::CSXinShouRecodeResp(const CSXinShouRecodeResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSXinShouRecodeResp)
}

void CSXinShouRecodeResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSXinShouRecodeResp::~CSXinShouRecodeResp() {
  // @@protoc_insertion_point(destructor:fgame.CSXinShouRecodeResp)
  SharedDtor();
}

void CSXinShouRecodeResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSXinShouRecodeResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSXinShouRecodeResp& CSXinShouRecodeResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSXinShouRecodeResp* CSXinShouRecodeResp::default_instance_ = NULL;

CSXinShouRecodeResp* CSXinShouRecodeResp::New() const {
  return new CSXinShouRecodeResp;
}

void CSXinShouRecodeResp::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSXinShouRecodeResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSXinShouRecodeResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSXinShouRecodeResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSXinShouRecodeResp)
  return false;
#undef DO_
}

void CSXinShouRecodeResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSXinShouRecodeResp)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSXinShouRecodeResp)
}

int CSXinShouRecodeResp::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSXinShouRecodeResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSXinShouRecodeResp*>(&from));
}

void CSXinShouRecodeResp::MergeFrom(const CSXinShouRecodeResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSXinShouRecodeResp::CopyFrom(const CSXinShouRecodeResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSXinShouRecodeResp::IsInitialized() const {

  return true;
}

void CSXinShouRecodeResp::Swap(CSXinShouRecodeResp* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSXinShouRecodeResp::GetTypeName() const {
  return "fgame.CSXinShouRecodeResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSMission::kMissionIdFieldNumber;
const int CSMission::kValueFieldNumber;
const int CSMission::kCompletedFieldNumber;
const int CSMission::kRequestFieldNumber;
const int CSMission::kGiftIdFieldNumber;
#endif  // !_MSC_VER

CSMission::CSMission()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSMission)
}

void CSMission::InitAsDefaultInstance() {
}

CSMission::CSMission(const CSMission& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSMission)
}

void CSMission::SharedCtor() {
  _cached_size_ = 0;
  missionid_ = 0u;
  value_ = 0u;
  completed_ = false;
  request_ = 0u;
  giftid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSMission::~CSMission() {
  // @@protoc_insertion_point(destructor:fgame.CSMission)
  SharedDtor();
}

void CSMission::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSMission::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSMission& CSMission::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSMission* CSMission::default_instance_ = NULL;

CSMission* CSMission::New() const {
  return new CSMission;
}

void CSMission::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSMission*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(missionid_, giftid_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSMission::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSMission)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 MissionId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &missionid_)));
          set_has_missionid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Value;
        break;
      }

      // optional uint32 Value = 2;
      case 2: {
        if (tag == 16) {
         parse_Value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Completed;
        break;
      }

      // optional bool Completed = 3;
      case 3: {
        if (tag == 24) {
         parse_Completed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &completed_)));
          set_has_completed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Request;
        break;
      }

      // optional uint32 Request = 4;
      case 4: {
        if (tag == 32) {
         parse_Request:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &request_)));
          set_has_request();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_GiftId;
        break;
      }

      // optional uint32 GiftId = 5;
      case 5: {
        if (tag == 40) {
         parse_GiftId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &giftid_)));
          set_has_giftid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSMission)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSMission)
  return false;
#undef DO_
}

void CSMission::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSMission)
  // required uint32 MissionId = 1;
  if (has_missionid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->missionid(), output);
  }

  // optional uint32 Value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->value(), output);
  }

  // optional bool Completed = 3;
  if (has_completed()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->completed(), output);
  }

  // optional uint32 Request = 4;
  if (has_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->request(), output);
  }

  // optional uint32 GiftId = 5;
  if (has_giftid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->giftid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSMission)
}

int CSMission::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 MissionId = 1;
    if (has_missionid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->missionid());
    }

    // optional uint32 Value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

    // optional bool Completed = 3;
    if (has_completed()) {
      total_size += 1 + 1;
    }

    // optional uint32 Request = 4;
    if (has_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->request());
    }

    // optional uint32 GiftId = 5;
    if (has_giftid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->giftid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSMission::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSMission*>(&from));
}

void CSMission::MergeFrom(const CSMission& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_missionid()) {
      set_missionid(from.missionid());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_completed()) {
      set_completed(from.completed());
    }
    if (from.has_request()) {
      set_request(from.request());
    }
    if (from.has_giftid()) {
      set_giftid(from.giftid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSMission::CopyFrom(const CSMission& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSMission::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSMission::Swap(CSMission* other) {
  if (other != this) {
    std::swap(missionid_, other->missionid_);
    std::swap(value_, other->value_);
    std::swap(completed_, other->completed_);
    std::swap(request_, other->request_);
    std::swap(giftid_, other->giftid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSMission::GetTypeName() const {
  return "fgame.CSMission";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSMissionListReq::CSMissionListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSMissionListReq)
}

void CSMissionListReq::InitAsDefaultInstance() {
}

CSMissionListReq::CSMissionListReq(const CSMissionListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSMissionListReq)
}

void CSMissionListReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSMissionListReq::~CSMissionListReq() {
  // @@protoc_insertion_point(destructor:fgame.CSMissionListReq)
  SharedDtor();
}

void CSMissionListReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSMissionListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSMissionListReq& CSMissionListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSMissionListReq* CSMissionListReq::default_instance_ = NULL;

CSMissionListReq* CSMissionListReq::New() const {
  return new CSMissionListReq;
}

void CSMissionListReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSMissionListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSMissionListReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSMissionListReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSMissionListReq)
  return false;
#undef DO_
}

void CSMissionListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSMissionListReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSMissionListReq)
}

int CSMissionListReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSMissionListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSMissionListReq*>(&from));
}

void CSMissionListReq::MergeFrom(const CSMissionListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSMissionListReq::CopyFrom(const CSMissionListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSMissionListReq::IsInitialized() const {

  return true;
}

void CSMissionListReq::Swap(CSMissionListReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSMissionListReq::GetTypeName() const {
  return "fgame.CSMissionListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSMissionListResp::kMissionDayFieldNumber;
const int CSMissionListResp::kMissionsFieldNumber;
#endif  // !_MSC_VER

CSMissionListResp::CSMissionListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSMissionListResp)
}

void CSMissionListResp::InitAsDefaultInstance() {
}

CSMissionListResp::CSMissionListResp(const CSMissionListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSMissionListResp)
}

void CSMissionListResp::SharedCtor() {
  _cached_size_ = 0;
  missionday_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSMissionListResp::~CSMissionListResp() {
  // @@protoc_insertion_point(destructor:fgame.CSMissionListResp)
  SharedDtor();
}

void CSMissionListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSMissionListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSMissionListResp& CSMissionListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSMissionListResp* CSMissionListResp::default_instance_ = NULL;

CSMissionListResp* CSMissionListResp::New() const {
  return new CSMissionListResp;
}

void CSMissionListResp::Clear() {
  missionday_ = 0u;
  missions_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSMissionListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSMissionListResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 MissionDay = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &missionday_)));
          set_has_missionday();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Missions;
        break;
      }

      // repeated .fgame.CSMission Missions = 2;
      case 2: {
        if (tag == 18) {
         parse_Missions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_missions()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Missions;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSMissionListResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSMissionListResp)
  return false;
#undef DO_
}

void CSMissionListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSMissionListResp)
  // optional uint32 MissionDay = 1;
  if (has_missionday()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->missionday(), output);
  }

  // repeated .fgame.CSMission Missions = 2;
  for (int i = 0; i < this->missions_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->missions(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSMissionListResp)
}

int CSMissionListResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 MissionDay = 1;
    if (has_missionday()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->missionday());
    }

  }
  // repeated .fgame.CSMission Missions = 2;
  total_size += 1 * this->missions_size();
  for (int i = 0; i < this->missions_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->missions(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSMissionListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSMissionListResp*>(&from));
}

void CSMissionListResp::MergeFrom(const CSMissionListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  missions_.MergeFrom(from.missions_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_missionday()) {
      set_missionday(from.missionday());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSMissionListResp::CopyFrom(const CSMissionListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSMissionListResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->missions())) return false;
  return true;
}

void CSMissionListResp::Swap(CSMissionListResp* other) {
  if (other != this) {
    std::swap(missionday_, other->missionday_);
    missions_.Swap(&other->missions_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSMissionListResp::GetTypeName() const {
  return "fgame.CSMissionListResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSMissionCompleteReq::kMissionIdFieldNumber;
#endif  // !_MSC_VER

CSMissionCompleteReq::CSMissionCompleteReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSMissionCompleteReq)
}

void CSMissionCompleteReq::InitAsDefaultInstance() {
}

CSMissionCompleteReq::CSMissionCompleteReq(const CSMissionCompleteReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSMissionCompleteReq)
}

void CSMissionCompleteReq::SharedCtor() {
  _cached_size_ = 0;
  missionid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSMissionCompleteReq::~CSMissionCompleteReq() {
  // @@protoc_insertion_point(destructor:fgame.CSMissionCompleteReq)
  SharedDtor();
}

void CSMissionCompleteReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSMissionCompleteReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSMissionCompleteReq& CSMissionCompleteReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSMissionCompleteReq* CSMissionCompleteReq::default_instance_ = NULL;

CSMissionCompleteReq* CSMissionCompleteReq::New() const {
  return new CSMissionCompleteReq;
}

void CSMissionCompleteReq::Clear() {
  missionid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSMissionCompleteReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSMissionCompleteReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 MissionId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &missionid_)));
          set_has_missionid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSMissionCompleteReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSMissionCompleteReq)
  return false;
#undef DO_
}

void CSMissionCompleteReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSMissionCompleteReq)
  // required uint32 MissionId = 1;
  if (has_missionid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->missionid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSMissionCompleteReq)
}

int CSMissionCompleteReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 MissionId = 1;
    if (has_missionid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->missionid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSMissionCompleteReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSMissionCompleteReq*>(&from));
}

void CSMissionCompleteReq::MergeFrom(const CSMissionCompleteReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_missionid()) {
      set_missionid(from.missionid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSMissionCompleteReq::CopyFrom(const CSMissionCompleteReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSMissionCompleteReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSMissionCompleteReq::Swap(CSMissionCompleteReq* other) {
  if (other != this) {
    std::swap(missionid_, other->missionid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSMissionCompleteReq::GetTypeName() const {
  return "fgame.CSMissionCompleteReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSMissionCompleteResp::kMissionFieldNumber;
#endif  // !_MSC_VER

CSMissionCompleteResp::CSMissionCompleteResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSMissionCompleteResp)
}

void CSMissionCompleteResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  mission_ = const_cast< ::fgame::CSMission*>(
      ::fgame::CSMission::internal_default_instance());
#else
  mission_ = const_cast< ::fgame::CSMission*>(&::fgame::CSMission::default_instance());
#endif
}

CSMissionCompleteResp::CSMissionCompleteResp(const CSMissionCompleteResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSMissionCompleteResp)
}

void CSMissionCompleteResp::SharedCtor() {
  _cached_size_ = 0;
  mission_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSMissionCompleteResp::~CSMissionCompleteResp() {
  // @@protoc_insertion_point(destructor:fgame.CSMissionCompleteResp)
  SharedDtor();
}

void CSMissionCompleteResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete mission_;
  }
}

void CSMissionCompleteResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSMissionCompleteResp& CSMissionCompleteResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSMissionCompleteResp* CSMissionCompleteResp::default_instance_ = NULL;

CSMissionCompleteResp* CSMissionCompleteResp::New() const {
  return new CSMissionCompleteResp;
}

void CSMissionCompleteResp::Clear() {
  if (has_mission()) {
    if (mission_ != NULL) mission_->::fgame::CSMission::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSMissionCompleteResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSMissionCompleteResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .fgame.CSMission Mission = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mission()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSMissionCompleteResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSMissionCompleteResp)
  return false;
#undef DO_
}

void CSMissionCompleteResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSMissionCompleteResp)
  // required .fgame.CSMission Mission = 1;
  if (has_mission()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->mission(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSMissionCompleteResp)
}

int CSMissionCompleteResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .fgame.CSMission Mission = 1;
    if (has_mission()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mission());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSMissionCompleteResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSMissionCompleteResp*>(&from));
}

void CSMissionCompleteResp::MergeFrom(const CSMissionCompleteResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mission()) {
      mutable_mission()->::fgame::CSMission::MergeFrom(from.mission());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSMissionCompleteResp::CopyFrom(const CSMissionCompleteResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSMissionCompleteResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_mission()) {
    if (!this->mission().IsInitialized()) return false;
  }
  return true;
}

void CSMissionCompleteResp::Swap(CSMissionCompleteResp* other) {
  if (other != this) {
    std::swap(mission_, other->mission_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSMissionCompleteResp::GetTypeName() const {
  return "fgame.CSMissionCompleteResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSMissionUpdateResp::kMissionIdFieldNumber;
const int CSMissionUpdateResp::kValueFieldNumber;
#endif  // !_MSC_VER

CSMissionUpdateResp::CSMissionUpdateResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSMissionUpdateResp)
}

void CSMissionUpdateResp::InitAsDefaultInstance() {
}

CSMissionUpdateResp::CSMissionUpdateResp(const CSMissionUpdateResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSMissionUpdateResp)
}

void CSMissionUpdateResp::SharedCtor() {
  _cached_size_ = 0;
  missionid_ = 0u;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSMissionUpdateResp::~CSMissionUpdateResp() {
  // @@protoc_insertion_point(destructor:fgame.CSMissionUpdateResp)
  SharedDtor();
}

void CSMissionUpdateResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSMissionUpdateResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSMissionUpdateResp& CSMissionUpdateResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSMissionUpdateResp* CSMissionUpdateResp::default_instance_ = NULL;

CSMissionUpdateResp* CSMissionUpdateResp::New() const {
  return new CSMissionUpdateResp;
}

void CSMissionUpdateResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSMissionUpdateResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(missionid_, value_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSMissionUpdateResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSMissionUpdateResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 MissionId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &missionid_)));
          set_has_missionid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Value;
        break;
      }

      // required uint32 Value = 2;
      case 2: {
        if (tag == 16) {
         parse_Value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSMissionUpdateResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSMissionUpdateResp)
  return false;
#undef DO_
}

void CSMissionUpdateResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSMissionUpdateResp)
  // required uint32 MissionId = 1;
  if (has_missionid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->missionid(), output);
  }

  // required uint32 Value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->value(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSMissionUpdateResp)
}

int CSMissionUpdateResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 MissionId = 1;
    if (has_missionid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->missionid());
    }

    // required uint32 Value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSMissionUpdateResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSMissionUpdateResp*>(&from));
}

void CSMissionUpdateResp::MergeFrom(const CSMissionUpdateResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_missionid()) {
      set_missionid(from.missionid());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSMissionUpdateResp::CopyFrom(const CSMissionUpdateResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSMissionUpdateResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSMissionUpdateResp::Swap(CSMissionUpdateResp* other) {
  if (other != this) {
    std::swap(missionid_, other->missionid_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSMissionUpdateResp::GetTypeName() const {
  return "fgame.CSMissionUpdateResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSBuyNewbieGiftReq::kIdFieldNumber;
#endif  // !_MSC_VER

CSBuyNewbieGiftReq::CSBuyNewbieGiftReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSBuyNewbieGiftReq)
}

void CSBuyNewbieGiftReq::InitAsDefaultInstance() {
}

CSBuyNewbieGiftReq::CSBuyNewbieGiftReq(const CSBuyNewbieGiftReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSBuyNewbieGiftReq)
}

void CSBuyNewbieGiftReq::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSBuyNewbieGiftReq::~CSBuyNewbieGiftReq() {
  // @@protoc_insertion_point(destructor:fgame.CSBuyNewbieGiftReq)
  SharedDtor();
}

void CSBuyNewbieGiftReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSBuyNewbieGiftReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSBuyNewbieGiftReq& CSBuyNewbieGiftReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSBuyNewbieGiftReq* CSBuyNewbieGiftReq::default_instance_ = NULL;

CSBuyNewbieGiftReq* CSBuyNewbieGiftReq::New() const {
  return new CSBuyNewbieGiftReq;
}

void CSBuyNewbieGiftReq::Clear() {
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSBuyNewbieGiftReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSBuyNewbieGiftReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSBuyNewbieGiftReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSBuyNewbieGiftReq)
  return false;
#undef DO_
}

void CSBuyNewbieGiftReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSBuyNewbieGiftReq)
  // required uint32 Id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSBuyNewbieGiftReq)
}

int CSBuyNewbieGiftReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSBuyNewbieGiftReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSBuyNewbieGiftReq*>(&from));
}

void CSBuyNewbieGiftReq::MergeFrom(const CSBuyNewbieGiftReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSBuyNewbieGiftReq::CopyFrom(const CSBuyNewbieGiftReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSBuyNewbieGiftReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSBuyNewbieGiftReq::Swap(CSBuyNewbieGiftReq* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSBuyNewbieGiftReq::GetTypeName() const {
  return "fgame.CSBuyNewbieGiftReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSBuyNewbieGiftResp::kRetFieldNumber;
#endif  // !_MSC_VER

CSBuyNewbieGiftResp::CSBuyNewbieGiftResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSBuyNewbieGiftResp)
}

void CSBuyNewbieGiftResp::InitAsDefaultInstance() {
}

CSBuyNewbieGiftResp::CSBuyNewbieGiftResp(const CSBuyNewbieGiftResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSBuyNewbieGiftResp)
}

void CSBuyNewbieGiftResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSBuyNewbieGiftResp::~CSBuyNewbieGiftResp() {
  // @@protoc_insertion_point(destructor:fgame.CSBuyNewbieGiftResp)
  SharedDtor();
}

void CSBuyNewbieGiftResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSBuyNewbieGiftResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSBuyNewbieGiftResp& CSBuyNewbieGiftResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSBuyNewbieGiftResp* CSBuyNewbieGiftResp::default_instance_ = NULL;

CSBuyNewbieGiftResp* CSBuyNewbieGiftResp::New() const {
  return new CSBuyNewbieGiftResp;
}

void CSBuyNewbieGiftResp::Clear() {
  ret_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSBuyNewbieGiftResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSBuyNewbieGiftResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSBuyNewbieGiftResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSBuyNewbieGiftResp)
  return false;
#undef DO_
}

void CSBuyNewbieGiftResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSBuyNewbieGiftResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSBuyNewbieGiftResp)
}

int CSBuyNewbieGiftResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSBuyNewbieGiftResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSBuyNewbieGiftResp*>(&from));
}

void CSBuyNewbieGiftResp::MergeFrom(const CSBuyNewbieGiftResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSBuyNewbieGiftResp::CopyFrom(const CSBuyNewbieGiftResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSBuyNewbieGiftResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSBuyNewbieGiftResp::Swap(CSBuyNewbieGiftResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSBuyNewbieGiftResp::GetTypeName() const {
  return "fgame.CSBuyNewbieGiftResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSMailInfo::kIdFieldNumber;
const int CSMailInfo::kTitleFieldNumber;
const int CSMailInfo::kContentFieldNumber;
const int CSMailInfo::kPlugInFieldNumber;
const int CSMailInfo::kSendTimeFieldNumber;
const int CSMailInfo::kOutDateFieldNumber;
#endif  // !_MSC_VER

CSMailInfo::CSMailInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSMailInfo)
}

void CSMailInfo::InitAsDefaultInstance() {
}

CSMailInfo::CSMailInfo(const CSMailInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSMailInfo)
}

void CSMailInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_ = 0u;
  title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  plugin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sendtime_ = 0u;
  outdate_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSMailInfo::~CSMailInfo() {
  // @@protoc_insertion_point(destructor:fgame.CSMailInfo)
  SharedDtor();
}

void CSMailInfo::SharedDtor() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (plugin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete plugin_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSMailInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSMailInfo& CSMailInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSMailInfo* CSMailInfo::default_instance_ = NULL;

CSMailInfo* CSMailInfo::New() const {
  return new CSMailInfo;
}

void CSMailInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSMailInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(id_, sendtime_);
    if (has_title()) {
      if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        title_->clear();
      }
    }
    if (has_content()) {
      if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        content_->clear();
      }
    }
    if (has_plugin()) {
      if (plugin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        plugin_->clear();
      }
    }
    outdate_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSMailInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSMailInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Title;
        break;
      }

      // required string Title = 2;
      case 2: {
        if (tag == 18) {
         parse_Title:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_title()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_Content;
        break;
      }

      // required string Content = 3;
      case 3: {
        if (tag == 26) {
         parse_Content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_content()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_PlugIn;
        break;
      }

      // required string PlugIn = 4;
      case 4: {
        if (tag == 34) {
         parse_PlugIn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_plugin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_SendTime;
        break;
      }

      // required uint32 SendTime = 5;
      case 5: {
        if (tag == 40) {
         parse_SendTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sendtime_)));
          set_has_sendtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_OutDate;
        break;
      }

      // required uint32 OutDate = 6;
      case 6: {
        if (tag == 48) {
         parse_OutDate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &outdate_)));
          set_has_outdate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSMailInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSMailInfo)
  return false;
#undef DO_
}

void CSMailInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSMailInfo)
  // required uint32 Id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required string Title = 2;
  if (has_title()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->title(), output);
  }

  // required string Content = 3;
  if (has_content()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->content(), output);
  }

  // required string PlugIn = 4;
  if (has_plugin()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->plugin(), output);
  }

  // required uint32 SendTime = 5;
  if (has_sendtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->sendtime(), output);
  }

  // required uint32 OutDate = 6;
  if (has_outdate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->outdate(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSMailInfo)
}

int CSMailInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required string Title = 2;
    if (has_title()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->title());
    }

    // required string Content = 3;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->content());
    }

    // required string PlugIn = 4;
    if (has_plugin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->plugin());
    }

    // required uint32 SendTime = 5;
    if (has_sendtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sendtime());
    }

    // required uint32 OutDate = 6;
    if (has_outdate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->outdate());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSMailInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSMailInfo*>(&from));
}

void CSMailInfo::MergeFrom(const CSMailInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_title()) {
      set_title(from.title());
    }
    if (from.has_content()) {
      set_content(from.content());
    }
    if (from.has_plugin()) {
      set_plugin(from.plugin());
    }
    if (from.has_sendtime()) {
      set_sendtime(from.sendtime());
    }
    if (from.has_outdate()) {
      set_outdate(from.outdate());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSMailInfo::CopyFrom(const CSMailInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSMailInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void CSMailInfo::Swap(CSMailInfo* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(title_, other->title_);
    std::swap(content_, other->content_);
    std::swap(plugin_, other->plugin_);
    std::swap(sendtime_, other->sendtime_);
    std::swap(outdate_, other->outdate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSMailInfo::GetTypeName() const {
  return "fgame.CSMailInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGetMailReq::kGetNumFieldNumber;
#endif  // !_MSC_VER

CSGetMailReq::CSGetMailReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetMailReq)
}

void CSGetMailReq::InitAsDefaultInstance() {
}

CSGetMailReq::CSGetMailReq(const CSGetMailReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetMailReq)
}

void CSGetMailReq::SharedCtor() {
  _cached_size_ = 0;
  getnum_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetMailReq::~CSGetMailReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGetMailReq)
  SharedDtor();
}

void CSGetMailReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetMailReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetMailReq& CSGetMailReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetMailReq* CSGetMailReq::default_instance_ = NULL;

CSGetMailReq* CSGetMailReq::New() const {
  return new CSGetMailReq;
}

void CSGetMailReq::Clear() {
  getnum_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetMailReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetMailReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 GetNum = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &getnum_)));
          set_has_getnum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetMailReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetMailReq)
  return false;
#undef DO_
}

void CSGetMailReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetMailReq)
  // required uint32 GetNum = 1;
  if (has_getnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->getnum(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetMailReq)
}

int CSGetMailReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 GetNum = 1;
    if (has_getnum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->getnum());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetMailReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetMailReq*>(&from));
}

void CSGetMailReq::MergeFrom(const CSGetMailReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_getnum()) {
      set_getnum(from.getnum());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetMailReq::CopyFrom(const CSGetMailReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetMailReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSGetMailReq::Swap(CSGetMailReq* other) {
  if (other != this) {
    std::swap(getnum_, other->getnum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetMailReq::GetTypeName() const {
  return "fgame.CSGetMailReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGetMailResp::kNewMailFieldNumber;
const int CSGetMailResp::kMailNOFieldNumber;
const int CSGetMailResp::kMailInfoFieldNumber;
#endif  // !_MSC_VER

CSGetMailResp::CSGetMailResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetMailResp)
}

void CSGetMailResp::InitAsDefaultInstance() {
}

CSGetMailResp::CSGetMailResp(const CSGetMailResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetMailResp)
}

void CSGetMailResp::SharedCtor() {
  _cached_size_ = 0;
  newmail_ = false;
  mailno_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetMailResp::~CSGetMailResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGetMailResp)
  SharedDtor();
}

void CSGetMailResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetMailResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetMailResp& CSGetMailResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetMailResp* CSGetMailResp::default_instance_ = NULL;

CSGetMailResp* CSGetMailResp::New() const {
  return new CSGetMailResp;
}

void CSGetMailResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSGetMailResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(newmail_, mailno_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  mailinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetMailResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetMailResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool NewMail = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &newmail_)));
          set_has_newmail();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_MailNO;
        break;
      }

      // optional uint32 MailNO = 2;
      case 2: {
        if (tag == 16) {
         parse_MailNO:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mailno_)));
          set_has_mailno();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_MailInfo;
        break;
      }

      // repeated .fgame.CSMailInfo MailInfo = 3;
      case 3: {
        if (tag == 26) {
         parse_MailInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_mailinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_MailInfo;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetMailResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetMailResp)
  return false;
#undef DO_
}

void CSGetMailResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetMailResp)
  // optional bool NewMail = 1;
  if (has_newmail()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->newmail(), output);
  }

  // optional uint32 MailNO = 2;
  if (has_mailno()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->mailno(), output);
  }

  // repeated .fgame.CSMailInfo MailInfo = 3;
  for (int i = 0; i < this->mailinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->mailinfo(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetMailResp)
}

int CSGetMailResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool NewMail = 1;
    if (has_newmail()) {
      total_size += 1 + 1;
    }

    // optional uint32 MailNO = 2;
    if (has_mailno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mailno());
    }

  }
  // repeated .fgame.CSMailInfo MailInfo = 3;
  total_size += 1 * this->mailinfo_size();
  for (int i = 0; i < this->mailinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->mailinfo(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetMailResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetMailResp*>(&from));
}

void CSGetMailResp::MergeFrom(const CSGetMailResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  mailinfo_.MergeFrom(from.mailinfo_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_newmail()) {
      set_newmail(from.newmail());
    }
    if (from.has_mailno()) {
      set_mailno(from.mailno());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetMailResp::CopyFrom(const CSGetMailResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetMailResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->mailinfo())) return false;
  return true;
}

void CSGetMailResp::Swap(CSGetMailResp* other) {
  if (other != this) {
    std::swap(newmail_, other->newmail_);
    std::swap(mailno_, other->mailno_);
    mailinfo_.Swap(&other->mailinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetMailResp::GetTypeName() const {
  return "fgame.CSGetMailResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDelMailReq::kIdFieldNumber;
#endif  // !_MSC_VER

CSDelMailReq::CSDelMailReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSDelMailReq)
}

void CSDelMailReq::InitAsDefaultInstance() {
}

CSDelMailReq::CSDelMailReq(const CSDelMailReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSDelMailReq)
}

void CSDelMailReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDelMailReq::~CSDelMailReq() {
  // @@protoc_insertion_point(destructor:fgame.CSDelMailReq)
  SharedDtor();
}

void CSDelMailReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSDelMailReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDelMailReq& CSDelMailReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSDelMailReq* CSDelMailReq::default_instance_ = NULL;

CSDelMailReq* CSDelMailReq::New() const {
  return new CSDelMailReq;
}

void CSDelMailReq::Clear() {
  id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSDelMailReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSDelMailReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 Id = 1;
      case 1: {
        if (tag == 8) {
         parse_Id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_id())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_id())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_Id;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSDelMailReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSDelMailReq)
  return false;
#undef DO_
}

void CSDelMailReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSDelMailReq)
  // repeated uint32 Id = 1;
  for (int i = 0; i < this->id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->id(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSDelMailReq)
}

int CSDelMailReq::ByteSize() const {
  int total_size = 0;

  // repeated uint32 Id = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->id(i));
    }
    total_size += 1 * this->id_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDelMailReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDelMailReq*>(&from));
}

void CSDelMailReq::MergeFrom(const CSDelMailReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  id_.MergeFrom(from.id_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSDelMailReq::CopyFrom(const CSDelMailReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDelMailReq::IsInitialized() const {

  return true;
}

void CSDelMailReq::Swap(CSDelMailReq* other) {
  if (other != this) {
    id_.Swap(&other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDelMailReq::GetTypeName() const {
  return "fgame.CSDelMailReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDelMailResp::kRetFieldNumber;
#endif  // !_MSC_VER

CSDelMailResp::CSDelMailResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSDelMailResp)
}

void CSDelMailResp::InitAsDefaultInstance() {
}

CSDelMailResp::CSDelMailResp(const CSDelMailResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSDelMailResp)
}

void CSDelMailResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDelMailResp::~CSDelMailResp() {
  // @@protoc_insertion_point(destructor:fgame.CSDelMailResp)
  SharedDtor();
}

void CSDelMailResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSDelMailResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDelMailResp& CSDelMailResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSDelMailResp* CSDelMailResp::default_instance_ = NULL;

CSDelMailResp* CSDelMailResp::New() const {
  return new CSDelMailResp;
}

void CSDelMailResp::Clear() {
  ret_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSDelMailResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSDelMailResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
         parse_Ret:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_ret())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_ret())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_Ret;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSDelMailResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSDelMailResp)
  return false;
#undef DO_
}

void CSDelMailResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSDelMailResp)
  // repeated uint32 Ret = 1;
  for (int i = 0; i < this->ret_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->ret(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSDelMailResp)
}

int CSDelMailResp::ByteSize() const {
  int total_size = 0;

  // repeated uint32 Ret = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->ret_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->ret(i));
    }
    total_size += 1 * this->ret_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDelMailResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDelMailResp*>(&from));
}

void CSDelMailResp::MergeFrom(const CSDelMailResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  ret_.MergeFrom(from.ret_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSDelMailResp::CopyFrom(const CSDelMailResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDelMailResp::IsInitialized() const {

  return true;
}

void CSDelMailResp::Swap(CSDelMailResp* other) {
  if (other != this) {
    ret_.Swap(&other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDelMailResp::GetTypeName() const {
  return "fgame.CSDelMailResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSNoticeMailReq::CSNoticeMailReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSNoticeMailReq)
}

void CSNoticeMailReq::InitAsDefaultInstance() {
}

CSNoticeMailReq::CSNoticeMailReq(const CSNoticeMailReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSNoticeMailReq)
}

void CSNoticeMailReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSNoticeMailReq::~CSNoticeMailReq() {
  // @@protoc_insertion_point(destructor:fgame.CSNoticeMailReq)
  SharedDtor();
}

void CSNoticeMailReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSNoticeMailReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSNoticeMailReq& CSNoticeMailReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSNoticeMailReq* CSNoticeMailReq::default_instance_ = NULL;

CSNoticeMailReq* CSNoticeMailReq::New() const {
  return new CSNoticeMailReq;
}

void CSNoticeMailReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSNoticeMailReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSNoticeMailReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSNoticeMailReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSNoticeMailReq)
  return false;
#undef DO_
}

void CSNoticeMailReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSNoticeMailReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSNoticeMailReq)
}

int CSNoticeMailReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSNoticeMailReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSNoticeMailReq*>(&from));
}

void CSNoticeMailReq::MergeFrom(const CSNoticeMailReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSNoticeMailReq::CopyFrom(const CSNoticeMailReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSNoticeMailReq::IsInitialized() const {

  return true;
}

void CSNoticeMailReq::Swap(CSNoticeMailReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSNoticeMailReq::GetTypeName() const {
  return "fgame.CSNoticeMailReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSRechargeCallbackReq::kIdFieldNumber;
#endif  // !_MSC_VER

CSRechargeCallbackReq::CSRechargeCallbackReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRechargeCallbackReq)
}

void CSRechargeCallbackReq::InitAsDefaultInstance() {
}

CSRechargeCallbackReq::CSRechargeCallbackReq(const CSRechargeCallbackReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRechargeCallbackReq)
}

void CSRechargeCallbackReq::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRechargeCallbackReq::~CSRechargeCallbackReq() {
  // @@protoc_insertion_point(destructor:fgame.CSRechargeCallbackReq)
  SharedDtor();
}

void CSRechargeCallbackReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRechargeCallbackReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRechargeCallbackReq& CSRechargeCallbackReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSRechargeCallbackReq* CSRechargeCallbackReq::default_instance_ = NULL;

CSRechargeCallbackReq* CSRechargeCallbackReq::New() const {
  return new CSRechargeCallbackReq;
}

void CSRechargeCallbackReq::Clear() {
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRechargeCallbackReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRechargeCallbackReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRechargeCallbackReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRechargeCallbackReq)
  return false;
#undef DO_
}

void CSRechargeCallbackReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRechargeCallbackReq)
  // required uint32 Id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRechargeCallbackReq)
}

int CSRechargeCallbackReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRechargeCallbackReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRechargeCallbackReq*>(&from));
}

void CSRechargeCallbackReq::MergeFrom(const CSRechargeCallbackReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRechargeCallbackReq::CopyFrom(const CSRechargeCallbackReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRechargeCallbackReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSRechargeCallbackReq::Swap(CSRechargeCallbackReq* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRechargeCallbackReq::GetTypeName() const {
  return "fgame.CSRechargeCallbackReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSRechargeCallbackResp::kRetFieldNumber;
const int CSRechargeCallbackResp::kIdFieldNumber;
const int CSRechargeCallbackResp::kOrderIdFieldNumber;
#endif  // !_MSC_VER

CSRechargeCallbackResp::CSRechargeCallbackResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRechargeCallbackResp)
}

void CSRechargeCallbackResp::InitAsDefaultInstance() {
}

CSRechargeCallbackResp::CSRechargeCallbackResp(const CSRechargeCallbackResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRechargeCallbackResp)
}

void CSRechargeCallbackResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ret_ = 0u;
  id_ = 0u;
  orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRechargeCallbackResp::~CSRechargeCallbackResp() {
  // @@protoc_insertion_point(destructor:fgame.CSRechargeCallbackResp)
  SharedDtor();
}

void CSRechargeCallbackResp::SharedDtor() {
  if (orderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete orderid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRechargeCallbackResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRechargeCallbackResp& CSRechargeCallbackResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSRechargeCallbackResp* CSRechargeCallbackResp::default_instance_ = NULL;

CSRechargeCallbackResp* CSRechargeCallbackResp::New() const {
  return new CSRechargeCallbackResp;
}

void CSRechargeCallbackResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSRechargeCallbackResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(ret_, id_);
    if (has_orderid()) {
      if (orderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        orderid_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRechargeCallbackResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRechargeCallbackResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Id;
        break;
      }

      // required uint32 Id = 2;
      case 2: {
        if (tag == 16) {
         parse_Id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_OrderId;
        break;
      }

      // required string OrderId = 3;
      case 3: {
        if (tag == 26) {
         parse_OrderId:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_orderid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRechargeCallbackResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRechargeCallbackResp)
  return false;
#undef DO_
}

void CSRechargeCallbackResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRechargeCallbackResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // required uint32 Id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->id(), output);
  }

  // required string OrderId = 3;
  if (has_orderid()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->orderid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRechargeCallbackResp)
}

int CSRechargeCallbackResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // required uint32 Id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required string OrderId = 3;
    if (has_orderid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->orderid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRechargeCallbackResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRechargeCallbackResp*>(&from));
}

void CSRechargeCallbackResp::MergeFrom(const CSRechargeCallbackResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_orderid()) {
      set_orderid(from.orderid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRechargeCallbackResp::CopyFrom(const CSRechargeCallbackResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRechargeCallbackResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSRechargeCallbackResp::Swap(CSRechargeCallbackResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(id_, other->id_);
    std::swap(orderid_, other->orderid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRechargeCallbackResp::GetTypeName() const {
  return "fgame.CSRechargeCallbackResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSUseGiftCodeReq::kGiftCodeFieldNumber;
#endif  // !_MSC_VER

CSUseGiftCodeReq::CSUseGiftCodeReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSUseGiftCodeReq)
}

void CSUseGiftCodeReq::InitAsDefaultInstance() {
}

CSUseGiftCodeReq::CSUseGiftCodeReq(const CSUseGiftCodeReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSUseGiftCodeReq)
}

void CSUseGiftCodeReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  giftcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSUseGiftCodeReq::~CSUseGiftCodeReq() {
  // @@protoc_insertion_point(destructor:fgame.CSUseGiftCodeReq)
  SharedDtor();
}

void CSUseGiftCodeReq::SharedDtor() {
  if (giftcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete giftcode_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSUseGiftCodeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSUseGiftCodeReq& CSUseGiftCodeReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSUseGiftCodeReq* CSUseGiftCodeReq::default_instance_ = NULL;

CSUseGiftCodeReq* CSUseGiftCodeReq::New() const {
  return new CSUseGiftCodeReq;
}

void CSUseGiftCodeReq::Clear() {
  if (has_giftcode()) {
    if (giftcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      giftcode_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSUseGiftCodeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSUseGiftCodeReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string GiftCode = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_giftcode()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSUseGiftCodeReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSUseGiftCodeReq)
  return false;
#undef DO_
}

void CSUseGiftCodeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSUseGiftCodeReq)
  // required string GiftCode = 1;
  if (has_giftcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->giftcode(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSUseGiftCodeReq)
}

int CSUseGiftCodeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string GiftCode = 1;
    if (has_giftcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->giftcode());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSUseGiftCodeReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSUseGiftCodeReq*>(&from));
}

void CSUseGiftCodeReq::MergeFrom(const CSUseGiftCodeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_giftcode()) {
      set_giftcode(from.giftcode());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSUseGiftCodeReq::CopyFrom(const CSUseGiftCodeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSUseGiftCodeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSUseGiftCodeReq::Swap(CSUseGiftCodeReq* other) {
  if (other != this) {
    std::swap(giftcode_, other->giftcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSUseGiftCodeReq::GetTypeName() const {
  return "fgame.CSUseGiftCodeReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSUseGiftCodeResp::kRetFieldNumber;
const int CSUseGiftCodeResp::kRewardFieldNumber;
#endif  // !_MSC_VER

CSUseGiftCodeResp::CSUseGiftCodeResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSUseGiftCodeResp)
}

void CSUseGiftCodeResp::InitAsDefaultInstance() {
}

CSUseGiftCodeResp::CSUseGiftCodeResp(const CSUseGiftCodeResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSUseGiftCodeResp)
}

void CSUseGiftCodeResp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  reward_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSUseGiftCodeResp::~CSUseGiftCodeResp() {
  // @@protoc_insertion_point(destructor:fgame.CSUseGiftCodeResp)
  SharedDtor();
}

void CSUseGiftCodeResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSUseGiftCodeResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSUseGiftCodeResp& CSUseGiftCodeResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSUseGiftCodeResp* CSUseGiftCodeResp::default_instance_ = NULL;

CSUseGiftCodeResp* CSUseGiftCodeResp::New() const {
  return new CSUseGiftCodeResp;
}

void CSUseGiftCodeResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSUseGiftCodeResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ret_, reward_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSUseGiftCodeResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSUseGiftCodeResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Reward;
        break;
      }

      // required uint32 Reward = 2;
      case 2: {
        if (tag == 16) {
         parse_Reward:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reward_)));
          set_has_reward();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSUseGiftCodeResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSUseGiftCodeResp)
  return false;
#undef DO_
}

void CSUseGiftCodeResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSUseGiftCodeResp)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // required uint32 Reward = 2;
  if (has_reward()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->reward(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSUseGiftCodeResp)
}

int CSUseGiftCodeResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // required uint32 Reward = 2;
    if (has_reward()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->reward());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSUseGiftCodeResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSUseGiftCodeResp*>(&from));
}

void CSUseGiftCodeResp::MergeFrom(const CSUseGiftCodeResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_reward()) {
      set_reward(from.reward());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSUseGiftCodeResp::CopyFrom(const CSUseGiftCodeResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSUseGiftCodeResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSUseGiftCodeResp::Swap(CSUseGiftCodeResp* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(reward_, other->reward_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSUseGiftCodeResp::GetTypeName() const {
  return "fgame.CSUseGiftCodeResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CheckPtData::kIdFieldNumber;
const int CheckPtData::kStarsFieldNumber;
const int CheckPtData::kRewardFieldNumber;
const int CheckPtData::kBattleTimeFieldNumber;
const int CheckPtData::kFullRewardFieldNumber;
const int CheckPtData::kWinFieldNumber;
const int CheckPtData::kChapterIdFieldNumber;
const int CheckPtData::kSkipFieldNumber;
const int CheckPtData::kScoreFieldNumber;
#endif  // !_MSC_VER

CheckPtData::CheckPtData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CheckPtData)
}

void CheckPtData::InitAsDefaultInstance() {
}

CheckPtData::CheckPtData(const CheckPtData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CheckPtData)
}

void CheckPtData::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  stars_ = 0u;
  reward_ = false;
  battletime_ = 0u;
  fullreward_ = false;
  win_ = false;
  chapterid_ = 0u;
  skip_ = false;
  score_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckPtData::~CheckPtData() {
  // @@protoc_insertion_point(destructor:fgame.CheckPtData)
  SharedDtor();
}

void CheckPtData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CheckPtData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CheckPtData& CheckPtData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CheckPtData* CheckPtData::default_instance_ = NULL;

CheckPtData* CheckPtData::New() const {
  return new CheckPtData;
}

void CheckPtData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CheckPtData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(id_, chapterid_);
  }
  score_ = 0u;

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CheckPtData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CheckPtData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_stars;
        break;
      }

      // optional uint32 stars = 2;
      case 2: {
        if (tag == 16) {
         parse_stars:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &stars_)));
          set_has_stars();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_reward;
        break;
      }

      // optional bool reward = 3;
      case 3: {
        if (tag == 24) {
         parse_reward:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &reward_)));
          set_has_reward();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_BattleTime;
        break;
      }

      // optional uint32 BattleTime = 4;
      case 4: {
        if (tag == 32) {
         parse_BattleTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &battletime_)));
          set_has_battletime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_FullReward;
        break;
      }

      // optional bool FullReward = 5;
      case 5: {
        if (tag == 40) {
         parse_FullReward:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &fullreward_)));
          set_has_fullreward();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_Win;
        break;
      }

      // optional bool Win = 6;
      case 6: {
        if (tag == 48) {
         parse_Win:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &win_)));
          set_has_win();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_ChapterId;
        break;
      }

      // optional uint32 ChapterId = 7;
      case 7: {
        if (tag == 56) {
         parse_ChapterId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chapterid_)));
          set_has_chapterid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_Skip;
        break;
      }

      // optional bool Skip = 8;
      case 8: {
        if (tag == 64) {
         parse_Skip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &skip_)));
          set_has_skip();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_Score;
        break;
      }

      // optional uint32 Score = 9;
      case 9: {
        if (tag == 72) {
         parse_Score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CheckPtData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CheckPtData)
  return false;
#undef DO_
}

void CheckPtData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CheckPtData)
  // optional uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional uint32 stars = 2;
  if (has_stars()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->stars(), output);
  }

  // optional bool reward = 3;
  if (has_reward()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->reward(), output);
  }

  // optional uint32 BattleTime = 4;
  if (has_battletime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->battletime(), output);
  }

  // optional bool FullReward = 5;
  if (has_fullreward()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->fullreward(), output);
  }

  // optional bool Win = 6;
  if (has_win()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->win(), output);
  }

  // optional uint32 ChapterId = 7;
  if (has_chapterid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->chapterid(), output);
  }

  // optional bool Skip = 8;
  if (has_skip()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->skip(), output);
  }

  // optional uint32 Score = 9;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->score(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CheckPtData)
}

int CheckPtData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional uint32 stars = 2;
    if (has_stars()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->stars());
    }

    // optional bool reward = 3;
    if (has_reward()) {
      total_size += 1 + 1;
    }

    // optional uint32 BattleTime = 4;
    if (has_battletime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->battletime());
    }

    // optional bool FullReward = 5;
    if (has_fullreward()) {
      total_size += 1 + 1;
    }

    // optional bool Win = 6;
    if (has_win()) {
      total_size += 1 + 1;
    }

    // optional uint32 ChapterId = 7;
    if (has_chapterid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chapterid());
    }

    // optional bool Skip = 8;
    if (has_skip()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 Score = 9;
    if (has_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->score());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckPtData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CheckPtData*>(&from));
}

void CheckPtData::MergeFrom(const CheckPtData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_stars()) {
      set_stars(from.stars());
    }
    if (from.has_reward()) {
      set_reward(from.reward());
    }
    if (from.has_battletime()) {
      set_battletime(from.battletime());
    }
    if (from.has_fullreward()) {
      set_fullreward(from.fullreward());
    }
    if (from.has_win()) {
      set_win(from.win());
    }
    if (from.has_chapterid()) {
      set_chapterid(from.chapterid());
    }
    if (from.has_skip()) {
      set_skip(from.skip());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_score()) {
      set_score(from.score());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CheckPtData::CopyFrom(const CheckPtData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckPtData::IsInitialized() const {

  return true;
}

void CheckPtData::Swap(CheckPtData* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(stars_, other->stars_);
    std::swap(reward_, other->reward_);
    std::swap(battletime_, other->battletime_);
    std::swap(fullreward_, other->fullreward_);
    std::swap(win_, other->win_);
    std::swap(chapterid_, other->chapterid_);
    std::swap(skip_, other->skip_);
    std::swap(score_, other->score_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CheckPtData::GetTypeName() const {
  return "fgame.CheckPtData";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSaveCheckPtDataReq::kCPDataFieldNumber;
const int CSSaveCheckPtDataReq::kOpenCheckPtIdFieldNumber;
#endif  // !_MSC_VER

CSSaveCheckPtDataReq::CSSaveCheckPtDataReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSaveCheckPtDataReq)
}

void CSSaveCheckPtDataReq::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  cpdata_ = const_cast< ::fgame::CheckPtData*>(
      ::fgame::CheckPtData::internal_default_instance());
#else
  cpdata_ = const_cast< ::fgame::CheckPtData*>(&::fgame::CheckPtData::default_instance());
#endif
}

CSSaveCheckPtDataReq::CSSaveCheckPtDataReq(const CSSaveCheckPtDataReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSaveCheckPtDataReq)
}

void CSSaveCheckPtDataReq::SharedCtor() {
  _cached_size_ = 0;
  cpdata_ = NULL;
  opencheckptid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSaveCheckPtDataReq::~CSSaveCheckPtDataReq() {
  // @@protoc_insertion_point(destructor:fgame.CSSaveCheckPtDataReq)
  SharedDtor();
}

void CSSaveCheckPtDataReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete cpdata_;
  }
}

void CSSaveCheckPtDataReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSaveCheckPtDataReq& CSSaveCheckPtDataReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSaveCheckPtDataReq* CSSaveCheckPtDataReq::default_instance_ = NULL;

CSSaveCheckPtDataReq* CSSaveCheckPtDataReq::New() const {
  return new CSSaveCheckPtDataReq;
}

void CSSaveCheckPtDataReq::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_cpdata()) {
      if (cpdata_ != NULL) cpdata_->::fgame::CheckPtData::Clear();
    }
    opencheckptid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSaveCheckPtDataReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSaveCheckPtDataReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .fgame.CheckPtData CPData = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cpdata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_OpenCheckPtId;
        break;
      }

      // required uint32 OpenCheckPtId = 2;
      case 2: {
        if (tag == 16) {
         parse_OpenCheckPtId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &opencheckptid_)));
          set_has_opencheckptid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSaveCheckPtDataReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSaveCheckPtDataReq)
  return false;
#undef DO_
}

void CSSaveCheckPtDataReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSaveCheckPtDataReq)
  // required .fgame.CheckPtData CPData = 1;
  if (has_cpdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->cpdata(), output);
  }

  // required uint32 OpenCheckPtId = 2;
  if (has_opencheckptid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->opencheckptid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSaveCheckPtDataReq)
}

int CSSaveCheckPtDataReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .fgame.CheckPtData CPData = 1;
    if (has_cpdata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cpdata());
    }

    // required uint32 OpenCheckPtId = 2;
    if (has_opencheckptid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->opencheckptid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSaveCheckPtDataReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSaveCheckPtDataReq*>(&from));
}

void CSSaveCheckPtDataReq::MergeFrom(const CSSaveCheckPtDataReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cpdata()) {
      mutable_cpdata()->::fgame::CheckPtData::MergeFrom(from.cpdata());
    }
    if (from.has_opencheckptid()) {
      set_opencheckptid(from.opencheckptid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSaveCheckPtDataReq::CopyFrom(const CSSaveCheckPtDataReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSaveCheckPtDataReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSSaveCheckPtDataReq::Swap(CSSaveCheckPtDataReq* other) {
  if (other != this) {
    std::swap(cpdata_, other->cpdata_);
    std::swap(opencheckptid_, other->opencheckptid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSaveCheckPtDataReq::GetTypeName() const {
  return "fgame.CSSaveCheckPtDataReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSaveCheckPtDataResp::kIdFieldNumber;
const int CSSaveCheckPtDataResp::kRewardFieldNumber;
const int CSSaveCheckPtDataResp::kFullRewardFieldNumber;
const int CSSaveCheckPtDataResp::kStarsFieldNumber;
const int CSSaveCheckPtDataResp::kWinFieldNumber;
const int CSSaveCheckPtDataResp::kShareIdFieldNumber;
const int CSSaveCheckPtDataResp::kSkipNumFieldNumber;
#endif  // !_MSC_VER

CSSaveCheckPtDataResp::CSSaveCheckPtDataResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSaveCheckPtDataResp)
}

void CSSaveCheckPtDataResp::InitAsDefaultInstance() {
}

CSSaveCheckPtDataResp::CSSaveCheckPtDataResp(const CSSaveCheckPtDataResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSaveCheckPtDataResp)
}

void CSSaveCheckPtDataResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_ = 0u;
  reward_ = false;
  fullreward_ = false;
  stars_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  win_ = false;
  shareid_ = 0u;
  skipnum_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSaveCheckPtDataResp::~CSSaveCheckPtDataResp() {
  // @@protoc_insertion_point(destructor:fgame.CSSaveCheckPtDataResp)
  SharedDtor();
}

void CSSaveCheckPtDataResp::SharedDtor() {
  if (stars_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stars_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSaveCheckPtDataResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSaveCheckPtDataResp& CSSaveCheckPtDataResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSaveCheckPtDataResp* CSSaveCheckPtDataResp::default_instance_ = NULL;

CSSaveCheckPtDataResp* CSSaveCheckPtDataResp::New() const {
  return new CSSaveCheckPtDataResp;
}

void CSSaveCheckPtDataResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSSaveCheckPtDataResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(id_, win_);
    ZR_(shareid_, skipnum_);
    if (has_stars()) {
      if (stars_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        stars_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSaveCheckPtDataResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSaveCheckPtDataResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_reward;
        break;
      }

      // optional bool reward = 2;
      case 2: {
        if (tag == 16) {
         parse_reward:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &reward_)));
          set_has_reward();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_FullReward;
        break;
      }

      // optional bool FullReward = 3;
      case 3: {
        if (tag == 24) {
         parse_FullReward:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &fullreward_)));
          set_has_fullreward();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_Stars;
        break;
      }

      // optional string Stars = 4;
      case 4: {
        if (tag == 34) {
         parse_Stars:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_stars()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_Win;
        break;
      }

      // optional bool Win = 5;
      case 5: {
        if (tag == 40) {
         parse_Win:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &win_)));
          set_has_win();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_ShareId;
        break;
      }

      // optional uint32 ShareId = 6;
      case 6: {
        if (tag == 48) {
         parse_ShareId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shareid_)));
          set_has_shareid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_SkipNum;
        break;
      }

      // optional uint32 SkipNum = 7;
      case 7: {
        if (tag == 56) {
         parse_SkipNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &skipnum_)));
          set_has_skipnum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSaveCheckPtDataResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSaveCheckPtDataResp)
  return false;
#undef DO_
}

void CSSaveCheckPtDataResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSaveCheckPtDataResp)
  // optional uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional bool reward = 2;
  if (has_reward()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->reward(), output);
  }

  // optional bool FullReward = 3;
  if (has_fullreward()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->fullreward(), output);
  }

  // optional string Stars = 4;
  if (has_stars()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->stars(), output);
  }

  // optional bool Win = 5;
  if (has_win()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->win(), output);
  }

  // optional uint32 ShareId = 6;
  if (has_shareid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->shareid(), output);
  }

  // optional uint32 SkipNum = 7;
  if (has_skipnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->skipnum(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSaveCheckPtDataResp)
}

int CSSaveCheckPtDataResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional bool reward = 2;
    if (has_reward()) {
      total_size += 1 + 1;
    }

    // optional bool FullReward = 3;
    if (has_fullreward()) {
      total_size += 1 + 1;
    }

    // optional string Stars = 4;
    if (has_stars()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->stars());
    }

    // optional bool Win = 5;
    if (has_win()) {
      total_size += 1 + 1;
    }

    // optional uint32 ShareId = 6;
    if (has_shareid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shareid());
    }

    // optional uint32 SkipNum = 7;
    if (has_skipnum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->skipnum());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSaveCheckPtDataResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSaveCheckPtDataResp*>(&from));
}

void CSSaveCheckPtDataResp::MergeFrom(const CSSaveCheckPtDataResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_reward()) {
      set_reward(from.reward());
    }
    if (from.has_fullreward()) {
      set_fullreward(from.fullreward());
    }
    if (from.has_stars()) {
      set_stars(from.stars());
    }
    if (from.has_win()) {
      set_win(from.win());
    }
    if (from.has_shareid()) {
      set_shareid(from.shareid());
    }
    if (from.has_skipnum()) {
      set_skipnum(from.skipnum());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSaveCheckPtDataResp::CopyFrom(const CSSaveCheckPtDataResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSaveCheckPtDataResp::IsInitialized() const {

  return true;
}

void CSSaveCheckPtDataResp::Swap(CSSaveCheckPtDataResp* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(reward_, other->reward_);
    std::swap(fullreward_, other->fullreward_);
    std::swap(stars_, other->stars_);
    std::swap(win_, other->win_);
    std::swap(shareid_, other->shareid_);
    std::swap(skipnum_, other->skipnum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSaveCheckPtDataResp::GetTypeName() const {
  return "fgame.CSSaveCheckPtDataResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSRetriveCheckPtRewardReq::kIdFieldNumber;
const int CSRetriveCheckPtRewardReq::kRewardTypeFieldNumber;
#endif  // !_MSC_VER

CSRetriveCheckPtRewardReq::CSRetriveCheckPtRewardReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRetriveCheckPtRewardReq)
}

void CSRetriveCheckPtRewardReq::InitAsDefaultInstance() {
}

CSRetriveCheckPtRewardReq::CSRetriveCheckPtRewardReq(const CSRetriveCheckPtRewardReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRetriveCheckPtRewardReq)
}

void CSRetriveCheckPtRewardReq::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  rewardtype_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRetriveCheckPtRewardReq::~CSRetriveCheckPtRewardReq() {
  // @@protoc_insertion_point(destructor:fgame.CSRetriveCheckPtRewardReq)
  SharedDtor();
}

void CSRetriveCheckPtRewardReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRetriveCheckPtRewardReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRetriveCheckPtRewardReq& CSRetriveCheckPtRewardReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSRetriveCheckPtRewardReq* CSRetriveCheckPtRewardReq::default_instance_ = NULL;

CSRetriveCheckPtRewardReq* CSRetriveCheckPtRewardReq::New() const {
  return new CSRetriveCheckPtRewardReq;
}

void CSRetriveCheckPtRewardReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSRetriveCheckPtRewardReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, rewardtype_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRetriveCheckPtRewardReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRetriveCheckPtRewardReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_RewardType;
        break;
      }

      // required uint32 RewardType = 2;
      case 2: {
        if (tag == 16) {
         parse_RewardType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rewardtype_)));
          set_has_rewardtype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRetriveCheckPtRewardReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRetriveCheckPtRewardReq)
  return false;
#undef DO_
}

void CSRetriveCheckPtRewardReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRetriveCheckPtRewardReq)
  // required uint32 Id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 RewardType = 2;
  if (has_rewardtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->rewardtype(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRetriveCheckPtRewardReq)
}

int CSRetriveCheckPtRewardReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 RewardType = 2;
    if (has_rewardtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rewardtype());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRetriveCheckPtRewardReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRetriveCheckPtRewardReq*>(&from));
}

void CSRetriveCheckPtRewardReq::MergeFrom(const CSRetriveCheckPtRewardReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_rewardtype()) {
      set_rewardtype(from.rewardtype());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRetriveCheckPtRewardReq::CopyFrom(const CSRetriveCheckPtRewardReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRetriveCheckPtRewardReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSRetriveCheckPtRewardReq::Swap(CSRetriveCheckPtRewardReq* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(rewardtype_, other->rewardtype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRetriveCheckPtRewardReq::GetTypeName() const {
  return "fgame.CSRetriveCheckPtRewardReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSRetriveCheckPtRewardResp::kIdFieldNumber;
const int CSRetriveCheckPtRewardResp::kRewardTypeFieldNumber;
const int CSRetriveCheckPtRewardResp::kRetFieldNumber;
#endif  // !_MSC_VER

CSRetriveCheckPtRewardResp::CSRetriveCheckPtRewardResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRetriveCheckPtRewardResp)
}

void CSRetriveCheckPtRewardResp::InitAsDefaultInstance() {
}

CSRetriveCheckPtRewardResp::CSRetriveCheckPtRewardResp(const CSRetriveCheckPtRewardResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRetriveCheckPtRewardResp)
}

void CSRetriveCheckPtRewardResp::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  rewardtype_ = 0u;
  ret_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRetriveCheckPtRewardResp::~CSRetriveCheckPtRewardResp() {
  // @@protoc_insertion_point(destructor:fgame.CSRetriveCheckPtRewardResp)
  SharedDtor();
}

void CSRetriveCheckPtRewardResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRetriveCheckPtRewardResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRetriveCheckPtRewardResp& CSRetriveCheckPtRewardResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSRetriveCheckPtRewardResp* CSRetriveCheckPtRewardResp::default_instance_ = NULL;

CSRetriveCheckPtRewardResp* CSRetriveCheckPtRewardResp::New() const {
  return new CSRetriveCheckPtRewardResp;
}

void CSRetriveCheckPtRewardResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSRetriveCheckPtRewardResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, ret_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRetriveCheckPtRewardResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRetriveCheckPtRewardResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_RewardType;
        break;
      }

      // required uint32 RewardType = 2;
      case 2: {
        if (tag == 16) {
         parse_RewardType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rewardtype_)));
          set_has_rewardtype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Ret;
        break;
      }

      // optional bool Ret = 3;
      case 3: {
        if (tag == 24) {
         parse_Ret:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRetriveCheckPtRewardResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRetriveCheckPtRewardResp)
  return false;
#undef DO_
}

void CSRetriveCheckPtRewardResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRetriveCheckPtRewardResp)
  // required uint32 Id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 RewardType = 2;
  if (has_rewardtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->rewardtype(), output);
  }

  // optional bool Ret = 3;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->ret(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRetriveCheckPtRewardResp)
}

int CSRetriveCheckPtRewardResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 RewardType = 2;
    if (has_rewardtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rewardtype());
    }

    // optional bool Ret = 3;
    if (has_ret()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRetriveCheckPtRewardResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRetriveCheckPtRewardResp*>(&from));
}

void CSRetriveCheckPtRewardResp::MergeFrom(const CSRetriveCheckPtRewardResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_rewardtype()) {
      set_rewardtype(from.rewardtype());
    }
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRetriveCheckPtRewardResp::CopyFrom(const CSRetriveCheckPtRewardResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRetriveCheckPtRewardResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSRetriveCheckPtRewardResp::Swap(CSRetriveCheckPtRewardResp* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(rewardtype_, other->rewardtype_);
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRetriveCheckPtRewardResp::GetTypeName() const {
  return "fgame.CSRetriveCheckPtRewardResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSGetCheckPtDataReq::CSGetCheckPtDataReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetCheckPtDataReq)
}

void CSGetCheckPtDataReq::InitAsDefaultInstance() {
}

CSGetCheckPtDataReq::CSGetCheckPtDataReq(const CSGetCheckPtDataReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetCheckPtDataReq)
}

void CSGetCheckPtDataReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetCheckPtDataReq::~CSGetCheckPtDataReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGetCheckPtDataReq)
  SharedDtor();
}

void CSGetCheckPtDataReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetCheckPtDataReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetCheckPtDataReq& CSGetCheckPtDataReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetCheckPtDataReq* CSGetCheckPtDataReq::default_instance_ = NULL;

CSGetCheckPtDataReq* CSGetCheckPtDataReq::New() const {
  return new CSGetCheckPtDataReq;
}

void CSGetCheckPtDataReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetCheckPtDataReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetCheckPtDataReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetCheckPtDataReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetCheckPtDataReq)
  return false;
#undef DO_
}

void CSGetCheckPtDataReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetCheckPtDataReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetCheckPtDataReq)
}

int CSGetCheckPtDataReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetCheckPtDataReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetCheckPtDataReq*>(&from));
}

void CSGetCheckPtDataReq::MergeFrom(const CSGetCheckPtDataReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetCheckPtDataReq::CopyFrom(const CSGetCheckPtDataReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetCheckPtDataReq::IsInitialized() const {

  return true;
}

void CSGetCheckPtDataReq::Swap(CSGetCheckPtDataReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetCheckPtDataReq::GetTypeName() const {
  return "fgame.CSGetCheckPtDataReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ChapterData::kChapterIdFieldNumber;
const int ChapterData::kCpDataFieldNumber;
const int ChapterData::kStarsFieldNumber;
const int ChapterData::kChestFieldNumber;
const int ChapterData::kMaxCpIdFieldNumber;
#endif  // !_MSC_VER

ChapterData::ChapterData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.ChapterData)
}

void ChapterData::InitAsDefaultInstance() {
}

ChapterData::ChapterData(const ChapterData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.ChapterData)
}

void ChapterData::SharedCtor() {
  _cached_size_ = 0;
  chapterid_ = 0u;
  stars_ = 0u;
  chest_ = 0u;
  maxcpid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChapterData::~ChapterData() {
  // @@protoc_insertion_point(destructor:fgame.ChapterData)
  SharedDtor();
}

void ChapterData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChapterData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChapterData& ChapterData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

ChapterData* ChapterData::default_instance_ = NULL;

ChapterData* ChapterData::New() const {
  return new ChapterData;
}

void ChapterData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ChapterData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(chapterid_, maxcpid_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  cpdata_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ChapterData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.ChapterData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ChapterId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chapterid_)));
          set_has_chapterid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_CpData;
        break;
      }

      // repeated .fgame.CheckPtData CpData = 2;
      case 2: {
        if (tag == 18) {
         parse_CpData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_cpdata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_CpData;
        if (input->ExpectTag(24)) goto parse_Stars;
        break;
      }

      // required uint32 Stars = 3;
      case 3: {
        if (tag == 24) {
         parse_Stars:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &stars_)));
          set_has_stars();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Chest;
        break;
      }

      // required uint32 Chest = 4;
      case 4: {
        if (tag == 32) {
         parse_Chest:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chest_)));
          set_has_chest();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_MaxCpId;
        break;
      }

      // required uint32 MaxCpId = 5;
      case 5: {
        if (tag == 40) {
         parse_MaxCpId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &maxcpid_)));
          set_has_maxcpid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.ChapterData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.ChapterData)
  return false;
#undef DO_
}

void ChapterData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.ChapterData)
  // required uint32 ChapterId = 1;
  if (has_chapterid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->chapterid(), output);
  }

  // repeated .fgame.CheckPtData CpData = 2;
  for (int i = 0; i < this->cpdata_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->cpdata(i), output);
  }

  // required uint32 Stars = 3;
  if (has_stars()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->stars(), output);
  }

  // required uint32 Chest = 4;
  if (has_chest()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->chest(), output);
  }

  // required uint32 MaxCpId = 5;
  if (has_maxcpid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->maxcpid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.ChapterData)
}

int ChapterData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ChapterId = 1;
    if (has_chapterid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chapterid());
    }

    // required uint32 Stars = 3;
    if (has_stars()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->stars());
    }

    // required uint32 Chest = 4;
    if (has_chest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chest());
    }

    // required uint32 MaxCpId = 5;
    if (has_maxcpid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->maxcpid());
    }

  }
  // repeated .fgame.CheckPtData CpData = 2;
  total_size += 1 * this->cpdata_size();
  for (int i = 0; i < this->cpdata_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->cpdata(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChapterData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChapterData*>(&from));
}

void ChapterData::MergeFrom(const ChapterData& from) {
  GOOGLE_CHECK_NE(&from, this);
  cpdata_.MergeFrom(from.cpdata_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_chapterid()) {
      set_chapterid(from.chapterid());
    }
    if (from.has_stars()) {
      set_stars(from.stars());
    }
    if (from.has_chest()) {
      set_chest(from.chest());
    }
    if (from.has_maxcpid()) {
      set_maxcpid(from.maxcpid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ChapterData::CopyFrom(const ChapterData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChapterData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001d) != 0x0000001d) return false;

  return true;
}

void ChapterData::Swap(ChapterData* other) {
  if (other != this) {
    std::swap(chapterid_, other->chapterid_);
    cpdata_.Swap(&other->cpdata_);
    std::swap(stars_, other->stars_);
    std::swap(chest_, other->chest_);
    std::swap(maxcpid_, other->maxcpid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChapterData::GetTypeName() const {
  return "fgame.ChapterData";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGetCheckPtDataResp::kDataFieldNumber;
const int CSGetCheckPtDataResp::kSkipNumFieldNumber;
#endif  // !_MSC_VER

CSGetCheckPtDataResp::CSGetCheckPtDataResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetCheckPtDataResp)
}

void CSGetCheckPtDataResp::InitAsDefaultInstance() {
}

CSGetCheckPtDataResp::CSGetCheckPtDataResp(const CSGetCheckPtDataResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetCheckPtDataResp)
}

void CSGetCheckPtDataResp::SharedCtor() {
  _cached_size_ = 0;
  skipnum_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetCheckPtDataResp::~CSGetCheckPtDataResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGetCheckPtDataResp)
  SharedDtor();
}

void CSGetCheckPtDataResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetCheckPtDataResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetCheckPtDataResp& CSGetCheckPtDataResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetCheckPtDataResp* CSGetCheckPtDataResp::default_instance_ = NULL;

CSGetCheckPtDataResp* CSGetCheckPtDataResp::New() const {
  return new CSGetCheckPtDataResp;
}

void CSGetCheckPtDataResp::Clear() {
  skipnum_ = 0u;
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetCheckPtDataResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetCheckPtDataResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.ChapterData Data = 1;
      case 1: {
        if (tag == 10) {
         parse_Data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_Data;
        if (input->ExpectTag(16)) goto parse_SkipNum;
        break;
      }

      // optional uint32 SkipNum = 2;
      case 2: {
        if (tag == 16) {
         parse_SkipNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &skipnum_)));
          set_has_skipnum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetCheckPtDataResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetCheckPtDataResp)
  return false;
#undef DO_
}

void CSGetCheckPtDataResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetCheckPtDataResp)
  // repeated .fgame.ChapterData Data = 1;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->data(i), output);
  }

  // optional uint32 SkipNum = 2;
  if (has_skipnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->skipnum(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetCheckPtDataResp)
}

int CSGetCheckPtDataResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional uint32 SkipNum = 2;
    if (has_skipnum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->skipnum());
    }

  }
  // repeated .fgame.ChapterData Data = 1;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetCheckPtDataResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetCheckPtDataResp*>(&from));
}

void CSGetCheckPtDataResp::MergeFrom(const CSGetCheckPtDataResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_skipnum()) {
      set_skipnum(from.skipnum());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetCheckPtDataResp::CopyFrom(const CSGetCheckPtDataResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetCheckPtDataResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->data())) return false;
  return true;
}

void CSGetCheckPtDataResp::Swap(CSGetCheckPtDataResp* other) {
  if (other != this) {
    data_.Swap(&other->data_);
    std::swap(skipnum_, other->skipnum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetCheckPtDataResp::GetTypeName() const {
  return "fgame.CSGetCheckPtDataResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSChapterUnlockReq::kChapterIdFieldNumber;
const int CSChapterUnlockReq::kUnlockByFieldNumber;
#endif  // !_MSC_VER

CSChapterUnlockReq::CSChapterUnlockReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSChapterUnlockReq)
}

void CSChapterUnlockReq::InitAsDefaultInstance() {
}

CSChapterUnlockReq::CSChapterUnlockReq(const CSChapterUnlockReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSChapterUnlockReq)
}

void CSChapterUnlockReq::SharedCtor() {
  _cached_size_ = 0;
  chapterid_ = 0u;
  unlockby_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSChapterUnlockReq::~CSChapterUnlockReq() {
  // @@protoc_insertion_point(destructor:fgame.CSChapterUnlockReq)
  SharedDtor();
}

void CSChapterUnlockReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSChapterUnlockReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSChapterUnlockReq& CSChapterUnlockReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSChapterUnlockReq* CSChapterUnlockReq::default_instance_ = NULL;

CSChapterUnlockReq* CSChapterUnlockReq::New() const {
  return new CSChapterUnlockReq;
}

void CSChapterUnlockReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSChapterUnlockReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(chapterid_, unlockby_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSChapterUnlockReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSChapterUnlockReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ChapterId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chapterid_)));
          set_has_chapterid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_UnlockBy;
        break;
      }

      // required uint32 UnlockBy = 2;
      case 2: {
        if (tag == 16) {
         parse_UnlockBy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unlockby_)));
          set_has_unlockby();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSChapterUnlockReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSChapterUnlockReq)
  return false;
#undef DO_
}

void CSChapterUnlockReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSChapterUnlockReq)
  // required uint32 ChapterId = 1;
  if (has_chapterid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->chapterid(), output);
  }

  // required uint32 UnlockBy = 2;
  if (has_unlockby()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unlockby(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSChapterUnlockReq)
}

int CSChapterUnlockReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ChapterId = 1;
    if (has_chapterid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chapterid());
    }

    // required uint32 UnlockBy = 2;
    if (has_unlockby()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unlockby());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSChapterUnlockReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSChapterUnlockReq*>(&from));
}

void CSChapterUnlockReq::MergeFrom(const CSChapterUnlockReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_chapterid()) {
      set_chapterid(from.chapterid());
    }
    if (from.has_unlockby()) {
      set_unlockby(from.unlockby());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSChapterUnlockReq::CopyFrom(const CSChapterUnlockReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSChapterUnlockReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSChapterUnlockReq::Swap(CSChapterUnlockReq* other) {
  if (other != this) {
    std::swap(chapterid_, other->chapterid_);
    std::swap(unlockby_, other->unlockby_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSChapterUnlockReq::GetTypeName() const {
  return "fgame.CSChapterUnlockReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSChapterUnlockResp::kChapterIdFieldNumber;
const int CSChapterUnlockResp::kUnlockByFieldNumber;
#endif  // !_MSC_VER

CSChapterUnlockResp::CSChapterUnlockResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSChapterUnlockResp)
}

void CSChapterUnlockResp::InitAsDefaultInstance() {
}

CSChapterUnlockResp::CSChapterUnlockResp(const CSChapterUnlockResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSChapterUnlockResp)
}

void CSChapterUnlockResp::SharedCtor() {
  _cached_size_ = 0;
  chapterid_ = 0u;
  unlockby_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSChapterUnlockResp::~CSChapterUnlockResp() {
  // @@protoc_insertion_point(destructor:fgame.CSChapterUnlockResp)
  SharedDtor();
}

void CSChapterUnlockResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSChapterUnlockResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSChapterUnlockResp& CSChapterUnlockResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSChapterUnlockResp* CSChapterUnlockResp::default_instance_ = NULL;

CSChapterUnlockResp* CSChapterUnlockResp::New() const {
  return new CSChapterUnlockResp;
}

void CSChapterUnlockResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSChapterUnlockResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(chapterid_, unlockby_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSChapterUnlockResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSChapterUnlockResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ChapterId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chapterid_)));
          set_has_chapterid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_UnlockBy;
        break;
      }

      // required uint32 UnlockBy = 2;
      case 2: {
        if (tag == 16) {
         parse_UnlockBy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unlockby_)));
          set_has_unlockby();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSChapterUnlockResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSChapterUnlockResp)
  return false;
#undef DO_
}

void CSChapterUnlockResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSChapterUnlockResp)
  // required uint32 ChapterId = 1;
  if (has_chapterid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->chapterid(), output);
  }

  // required uint32 UnlockBy = 2;
  if (has_unlockby()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unlockby(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSChapterUnlockResp)
}

int CSChapterUnlockResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ChapterId = 1;
    if (has_chapterid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chapterid());
    }

    // required uint32 UnlockBy = 2;
    if (has_unlockby()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unlockby());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSChapterUnlockResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSChapterUnlockResp*>(&from));
}

void CSChapterUnlockResp::MergeFrom(const CSChapterUnlockResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_chapterid()) {
      set_chapterid(from.chapterid());
    }
    if (from.has_unlockby()) {
      set_unlockby(from.unlockby());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSChapterUnlockResp::CopyFrom(const CSChapterUnlockResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSChapterUnlockResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSChapterUnlockResp::Swap(CSChapterUnlockResp* other) {
  if (other != this) {
    std::swap(chapterid_, other->chapterid_);
    std::swap(unlockby_, other->unlockby_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSChapterUnlockResp::GetTypeName() const {
  return "fgame.CSChapterUnlockResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGetChestReq::kChapterIdFieldNumber;
const int CSGetChestReq::kChestIdFieldNumber;
const int CSGetChestReq::kChestGiftFieldNumber;
#endif  // !_MSC_VER

CSGetChestReq::CSGetChestReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetChestReq)
}

void CSGetChestReq::InitAsDefaultInstance() {
}

CSGetChestReq::CSGetChestReq(const CSGetChestReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetChestReq)
}

void CSGetChestReq::SharedCtor() {
  _cached_size_ = 0;
  chapterid_ = 0u;
  chestid_ = 0u;
  chestgift_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetChestReq::~CSGetChestReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGetChestReq)
  SharedDtor();
}

void CSGetChestReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetChestReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetChestReq& CSGetChestReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetChestReq* CSGetChestReq::default_instance_ = NULL;

CSGetChestReq* CSGetChestReq::New() const {
  return new CSGetChestReq;
}

void CSGetChestReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSGetChestReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(chapterid_, chestgift_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetChestReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetChestReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ChapterId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chapterid_)));
          set_has_chapterid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ChestId;
        break;
      }

      // required uint32 ChestId = 2;
      case 2: {
        if (tag == 16) {
         parse_ChestId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chestid_)));
          set_has_chestid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_ChestGift;
        break;
      }

      // required uint32 ChestGift = 3;
      case 3: {
        if (tag == 24) {
         parse_ChestGift:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chestgift_)));
          set_has_chestgift();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetChestReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetChestReq)
  return false;
#undef DO_
}

void CSGetChestReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetChestReq)
  // required uint32 ChapterId = 1;
  if (has_chapterid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->chapterid(), output);
  }

  // required uint32 ChestId = 2;
  if (has_chestid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->chestid(), output);
  }

  // required uint32 ChestGift = 3;
  if (has_chestgift()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->chestgift(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetChestReq)
}

int CSGetChestReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ChapterId = 1;
    if (has_chapterid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chapterid());
    }

    // required uint32 ChestId = 2;
    if (has_chestid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chestid());
    }

    // required uint32 ChestGift = 3;
    if (has_chestgift()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chestgift());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetChestReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetChestReq*>(&from));
}

void CSGetChestReq::MergeFrom(const CSGetChestReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_chapterid()) {
      set_chapterid(from.chapterid());
    }
    if (from.has_chestid()) {
      set_chestid(from.chestid());
    }
    if (from.has_chestgift()) {
      set_chestgift(from.chestgift());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetChestReq::CopyFrom(const CSGetChestReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetChestReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSGetChestReq::Swap(CSGetChestReq* other) {
  if (other != this) {
    std::swap(chapterid_, other->chapterid_);
    std::swap(chestid_, other->chestid_);
    std::swap(chestgift_, other->chestgift_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetChestReq::GetTypeName() const {
  return "fgame.CSGetChestReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGetChestResp::kChapterIdFieldNumber;
const int CSGetChestResp::kChestFieldNumber;
#endif  // !_MSC_VER

CSGetChestResp::CSGetChestResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetChestResp)
}

void CSGetChestResp::InitAsDefaultInstance() {
}

CSGetChestResp::CSGetChestResp(const CSGetChestResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetChestResp)
}

void CSGetChestResp::SharedCtor() {
  _cached_size_ = 0;
  chapterid_ = 0u;
  chest_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetChestResp::~CSGetChestResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGetChestResp)
  SharedDtor();
}

void CSGetChestResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetChestResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetChestResp& CSGetChestResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetChestResp* CSGetChestResp::default_instance_ = NULL;

CSGetChestResp* CSGetChestResp::New() const {
  return new CSGetChestResp;
}

void CSGetChestResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSGetChestResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(chapterid_, chest_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetChestResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetChestResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ChapterId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chapterid_)));
          set_has_chapterid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Chest;
        break;
      }

      // required uint32 Chest = 2;
      case 2: {
        if (tag == 16) {
         parse_Chest:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chest_)));
          set_has_chest();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetChestResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetChestResp)
  return false;
#undef DO_
}

void CSGetChestResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetChestResp)
  // required uint32 ChapterId = 1;
  if (has_chapterid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->chapterid(), output);
  }

  // required uint32 Chest = 2;
  if (has_chest()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->chest(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetChestResp)
}

int CSGetChestResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ChapterId = 1;
    if (has_chapterid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chapterid());
    }

    // required uint32 Chest = 2;
    if (has_chest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chest());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetChestResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetChestResp*>(&from));
}

void CSGetChestResp::MergeFrom(const CSGetChestResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_chapterid()) {
      set_chapterid(from.chapterid());
    }
    if (from.has_chest()) {
      set_chest(from.chest());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetChestResp::CopyFrom(const CSGetChestResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetChestResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSGetChestResp::Swap(CSGetChestResp* other) {
  if (other != this) {
    std::swap(chapterid_, other->chapterid_);
    std::swap(chest_, other->chest_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetChestResp::GetTypeName() const {
  return "fgame.CSGetChestResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPveNotifyReq::kCheckPointFieldNumber;
const int CSPveNotifyReq::kActionFieldNumber;
const int CSPveNotifyReq::kChapterIdFieldNumber;
const int CSPveNotifyReq::kNeedPowerFieldNumber;
const int CSPveNotifyReq::kBattleTimeFieldNumber;
#endif  // !_MSC_VER

CSPveNotifyReq::CSPveNotifyReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPveNotifyReq)
}

void CSPveNotifyReq::InitAsDefaultInstance() {
}

CSPveNotifyReq::CSPveNotifyReq(const CSPveNotifyReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPveNotifyReq)
}

void CSPveNotifyReq::SharedCtor() {
  _cached_size_ = 0;
  checkpoint_ = 0u;
  action_ = 0u;
  chapterid_ = 0u;
  needpower_ = false;
  battletime_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPveNotifyReq::~CSPveNotifyReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPveNotifyReq)
  SharedDtor();
}

void CSPveNotifyReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPveNotifyReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPveNotifyReq& CSPveNotifyReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSPveNotifyReq* CSPveNotifyReq::default_instance_ = NULL;

CSPveNotifyReq* CSPveNotifyReq::New() const {
  return new CSPveNotifyReq;
}

void CSPveNotifyReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPveNotifyReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(checkpoint_, battletime_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPveNotifyReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPveNotifyReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 CheckPoint = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &checkpoint_)));
          set_has_checkpoint();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Action;
        break;
      }

      // required uint32 Action = 2;
      case 2: {
        if (tag == 16) {
         parse_Action:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &action_)));
          set_has_action();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_ChapterId;
        break;
      }

      // required uint32 ChapterId = 3;
      case 3: {
        if (tag == 24) {
         parse_ChapterId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chapterid_)));
          set_has_chapterid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_NeedPower;
        break;
      }

      // required bool NeedPower = 4;
      case 4: {
        if (tag == 32) {
         parse_NeedPower:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &needpower_)));
          set_has_needpower();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_BattleTime;
        break;
      }

      // optional uint32 BattleTime = 5;
      case 5: {
        if (tag == 40) {
         parse_BattleTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &battletime_)));
          set_has_battletime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPveNotifyReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPveNotifyReq)
  return false;
#undef DO_
}

void CSPveNotifyReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPveNotifyReq)
  // required uint32 CheckPoint = 1;
  if (has_checkpoint()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->checkpoint(), output);
  }

  // required uint32 Action = 2;
  if (has_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->action(), output);
  }

  // required uint32 ChapterId = 3;
  if (has_chapterid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->chapterid(), output);
  }

  // required bool NeedPower = 4;
  if (has_needpower()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->needpower(), output);
  }

  // optional uint32 BattleTime = 5;
  if (has_battletime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->battletime(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPveNotifyReq)
}

int CSPveNotifyReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 CheckPoint = 1;
    if (has_checkpoint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->checkpoint());
    }

    // required uint32 Action = 2;
    if (has_action()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->action());
    }

    // required uint32 ChapterId = 3;
    if (has_chapterid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chapterid());
    }

    // required bool NeedPower = 4;
    if (has_needpower()) {
      total_size += 1 + 1;
    }

    // optional uint32 BattleTime = 5;
    if (has_battletime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->battletime());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPveNotifyReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPveNotifyReq*>(&from));
}

void CSPveNotifyReq::MergeFrom(const CSPveNotifyReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_checkpoint()) {
      set_checkpoint(from.checkpoint());
    }
    if (from.has_action()) {
      set_action(from.action());
    }
    if (from.has_chapterid()) {
      set_chapterid(from.chapterid());
    }
    if (from.has_needpower()) {
      set_needpower(from.needpower());
    }
    if (from.has_battletime()) {
      set_battletime(from.battletime());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPveNotifyReq::CopyFrom(const CSPveNotifyReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPveNotifyReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void CSPveNotifyReq::Swap(CSPveNotifyReq* other) {
  if (other != this) {
    std::swap(checkpoint_, other->checkpoint_);
    std::swap(action_, other->action_);
    std::swap(chapterid_, other->chapterid_);
    std::swap(needpower_, other->needpower_);
    std::swap(battletime_, other->battletime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPveNotifyReq::GetTypeName() const {
  return "fgame.CSPveNotifyReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPveNotifyResp::kNeedPowerFieldNumber;
#endif  // !_MSC_VER

CSPveNotifyResp::CSPveNotifyResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPveNotifyResp)
}

void CSPveNotifyResp::InitAsDefaultInstance() {
}

CSPveNotifyResp::CSPveNotifyResp(const CSPveNotifyResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPveNotifyResp)
}

void CSPveNotifyResp::SharedCtor() {
  _cached_size_ = 0;
  needpower_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPveNotifyResp::~CSPveNotifyResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPveNotifyResp)
  SharedDtor();
}

void CSPveNotifyResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPveNotifyResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPveNotifyResp& CSPveNotifyResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSPveNotifyResp* CSPveNotifyResp::default_instance_ = NULL;

CSPveNotifyResp* CSPveNotifyResp::New() const {
  return new CSPveNotifyResp;
}

void CSPveNotifyResp::Clear() {
  needpower_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPveNotifyResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPveNotifyResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool NeedPower = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &needpower_)));
          set_has_needpower();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPveNotifyResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPveNotifyResp)
  return false;
#undef DO_
}

void CSPveNotifyResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPveNotifyResp)
  // required bool NeedPower = 1;
  if (has_needpower()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->needpower(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPveNotifyResp)
}

int CSPveNotifyResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool NeedPower = 1;
    if (has_needpower()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPveNotifyResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPveNotifyResp*>(&from));
}

void CSPveNotifyResp::MergeFrom(const CSPveNotifyResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_needpower()) {
      set_needpower(from.needpower());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPveNotifyResp::CopyFrom(const CSPveNotifyResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPveNotifyResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPveNotifyResp::Swap(CSPveNotifyResp* other) {
  if (other != this) {
    std::swap(needpower_, other->needpower_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPveNotifyResp::GetTypeName() const {
  return "fgame.CSPveNotifyResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSPveCheckAwardReq::CSPveCheckAwardReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPveCheckAwardReq)
}

void CSPveCheckAwardReq::InitAsDefaultInstance() {
}

CSPveCheckAwardReq::CSPveCheckAwardReq(const CSPveCheckAwardReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPveCheckAwardReq)
}

void CSPveCheckAwardReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPveCheckAwardReq::~CSPveCheckAwardReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPveCheckAwardReq)
  SharedDtor();
}

void CSPveCheckAwardReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPveCheckAwardReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPveCheckAwardReq& CSPveCheckAwardReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSPveCheckAwardReq* CSPveCheckAwardReq::default_instance_ = NULL;

CSPveCheckAwardReq* CSPveCheckAwardReq::New() const {
  return new CSPveCheckAwardReq;
}

void CSPveCheckAwardReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPveCheckAwardReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPveCheckAwardReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPveCheckAwardReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPveCheckAwardReq)
  return false;
#undef DO_
}

void CSPveCheckAwardReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPveCheckAwardReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPveCheckAwardReq)
}

int CSPveCheckAwardReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPveCheckAwardReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPveCheckAwardReq*>(&from));
}

void CSPveCheckAwardReq::MergeFrom(const CSPveCheckAwardReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPveCheckAwardReq::CopyFrom(const CSPveCheckAwardReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPveCheckAwardReq::IsInitialized() const {

  return true;
}

void CSPveCheckAwardReq::Swap(CSPveCheckAwardReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPveCheckAwardReq::GetTypeName() const {
  return "fgame.CSPveCheckAwardReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPveCheckAwardResp::kHaveAwardFieldNumber;
const int CSPveCheckAwardResp::kGiftIDFieldNumber;
#endif  // !_MSC_VER

CSPveCheckAwardResp::CSPveCheckAwardResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPveCheckAwardResp)
}

void CSPveCheckAwardResp::InitAsDefaultInstance() {
}

CSPveCheckAwardResp::CSPveCheckAwardResp(const CSPveCheckAwardResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPveCheckAwardResp)
}

void CSPveCheckAwardResp::SharedCtor() {
  _cached_size_ = 0;
  haveaward_ = false;
  giftid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPveCheckAwardResp::~CSPveCheckAwardResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPveCheckAwardResp)
  SharedDtor();
}

void CSPveCheckAwardResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPveCheckAwardResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPveCheckAwardResp& CSPveCheckAwardResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSPveCheckAwardResp* CSPveCheckAwardResp::default_instance_ = NULL;

CSPveCheckAwardResp* CSPveCheckAwardResp::New() const {
  return new CSPveCheckAwardResp;
}

void CSPveCheckAwardResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPveCheckAwardResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(haveaward_, giftid_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPveCheckAwardResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPveCheckAwardResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool HaveAward = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &haveaward_)));
          set_has_haveaward();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_GiftID;
        break;
      }

      // optional uint32 GiftID = 2;
      case 2: {
        if (tag == 16) {
         parse_GiftID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &giftid_)));
          set_has_giftid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPveCheckAwardResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPveCheckAwardResp)
  return false;
#undef DO_
}

void CSPveCheckAwardResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPveCheckAwardResp)
  // required bool HaveAward = 1;
  if (has_haveaward()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->haveaward(), output);
  }

  // optional uint32 GiftID = 2;
  if (has_giftid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->giftid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPveCheckAwardResp)
}

int CSPveCheckAwardResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool HaveAward = 1;
    if (has_haveaward()) {
      total_size += 1 + 1;
    }

    // optional uint32 GiftID = 2;
    if (has_giftid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->giftid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPveCheckAwardResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPveCheckAwardResp*>(&from));
}

void CSPveCheckAwardResp::MergeFrom(const CSPveCheckAwardResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_haveaward()) {
      set_haveaward(from.haveaward());
    }
    if (from.has_giftid()) {
      set_giftid(from.giftid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPveCheckAwardResp::CopyFrom(const CSPveCheckAwardResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPveCheckAwardResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPveCheckAwardResp::Swap(CSPveCheckAwardResp* other) {
  if (other != this) {
    std::swap(haveaward_, other->haveaward_);
    std::swap(giftid_, other->giftid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPveCheckAwardResp::GetTypeName() const {
  return "fgame.CSPveCheckAwardResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvePveRank::kCpIdFieldNumber;
const int CSPvePveRank::kDataFieldNumber;
#endif  // !_MSC_VER

CSPvePveRank::CSPvePveRank()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvePveRank)
}

void CSPvePveRank::InitAsDefaultInstance() {
}

CSPvePveRank::CSPvePveRank(const CSPvePveRank& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvePveRank)
}

void CSPvePveRank::SharedCtor() {
  _cached_size_ = 0;
  cpid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvePveRank::~CSPvePveRank() {
  // @@protoc_insertion_point(destructor:fgame.CSPvePveRank)
  SharedDtor();
}

void CSPvePveRank::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvePveRank::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvePveRank& CSPvePveRank::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSPvePveRank* CSPvePveRank::default_instance_ = NULL;

CSPvePveRank* CSPvePveRank::New() const {
  return new CSPvePveRank;
}

void CSPvePveRank::Clear() {
  cpid_ = 0u;
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvePveRank::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvePveRank)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 CpId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cpid_)));
          set_has_cpid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Data;
        break;
      }

      // repeated .fgame.CSPveRankData Data = 2;
      case 2: {
        if (tag == 18) {
         parse_Data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Data;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvePveRank)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvePveRank)
  return false;
#undef DO_
}

void CSPvePveRank::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvePveRank)
  // required uint32 CpId = 1;
  if (has_cpid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->cpid(), output);
  }

  // repeated .fgame.CSPveRankData Data = 2;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->data(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvePveRank)
}

int CSPvePveRank::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 CpId = 1;
    if (has_cpid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cpid());
    }

  }
  // repeated .fgame.CSPveRankData Data = 2;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvePveRank::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvePveRank*>(&from));
}

void CSPvePveRank::MergeFrom(const CSPvePveRank& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cpid()) {
      set_cpid(from.cpid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvePveRank::CopyFrom(const CSPvePveRank& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvePveRank::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPvePveRank::Swap(CSPvePveRank* other) {
  if (other != this) {
    std::swap(cpid_, other->cpid_);
    data_.Swap(&other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvePveRank::GetTypeName() const {
  return "fgame.CSPvePveRank";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPveRankData::kRankFieldNumber;
const int CSPveRankData::kUinFieldNumber;
const int CSPveRankData::kNameFieldNumber;
const int CSPveRankData::kAvatorFieldNumber;
const int CSPveRankData::kScoreFieldNumber;
#endif  // !_MSC_VER

CSPveRankData::CSPveRankData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPveRankData)
}

void CSPveRankData::InitAsDefaultInstance() {
}

CSPveRankData::CSPveRankData(const CSPveRankData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPveRankData)
}

void CSPveRankData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  rank_ = 0u;
  uin_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  avator_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  score_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPveRankData::~CSPveRankData() {
  // @@protoc_insertion_point(destructor:fgame.CSPveRankData)
  SharedDtor();
}

void CSPveRankData::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (avator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avator_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPveRankData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPveRankData& CSPveRankData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSPveRankData* CSPveRankData::default_instance_ = NULL;

CSPveRankData* CSPveRankData::New() const {
  return new CSPveRankData;
}

void CSPveRankData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPveRankData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(rank_, uin_);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_avator()) {
      if (avator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        avator_->clear();
      }
    }
    score_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPveRankData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPveRankData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 Rank = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_)));
          set_has_rank();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Uin;
        break;
      }

      // optional uint32 Uin = 2;
      case 2: {
        if (tag == 16) {
         parse_Uin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_Name;
        break;
      }

      // optional string Name = 3;
      case 3: {
        if (tag == 26) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_Avator;
        break;
      }

      // optional string Avator = 4;
      case 4: {
        if (tag == 34) {
         parse_Avator:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_avator()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_Score;
        break;
      }

      // optional uint32 Score = 5;
      case 5: {
        if (tag == 40) {
         parse_Score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPveRankData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPveRankData)
  return false;
#undef DO_
}

void CSPveRankData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPveRankData)
  // optional uint32 Rank = 1;
  if (has_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->rank(), output);
  }

  // optional uint32 Uin = 2;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->uin(), output);
  }

  // optional string Name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // optional string Avator = 4;
  if (has_avator()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->avator(), output);
  }

  // optional uint32 Score = 5;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->score(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPveRankData)
}

int CSPveRankData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 Rank = 1;
    if (has_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank());
    }

    // optional uint32 Uin = 2;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uin());
    }

    // optional string Name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string Avator = 4;
    if (has_avator()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->avator());
    }

    // optional uint32 Score = 5;
    if (has_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->score());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPveRankData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPveRankData*>(&from));
}

void CSPveRankData::MergeFrom(const CSPveRankData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rank()) {
      set_rank(from.rank());
    }
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_avator()) {
      set_avator(from.avator());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPveRankData::CopyFrom(const CSPveRankData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPveRankData::IsInitialized() const {

  return true;
}

void CSPveRankData::Swap(CSPveRankData* other) {
  if (other != this) {
    std::swap(rank_, other->rank_);
    std::swap(uin_, other->uin_);
    std::swap(name_, other->name_);
    std::swap(avator_, other->avator_);
    std::swap(score_, other->score_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPveRankData::GetTypeName() const {
  return "fgame.CSPveRankData";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSPveRankReq::CSPveRankReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPveRankReq)
}

void CSPveRankReq::InitAsDefaultInstance() {
}

CSPveRankReq::CSPveRankReq(const CSPveRankReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPveRankReq)
}

void CSPveRankReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPveRankReq::~CSPveRankReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPveRankReq)
  SharedDtor();
}

void CSPveRankReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPveRankReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPveRankReq& CSPveRankReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSPveRankReq* CSPveRankReq::default_instance_ = NULL;

CSPveRankReq* CSPveRankReq::New() const {
  return new CSPveRankReq;
}

void CSPveRankReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPveRankReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPveRankReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPveRankReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPveRankReq)
  return false;
#undef DO_
}

void CSPveRankReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPveRankReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPveRankReq)
}

int CSPveRankReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPveRankReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPveRankReq*>(&from));
}

void CSPveRankReq::MergeFrom(const CSPveRankReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPveRankReq::CopyFrom(const CSPveRankReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPveRankReq::IsInitialized() const {

  return true;
}

void CSPveRankReq::Swap(CSPveRankReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPveRankReq::GetTypeName() const {
  return "fgame.CSPveRankReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPveRankResp::kRankFieldNumber;
#endif  // !_MSC_VER

CSPveRankResp::CSPveRankResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPveRankResp)
}

void CSPveRankResp::InitAsDefaultInstance() {
}

CSPveRankResp::CSPveRankResp(const CSPveRankResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPveRankResp)
}

void CSPveRankResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPveRankResp::~CSPveRankResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPveRankResp)
  SharedDtor();
}

void CSPveRankResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPveRankResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPveRankResp& CSPveRankResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSPveRankResp* CSPveRankResp::default_instance_ = NULL;

CSPveRankResp* CSPveRankResp::New() const {
  return new CSPveRankResp;
}

void CSPveRankResp::Clear() {
  rank_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPveRankResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPveRankResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.CSPvePveRank Rank = 1;
      case 1: {
        if (tag == 10) {
         parse_Rank:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_rank()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_Rank;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPveRankResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPveRankResp)
  return false;
#undef DO_
}

void CSPveRankResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPveRankResp)
  // repeated .fgame.CSPvePveRank Rank = 1;
  for (int i = 0; i < this->rank_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->rank(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPveRankResp)
}

int CSPveRankResp::ByteSize() const {
  int total_size = 0;

  // repeated .fgame.CSPvePveRank Rank = 1;
  total_size += 1 * this->rank_size();
  for (int i = 0; i < this->rank_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rank(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPveRankResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPveRankResp*>(&from));
}

void CSPveRankResp::MergeFrom(const CSPveRankResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  rank_.MergeFrom(from.rank_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPveRankResp::CopyFrom(const CSPveRankResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPveRankResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->rank())) return false;
  return true;
}

void CSPveRankResp::Swap(CSPveRankResp* other) {
  if (other != this) {
    rank_.Swap(&other->rank_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPveRankResp::GetTypeName() const {
  return "fgame.CSPveRankResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSOpenChestResp::kUpdateDataFieldNumber;
#endif  // !_MSC_VER

CSOpenChestResp::CSOpenChestResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSOpenChestResp)
}

void CSOpenChestResp::InitAsDefaultInstance() {
}

CSOpenChestResp::CSOpenChestResp(const CSOpenChestResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSOpenChestResp)
}

void CSOpenChestResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSOpenChestResp::~CSOpenChestResp() {
  // @@protoc_insertion_point(destructor:fgame.CSOpenChestResp)
  SharedDtor();
}

void CSOpenChestResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSOpenChestResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSOpenChestResp& CSOpenChestResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSOpenChestResp* CSOpenChestResp::default_instance_ = NULL;

CSOpenChestResp* CSOpenChestResp::New() const {
  return new CSOpenChestResp;
}

void CSOpenChestResp::Clear() {
  updatedata_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSOpenChestResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSOpenChestResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.PropertyUpdateData UpdateData = 1;
      case 1: {
        if (tag == 10) {
         parse_UpdateData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_updatedata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_UpdateData;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSOpenChestResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSOpenChestResp)
  return false;
#undef DO_
}

void CSOpenChestResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSOpenChestResp)
  // repeated .fgame.PropertyUpdateData UpdateData = 1;
  for (int i = 0; i < this->updatedata_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->updatedata(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSOpenChestResp)
}

int CSOpenChestResp::ByteSize() const {
  int total_size = 0;

  // repeated .fgame.PropertyUpdateData UpdateData = 1;
  total_size += 1 * this->updatedata_size();
  for (int i = 0; i < this->updatedata_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->updatedata(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSOpenChestResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSOpenChestResp*>(&from));
}

void CSOpenChestResp::MergeFrom(const CSOpenChestResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  updatedata_.MergeFrom(from.updatedata_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSOpenChestResp::CopyFrom(const CSOpenChestResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOpenChestResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->updatedata())) return false;
  return true;
}

void CSOpenChestResp::Swap(CSOpenChestResp* other) {
  if (other != this) {
    updatedata_.Swap(&other->updatedata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSOpenChestResp::GetTypeName() const {
  return "fgame.CSOpenChestResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSetSignatureReq::kSignatureFieldNumber;
#endif  // !_MSC_VER

CSSetSignatureReq::CSSetSignatureReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSetSignatureReq)
}

void CSSetSignatureReq::InitAsDefaultInstance() {
}

CSSetSignatureReq::CSSetSignatureReq(const CSSetSignatureReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSetSignatureReq)
}

void CSSetSignatureReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSetSignatureReq::~CSSetSignatureReq() {
  // @@protoc_insertion_point(destructor:fgame.CSSetSignatureReq)
  SharedDtor();
}

void CSSetSignatureReq::SharedDtor() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSetSignatureReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSetSignatureReq& CSSetSignatureReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSetSignatureReq* CSSetSignatureReq::default_instance_ = NULL;

CSSetSignatureReq* CSSetSignatureReq::New() const {
  return new CSSetSignatureReq;
}

void CSSetSignatureReq::Clear() {
  if (has_signature()) {
    if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      signature_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSetSignatureReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSetSignatureReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string Signature = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSetSignatureReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSetSignatureReq)
  return false;
#undef DO_
}

void CSSetSignatureReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSetSignatureReq)
  // required string Signature = 1;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->signature(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSetSignatureReq)
}

int CSSetSignatureReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string Signature = 1;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->signature());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSetSignatureReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSetSignatureReq*>(&from));
}

void CSSetSignatureReq::MergeFrom(const CSSetSignatureReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_signature()) {
      set_signature(from.signature());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSetSignatureReq::CopyFrom(const CSSetSignatureReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSetSignatureReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSSetSignatureReq::Swap(CSSetSignatureReq* other) {
  if (other != this) {
    std::swap(signature_, other->signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSetSignatureReq::GetTypeName() const {
  return "fgame.CSSetSignatureReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSetSignatureResp::kSignatureFieldNumber;
#endif  // !_MSC_VER

CSSetSignatureResp::CSSetSignatureResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSetSignatureResp)
}

void CSSetSignatureResp::InitAsDefaultInstance() {
}

CSSetSignatureResp::CSSetSignatureResp(const CSSetSignatureResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSetSignatureResp)
}

void CSSetSignatureResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSetSignatureResp::~CSSetSignatureResp() {
  // @@protoc_insertion_point(destructor:fgame.CSSetSignatureResp)
  SharedDtor();
}

void CSSetSignatureResp::SharedDtor() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSetSignatureResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSetSignatureResp& CSSetSignatureResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSetSignatureResp* CSSetSignatureResp::default_instance_ = NULL;

CSSetSignatureResp* CSSetSignatureResp::New() const {
  return new CSSetSignatureResp;
}

void CSSetSignatureResp::Clear() {
  if (has_signature()) {
    if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      signature_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSetSignatureResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSetSignatureResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string Signature = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSetSignatureResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSetSignatureResp)
  return false;
#undef DO_
}

void CSSetSignatureResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSetSignatureResp)
  // required string Signature = 1;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->signature(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSetSignatureResp)
}

int CSSetSignatureResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string Signature = 1;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->signature());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSetSignatureResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSetSignatureResp*>(&from));
}

void CSSetSignatureResp::MergeFrom(const CSSetSignatureResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_signature()) {
      set_signature(from.signature());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSetSignatureResp::CopyFrom(const CSSetSignatureResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSetSignatureResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSSetSignatureResp::Swap(CSSetSignatureResp* other) {
  if (other != this) {
    std::swap(signature_, other->signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSetSignatureResp::GetTypeName() const {
  return "fgame.CSSetSignatureResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSetExtraInfoVisibleReq::kVisibleFieldNumber;
#endif  // !_MSC_VER

CSSetExtraInfoVisibleReq::CSSetExtraInfoVisibleReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSetExtraInfoVisibleReq)
}

void CSSetExtraInfoVisibleReq::InitAsDefaultInstance() {
}

CSSetExtraInfoVisibleReq::CSSetExtraInfoVisibleReq(const CSSetExtraInfoVisibleReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSetExtraInfoVisibleReq)
}

void CSSetExtraInfoVisibleReq::SharedCtor() {
  _cached_size_ = 0;
  visible_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSetExtraInfoVisibleReq::~CSSetExtraInfoVisibleReq() {
  // @@protoc_insertion_point(destructor:fgame.CSSetExtraInfoVisibleReq)
  SharedDtor();
}

void CSSetExtraInfoVisibleReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSetExtraInfoVisibleReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSetExtraInfoVisibleReq& CSSetExtraInfoVisibleReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSetExtraInfoVisibleReq* CSSetExtraInfoVisibleReq::default_instance_ = NULL;

CSSetExtraInfoVisibleReq* CSSetExtraInfoVisibleReq::New() const {
  return new CSSetExtraInfoVisibleReq;
}

void CSSetExtraInfoVisibleReq::Clear() {
  visible_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSetExtraInfoVisibleReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSetExtraInfoVisibleReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool Visible = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &visible_)));
          set_has_visible();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSetExtraInfoVisibleReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSetExtraInfoVisibleReq)
  return false;
#undef DO_
}

void CSSetExtraInfoVisibleReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSetExtraInfoVisibleReq)
  // required bool Visible = 1;
  if (has_visible()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->visible(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSetExtraInfoVisibleReq)
}

int CSSetExtraInfoVisibleReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool Visible = 1;
    if (has_visible()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSetExtraInfoVisibleReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSetExtraInfoVisibleReq*>(&from));
}

void CSSetExtraInfoVisibleReq::MergeFrom(const CSSetExtraInfoVisibleReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_visible()) {
      set_visible(from.visible());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSetExtraInfoVisibleReq::CopyFrom(const CSSetExtraInfoVisibleReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSetExtraInfoVisibleReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSSetExtraInfoVisibleReq::Swap(CSSetExtraInfoVisibleReq* other) {
  if (other != this) {
    std::swap(visible_, other->visible_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSetExtraInfoVisibleReq::GetTypeName() const {
  return "fgame.CSSetExtraInfoVisibleReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSSetExtraInfoVisibleResp::kVisibleFieldNumber;
#endif  // !_MSC_VER

CSSetExtraInfoVisibleResp::CSSetExtraInfoVisibleResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSSetExtraInfoVisibleResp)
}

void CSSetExtraInfoVisibleResp::InitAsDefaultInstance() {
}

CSSetExtraInfoVisibleResp::CSSetExtraInfoVisibleResp(const CSSetExtraInfoVisibleResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSSetExtraInfoVisibleResp)
}

void CSSetExtraInfoVisibleResp::SharedCtor() {
  _cached_size_ = 0;
  visible_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSSetExtraInfoVisibleResp::~CSSetExtraInfoVisibleResp() {
  // @@protoc_insertion_point(destructor:fgame.CSSetExtraInfoVisibleResp)
  SharedDtor();
}

void CSSetExtraInfoVisibleResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSSetExtraInfoVisibleResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSSetExtraInfoVisibleResp& CSSetExtraInfoVisibleResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSSetExtraInfoVisibleResp* CSSetExtraInfoVisibleResp::default_instance_ = NULL;

CSSetExtraInfoVisibleResp* CSSetExtraInfoVisibleResp::New() const {
  return new CSSetExtraInfoVisibleResp;
}

void CSSetExtraInfoVisibleResp::Clear() {
  visible_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSSetExtraInfoVisibleResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSSetExtraInfoVisibleResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool Visible = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &visible_)));
          set_has_visible();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSSetExtraInfoVisibleResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSSetExtraInfoVisibleResp)
  return false;
#undef DO_
}

void CSSetExtraInfoVisibleResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSSetExtraInfoVisibleResp)
  // required bool Visible = 1;
  if (has_visible()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->visible(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSSetExtraInfoVisibleResp)
}

int CSSetExtraInfoVisibleResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool Visible = 1;
    if (has_visible()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSSetExtraInfoVisibleResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSSetExtraInfoVisibleResp*>(&from));
}

void CSSetExtraInfoVisibleResp::MergeFrom(const CSSetExtraInfoVisibleResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_visible()) {
      set_visible(from.visible());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSSetExtraInfoVisibleResp::CopyFrom(const CSSetExtraInfoVisibleResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSetExtraInfoVisibleResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSSetExtraInfoVisibleResp::Swap(CSSetExtraInfoVisibleResp* other) {
  if (other != this) {
    std::swap(visible_, other->visible_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSSetExtraInfoVisibleResp::GetTypeName() const {
  return "fgame.CSSetExtraInfoVisibleResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGetExtraInfoReq::kUinFieldNumber;
#endif  // !_MSC_VER

CSGetExtraInfoReq::CSGetExtraInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetExtraInfoReq)
}

void CSGetExtraInfoReq::InitAsDefaultInstance() {
}

CSGetExtraInfoReq::CSGetExtraInfoReq(const CSGetExtraInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetExtraInfoReq)
}

void CSGetExtraInfoReq::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetExtraInfoReq::~CSGetExtraInfoReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGetExtraInfoReq)
  SharedDtor();
}

void CSGetExtraInfoReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetExtraInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetExtraInfoReq& CSGetExtraInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetExtraInfoReq* CSGetExtraInfoReq::default_instance_ = NULL;

CSGetExtraInfoReq* CSGetExtraInfoReq::New() const {
  return new CSGetExtraInfoReq;
}

void CSGetExtraInfoReq::Clear() {
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetExtraInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetExtraInfoReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetExtraInfoReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetExtraInfoReq)
  return false;
#undef DO_
}

void CSGetExtraInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetExtraInfoReq)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetExtraInfoReq)
}

int CSGetExtraInfoReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetExtraInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetExtraInfoReq*>(&from));
}

void CSGetExtraInfoReq::MergeFrom(const CSGetExtraInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetExtraInfoReq::CopyFrom(const CSGetExtraInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetExtraInfoReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSGetExtraInfoReq::Swap(CSGetExtraInfoReq* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetExtraInfoReq::GetTypeName() const {
  return "fgame.CSGetExtraInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGetExtraInfoResp::kUinFieldNumber;
const int CSGetExtraInfoResp::kTotalPvpCountFieldNumber;
const int CSGetExtraInfoResp::kTotalPveCountFieldNumber;
const int CSGetExtraInfoResp::kTotalPvpUseItemFieldNumber;
const int CSGetExtraInfoResp::kTotalPveUseItemFieldNumber;
const int CSGetExtraInfoResp::kMaxPvpPointFieldNumber;
const int CSGetExtraInfoResp::kMaxPvpWinCountFieldNumber;
#endif  // !_MSC_VER

CSGetExtraInfoResp::CSGetExtraInfoResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetExtraInfoResp)
}

void CSGetExtraInfoResp::InitAsDefaultInstance() {
}

CSGetExtraInfoResp::CSGetExtraInfoResp(const CSGetExtraInfoResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetExtraInfoResp)
}

void CSGetExtraInfoResp::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  totalpvpcount_ = 0u;
  totalpvecount_ = 0u;
  totalpvpuseitem_ = 0u;
  totalpveuseitem_ = 0u;
  maxpvppoint_ = 0u;
  maxpvpwincount_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetExtraInfoResp::~CSGetExtraInfoResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGetExtraInfoResp)
  SharedDtor();
}

void CSGetExtraInfoResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetExtraInfoResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetExtraInfoResp& CSGetExtraInfoResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetExtraInfoResp* CSGetExtraInfoResp::default_instance_ = NULL;

CSGetExtraInfoResp* CSGetExtraInfoResp::New() const {
  return new CSGetExtraInfoResp;
}

void CSGetExtraInfoResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSGetExtraInfoResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(uin_, maxpvpwincount_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetExtraInfoResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetExtraInfoResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_TotalPvpCount;
        break;
      }

      // optional uint32 TotalPvpCount = 2;
      case 2: {
        if (tag == 16) {
         parse_TotalPvpCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &totalpvpcount_)));
          set_has_totalpvpcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_TotalPveCount;
        break;
      }

      // optional uint32 TotalPveCount = 3;
      case 3: {
        if (tag == 24) {
         parse_TotalPveCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &totalpvecount_)));
          set_has_totalpvecount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_TotalPvpUseItem;
        break;
      }

      // optional uint32 TotalPvpUseItem = 4;
      case 4: {
        if (tag == 32) {
         parse_TotalPvpUseItem:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &totalpvpuseitem_)));
          set_has_totalpvpuseitem();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_TotalPveUseItem;
        break;
      }

      // optional uint32 TotalPveUseItem = 5;
      case 5: {
        if (tag == 40) {
         parse_TotalPveUseItem:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &totalpveuseitem_)));
          set_has_totalpveuseitem();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_MaxPvpPoint;
        break;
      }

      // optional uint32 MaxPvpPoint = 6;
      case 6: {
        if (tag == 48) {
         parse_MaxPvpPoint:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &maxpvppoint_)));
          set_has_maxpvppoint();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_MaxPvpWinCount;
        break;
      }

      // optional uint32 MaxPvpWinCount = 7;
      case 7: {
        if (tag == 56) {
         parse_MaxPvpWinCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &maxpvpwincount_)));
          set_has_maxpvpwincount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetExtraInfoResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetExtraInfoResp)
  return false;
#undef DO_
}

void CSGetExtraInfoResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetExtraInfoResp)
  // optional uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  // optional uint32 TotalPvpCount = 2;
  if (has_totalpvpcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->totalpvpcount(), output);
  }

  // optional uint32 TotalPveCount = 3;
  if (has_totalpvecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->totalpvecount(), output);
  }

  // optional uint32 TotalPvpUseItem = 4;
  if (has_totalpvpuseitem()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->totalpvpuseitem(), output);
  }

  // optional uint32 TotalPveUseItem = 5;
  if (has_totalpveuseitem()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->totalpveuseitem(), output);
  }

  // optional uint32 MaxPvpPoint = 6;
  if (has_maxpvppoint()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->maxpvppoint(), output);
  }

  // optional uint32 MaxPvpWinCount = 7;
  if (has_maxpvpwincount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->maxpvpwincount(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetExtraInfoResp)
}

int CSGetExtraInfoResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

    // optional uint32 TotalPvpCount = 2;
    if (has_totalpvpcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->totalpvpcount());
    }

    // optional uint32 TotalPveCount = 3;
    if (has_totalpvecount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->totalpvecount());
    }

    // optional uint32 TotalPvpUseItem = 4;
    if (has_totalpvpuseitem()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->totalpvpuseitem());
    }

    // optional uint32 TotalPveUseItem = 5;
    if (has_totalpveuseitem()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->totalpveuseitem());
    }

    // optional uint32 MaxPvpPoint = 6;
    if (has_maxpvppoint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->maxpvppoint());
    }

    // optional uint32 MaxPvpWinCount = 7;
    if (has_maxpvpwincount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->maxpvpwincount());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetExtraInfoResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetExtraInfoResp*>(&from));
}

void CSGetExtraInfoResp::MergeFrom(const CSGetExtraInfoResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_totalpvpcount()) {
      set_totalpvpcount(from.totalpvpcount());
    }
    if (from.has_totalpvecount()) {
      set_totalpvecount(from.totalpvecount());
    }
    if (from.has_totalpvpuseitem()) {
      set_totalpvpuseitem(from.totalpvpuseitem());
    }
    if (from.has_totalpveuseitem()) {
      set_totalpveuseitem(from.totalpveuseitem());
    }
    if (from.has_maxpvppoint()) {
      set_maxpvppoint(from.maxpvppoint());
    }
    if (from.has_maxpvpwincount()) {
      set_maxpvpwincount(from.maxpvpwincount());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetExtraInfoResp::CopyFrom(const CSGetExtraInfoResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetExtraInfoResp::IsInitialized() const {

  return true;
}

void CSGetExtraInfoResp::Swap(CSGetExtraInfoResp* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(totalpvpcount_, other->totalpvpcount_);
    std::swap(totalpvecount_, other->totalpvecount_);
    std::swap(totalpvpuseitem_, other->totalpvpuseitem_);
    std::swap(totalpveuseitem_, other->totalpveuseitem_);
    std::swap(maxpvppoint_, other->maxpvppoint_);
    std::swap(maxpvpwincount_, other->maxpvpwincount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetExtraInfoResp::GetTypeName() const {
  return "fgame.CSGetExtraInfoResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSShareRewardGetResq::kRetFieldNumber;
const int CSShareRewardGetResq::kShareIdFieldNumber;
#endif  // !_MSC_VER

CSShareRewardGetResq::CSShareRewardGetResq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSShareRewardGetResq)
}

void CSShareRewardGetResq::InitAsDefaultInstance() {
}

CSShareRewardGetResq::CSShareRewardGetResq(const CSShareRewardGetResq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSShareRewardGetResq)
}

void CSShareRewardGetResq::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  shareid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSShareRewardGetResq::~CSShareRewardGetResq() {
  // @@protoc_insertion_point(destructor:fgame.CSShareRewardGetResq)
  SharedDtor();
}

void CSShareRewardGetResq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSShareRewardGetResq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSShareRewardGetResq& CSShareRewardGetResq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSShareRewardGetResq* CSShareRewardGetResq::default_instance_ = NULL;

CSShareRewardGetResq* CSShareRewardGetResq::New() const {
  return new CSShareRewardGetResq;
}

void CSShareRewardGetResq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSShareRewardGetResq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ret_, shareid_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSShareRewardGetResq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSShareRewardGetResq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ShareId;
        break;
      }

      // required uint32 ShareId = 2;
      case 2: {
        if (tag == 16) {
         parse_ShareId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shareid_)));
          set_has_shareid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSShareRewardGetResq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSShareRewardGetResq)
  return false;
#undef DO_
}

void CSShareRewardGetResq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSShareRewardGetResq)
  // required uint32 Ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // required uint32 ShareId = 2;
  if (has_shareid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->shareid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSShareRewardGetResq)
}

int CSShareRewardGetResq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // required uint32 ShareId = 2;
    if (has_shareid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shareid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSShareRewardGetResq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSShareRewardGetResq*>(&from));
}

void CSShareRewardGetResq::MergeFrom(const CSShareRewardGetResq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_shareid()) {
      set_shareid(from.shareid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSShareRewardGetResq::CopyFrom(const CSShareRewardGetResq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSShareRewardGetResq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSShareRewardGetResq::Swap(CSShareRewardGetResq* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(shareid_, other->shareid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSShareRewardGetResq::GetTypeName() const {
  return "fgame.CSShareRewardGetResq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSShareRewardGetReq::kShareIdFieldNumber;
#endif  // !_MSC_VER

CSShareRewardGetReq::CSShareRewardGetReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSShareRewardGetReq)
}

void CSShareRewardGetReq::InitAsDefaultInstance() {
}

CSShareRewardGetReq::CSShareRewardGetReq(const CSShareRewardGetReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSShareRewardGetReq)
}

void CSShareRewardGetReq::SharedCtor() {
  _cached_size_ = 0;
  shareid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSShareRewardGetReq::~CSShareRewardGetReq() {
  // @@protoc_insertion_point(destructor:fgame.CSShareRewardGetReq)
  SharedDtor();
}

void CSShareRewardGetReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSShareRewardGetReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSShareRewardGetReq& CSShareRewardGetReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSShareRewardGetReq* CSShareRewardGetReq::default_instance_ = NULL;

CSShareRewardGetReq* CSShareRewardGetReq::New() const {
  return new CSShareRewardGetReq;
}

void CSShareRewardGetReq::Clear() {
  shareid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSShareRewardGetReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSShareRewardGetReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ShareId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shareid_)));
          set_has_shareid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSShareRewardGetReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSShareRewardGetReq)
  return false;
#undef DO_
}

void CSShareRewardGetReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSShareRewardGetReq)
  // required uint32 ShareId = 1;
  if (has_shareid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->shareid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSShareRewardGetReq)
}

int CSShareRewardGetReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ShareId = 1;
    if (has_shareid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shareid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSShareRewardGetReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSShareRewardGetReq*>(&from));
}

void CSShareRewardGetReq::MergeFrom(const CSShareRewardGetReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_shareid()) {
      set_shareid(from.shareid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSShareRewardGetReq::CopyFrom(const CSShareRewardGetReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSShareRewardGetReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSShareRewardGetReq::Swap(CSShareRewardGetReq* other) {
  if (other != this) {
    std::swap(shareid_, other->shareid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSShareRewardGetReq::GetTypeName() const {
  return "fgame.CSShareRewardGetReq";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSGetSevenGoalListReq::CSGetSevenGoalListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetSevenGoalListReq)
}

void CSGetSevenGoalListReq::InitAsDefaultInstance() {
}

CSGetSevenGoalListReq::CSGetSevenGoalListReq(const CSGetSevenGoalListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetSevenGoalListReq)
}

void CSGetSevenGoalListReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetSevenGoalListReq::~CSGetSevenGoalListReq() {
  // @@protoc_insertion_point(destructor:fgame.CSGetSevenGoalListReq)
  SharedDtor();
}

void CSGetSevenGoalListReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetSevenGoalListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetSevenGoalListReq& CSGetSevenGoalListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetSevenGoalListReq* CSGetSevenGoalListReq::default_instance_ = NULL;

CSGetSevenGoalListReq* CSGetSevenGoalListReq::New() const {
  return new CSGetSevenGoalListReq;
}

void CSGetSevenGoalListReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetSevenGoalListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetSevenGoalListReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetSevenGoalListReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetSevenGoalListReq)
  return false;
#undef DO_
}

void CSGetSevenGoalListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetSevenGoalListReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetSevenGoalListReq)
}

int CSGetSevenGoalListReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetSevenGoalListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetSevenGoalListReq*>(&from));
}

void CSGetSevenGoalListReq::MergeFrom(const CSGetSevenGoalListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetSevenGoalListReq::CopyFrom(const CSGetSevenGoalListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetSevenGoalListReq::IsInitialized() const {

  return true;
}

void CSGetSevenGoalListReq::Swap(CSGetSevenGoalListReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetSevenGoalListReq::GetTypeName() const {
  return "fgame.CSGetSevenGoalListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSGetSevenGoalListResp::kNowDayFieldNumber;
const int CSGetSevenGoalListResp::kIsRetrivedFieldNumber;
const int CSGetSevenGoalListResp::kNumFieldNumber;
const int CSGetSevenGoalListResp::kNextNumFieldNumber;
#endif  // !_MSC_VER

CSGetSevenGoalListResp::CSGetSevenGoalListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSGetSevenGoalListResp)
}

void CSGetSevenGoalListResp::InitAsDefaultInstance() {
}

CSGetSevenGoalListResp::CSGetSevenGoalListResp(const CSGetSevenGoalListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSGetSevenGoalListResp)
}

void CSGetSevenGoalListResp::SharedCtor() {
  _cached_size_ = 0;
  nowday_ = 0u;
  isretrived_ = false;
  num_ = 0u;
  nextnum_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSGetSevenGoalListResp::~CSGetSevenGoalListResp() {
  // @@protoc_insertion_point(destructor:fgame.CSGetSevenGoalListResp)
  SharedDtor();
}

void CSGetSevenGoalListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSGetSevenGoalListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSGetSevenGoalListResp& CSGetSevenGoalListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSGetSevenGoalListResp* CSGetSevenGoalListResp::default_instance_ = NULL;

CSGetSevenGoalListResp* CSGetSevenGoalListResp::New() const {
  return new CSGetSevenGoalListResp;
}

void CSGetSevenGoalListResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSGetSevenGoalListResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(nowday_, nextnum_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSGetSevenGoalListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSGetSevenGoalListResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 NowDay = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nowday_)));
          set_has_nowday();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_IsRetrived;
        break;
      }

      // required bool IsRetrived = 2;
      case 2: {
        if (tag == 16) {
         parse_IsRetrived:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isretrived_)));
          set_has_isretrived();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Num;
        break;
      }

      // required uint32 Num = 3;
      case 3: {
        if (tag == 24) {
         parse_Num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_NextNum;
        break;
      }

      // required uint32 NextNum = 4;
      case 4: {
        if (tag == 32) {
         parse_NextNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nextnum_)));
          set_has_nextnum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSGetSevenGoalListResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSGetSevenGoalListResp)
  return false;
#undef DO_
}

void CSGetSevenGoalListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSGetSevenGoalListResp)
  // required uint32 NowDay = 1;
  if (has_nowday()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->nowday(), output);
  }

  // required bool IsRetrived = 2;
  if (has_isretrived()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->isretrived(), output);
  }

  // required uint32 Num = 3;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->num(), output);
  }

  // required uint32 NextNum = 4;
  if (has_nextnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->nextnum(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSGetSevenGoalListResp)
}

int CSGetSevenGoalListResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 NowDay = 1;
    if (has_nowday()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nowday());
    }

    // required bool IsRetrived = 2;
    if (has_isretrived()) {
      total_size += 1 + 1;
    }

    // required uint32 Num = 3;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num());
    }

    // required uint32 NextNum = 4;
    if (has_nextnum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nextnum());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSGetSevenGoalListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSGetSevenGoalListResp*>(&from));
}

void CSGetSevenGoalListResp::MergeFrom(const CSGetSevenGoalListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nowday()) {
      set_nowday(from.nowday());
    }
    if (from.has_isretrived()) {
      set_isretrived(from.isretrived());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
    if (from.has_nextnum()) {
      set_nextnum(from.nextnum());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSGetSevenGoalListResp::CopyFrom(const CSGetSevenGoalListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGetSevenGoalListResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void CSGetSevenGoalListResp::Swap(CSGetSevenGoalListResp* other) {
  if (other != this) {
    std::swap(nowday_, other->nowday_);
    std::swap(isretrived_, other->isretrived_);
    std::swap(num_, other->num_);
    std::swap(nextnum_, other->nextnum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSGetSevenGoalListResp::GetTypeName() const {
  return "fgame.CSGetSevenGoalListResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSNoticeSevenGoalResp::CSNoticeSevenGoalResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSNoticeSevenGoalResp)
}

void CSNoticeSevenGoalResp::InitAsDefaultInstance() {
}

CSNoticeSevenGoalResp::CSNoticeSevenGoalResp(const CSNoticeSevenGoalResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSNoticeSevenGoalResp)
}

void CSNoticeSevenGoalResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSNoticeSevenGoalResp::~CSNoticeSevenGoalResp() {
  // @@protoc_insertion_point(destructor:fgame.CSNoticeSevenGoalResp)
  SharedDtor();
}

void CSNoticeSevenGoalResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSNoticeSevenGoalResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSNoticeSevenGoalResp& CSNoticeSevenGoalResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSNoticeSevenGoalResp* CSNoticeSevenGoalResp::default_instance_ = NULL;

CSNoticeSevenGoalResp* CSNoticeSevenGoalResp::New() const {
  return new CSNoticeSevenGoalResp;
}

void CSNoticeSevenGoalResp::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSNoticeSevenGoalResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSNoticeSevenGoalResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSNoticeSevenGoalResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSNoticeSevenGoalResp)
  return false;
#undef DO_
}

void CSNoticeSevenGoalResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSNoticeSevenGoalResp)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSNoticeSevenGoalResp)
}

int CSNoticeSevenGoalResp::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSNoticeSevenGoalResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSNoticeSevenGoalResp*>(&from));
}

void CSNoticeSevenGoalResp::MergeFrom(const CSNoticeSevenGoalResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSNoticeSevenGoalResp::CopyFrom(const CSNoticeSevenGoalResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSNoticeSevenGoalResp::IsInitialized() const {

  return true;
}

void CSNoticeSevenGoalResp::Swap(CSNoticeSevenGoalResp* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSNoticeSevenGoalResp::GetTypeName() const {
  return "fgame.CSNoticeSevenGoalResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSRetriveSevenGoalReq::kNowDayFieldNumber;
#endif  // !_MSC_VER

CSRetriveSevenGoalReq::CSRetriveSevenGoalReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRetriveSevenGoalReq)
}

void CSRetriveSevenGoalReq::InitAsDefaultInstance() {
}

CSRetriveSevenGoalReq::CSRetriveSevenGoalReq(const CSRetriveSevenGoalReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRetriveSevenGoalReq)
}

void CSRetriveSevenGoalReq::SharedCtor() {
  _cached_size_ = 0;
  nowday_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRetriveSevenGoalReq::~CSRetriveSevenGoalReq() {
  // @@protoc_insertion_point(destructor:fgame.CSRetriveSevenGoalReq)
  SharedDtor();
}

void CSRetriveSevenGoalReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRetriveSevenGoalReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRetriveSevenGoalReq& CSRetriveSevenGoalReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSRetriveSevenGoalReq* CSRetriveSevenGoalReq::default_instance_ = NULL;

CSRetriveSevenGoalReq* CSRetriveSevenGoalReq::New() const {
  return new CSRetriveSevenGoalReq;
}

void CSRetriveSevenGoalReq::Clear() {
  nowday_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRetriveSevenGoalReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRetriveSevenGoalReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 NowDay = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nowday_)));
          set_has_nowday();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRetriveSevenGoalReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRetriveSevenGoalReq)
  return false;
#undef DO_
}

void CSRetriveSevenGoalReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRetriveSevenGoalReq)
  // required uint32 NowDay = 1;
  if (has_nowday()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->nowday(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRetriveSevenGoalReq)
}

int CSRetriveSevenGoalReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 NowDay = 1;
    if (has_nowday()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nowday());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRetriveSevenGoalReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRetriveSevenGoalReq*>(&from));
}

void CSRetriveSevenGoalReq::MergeFrom(const CSRetriveSevenGoalReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nowday()) {
      set_nowday(from.nowday());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRetriveSevenGoalReq::CopyFrom(const CSRetriveSevenGoalReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRetriveSevenGoalReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSRetriveSevenGoalReq::Swap(CSRetriveSevenGoalReq* other) {
  if (other != this) {
    std::swap(nowday_, other->nowday_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRetriveSevenGoalReq::GetTypeName() const {
  return "fgame.CSRetriveSevenGoalReq";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSRetriveSevenGoalResp::CSRetriveSevenGoalResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSRetriveSevenGoalResp)
}

void CSRetriveSevenGoalResp::InitAsDefaultInstance() {
}

CSRetriveSevenGoalResp::CSRetriveSevenGoalResp(const CSRetriveSevenGoalResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSRetriveSevenGoalResp)
}

void CSRetriveSevenGoalResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSRetriveSevenGoalResp::~CSRetriveSevenGoalResp() {
  // @@protoc_insertion_point(destructor:fgame.CSRetriveSevenGoalResp)
  SharedDtor();
}

void CSRetriveSevenGoalResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSRetriveSevenGoalResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSRetriveSevenGoalResp& CSRetriveSevenGoalResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSRetriveSevenGoalResp* CSRetriveSevenGoalResp::default_instance_ = NULL;

CSRetriveSevenGoalResp* CSRetriveSevenGoalResp::New() const {
  return new CSRetriveSevenGoalResp;
}

void CSRetriveSevenGoalResp::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSRetriveSevenGoalResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSRetriveSevenGoalResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSRetriveSevenGoalResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSRetriveSevenGoalResp)
  return false;
#undef DO_
}

void CSRetriveSevenGoalResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSRetriveSevenGoalResp)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSRetriveSevenGoalResp)
}

int CSRetriveSevenGoalResp::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSRetriveSevenGoalResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSRetriveSevenGoalResp*>(&from));
}

void CSRetriveSevenGoalResp::MergeFrom(const CSRetriveSevenGoalResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSRetriveSevenGoalResp::CopyFrom(const CSRetriveSevenGoalResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSRetriveSevenGoalResp::IsInitialized() const {

  return true;
}

void CSRetriveSevenGoalResp::Swap(CSRetriveSevenGoalResp* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSRetriveSevenGoalResp::GetTypeName() const {
  return "fgame.CSRetriveSevenGoalResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSTopRankReq::kCategoryFieldNumber;
#endif  // !_MSC_VER

CSTopRankReq::CSTopRankReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSTopRankReq)
}

void CSTopRankReq::InitAsDefaultInstance() {
}

CSTopRankReq::CSTopRankReq(const CSTopRankReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSTopRankReq)
}

void CSTopRankReq::SharedCtor() {
  _cached_size_ = 0;
  category_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSTopRankReq::~CSTopRankReq() {
  // @@protoc_insertion_point(destructor:fgame.CSTopRankReq)
  SharedDtor();
}

void CSTopRankReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSTopRankReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSTopRankReq& CSTopRankReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSTopRankReq* CSTopRankReq::default_instance_ = NULL;

CSTopRankReq* CSTopRankReq::New() const {
  return new CSTopRankReq;
}

void CSTopRankReq::Clear() {
  category_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSTopRankReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSTopRankReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Category = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &category_)));
          set_has_category();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSTopRankReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSTopRankReq)
  return false;
#undef DO_
}

void CSTopRankReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSTopRankReq)
  // required uint32 Category = 1;
  if (has_category()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->category(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSTopRankReq)
}

int CSTopRankReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Category = 1;
    if (has_category()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->category());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSTopRankReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSTopRankReq*>(&from));
}

void CSTopRankReq::MergeFrom(const CSTopRankReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_category()) {
      set_category(from.category());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSTopRankReq::CopyFrom(const CSTopRankReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSTopRankReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSTopRankReq::Swap(CSTopRankReq* other) {
  if (other != this) {
    std::swap(category_, other->category_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSTopRankReq::GetTypeName() const {
  return "fgame.CSTopRankReq";
}


// ===================================================================

#ifndef _MSC_VER
const int TopRankData::kRankFieldNumber;
const int TopRankData::kUinFieldNumber;
const int TopRankData::kNameFieldNumber;
const int TopRankData::kAvatorFieldNumber;
const int TopRankData::kValueFieldNumber;
const int TopRankData::kUpFieldNumber;
const int TopRankData::kLevelFieldNumber;
#endif  // !_MSC_VER

TopRankData::TopRankData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.TopRankData)
}

void TopRankData::InitAsDefaultInstance() {
}

TopRankData::TopRankData(const TopRankData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.TopRankData)
}

void TopRankData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  rank_ = 0u;
  uin_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  avator_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_ = 0u;
  up_ = false;
  level_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TopRankData::~TopRankData() {
  // @@protoc_insertion_point(destructor:fgame.TopRankData)
  SharedDtor();
}

void TopRankData::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (avator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avator_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TopRankData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TopRankData& TopRankData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

TopRankData* TopRankData::default_instance_ = NULL;

TopRankData* TopRankData::New() const {
  return new TopRankData;
}

void TopRankData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TopRankData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(rank_, uin_);
    ZR_(value_, level_);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_avator()) {
      if (avator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        avator_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool TopRankData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.TopRankData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 Rank = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_)));
          set_has_rank();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Uin;
        break;
      }

      // optional uint32 Uin = 2;
      case 2: {
        if (tag == 16) {
         parse_Uin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_Name;
        break;
      }

      // optional string Name = 3;
      case 3: {
        if (tag == 26) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_Avator;
        break;
      }

      // optional string Avator = 4;
      case 4: {
        if (tag == 34) {
         parse_Avator:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_avator()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_Value;
        break;
      }

      // optional uint32 Value = 5;
      case 5: {
        if (tag == 40) {
         parse_Value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_Up;
        break;
      }

      // optional bool Up = 6;
      case 6: {
        if (tag == 48) {
         parse_Up:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &up_)));
          set_has_up();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_Level;
        break;
      }

      // optional uint32 Level = 7;
      case 7: {
        if (tag == 56) {
         parse_Level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.TopRankData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.TopRankData)
  return false;
#undef DO_
}

void TopRankData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.TopRankData)
  // optional uint32 Rank = 1;
  if (has_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->rank(), output);
  }

  // optional uint32 Uin = 2;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->uin(), output);
  }

  // optional string Name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // optional string Avator = 4;
  if (has_avator()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->avator(), output);
  }

  // optional uint32 Value = 5;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->value(), output);
  }

  // optional bool Up = 6;
  if (has_up()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->up(), output);
  }

  // optional uint32 Level = 7;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->level(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.TopRankData)
}

int TopRankData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 Rank = 1;
    if (has_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank());
    }

    // optional uint32 Uin = 2;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uin());
    }

    // optional string Name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string Avator = 4;
    if (has_avator()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->avator());
    }

    // optional uint32 Value = 5;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

    // optional bool Up = 6;
    if (has_up()) {
      total_size += 1 + 1;
    }

    // optional uint32 Level = 7;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->level());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TopRankData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TopRankData*>(&from));
}

void TopRankData::MergeFrom(const TopRankData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rank()) {
      set_rank(from.rank());
    }
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_avator()) {
      set_avator(from.avator());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_up()) {
      set_up(from.up());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void TopRankData::CopyFrom(const TopRankData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopRankData::IsInitialized() const {

  return true;
}

void TopRankData::Swap(TopRankData* other) {
  if (other != this) {
    std::swap(rank_, other->rank_);
    std::swap(uin_, other->uin_);
    std::swap(name_, other->name_);
    std::swap(avator_, other->avator_);
    std::swap(value_, other->value_);
    std::swap(up_, other->up_);
    std::swap(level_, other->level_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TopRankData::GetTypeName() const {
  return "fgame.TopRankData";
}


// ===================================================================

#ifndef _MSC_VER
const int CSTopRankResp::kCategoryFieldNumber;
const int CSTopRankResp::kDataFieldNumber;
const int CSTopRankResp::kOwnerDataFieldNumber;
#endif  // !_MSC_VER

CSTopRankResp::CSTopRankResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSTopRankResp)
}

void CSTopRankResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  ownerdata_ = const_cast< ::fgame::TopRankData*>(
      ::fgame::TopRankData::internal_default_instance());
#else
  ownerdata_ = const_cast< ::fgame::TopRankData*>(&::fgame::TopRankData::default_instance());
#endif
}

CSTopRankResp::CSTopRankResp(const CSTopRankResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSTopRankResp)
}

void CSTopRankResp::SharedCtor() {
  _cached_size_ = 0;
  category_ = 0u;
  ownerdata_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSTopRankResp::~CSTopRankResp() {
  // @@protoc_insertion_point(destructor:fgame.CSTopRankResp)
  SharedDtor();
}

void CSTopRankResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete ownerdata_;
  }
}

void CSTopRankResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSTopRankResp& CSTopRankResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSTopRankResp* CSTopRankResp::default_instance_ = NULL;

CSTopRankResp* CSTopRankResp::New() const {
  return new CSTopRankResp;
}

void CSTopRankResp::Clear() {
  if (_has_bits_[0 / 32] & 5) {
    category_ = 0u;
    if (has_ownerdata()) {
      if (ownerdata_ != NULL) ownerdata_->::fgame::TopRankData::Clear();
    }
  }
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSTopRankResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSTopRankResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Category = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &category_)));
          set_has_category();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Data;
        break;
      }

      // repeated .fgame.TopRankData Data = 2;
      case 2: {
        if (tag == 18) {
         parse_Data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Data;
        if (input->ExpectTag(26)) goto parse_OwnerData;
        break;
      }

      // optional .fgame.TopRankData OwnerData = 3;
      case 3: {
        if (tag == 26) {
         parse_OwnerData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ownerdata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSTopRankResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSTopRankResp)
  return false;
#undef DO_
}

void CSTopRankResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSTopRankResp)
  // required uint32 Category = 1;
  if (has_category()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->category(), output);
  }

  // repeated .fgame.TopRankData Data = 2;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->data(i), output);
  }

  // optional .fgame.TopRankData OwnerData = 3;
  if (has_ownerdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->ownerdata(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSTopRankResp)
}

int CSTopRankResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Category = 1;
    if (has_category()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->category());
    }

    // optional .fgame.TopRankData OwnerData = 3;
    if (has_ownerdata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ownerdata());
    }

  }
  // repeated .fgame.TopRankData Data = 2;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSTopRankResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSTopRankResp*>(&from));
}

void CSTopRankResp::MergeFrom(const CSTopRankResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_category()) {
      set_category(from.category());
    }
    if (from.has_ownerdata()) {
      mutable_ownerdata()->::fgame::TopRankData::MergeFrom(from.ownerdata());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSTopRankResp::CopyFrom(const CSTopRankResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSTopRankResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSTopRankResp::Swap(CSTopRankResp* other) {
  if (other != this) {
    std::swap(category_, other->category_);
    data_.Swap(&other->data_);
    std::swap(ownerdata_, other->ownerdata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSTopRankResp::GetTypeName() const {
  return "fgame.CSTopRankResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSTopRankTimeReq::kCategoryFieldNumber;
#endif  // !_MSC_VER

CSTopRankTimeReq::CSTopRankTimeReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSTopRankTimeReq)
}

void CSTopRankTimeReq::InitAsDefaultInstance() {
}

CSTopRankTimeReq::CSTopRankTimeReq(const CSTopRankTimeReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSTopRankTimeReq)
}

void CSTopRankTimeReq::SharedCtor() {
  _cached_size_ = 0;
  category_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSTopRankTimeReq::~CSTopRankTimeReq() {
  // @@protoc_insertion_point(destructor:fgame.CSTopRankTimeReq)
  SharedDtor();
}

void CSTopRankTimeReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSTopRankTimeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSTopRankTimeReq& CSTopRankTimeReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSTopRankTimeReq* CSTopRankTimeReq::default_instance_ = NULL;

CSTopRankTimeReq* CSTopRankTimeReq::New() const {
  return new CSTopRankTimeReq;
}

void CSTopRankTimeReq::Clear() {
  category_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSTopRankTimeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSTopRankTimeReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Category = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &category_)));
          set_has_category();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSTopRankTimeReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSTopRankTimeReq)
  return false;
#undef DO_
}

void CSTopRankTimeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSTopRankTimeReq)
  // required uint32 Category = 1;
  if (has_category()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->category(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSTopRankTimeReq)
}

int CSTopRankTimeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Category = 1;
    if (has_category()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->category());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSTopRankTimeReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSTopRankTimeReq*>(&from));
}

void CSTopRankTimeReq::MergeFrom(const CSTopRankTimeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_category()) {
      set_category(from.category());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSTopRankTimeReq::CopyFrom(const CSTopRankTimeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSTopRankTimeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSTopRankTimeReq::Swap(CSTopRankTimeReq* other) {
  if (other != this) {
    std::swap(category_, other->category_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSTopRankTimeReq::GetTypeName() const {
  return "fgame.CSTopRankTimeReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSTopRankTimeResp::kBeginAtFieldNumber;
const int CSTopRankTimeResp::kEndAtFieldNumber;
const int CSTopRankTimeResp::kCategoryFieldNumber;
const int CSTopRankTimeResp::kSecsFieldNumber;
#endif  // !_MSC_VER

CSTopRankTimeResp::CSTopRankTimeResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSTopRankTimeResp)
}

void CSTopRankTimeResp::InitAsDefaultInstance() {
}

CSTopRankTimeResp::CSTopRankTimeResp(const CSTopRankTimeResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSTopRankTimeResp)
}

void CSTopRankTimeResp::SharedCtor() {
  _cached_size_ = 0;
  beginat_ = 0u;
  endat_ = 0u;
  category_ = 0u;
  secs_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSTopRankTimeResp::~CSTopRankTimeResp() {
  // @@protoc_insertion_point(destructor:fgame.CSTopRankTimeResp)
  SharedDtor();
}

void CSTopRankTimeResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSTopRankTimeResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSTopRankTimeResp& CSTopRankTimeResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Player_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Player_2eproto();
#endif
  return *default_instance_;
}

CSTopRankTimeResp* CSTopRankTimeResp::default_instance_ = NULL;

CSTopRankTimeResp* CSTopRankTimeResp::New() const {
  return new CSTopRankTimeResp;
}

void CSTopRankTimeResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSTopRankTimeResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(beginat_, secs_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSTopRankTimeResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSTopRankTimeResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 BeginAt = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &beginat_)));
          set_has_beginat();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_EndAt;
        break;
      }

      // optional uint32 EndAt = 2;
      case 2: {
        if (tag == 16) {
         parse_EndAt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endat_)));
          set_has_endat();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Category;
        break;
      }

      // optional uint32 Category = 3;
      case 3: {
        if (tag == 24) {
         parse_Category:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &category_)));
          set_has_category();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Secs;
        break;
      }

      // optional uint32 Secs = 4;
      case 4: {
        if (tag == 32) {
         parse_Secs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &secs_)));
          set_has_secs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSTopRankTimeResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSTopRankTimeResp)
  return false;
#undef DO_
}

void CSTopRankTimeResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSTopRankTimeResp)
  // optional uint32 BeginAt = 1;
  if (has_beginat()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->beginat(), output);
  }

  // optional uint32 EndAt = 2;
  if (has_endat()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->endat(), output);
  }

  // optional uint32 Category = 3;
  if (has_category()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->category(), output);
  }

  // optional uint32 Secs = 4;
  if (has_secs()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->secs(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSTopRankTimeResp)
}

int CSTopRankTimeResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 BeginAt = 1;
    if (has_beginat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->beginat());
    }

    // optional uint32 EndAt = 2;
    if (has_endat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endat());
    }

    // optional uint32 Category = 3;
    if (has_category()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->category());
    }

    // optional uint32 Secs = 4;
    if (has_secs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->secs());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSTopRankTimeResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSTopRankTimeResp*>(&from));
}

void CSTopRankTimeResp::MergeFrom(const CSTopRankTimeResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_beginat()) {
      set_beginat(from.beginat());
    }
    if (from.has_endat()) {
      set_endat(from.endat());
    }
    if (from.has_category()) {
      set_category(from.category());
    }
    if (from.has_secs()) {
      set_secs(from.secs());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSTopRankTimeResp::CopyFrom(const CSTopRankTimeResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSTopRankTimeResp::IsInitialized() const {

  return true;
}

void CSTopRankTimeResp::Swap(CSTopRankTimeResp* other) {
  if (other != this) {
    std::swap(beginat_, other->beginat_);
    std::swap(endat_, other->endat_);
    std::swap(category_, other->category_);
    std::swap(secs_, other->secs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSTopRankTimeResp::GetTypeName() const {
  return "fgame.CSTopRankTimeResp";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fgame

// @@protoc_insertion_point(global_scope)
