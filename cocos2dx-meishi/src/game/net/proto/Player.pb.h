// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Player.proto

#ifndef PROTOBUF_Player_2eproto__INCLUDED
#define PROTOBUF_Player_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace fgame {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Player_2eproto();
void protobuf_AssignDesc_Player_2eproto();
void protobuf_ShutdownFile_Player_2eproto();

class PropertyUpdateData;
class CSQueryPlayerInfoReq;
class CSQueryPlayerInfoResp;
class CSShopGuideReq;
class CSShopGuideResp;
class CSTestAddDiamondReq;
class CSSetTitleReq;
class CSSetTitleResp;
class CSShopBuyReq;
class CSShopBuyResp;
class CSShopListReq;
class DiamondData;
class GiftData;
class CSShopListResp;
class ExchangeItemInfo;
class CSExchangeItemReq;
class CSExchangeItemResp;
class CSUpdateExchangeListReq;
class CSUpdateExchangeListResp;
class CSChangePlayerIconReq;
class CSChangePlayerIconResp;
class CSSetNewBieReq;
class CSSetNewBieResp;
class CSGetNewBieListReq;
class CSGetNewBieListResp;
class CSSetNewBieOssReq;
class CSSetNewBieOssResp;
class CSOpenBigStageReq;
class CSOpenBigStageResp;
class CSEnterPointReq;
class CSEnterPointResp;
class CSBuyITtemReq;
class CSBuyItemResp;
class CSUseItemReq;
class CSUseItemResp;
class CSBuyVipReq;
class CSVipTimeReq;
class CSBuyVipResp;
class CSPropertyUpdateResp;
class CSGetAchievementReq;
class CSGetAchievementInfo;
class CSGetAchievementResp;
class CSReceiveAchievementReq;
class CSReceiveAchievementResp;
class CSReceiveAchievementRewardReq;
class CSReceiveAchievementRewardResp;
class CSUpdateAchievementResp;
class CSSevenDaySignListReq;
class CSSevenDayGetList;
class CSSevenDaySignListResp;
class CSSevenDaySignReq;
class CSSevenDaySignResp;
class CSGetServerReq;
class CSGetServerResp;
class CSEnterServerReq;
class CSEnterServerResp;
class CSCanEnterReq;
class CSDirectEnterReq;
class CSDircetEnterResp;
class CSQueueReq;
class CSStreakWinValueReq;
class CSStreakWinValueResp;
class CSStreakWinGetReq;
class CSStreakWinGetResp;
class CSItem;
class CSSycPlayerInfoReq;
class CSTitleItem;
class CSSycPlayerInfoResp;
class CSSyncPlayerDataReq;
class CSSyncPlayerDataResp;
class CSGetPlayerDataReq;
class CSGetPlayerDataResp;
class CSNoticeReq;
class CSChangeNameReq;
class CSChangeNameResp;
class CSGMCmdReq;
class CSXinShouRecodeReq;
class CSXinShouRecodeResp;
class CSMission;
class CSMissionListReq;
class CSMissionListResp;
class CSMissionCompleteReq;
class CSMissionCompleteResp;
class CSMissionUpdateResp;
class CSBuyNewbieGiftReq;
class CSBuyNewbieGiftResp;
class CSMailInfo;
class CSGetMailReq;
class CSGetMailResp;
class CSDelMailReq;
class CSDelMailResp;
class CSNoticeMailReq;
class CSRechargeCallbackReq;
class CSRechargeCallbackResp;
class CSUseGiftCodeReq;
class CSUseGiftCodeResp;
class CheckPtData;
class CSSaveCheckPtDataReq;
class CSSaveCheckPtDataResp;
class CSRetriveCheckPtRewardReq;
class CSRetriveCheckPtRewardResp;
class CSGetCheckPtDataReq;
class ChapterData;
class CSGetCheckPtDataResp;
class CSChapterUnlockReq;
class CSChapterUnlockResp;
class CSGetChestReq;
class CSGetChestResp;
class CSPveNotifyReq;
class CSPveNotifyResp;
class CSPveCheckAwardReq;
class CSPveCheckAwardResp;
class CSPvePveRank;
class CSPveRankData;
class CSPveRankReq;
class CSPveRankResp;
class CSOpenChestResp;
class CSSetSignatureReq;
class CSSetSignatureResp;
class CSSetExtraInfoVisibleReq;
class CSSetExtraInfoVisibleResp;
class CSGetExtraInfoReq;
class CSGetExtraInfoResp;
class CSShareRewardGetResq;
class CSShareRewardGetReq;
class CSGetSevenGoalListReq;
class CSGetSevenGoalListResp;
class CSNoticeSevenGoalResp;
class CSRetriveSevenGoalReq;
class CSRetriveSevenGoalResp;
class CSTopRankReq;
class TopRankData;
class CSTopRankResp;
class CSTopRankTimeReq;
class CSTopRankTimeResp;

// ===================================================================

class PropertyUpdateData : public ::google::protobuf::MessageLite {
 public:
  PropertyUpdateData();
  virtual ~PropertyUpdateData();

  PropertyUpdateData(const PropertyUpdateData& from);

  inline PropertyUpdateData& operator=(const PropertyUpdateData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PropertyUpdateData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PropertyUpdateData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PropertyUpdateData* other);

  // implements Message ----------------------------------------------

  PropertyUpdateData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PropertyUpdateData& from);
  void MergeFrom(const PropertyUpdateData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 UpType = 1;
  inline bool has_uptype() const;
  inline void clear_uptype();
  static const int kUpTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 uptype() const;
  inline void set_uptype(::google::protobuf::uint32 value);

  // optional uint32 Value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // optional uint32 Value2 = 3;
  inline bool has_value2() const;
  inline void clear_value2();
  static const int kValue2FieldNumber = 3;
  inline ::google::protobuf::uint32 value2() const;
  inline void set_value2(::google::protobuf::uint32 value);

  // optional string Extra = 4;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 4;
  inline const ::std::string& extra() const;
  inline void set_extra(const ::std::string& value);
  inline void set_extra(const char* value);
  inline void set_extra(const char* value, size_t size);
  inline ::std::string* mutable_extra();
  inline ::std::string* release_extra();
  inline void set_allocated_extra(::std::string* extra);

  // optional uint32 Src = 5;
  inline bool has_src() const;
  inline void clear_src();
  static const int kSrcFieldNumber = 5;
  inline ::google::protobuf::uint32 src() const;
  inline void set_src(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.PropertyUpdateData)
 private:
  inline void set_has_uptype();
  inline void clear_has_uptype();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_value2();
  inline void clear_has_value2();
  inline void set_has_extra();
  inline void clear_has_extra();
  inline void set_has_src();
  inline void clear_has_src();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 uptype_;
  ::google::protobuf::uint32 value_;
  ::std::string* extra_;
  ::google::protobuf::uint32 value2_;
  ::google::protobuf::uint32 src_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static PropertyUpdateData* default_instance_;
};
// -------------------------------------------------------------------

class CSQueryPlayerInfoReq : public ::google::protobuf::MessageLite {
 public:
  CSQueryPlayerInfoReq();
  virtual ~CSQueryPlayerInfoReq();

  CSQueryPlayerInfoReq(const CSQueryPlayerInfoReq& from);

  inline CSQueryPlayerInfoReq& operator=(const CSQueryPlayerInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSQueryPlayerInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQueryPlayerInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQueryPlayerInfoReq* other);

  // implements Message ----------------------------------------------

  CSQueryPlayerInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQueryPlayerInfoReq& from);
  void MergeFrom(const CSQueryPlayerInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:fgame.CSQueryPlayerInfoReq)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSQueryPlayerInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class CSQueryPlayerInfoResp : public ::google::protobuf::MessageLite {
 public:
  CSQueryPlayerInfoResp();
  virtual ~CSQueryPlayerInfoResp();

  CSQueryPlayerInfoResp(const CSQueryPlayerInfoResp& from);

  inline CSQueryPlayerInfoResp& operator=(const CSQueryPlayerInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSQueryPlayerInfoResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQueryPlayerInfoResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQueryPlayerInfoResp* other);

  // implements Message ----------------------------------------------

  CSQueryPlayerInfoResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQueryPlayerInfoResp& from);
  void MergeFrom(const CSQueryPlayerInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string Icon = 3;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 3;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // optional uint64 Title = 4;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 4;
  inline ::google::protobuf::uint64 title() const;
  inline void set_title(::google::protobuf::uint64 value);

  // optional uint32 Level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 Score = 6;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 6;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // optional float WinRate = 7;
  inline bool has_winrate() const;
  inline void clear_winrate();
  static const int kWinRateFieldNumber = 7;
  inline float winrate() const;
  inline void set_winrate(float value);

  // optional uint32 Group = 8;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 8;
  inline ::google::protobuf::uint32 group() const;
  inline void set_group(::google::protobuf::uint32 value);

  // optional uint32 Rank = 9;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 9;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // optional uint32 ExpLevel = 10;
  inline bool has_explevel() const;
  inline void clear_explevel();
  static const int kExpLevelFieldNumber = 10;
  inline ::google::protobuf::uint32 explevel() const;
  inline void set_explevel(::google::protobuf::uint32 value);

  // optional uint32 Exp = 11;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 11;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // optional uint32 GlyphsLevel = 12;
  inline bool has_glyphslevel() const;
  inline void clear_glyphslevel();
  static const int kGlyphsLevelFieldNumber = 12;
  inline ::google::protobuf::uint32 glyphslevel() const;
  inline void set_glyphslevel(::google::protobuf::uint32 value);

  // optional uint32 MaxCheckPoint = 13;
  inline bool has_maxcheckpoint() const;
  inline void clear_maxcheckpoint();
  static const int kMaxCheckPointFieldNumber = 13;
  inline ::google::protobuf::uint32 maxcheckpoint() const;
  inline void set_maxcheckpoint(::google::protobuf::uint32 value);

  // optional string Signature = 14;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 14;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const char* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional uint32 VipLevel = 15;
  inline bool has_viplevel() const;
  inline void clear_viplevel();
  static const int kVipLevelFieldNumber = 15;
  inline ::google::protobuf::uint32 viplevel() const;
  inline void set_viplevel(::google::protobuf::uint32 value);

  // optional bool Visible = 16;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 16;
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional uint32 Area = 17;
  inline bool has_area() const;
  inline void clear_area();
  static const int kAreaFieldNumber = 17;
  inline ::google::protobuf::uint32 area() const;
  inline void set_area(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSQueryPlayerInfoResp)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_winrate();
  inline void clear_has_winrate();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_explevel();
  inline void clear_has_explevel();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_glyphslevel();
  inline void clear_has_glyphslevel();
  inline void set_has_maxcheckpoint();
  inline void clear_has_maxcheckpoint();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_viplevel();
  inline void clear_has_viplevel();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_area();
  inline void clear_has_area();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  ::std::string* name_;
  ::std::string* icon_;
  ::google::protobuf::uint64 title_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 score_;
  float winrate_;
  ::google::protobuf::uint32 group_;
  ::google::protobuf::uint32 rank_;
  ::google::protobuf::uint32 explevel_;
  ::google::protobuf::uint32 exp_;
  ::google::protobuf::uint32 glyphslevel_;
  ::std::string* signature_;
  ::google::protobuf::uint32 maxcheckpoint_;
  ::google::protobuf::uint32 viplevel_;
  bool visible_;
  ::google::protobuf::uint32 area_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSQueryPlayerInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class CSShopGuideReq : public ::google::protobuf::MessageLite {
 public:
  CSShopGuideReq();
  virtual ~CSShopGuideReq();

  CSShopGuideReq(const CSShopGuideReq& from);

  inline CSShopGuideReq& operator=(const CSShopGuideReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSShopGuideReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSShopGuideReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSShopGuideReq* other);

  // implements Message ----------------------------------------------

  CSShopGuideReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSShopGuideReq& from);
  void MergeFrom(const CSShopGuideReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Diamond = 1;
  inline bool has_diamond() const;
  inline void clear_diamond();
  static const int kDiamondFieldNumber = 1;
  inline ::google::protobuf::uint32 diamond() const;
  inline void set_diamond(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSShopGuideReq)
 private:
  inline void set_has_diamond();
  inline void clear_has_diamond();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 diamond_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSShopGuideReq* default_instance_;
};
// -------------------------------------------------------------------

class CSShopGuideResp : public ::google::protobuf::MessageLite {
 public:
  CSShopGuideResp();
  virtual ~CSShopGuideResp();

  CSShopGuideResp(const CSShopGuideResp& from);

  inline CSShopGuideResp& operator=(const CSShopGuideResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSShopGuideResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSShopGuideResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSShopGuideResp* other);

  // implements Message ----------------------------------------------

  CSShopGuideResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSShopGuideResp& from);
  void MergeFrom(const CSShopGuideResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required uint32 Diamond = 2;
  inline bool has_diamond() const;
  inline void clear_diamond();
  static const int kDiamondFieldNumber = 2;
  inline ::google::protobuf::uint32 diamond() const;
  inline void set_diamond(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSShopGuideResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_diamond();
  inline void clear_has_diamond();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 diamond_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSShopGuideResp* default_instance_;
};
// -------------------------------------------------------------------

class CSTestAddDiamondReq : public ::google::protobuf::MessageLite {
 public:
  CSTestAddDiamondReq();
  virtual ~CSTestAddDiamondReq();

  CSTestAddDiamondReq(const CSTestAddDiamondReq& from);

  inline CSTestAddDiamondReq& operator=(const CSTestAddDiamondReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSTestAddDiamondReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSTestAddDiamondReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSTestAddDiamondReq* other);

  // implements Message ----------------------------------------------

  CSTestAddDiamondReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSTestAddDiamondReq& from);
  void MergeFrom(const CSTestAddDiamondReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Diamond = 1;
  inline bool has_diamond() const;
  inline void clear_diamond();
  static const int kDiamondFieldNumber = 1;
  inline ::google::protobuf::uint32 diamond() const;
  inline void set_diamond(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSTestAddDiamondReq)
 private:
  inline void set_has_diamond();
  inline void clear_has_diamond();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 diamond_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSTestAddDiamondReq* default_instance_;
};
// -------------------------------------------------------------------

class CSSetTitleReq : public ::google::protobuf::MessageLite {
 public:
  CSSetTitleReq();
  virtual ~CSSetTitleReq();

  CSSetTitleReq(const CSSetTitleReq& from);

  inline CSSetTitleReq& operator=(const CSSetTitleReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSetTitleReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSetTitleReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSetTitleReq* other);

  // implements Message ----------------------------------------------

  CSSetTitleReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSetTitleReq& from);
  void MergeFrom(const CSSetTitleReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline ::google::protobuf::uint32 title() const;
  inline void set_title(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSSetTitleReq)
 private:
  inline void set_has_title();
  inline void clear_has_title();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 title_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSetTitleReq* default_instance_;
};
// -------------------------------------------------------------------

class CSSetTitleResp : public ::google::protobuf::MessageLite {
 public:
  CSSetTitleResp();
  virtual ~CSSetTitleResp();

  CSSetTitleResp(const CSSetTitleResp& from);

  inline CSSetTitleResp& operator=(const CSSetTitleResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSetTitleResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSetTitleResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSetTitleResp* other);

  // implements Message ----------------------------------------------

  CSSetTitleResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSetTitleResp& from);
  void MergeFrom(const CSSetTitleResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline ::google::protobuf::uint32 title() const;
  inline void set_title(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSSetTitleResp)
 private:
  inline void set_has_title();
  inline void clear_has_title();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 title_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSetTitleResp* default_instance_;
};
// -------------------------------------------------------------------

class CSShopBuyReq : public ::google::protobuf::MessageLite {
 public:
  CSShopBuyReq();
  virtual ~CSShopBuyReq();

  CSShopBuyReq(const CSShopBuyReq& from);

  inline CSShopBuyReq& operator=(const CSShopBuyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSShopBuyReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSShopBuyReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSShopBuyReq* other);

  // implements Message ----------------------------------------------

  CSShopBuyReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSShopBuyReq& from);
  void MergeFrom(const CSShopBuyReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ShopId = 1;
  inline bool has_shopid() const;
  inline void clear_shopid();
  static const int kShopIdFieldNumber = 1;
  inline ::google::protobuf::uint32 shopid() const;
  inline void set_shopid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSShopBuyReq)
 private:
  inline void set_has_shopid();
  inline void clear_has_shopid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 shopid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSShopBuyReq* default_instance_;
};
// -------------------------------------------------------------------

class CSShopBuyResp : public ::google::protobuf::MessageLite {
 public:
  CSShopBuyResp();
  virtual ~CSShopBuyResp();

  CSShopBuyResp(const CSShopBuyResp& from);

  inline CSShopBuyResp& operator=(const CSShopBuyResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSShopBuyResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSShopBuyResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSShopBuyResp* other);

  // implements Message ----------------------------------------------

  CSShopBuyResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSShopBuyResp& from);
  void MergeFrom(const CSShopBuyResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ShopId = 1;
  inline bool has_shopid() const;
  inline void clear_shopid();
  static const int kShopIdFieldNumber = 1;
  inline ::google::protobuf::uint32 shopid() const;
  inline void set_shopid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSShopBuyResp)
 private:
  inline void set_has_shopid();
  inline void clear_has_shopid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 shopid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSShopBuyResp* default_instance_;
};
// -------------------------------------------------------------------

class CSShopListReq : public ::google::protobuf::MessageLite {
 public:
  CSShopListReq();
  virtual ~CSShopListReq();

  CSShopListReq(const CSShopListReq& from);

  inline CSShopListReq& operator=(const CSShopListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSShopListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSShopListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSShopListReq* other);

  // implements Message ----------------------------------------------

  CSShopListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSShopListReq& from);
  void MergeFrom(const CSShopListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSShopListReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSShopListReq* default_instance_;
};
// -------------------------------------------------------------------

class DiamondData : public ::google::protobuf::MessageLite {
 public:
  DiamondData();
  virtual ~DiamondData();

  DiamondData(const DiamondData& from);

  inline DiamondData& operator=(const DiamondData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DiamondData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DiamondData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DiamondData* other);

  // implements Message ----------------------------------------------

  DiamondData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DiamondData& from);
  void MergeFrom(const DiamondData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ShopId = 1;
  inline bool has_shopid() const;
  inline void clear_shopid();
  static const int kShopIdFieldNumber = 1;
  inline ::google::protobuf::uint32 shopid() const;
  inline void set_shopid(::google::protobuf::uint32 value);

  // optional bool First = 2;
  inline bool has_first() const;
  inline void clear_first();
  static const int kFirstFieldNumber = 2;
  inline bool first() const;
  inline void set_first(bool value);

  // @@protoc_insertion_point(class_scope:fgame.DiamondData)
 private:
  inline void set_has_shopid();
  inline void clear_has_shopid();
  inline void set_has_first();
  inline void clear_has_first();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 shopid_;
  bool first_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static DiamondData* default_instance_;
};
// -------------------------------------------------------------------

class GiftData : public ::google::protobuf::MessageLite {
 public:
  GiftData();
  virtual ~GiftData();

  GiftData(const GiftData& from);

  inline GiftData& operator=(const GiftData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GiftData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GiftData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GiftData* other);

  // implements Message ----------------------------------------------

  GiftData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GiftData& from);
  void MergeFrom(const GiftData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ShopId = 1;
  inline bool has_shopid() const;
  inline void clear_shopid();
  static const int kShopIdFieldNumber = 1;
  inline ::google::protobuf::uint32 shopid() const;
  inline void set_shopid(::google::protobuf::uint32 value);

  // required uint32 GiftId = 2;
  inline bool has_giftid() const;
  inline void clear_giftid();
  static const int kGiftIdFieldNumber = 2;
  inline ::google::protobuf::uint32 giftid() const;
  inline void set_giftid(::google::protobuf::uint32 value);

  // required uint32 StartTime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 starttime() const;
  inline void set_starttime(::google::protobuf::uint32 value);

  // required uint32 EndTime = 4;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 endtime() const;
  inline void set_endtime(::google::protobuf::uint32 value);

  // required uint32 LeftCount = 5;
  inline bool has_leftcount() const;
  inline void clear_leftcount();
  static const int kLeftCountFieldNumber = 5;
  inline ::google::protobuf::uint32 leftcount() const;
  inline void set_leftcount(::google::protobuf::uint32 value);

  // required string GiftName = 6;
  inline bool has_giftname() const;
  inline void clear_giftname();
  static const int kGiftNameFieldNumber = 6;
  inline const ::std::string& giftname() const;
  inline void set_giftname(const ::std::string& value);
  inline void set_giftname(const char* value);
  inline void set_giftname(const char* value, size_t size);
  inline ::std::string* mutable_giftname();
  inline ::std::string* release_giftname();
  inline void set_allocated_giftname(::std::string* giftname);

  // optional string Discount = 7;
  inline bool has_discount() const;
  inline void clear_discount();
  static const int kDiscountFieldNumber = 7;
  inline const ::std::string& discount() const;
  inline void set_discount(const ::std::string& value);
  inline void set_discount(const char* value);
  inline void set_discount(const char* value, size_t size);
  inline ::std::string* mutable_discount();
  inline ::std::string* release_discount();
  inline void set_allocated_discount(::std::string* discount);

  // optional uint32 Price = 8;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 8;
  inline ::google::protobuf::uint32 price() const;
  inline void set_price(::google::protobuf::uint32 value);

  // required string GiftIcon = 9;
  inline bool has_gifticon() const;
  inline void clear_gifticon();
  static const int kGiftIconFieldNumber = 9;
  inline const ::std::string& gifticon() const;
  inline void set_gifticon(const ::std::string& value);
  inline void set_gifticon(const char* value);
  inline void set_gifticon(const char* value, size_t size);
  inline ::std::string* mutable_gifticon();
  inline ::std::string* release_gifticon();
  inline void set_allocated_gifticon(::std::string* gifticon);

  // @@protoc_insertion_point(class_scope:fgame.GiftData)
 private:
  inline void set_has_shopid();
  inline void clear_has_shopid();
  inline void set_has_giftid();
  inline void clear_has_giftid();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_leftcount();
  inline void clear_has_leftcount();
  inline void set_has_giftname();
  inline void clear_has_giftname();
  inline void set_has_discount();
  inline void clear_has_discount();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_gifticon();
  inline void clear_has_gifticon();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 shopid_;
  ::google::protobuf::uint32 giftid_;
  ::google::protobuf::uint32 starttime_;
  ::google::protobuf::uint32 endtime_;
  ::std::string* giftname_;
  ::google::protobuf::uint32 leftcount_;
  ::google::protobuf::uint32 price_;
  ::std::string* discount_;
  ::std::string* gifticon_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static GiftData* default_instance_;
};
// -------------------------------------------------------------------

class CSShopListResp : public ::google::protobuf::MessageLite {
 public:
  CSShopListResp();
  virtual ~CSShopListResp();

  CSShopListResp(const CSShopListResp& from);

  inline CSShopListResp& operator=(const CSShopListResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSShopListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSShopListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSShopListResp* other);

  // implements Message ----------------------------------------------

  CSShopListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSShopListResp& from);
  void MergeFrom(const CSShopListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.DiamondData diamondList = 1;
  inline int diamondlist_size() const;
  inline void clear_diamondlist();
  static const int kDiamondListFieldNumber = 1;
  inline const ::fgame::DiamondData& diamondlist(int index) const;
  inline ::fgame::DiamondData* mutable_diamondlist(int index);
  inline ::fgame::DiamondData* add_diamondlist();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::DiamondData >&
      diamondlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::DiamondData >*
      mutable_diamondlist();

  // repeated .fgame.GiftData giftList = 2;
  inline int giftlist_size() const;
  inline void clear_giftlist();
  static const int kGiftListFieldNumber = 2;
  inline const ::fgame::GiftData& giftlist(int index) const;
  inline ::fgame::GiftData* mutable_giftlist(int index);
  inline ::fgame::GiftData* add_giftlist();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::GiftData >&
      giftlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::GiftData >*
      mutable_giftlist();

  // @@protoc_insertion_point(class_scope:fgame.CSShopListResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::DiamondData > diamondlist_;
  ::google::protobuf::RepeatedPtrField< ::fgame::GiftData > giftlist_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSShopListResp* default_instance_;
};
// -------------------------------------------------------------------

class ExchangeItemInfo : public ::google::protobuf::MessageLite {
 public:
  ExchangeItemInfo();
  virtual ~ExchangeItemInfo();

  ExchangeItemInfo(const ExchangeItemInfo& from);

  inline ExchangeItemInfo& operator=(const ExchangeItemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ExchangeItemInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExchangeItemInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExchangeItemInfo* other);

  // implements Message ----------------------------------------------

  ExchangeItemInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExchangeItemInfo& from);
  void MergeFrom(const ExchangeItemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ItemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // required uint32 BuyLeftCount = 2;
  inline bool has_buyleftcount() const;
  inline void clear_buyleftcount();
  static const int kBuyLeftCountFieldNumber = 2;
  inline ::google::protobuf::uint32 buyleftcount() const;
  inline void set_buyleftcount(::google::protobuf::uint32 value);

  // required uint32 RefreshTime = 3;
  inline bool has_refreshtime() const;
  inline void clear_refreshtime();
  static const int kRefreshTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 refreshtime() const;
  inline void set_refreshtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.ExchangeItemInfo)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_buyleftcount();
  inline void clear_has_buyleftcount();
  inline void set_has_refreshtime();
  inline void clear_has_refreshtime();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint32 buyleftcount_;
  ::google::protobuf::uint32 refreshtime_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static ExchangeItemInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSExchangeItemReq : public ::google::protobuf::MessageLite {
 public:
  CSExchangeItemReq();
  virtual ~CSExchangeItemReq();

  CSExchangeItemReq(const CSExchangeItemReq& from);

  inline CSExchangeItemReq& operator=(const CSExchangeItemReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSExchangeItemReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSExchangeItemReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSExchangeItemReq* other);

  // implements Message ----------------------------------------------

  CSExchangeItemReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSExchangeItemReq& from);
  void MergeFrom(const CSExchangeItemReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ItemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSExchangeItemReq)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 itemid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSExchangeItemReq* default_instance_;
};
// -------------------------------------------------------------------

class CSExchangeItemResp : public ::google::protobuf::MessageLite {
 public:
  CSExchangeItemResp();
  virtual ~CSExchangeItemResp();

  CSExchangeItemResp(const CSExchangeItemResp& from);

  inline CSExchangeItemResp& operator=(const CSExchangeItemResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSExchangeItemResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSExchangeItemResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSExchangeItemResp* other);

  // implements Message ----------------------------------------------

  CSExchangeItemResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSExchangeItemResp& from);
  void MergeFrom(const CSExchangeItemResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .fgame.ExchangeItemInfo ExchangeItem = 1;
  inline bool has_exchangeitem() const;
  inline void clear_exchangeitem();
  static const int kExchangeItemFieldNumber = 1;
  inline const ::fgame::ExchangeItemInfo& exchangeitem() const;
  inline ::fgame::ExchangeItemInfo* mutable_exchangeitem();
  inline ::fgame::ExchangeItemInfo* release_exchangeitem();
  inline void set_allocated_exchangeitem(::fgame::ExchangeItemInfo* exchangeitem);

  // required uint32 HonorCount = 2;
  inline bool has_honorcount() const;
  inline void clear_honorcount();
  static const int kHonorCountFieldNumber = 2;
  inline ::google::protobuf::uint32 honorcount() const;
  inline void set_honorcount(::google::protobuf::uint32 value);

  // required uint32 Ret = 3;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 3;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSExchangeItemResp)
 private:
  inline void set_has_exchangeitem();
  inline void clear_has_exchangeitem();
  inline void set_has_honorcount();
  inline void clear_has_honorcount();
  inline void set_has_ret();
  inline void clear_has_ret();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::fgame::ExchangeItemInfo* exchangeitem_;
  ::google::protobuf::uint32 honorcount_;
  ::google::protobuf::uint32 ret_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSExchangeItemResp* default_instance_;
};
// -------------------------------------------------------------------

class CSUpdateExchangeListReq : public ::google::protobuf::MessageLite {
 public:
  CSUpdateExchangeListReq();
  virtual ~CSUpdateExchangeListReq();

  CSUpdateExchangeListReq(const CSUpdateExchangeListReq& from);

  inline CSUpdateExchangeListReq& operator=(const CSUpdateExchangeListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSUpdateExchangeListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSUpdateExchangeListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSUpdateExchangeListReq* other);

  // implements Message ----------------------------------------------

  CSUpdateExchangeListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSUpdateExchangeListReq& from);
  void MergeFrom(const CSUpdateExchangeListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSUpdateExchangeListReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSUpdateExchangeListReq* default_instance_;
};
// -------------------------------------------------------------------

class CSUpdateExchangeListResp : public ::google::protobuf::MessageLite {
 public:
  CSUpdateExchangeListResp();
  virtual ~CSUpdateExchangeListResp();

  CSUpdateExchangeListResp(const CSUpdateExchangeListResp& from);

  inline CSUpdateExchangeListResp& operator=(const CSUpdateExchangeListResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSUpdateExchangeListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSUpdateExchangeListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSUpdateExchangeListResp* other);

  // implements Message ----------------------------------------------

  CSUpdateExchangeListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSUpdateExchangeListResp& from);
  void MergeFrom(const CSUpdateExchangeListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.ExchangeItemInfo ExchangeItem = 1;
  inline int exchangeitem_size() const;
  inline void clear_exchangeitem();
  static const int kExchangeItemFieldNumber = 1;
  inline const ::fgame::ExchangeItemInfo& exchangeitem(int index) const;
  inline ::fgame::ExchangeItemInfo* mutable_exchangeitem(int index);
  inline ::fgame::ExchangeItemInfo* add_exchangeitem();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::ExchangeItemInfo >&
      exchangeitem() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::ExchangeItemInfo >*
      mutable_exchangeitem();

  // required uint32 HonorCount = 2;
  inline bool has_honorcount() const;
  inline void clear_honorcount();
  static const int kHonorCountFieldNumber = 2;
  inline ::google::protobuf::uint32 honorcount() const;
  inline void set_honorcount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSUpdateExchangeListResp)
 private:
  inline void set_has_honorcount();
  inline void clear_has_honorcount();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::ExchangeItemInfo > exchangeitem_;
  ::google::protobuf::uint32 honorcount_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSUpdateExchangeListResp* default_instance_;
};
// -------------------------------------------------------------------

class CSChangePlayerIconReq : public ::google::protobuf::MessageLite {
 public:
  CSChangePlayerIconReq();
  virtual ~CSChangePlayerIconReq();

  CSChangePlayerIconReq(const CSChangePlayerIconReq& from);

  inline CSChangePlayerIconReq& operator=(const CSChangePlayerIconReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSChangePlayerIconReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChangePlayerIconReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChangePlayerIconReq* other);

  // implements Message ----------------------------------------------

  CSChangePlayerIconReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChangePlayerIconReq& from);
  void MergeFrom(const CSChangePlayerIconReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string IconId = 1;
  inline bool has_iconid() const;
  inline void clear_iconid();
  static const int kIconIdFieldNumber = 1;
  inline const ::std::string& iconid() const;
  inline void set_iconid(const ::std::string& value);
  inline void set_iconid(const char* value);
  inline void set_iconid(const char* value, size_t size);
  inline ::std::string* mutable_iconid();
  inline ::std::string* release_iconid();
  inline void set_allocated_iconid(::std::string* iconid);

  // @@protoc_insertion_point(class_scope:fgame.CSChangePlayerIconReq)
 private:
  inline void set_has_iconid();
  inline void clear_has_iconid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* iconid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSChangePlayerIconReq* default_instance_;
};
// -------------------------------------------------------------------

class CSChangePlayerIconResp : public ::google::protobuf::MessageLite {
 public:
  CSChangePlayerIconResp();
  virtual ~CSChangePlayerIconResp();

  CSChangePlayerIconResp(const CSChangePlayerIconResp& from);

  inline CSChangePlayerIconResp& operator=(const CSChangePlayerIconResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSChangePlayerIconResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChangePlayerIconResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChangePlayerIconResp* other);

  // implements Message ----------------------------------------------

  CSChangePlayerIconResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChangePlayerIconResp& from);
  void MergeFrom(const CSChangePlayerIconResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required string IconId = 2;
  inline bool has_iconid() const;
  inline void clear_iconid();
  static const int kIconIdFieldNumber = 2;
  inline const ::std::string& iconid() const;
  inline void set_iconid(const ::std::string& value);
  inline void set_iconid(const char* value);
  inline void set_iconid(const char* value, size_t size);
  inline ::std::string* mutable_iconid();
  inline ::std::string* release_iconid();
  inline void set_allocated_iconid(::std::string* iconid);

  // @@protoc_insertion_point(class_scope:fgame.CSChangePlayerIconResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_iconid();
  inline void clear_has_iconid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* iconid_;
  ::google::protobuf::uint32 ret_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSChangePlayerIconResp* default_instance_;
};
// -------------------------------------------------------------------

class CSSetNewBieReq : public ::google::protobuf::MessageLite {
 public:
  CSSetNewBieReq();
  virtual ~CSSetNewBieReq();

  CSSetNewBieReq(const CSSetNewBieReq& from);

  inline CSSetNewBieReq& operator=(const CSSetNewBieReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSetNewBieReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSetNewBieReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSetNewBieReq* other);

  // implements Message ----------------------------------------------

  CSSetNewBieReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSetNewBieReq& from);
  void MergeFrom(const CSSetNewBieReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 NewBieId = 1;
  inline int newbieid_size() const;
  inline void clear_newbieid();
  static const int kNewBieIdFieldNumber = 1;
  inline ::google::protobuf::uint32 newbieid(int index) const;
  inline void set_newbieid(int index, ::google::protobuf::uint32 value);
  inline void add_newbieid(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      newbieid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_newbieid();

  // optional bool isComplete = 2;
  inline bool has_iscomplete() const;
  inline void clear_iscomplete();
  static const int kIsCompleteFieldNumber = 2;
  inline bool iscomplete() const;
  inline void set_iscomplete(bool value);

  // @@protoc_insertion_point(class_scope:fgame.CSSetNewBieReq)
 private:
  inline void set_has_iscomplete();
  inline void clear_has_iscomplete();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > newbieid_;
  bool iscomplete_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSetNewBieReq* default_instance_;
};
// -------------------------------------------------------------------

class CSSetNewBieResp : public ::google::protobuf::MessageLite {
 public:
  CSSetNewBieResp();
  virtual ~CSSetNewBieResp();

  CSSetNewBieResp(const CSSetNewBieResp& from);

  inline CSSetNewBieResp& operator=(const CSSetNewBieResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSetNewBieResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSetNewBieResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSetNewBieResp* other);

  // implements Message ----------------------------------------------

  CSSetNewBieResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSetNewBieResp& from);
  void MergeFrom(const CSSetNewBieResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSSetNewBieResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSetNewBieResp* default_instance_;
};
// -------------------------------------------------------------------

class CSGetNewBieListReq : public ::google::protobuf::MessageLite {
 public:
  CSGetNewBieListReq();
  virtual ~CSGetNewBieListReq();

  CSGetNewBieListReq(const CSGetNewBieListReq& from);

  inline CSGetNewBieListReq& operator=(const CSGetNewBieListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetNewBieListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetNewBieListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetNewBieListReq* other);

  // implements Message ----------------------------------------------

  CSGetNewBieListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetNewBieListReq& from);
  void MergeFrom(const CSGetNewBieListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSGetNewBieListReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetNewBieListReq* default_instance_;
};
// -------------------------------------------------------------------

class CSGetNewBieListResp : public ::google::protobuf::MessageLite {
 public:
  CSGetNewBieListResp();
  virtual ~CSGetNewBieListResp();

  CSGetNewBieListResp(const CSGetNewBieListResp& from);

  inline CSGetNewBieListResp& operator=(const CSGetNewBieListResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetNewBieListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetNewBieListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetNewBieListResp* other);

  // implements Message ----------------------------------------------

  CSGetNewBieListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetNewBieListResp& from);
  void MergeFrom(const CSGetNewBieListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool isComplete = 1;
  inline bool has_iscomplete() const;
  inline void clear_iscomplete();
  static const int kIsCompleteFieldNumber = 1;
  inline bool iscomplete() const;
  inline void set_iscomplete(bool value);

  // repeated uint32 NewBieIds = 2;
  inline int newbieids_size() const;
  inline void clear_newbieids();
  static const int kNewBieIdsFieldNumber = 2;
  inline ::google::protobuf::uint32 newbieids(int index) const;
  inline void set_newbieids(int index, ::google::protobuf::uint32 value);
  inline void add_newbieids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      newbieids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_newbieids();

  // @@protoc_insertion_point(class_scope:fgame.CSGetNewBieListResp)
 private:
  inline void set_has_iscomplete();
  inline void clear_has_iscomplete();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > newbieids_;
  bool iscomplete_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetNewBieListResp* default_instance_;
};
// -------------------------------------------------------------------

class CSSetNewBieOssReq : public ::google::protobuf::MessageLite {
 public:
  CSSetNewBieOssReq();
  virtual ~CSSetNewBieOssReq();

  CSSetNewBieOssReq(const CSSetNewBieOssReq& from);

  inline CSSetNewBieOssReq& operator=(const CSSetNewBieOssReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSetNewBieOssReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSetNewBieOssReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSetNewBieOssReq* other);

  // implements Message ----------------------------------------------

  CSSetNewBieOssReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSetNewBieOssReq& from);
  void MergeFrom(const CSSetNewBieOssReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 NewBieId = 1;
  inline bool has_newbieid() const;
  inline void clear_newbieid();
  static const int kNewBieIdFieldNumber = 1;
  inline ::google::protobuf::uint32 newbieid() const;
  inline void set_newbieid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSSetNewBieOssReq)
 private:
  inline void set_has_newbieid();
  inline void clear_has_newbieid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 newbieid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSetNewBieOssReq* default_instance_;
};
// -------------------------------------------------------------------

class CSSetNewBieOssResp : public ::google::protobuf::MessageLite {
 public:
  CSSetNewBieOssResp();
  virtual ~CSSetNewBieOssResp();

  CSSetNewBieOssResp(const CSSetNewBieOssResp& from);

  inline CSSetNewBieOssResp& operator=(const CSSetNewBieOssResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSetNewBieOssResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSetNewBieOssResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSetNewBieOssResp* other);

  // implements Message ----------------------------------------------

  CSSetNewBieOssResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSetNewBieOssResp& from);
  void MergeFrom(const CSSetNewBieOssResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 NewBieId = 1;
  inline bool has_newbieid() const;
  inline void clear_newbieid();
  static const int kNewBieIdFieldNumber = 1;
  inline ::google::protobuf::uint32 newbieid() const;
  inline void set_newbieid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSSetNewBieOssResp)
 private:
  inline void set_has_newbieid();
  inline void clear_has_newbieid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 newbieid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSetNewBieOssResp* default_instance_;
};
// -------------------------------------------------------------------

class CSOpenBigStageReq : public ::google::protobuf::MessageLite {
 public:
  CSOpenBigStageReq();
  virtual ~CSOpenBigStageReq();

  CSOpenBigStageReq(const CSOpenBigStageReq& from);

  inline CSOpenBigStageReq& operator=(const CSOpenBigStageReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSOpenBigStageReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOpenBigStageReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOpenBigStageReq* other);

  // implements Message ----------------------------------------------

  CSOpenBigStageReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOpenBigStageReq& from);
  void MergeFrom(const CSOpenBigStageReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 PointId = 1;
  inline bool has_pointid() const;
  inline void clear_pointid();
  static const int kPointIdFieldNumber = 1;
  inline ::google::protobuf::uint32 pointid() const;
  inline void set_pointid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSOpenBigStageReq)
 private:
  inline void set_has_pointid();
  inline void clear_has_pointid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 pointid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSOpenBigStageReq* default_instance_;
};
// -------------------------------------------------------------------

class CSOpenBigStageResp : public ::google::protobuf::MessageLite {
 public:
  CSOpenBigStageResp();
  virtual ~CSOpenBigStageResp();

  CSOpenBigStageResp(const CSOpenBigStageResp& from);

  inline CSOpenBigStageResp& operator=(const CSOpenBigStageResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSOpenBigStageResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOpenBigStageResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOpenBigStageResp* other);

  // implements Message ----------------------------------------------

  CSOpenBigStageResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOpenBigStageResp& from);
  void MergeFrom(const CSOpenBigStageResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required uint32 PointId = 2;
  inline bool has_pointid() const;
  inline void clear_pointid();
  static const int kPointIdFieldNumber = 2;
  inline ::google::protobuf::uint32 pointid() const;
  inline void set_pointid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSOpenBigStageResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_pointid();
  inline void clear_has_pointid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 pointid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSOpenBigStageResp* default_instance_;
};
// -------------------------------------------------------------------

class CSEnterPointReq : public ::google::protobuf::MessageLite {
 public:
  CSEnterPointReq();
  virtual ~CSEnterPointReq();

  CSEnterPointReq(const CSEnterPointReq& from);

  inline CSEnterPointReq& operator=(const CSEnterPointReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSEnterPointReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEnterPointReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEnterPointReq* other);

  // implements Message ----------------------------------------------

  CSEnterPointReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEnterPointReq& from);
  void MergeFrom(const CSEnterPointReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 PointId = 1;
  inline bool has_pointid() const;
  inline void clear_pointid();
  static const int kPointIdFieldNumber = 1;
  inline ::google::protobuf::uint32 pointid() const;
  inline void set_pointid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSEnterPointReq)
 private:
  inline void set_has_pointid();
  inline void clear_has_pointid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 pointid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSEnterPointReq* default_instance_;
};
// -------------------------------------------------------------------

class CSEnterPointResp : public ::google::protobuf::MessageLite {
 public:
  CSEnterPointResp();
  virtual ~CSEnterPointResp();

  CSEnterPointResp(const CSEnterPointResp& from);

  inline CSEnterPointResp& operator=(const CSEnterPointResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSEnterPointResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEnterPointResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEnterPointResp* other);

  // implements Message ----------------------------------------------

  CSEnterPointResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEnterPointResp& from);
  void MergeFrom(const CSEnterPointResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 PointId = 1;
  inline bool has_pointid() const;
  inline void clear_pointid();
  static const int kPointIdFieldNumber = 1;
  inline ::google::protobuf::uint32 pointid() const;
  inline void set_pointid(::google::protobuf::uint32 value);

  // required bool Ret = 2;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 2;
  inline bool ret() const;
  inline void set_ret(bool value);

  // @@protoc_insertion_point(class_scope:fgame.CSEnterPointResp)
 private:
  inline void set_has_pointid();
  inline void clear_has_pointid();
  inline void set_has_ret();
  inline void clear_has_ret();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 pointid_;
  bool ret_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSEnterPointResp* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyITtemReq : public ::google::protobuf::MessageLite {
 public:
  CSBuyITtemReq();
  virtual ~CSBuyITtemReq();

  CSBuyITtemReq(const CSBuyITtemReq& from);

  inline CSBuyITtemReq& operator=(const CSBuyITtemReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSBuyITtemReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyITtemReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyITtemReq* other);

  // implements Message ----------------------------------------------

  CSBuyITtemReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyITtemReq& from);
  void MergeFrom(const CSBuyITtemReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ItemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // required uint32 Price = 2;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 2;
  inline ::google::protobuf::uint32 price() const;
  inline void set_price(::google::protobuf::uint32 value);

  // required uint32 Count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required uint32 From = 4;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 4;
  inline ::google::protobuf::uint32 from() const;
  inline void set_from(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSBuyITtemReq)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_from();
  inline void clear_has_from();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint32 price_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 from_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSBuyITtemReq* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyItemResp : public ::google::protobuf::MessageLite {
 public:
  CSBuyItemResp();
  virtual ~CSBuyItemResp();

  CSBuyItemResp(const CSBuyItemResp& from);

  inline CSBuyItemResp& operator=(const CSBuyItemResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSBuyItemResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyItemResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyItemResp* other);

  // implements Message ----------------------------------------------

  CSBuyItemResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyItemResp& from);
  void MergeFrom(const CSBuyItemResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required uint32 ItemId = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // required uint32 Count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required uint32 Price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline ::google::protobuf::uint32 price() const;
  inline void set_price(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSBuyItemResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_price();
  inline void clear_has_price();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 price_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSBuyItemResp* default_instance_;
};
// -------------------------------------------------------------------

class CSUseItemReq : public ::google::protobuf::MessageLite {
 public:
  CSUseItemReq();
  virtual ~CSUseItemReq();

  CSUseItemReq(const CSUseItemReq& from);

  inline CSUseItemReq& operator=(const CSUseItemReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSUseItemReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSUseItemReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSUseItemReq* other);

  // implements Message ----------------------------------------------

  CSUseItemReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSUseItemReq& from);
  void MergeFrom(const CSUseItemReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ItemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // required uint32 Count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSUseItemReq)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_count();
  inline void clear_has_count();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint32 count_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSUseItemReq* default_instance_;
};
// -------------------------------------------------------------------

class CSUseItemResp : public ::google::protobuf::MessageLite {
 public:
  CSUseItemResp();
  virtual ~CSUseItemResp();

  CSUseItemResp(const CSUseItemResp& from);

  inline CSUseItemResp& operator=(const CSUseItemResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSUseItemResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSUseItemResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSUseItemResp* other);

  // implements Message ----------------------------------------------

  CSUseItemResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSUseItemResp& from);
  void MergeFrom(const CSUseItemResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required uint32 ItemId = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSUseItemResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_itemid();
  inline void clear_has_itemid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 itemid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSUseItemResp* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyVipReq : public ::google::protobuf::MessageLite {
 public:
  CSBuyVipReq();
  virtual ~CSBuyVipReq();

  CSBuyVipReq(const CSBuyVipReq& from);

  inline CSBuyVipReq& operator=(const CSBuyVipReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSBuyVipReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyVipReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyVipReq* other);

  // implements Message ----------------------------------------------

  CSBuyVipReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyVipReq& from);
  void MergeFrom(const CSBuyVipReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 VipLevel = 1;
  inline bool has_viplevel() const;
  inline void clear_viplevel();
  static const int kVipLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 viplevel() const;
  inline void set_viplevel(::google::protobuf::uint32 value);

  // required uint32 Price = 2;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 2;
  inline ::google::protobuf::uint32 price() const;
  inline void set_price(::google::protobuf::uint32 value);

  // required uint32 Payment = 3;
  inline bool has_payment() const;
  inline void clear_payment();
  static const int kPaymentFieldNumber = 3;
  inline ::google::protobuf::uint32 payment() const;
  inline void set_payment(::google::protobuf::uint32 value);

  // required uint32 TimeType = 4;
  inline bool has_timetype() const;
  inline void clear_timetype();
  static const int kTimeTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 timetype() const;
  inline void set_timetype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSBuyVipReq)
 private:
  inline void set_has_viplevel();
  inline void clear_has_viplevel();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_payment();
  inline void clear_has_payment();
  inline void set_has_timetype();
  inline void clear_has_timetype();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 viplevel_;
  ::google::protobuf::uint32 price_;
  ::google::protobuf::uint32 payment_;
  ::google::protobuf::uint32 timetype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSBuyVipReq* default_instance_;
};
// -------------------------------------------------------------------

class CSVipTimeReq : public ::google::protobuf::MessageLite {
 public:
  CSVipTimeReq();
  virtual ~CSVipTimeReq();

  CSVipTimeReq(const CSVipTimeReq& from);

  inline CSVipTimeReq& operator=(const CSVipTimeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSVipTimeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSVipTimeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSVipTimeReq* other);

  // implements Message ----------------------------------------------

  CSVipTimeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSVipTimeReq& from);
  void MergeFrom(const CSVipTimeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSVipTimeReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSVipTimeReq* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyVipResp : public ::google::protobuf::MessageLite {
 public:
  CSBuyVipResp();
  virtual ~CSBuyVipResp();

  CSBuyVipResp(const CSBuyVipResp& from);

  inline CSBuyVipResp& operator=(const CSBuyVipResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSBuyVipResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyVipResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyVipResp* other);

  // implements Message ----------------------------------------------

  CSBuyVipResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyVipResp& from);
  void MergeFrom(const CSBuyVipResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 VipLevel = 1;
  inline bool has_viplevel() const;
  inline void clear_viplevel();
  static const int kVipLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 viplevel() const;
  inline void set_viplevel(::google::protobuf::uint32 value);

  // optional string RemainTime = 2;
  inline bool has_remaintime() const;
  inline void clear_remaintime();
  static const int kRemainTimeFieldNumber = 2;
  inline const ::std::string& remaintime() const;
  inline void set_remaintime(const ::std::string& value);
  inline void set_remaintime(const char* value);
  inline void set_remaintime(const char* value, size_t size);
  inline ::std::string* mutable_remaintime();
  inline ::std::string* release_remaintime();
  inline void set_allocated_remaintime(::std::string* remaintime);

  // optional uint32 Type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSBuyVipResp)
 private:
  inline void set_has_viplevel();
  inline void clear_has_viplevel();
  inline void set_has_remaintime();
  inline void clear_has_remaintime();
  inline void set_has_type();
  inline void clear_has_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* remaintime_;
  ::google::protobuf::uint32 viplevel_;
  ::google::protobuf::uint32 type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSBuyVipResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPropertyUpdateResp : public ::google::protobuf::MessageLite {
 public:
  CSPropertyUpdateResp();
  virtual ~CSPropertyUpdateResp();

  CSPropertyUpdateResp(const CSPropertyUpdateResp& from);

  inline CSPropertyUpdateResp& operator=(const CSPropertyUpdateResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPropertyUpdateResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPropertyUpdateResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPropertyUpdateResp* other);

  // implements Message ----------------------------------------------

  CSPropertyUpdateResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPropertyUpdateResp& from);
  void MergeFrom(const CSPropertyUpdateResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.PropertyUpdateData UpdateData = 1;
  inline int updatedata_size() const;
  inline void clear_updatedata();
  static const int kUpdateDataFieldNumber = 1;
  inline const ::fgame::PropertyUpdateData& updatedata(int index) const;
  inline ::fgame::PropertyUpdateData* mutable_updatedata(int index);
  inline ::fgame::PropertyUpdateData* add_updatedata();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >&
      updatedata() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >*
      mutable_updatedata();

  // @@protoc_insertion_point(class_scope:fgame.CSPropertyUpdateResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData > updatedata_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSPropertyUpdateResp* default_instance_;
};
// -------------------------------------------------------------------

class CSGetAchievementReq : public ::google::protobuf::MessageLite {
 public:
  CSGetAchievementReq();
  virtual ~CSGetAchievementReq();

  CSGetAchievementReq(const CSGetAchievementReq& from);

  inline CSGetAchievementReq& operator=(const CSGetAchievementReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetAchievementReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetAchievementReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetAchievementReq* other);

  // implements Message ----------------------------------------------

  CSGetAchievementReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetAchievementReq& from);
  void MergeFrom(const CSGetAchievementReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSGetAchievementReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetAchievementReq* default_instance_;
};
// -------------------------------------------------------------------

class CSGetAchievementInfo : public ::google::protobuf::MessageLite {
 public:
  CSGetAchievementInfo();
  virtual ~CSGetAchievementInfo();

  CSGetAchievementInfo(const CSGetAchievementInfo& from);

  inline CSGetAchievementInfo& operator=(const CSGetAchievementInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetAchievementInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetAchievementInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetAchievementInfo* other);

  // implements Message ----------------------------------------------

  CSGetAchievementInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetAchievementInfo& from);
  void MergeFrom(const CSGetAchievementInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 Status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // required uint32 ReceivePlayerCount = 3;
  inline bool has_receiveplayercount() const;
  inline void clear_receiveplayercount();
  static const int kReceivePlayerCountFieldNumber = 3;
  inline ::google::protobuf::uint32 receiveplayercount() const;
  inline void set_receiveplayercount(::google::protobuf::uint32 value);

  // optional uint64 CompleteCount = 4;
  inline bool has_completecount() const;
  inline void clear_completecount();
  static const int kCompleteCountFieldNumber = 4;
  inline ::google::protobuf::uint64 completecount() const;
  inline void set_completecount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGetAchievementInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_receiveplayercount();
  inline void clear_has_receiveplayercount();
  inline void set_has_completecount();
  inline void clear_has_completecount();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint64 completecount_;
  ::google::protobuf::uint32 receiveplayercount_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetAchievementInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSGetAchievementResp : public ::google::protobuf::MessageLite {
 public:
  CSGetAchievementResp();
  virtual ~CSGetAchievementResp();

  CSGetAchievementResp(const CSGetAchievementResp& from);

  inline CSGetAchievementResp& operator=(const CSGetAchievementResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetAchievementResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetAchievementResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetAchievementResp* other);

  // implements Message ----------------------------------------------

  CSGetAchievementResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetAchievementResp& from);
  void MergeFrom(const CSGetAchievementResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.CSGetAchievementInfo Data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::fgame::CSGetAchievementInfo& data(int index) const;
  inline ::fgame::CSGetAchievementInfo* mutable_data(int index);
  inline ::fgame::CSGetAchievementInfo* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSGetAchievementInfo >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSGetAchievementInfo >*
      mutable_data();

  // required uint32 AchievementPointCount = 2;
  inline bool has_achievementpointcount() const;
  inline void clear_achievementpointcount();
  static const int kAchievementPointCountFieldNumber = 2;
  inline ::google::protobuf::uint32 achievementpointcount() const;
  inline void set_achievementpointcount(::google::protobuf::uint32 value);

  // required uint32 AchievementLevel = 3;
  inline bool has_achievementlevel() const;
  inline void clear_achievementlevel();
  static const int kAchievementLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 achievementlevel() const;
  inline void set_achievementlevel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGetAchievementResp)
 private:
  inline void set_has_achievementpointcount();
  inline void clear_has_achievementpointcount();
  inline void set_has_achievementlevel();
  inline void clear_has_achievementlevel();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSGetAchievementInfo > data_;
  ::google::protobuf::uint32 achievementpointcount_;
  ::google::protobuf::uint32 achievementlevel_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetAchievementResp* default_instance_;
};
// -------------------------------------------------------------------

class CSReceiveAchievementReq : public ::google::protobuf::MessageLite {
 public:
  CSReceiveAchievementReq();
  virtual ~CSReceiveAchievementReq();

  CSReceiveAchievementReq(const CSReceiveAchievementReq& from);

  inline CSReceiveAchievementReq& operator=(const CSReceiveAchievementReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSReceiveAchievementReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSReceiveAchievementReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSReceiveAchievementReq* other);

  // implements Message ----------------------------------------------

  CSReceiveAchievementReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSReceiveAchievementReq& from);
  void MergeFrom(const CSReceiveAchievementReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 AchievementId = 1;
  inline bool has_achievementid() const;
  inline void clear_achievementid();
  static const int kAchievementIdFieldNumber = 1;
  inline ::google::protobuf::uint32 achievementid() const;
  inline void set_achievementid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSReceiveAchievementReq)
 private:
  inline void set_has_achievementid();
  inline void clear_has_achievementid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 achievementid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSReceiveAchievementReq* default_instance_;
};
// -------------------------------------------------------------------

class CSReceiveAchievementResp : public ::google::protobuf::MessageLite {
 public:
  CSReceiveAchievementResp();
  virtual ~CSReceiveAchievementResp();

  CSReceiveAchievementResp(const CSReceiveAchievementResp& from);

  inline CSReceiveAchievementResp& operator=(const CSReceiveAchievementResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSReceiveAchievementResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSReceiveAchievementResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSReceiveAchievementResp* other);

  // implements Message ----------------------------------------------

  CSReceiveAchievementResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSReceiveAchievementResp& from);
  void MergeFrom(const CSReceiveAchievementResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required uint32 AchievementId = 2;
  inline bool has_achievementid() const;
  inline void clear_achievementid();
  static const int kAchievementIdFieldNumber = 2;
  inline ::google::protobuf::uint32 achievementid() const;
  inline void set_achievementid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSReceiveAchievementResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_achievementid();
  inline void clear_has_achievementid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 achievementid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSReceiveAchievementResp* default_instance_;
};
// -------------------------------------------------------------------

class CSReceiveAchievementRewardReq : public ::google::protobuf::MessageLite {
 public:
  CSReceiveAchievementRewardReq();
  virtual ~CSReceiveAchievementRewardReq();

  CSReceiveAchievementRewardReq(const CSReceiveAchievementRewardReq& from);

  inline CSReceiveAchievementRewardReq& operator=(const CSReceiveAchievementRewardReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSReceiveAchievementRewardReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSReceiveAchievementRewardReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSReceiveAchievementRewardReq* other);

  // implements Message ----------------------------------------------

  CSReceiveAchievementRewardReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSReceiveAchievementRewardReq& from);
  void MergeFrom(const CSReceiveAchievementRewardReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 AchievementLevel = 1;
  inline bool has_achievementlevel() const;
  inline void clear_achievementlevel();
  static const int kAchievementLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 achievementlevel() const;
  inline void set_achievementlevel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSReceiveAchievementRewardReq)
 private:
  inline void set_has_achievementlevel();
  inline void clear_has_achievementlevel();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 achievementlevel_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSReceiveAchievementRewardReq* default_instance_;
};
// -------------------------------------------------------------------

class CSReceiveAchievementRewardResp : public ::google::protobuf::MessageLite {
 public:
  CSReceiveAchievementRewardResp();
  virtual ~CSReceiveAchievementRewardResp();

  CSReceiveAchievementRewardResp(const CSReceiveAchievementRewardResp& from);

  inline CSReceiveAchievementRewardResp& operator=(const CSReceiveAchievementRewardResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSReceiveAchievementRewardResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSReceiveAchievementRewardResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSReceiveAchievementRewardResp* other);

  // implements Message ----------------------------------------------

  CSReceiveAchievementRewardResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSReceiveAchievementRewardResp& from);
  void MergeFrom(const CSReceiveAchievementRewardResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required uint32 AchievementLevel = 2;
  inline bool has_achievementlevel() const;
  inline void clear_achievementlevel();
  static const int kAchievementLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 achievementlevel() const;
  inline void set_achievementlevel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSReceiveAchievementRewardResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_achievementlevel();
  inline void clear_has_achievementlevel();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 achievementlevel_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSReceiveAchievementRewardResp* default_instance_;
};
// -------------------------------------------------------------------

class CSUpdateAchievementResp : public ::google::protobuf::MessageLite {
 public:
  CSUpdateAchievementResp();
  virtual ~CSUpdateAchievementResp();

  CSUpdateAchievementResp(const CSUpdateAchievementResp& from);

  inline CSUpdateAchievementResp& operator=(const CSUpdateAchievementResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSUpdateAchievementResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSUpdateAchievementResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSUpdateAchievementResp* other);

  // implements Message ----------------------------------------------

  CSUpdateAchievementResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSUpdateAchievementResp& from);
  void MergeFrom(const CSUpdateAchievementResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 ListIds = 1;
  inline int listids_size() const;
  inline void clear_listids();
  static const int kListIdsFieldNumber = 1;
  inline ::google::protobuf::uint32 listids(int index) const;
  inline void set_listids(int index, ::google::protobuf::uint32 value);
  inline void add_listids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      listids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_listids();

  // @@protoc_insertion_point(class_scope:fgame.CSUpdateAchievementResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > listids_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSUpdateAchievementResp* default_instance_;
};
// -------------------------------------------------------------------

class CSSevenDaySignListReq : public ::google::protobuf::MessageLite {
 public:
  CSSevenDaySignListReq();
  virtual ~CSSevenDaySignListReq();

  CSSevenDaySignListReq(const CSSevenDaySignListReq& from);

  inline CSSevenDaySignListReq& operator=(const CSSevenDaySignListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSevenDaySignListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSevenDaySignListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSevenDaySignListReq* other);

  // implements Message ----------------------------------------------

  CSSevenDaySignListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSevenDaySignListReq& from);
  void MergeFrom(const CSSevenDaySignListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSSevenDaySignListReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSevenDaySignListReq* default_instance_;
};
// -------------------------------------------------------------------

class CSSevenDayGetList : public ::google::protobuf::MessageLite {
 public:
  CSSevenDayGetList();
  virtual ~CSSevenDayGetList();

  CSSevenDayGetList(const CSSevenDayGetList& from);

  inline CSSevenDayGetList& operator=(const CSSevenDayGetList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSevenDayGetList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSevenDayGetList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSevenDayGetList* other);

  // implements Message ----------------------------------------------

  CSSevenDayGetList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSevenDayGetList& from);
  void MergeFrom(const CSSevenDayGetList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool isGet = 1;
  inline bool has_isget() const;
  inline void clear_isget();
  static const int kIsGetFieldNumber = 1;
  inline bool isget() const;
  inline void set_isget(bool value);

  // required bool isNewGift = 2;
  inline bool has_isnewgift() const;
  inline void clear_isnewgift();
  static const int kIsNewGiftFieldNumber = 2;
  inline bool isnewgift() const;
  inline void set_isnewgift(bool value);

  // @@protoc_insertion_point(class_scope:fgame.CSSevenDayGetList)
 private:
  inline void set_has_isget();
  inline void clear_has_isget();
  inline void set_has_isnewgift();
  inline void clear_has_isnewgift();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool isget_;
  bool isnewgift_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSevenDayGetList* default_instance_;
};
// -------------------------------------------------------------------

class CSSevenDaySignListResp : public ::google::protobuf::MessageLite {
 public:
  CSSevenDaySignListResp();
  virtual ~CSSevenDaySignListResp();

  CSSevenDaySignListResp(const CSSevenDaySignListResp& from);

  inline CSSevenDaySignListResp& operator=(const CSSevenDaySignListResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSevenDaySignListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSevenDaySignListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSevenDaySignListResp* other);

  // implements Message ----------------------------------------------

  CSSevenDaySignListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSevenDaySignListResp& from);
  void MergeFrom(const CSSevenDaySignListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 nowDay = 1;
  inline bool has_nowday() const;
  inline void clear_nowday();
  static const int kNowDayFieldNumber = 1;
  inline ::google::protobuf::uint32 nowday() const;
  inline void set_nowday(::google::protobuf::uint32 value);

  // repeated .fgame.CSSevenDayGetList getList = 2;
  inline int getlist_size() const;
  inline void clear_getlist();
  static const int kGetListFieldNumber = 2;
  inline const ::fgame::CSSevenDayGetList& getlist(int index) const;
  inline ::fgame::CSSevenDayGetList* mutable_getlist(int index);
  inline ::fgame::CSSevenDayGetList* add_getlist();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSSevenDayGetList >&
      getlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSSevenDayGetList >*
      mutable_getlist();

  // @@protoc_insertion_point(class_scope:fgame.CSSevenDaySignListResp)
 private:
  inline void set_has_nowday();
  inline void clear_has_nowday();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSSevenDayGetList > getlist_;
  ::google::protobuf::uint32 nowday_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSevenDaySignListResp* default_instance_;
};
// -------------------------------------------------------------------

class CSSevenDaySignReq : public ::google::protobuf::MessageLite {
 public:
  CSSevenDaySignReq();
  virtual ~CSSevenDaySignReq();

  CSSevenDaySignReq(const CSSevenDaySignReq& from);

  inline CSSevenDaySignReq& operator=(const CSSevenDaySignReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSevenDaySignReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSevenDaySignReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSevenDaySignReq* other);

  // implements Message ----------------------------------------------

  CSSevenDaySignReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSevenDaySignReq& from);
  void MergeFrom(const CSSevenDaySignReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSSevenDaySignReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSevenDaySignReq* default_instance_;
};
// -------------------------------------------------------------------

class CSSevenDaySignResp : public ::google::protobuf::MessageLite {
 public:
  CSSevenDaySignResp();
  virtual ~CSSevenDaySignResp();

  CSSevenDaySignResp(const CSSevenDaySignResp& from);

  inline CSSevenDaySignResp& operator=(const CSSevenDaySignResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSevenDaySignResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSevenDaySignResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSevenDaySignResp* other);

  // implements Message ----------------------------------------------

  CSSevenDaySignResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSevenDaySignResp& from);
  void MergeFrom(const CSSevenDaySignResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 giftId = 1;
  inline bool has_giftid() const;
  inline void clear_giftid();
  static const int kGiftIdFieldNumber = 1;
  inline ::google::protobuf::uint32 giftid() const;
  inline void set_giftid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSSevenDaySignResp)
 private:
  inline void set_has_giftid();
  inline void clear_has_giftid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 giftid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSevenDaySignResp* default_instance_;
};
// -------------------------------------------------------------------

class CSGetServerReq : public ::google::protobuf::MessageLite {
 public:
  CSGetServerReq();
  virtual ~CSGetServerReq();

  CSGetServerReq(const CSGetServerReq& from);

  inline CSGetServerReq& operator=(const CSGetServerReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetServerReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetServerReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetServerReq* other);

  // implements Message ----------------------------------------------

  CSGetServerReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetServerReq& from);
  void MergeFrom(const CSGetServerReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string OpenId = 1;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenIdFieldNumber = 1;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional uint32 LastTs = 2;
  inline bool has_lastts() const;
  inline void clear_lastts();
  static const int kLastTsFieldNumber = 2;
  inline ::google::protobuf::uint32 lastts() const;
  inline void set_lastts(::google::protobuf::uint32 value);

  // optional string GameServerName = 3;
  inline bool has_gameservername() const;
  inline void clear_gameservername();
  static const int kGameServerNameFieldNumber = 3;
  inline const ::std::string& gameservername() const;
  inline void set_gameservername(const ::std::string& value);
  inline void set_gameservername(const char* value);
  inline void set_gameservername(const char* value, size_t size);
  inline ::std::string* mutable_gameservername();
  inline ::std::string* release_gameservername();
  inline void set_allocated_gameservername(::std::string* gameservername);

  // optional uint64 Uin = 4;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 4;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // optional string Version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:fgame.CSGetServerReq)
 private:
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_lastts();
  inline void clear_has_lastts();
  inline void set_has_gameservername();
  inline void clear_has_gameservername();
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_version();
  inline void clear_has_version();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* openid_;
  ::std::string* gameservername_;
  ::google::protobuf::uint64 uin_;
  ::std::string* version_;
  ::google::protobuf::uint32 lastts_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetServerReq* default_instance_;
};
// -------------------------------------------------------------------

class CSGetServerResp : public ::google::protobuf::MessageLite {
 public:
  CSGetServerResp();
  virtual ~CSGetServerResp();

  CSGetServerResp(const CSGetServerResp& from);

  inline CSGetServerResp& operator=(const CSGetServerResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetServerResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetServerResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetServerResp* other);

  // implements Message ----------------------------------------------

  CSGetServerResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetServerResp& from);
  void MergeFrom(const CSGetServerResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string LoginServer = 1;
  inline bool has_loginserver() const;
  inline void clear_loginserver();
  static const int kLoginServerFieldNumber = 1;
  inline const ::std::string& loginserver() const;
  inline void set_loginserver(const ::std::string& value);
  inline void set_loginserver(const char* value);
  inline void set_loginserver(const char* value, size_t size);
  inline ::std::string* mutable_loginserver();
  inline ::std::string* release_loginserver();
  inline void set_allocated_loginserver(::std::string* loginserver);

  // optional string GameServer = 2;
  inline bool has_gameserver() const;
  inline void clear_gameserver();
  static const int kGameServerFieldNumber = 2;
  inline const ::std::string& gameserver() const;
  inline void set_gameserver(const ::std::string& value);
  inline void set_gameserver(const char* value);
  inline void set_gameserver(const char* value, size_t size);
  inline ::std::string* mutable_gameserver();
  inline ::std::string* release_gameserver();
  inline void set_allocated_gameserver(::std::string* gameserver);

  // optional string GameServerName = 3;
  inline bool has_gameservername() const;
  inline void clear_gameservername();
  static const int kGameServerNameFieldNumber = 3;
  inline const ::std::string& gameservername() const;
  inline void set_gameservername(const ::std::string& value);
  inline void set_gameservername(const char* value);
  inline void set_gameservername(const char* value, size_t size);
  inline ::std::string* mutable_gameservername();
  inline ::std::string* release_gameservername();
  inline void set_allocated_gameservername(::std::string* gameservername);

  // optional uint32 WhiteUpdate = 4;
  inline bool has_whiteupdate() const;
  inline void clear_whiteupdate();
  static const int kWhiteUpdateFieldNumber = 4;
  inline ::google::protobuf::uint32 whiteupdate() const;
  inline void set_whiteupdate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGetServerResp)
 private:
  inline void set_has_loginserver();
  inline void clear_has_loginserver();
  inline void set_has_gameserver();
  inline void clear_has_gameserver();
  inline void set_has_gameservername();
  inline void clear_has_gameservername();
  inline void set_has_whiteupdate();
  inline void clear_has_whiteupdate();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* loginserver_;
  ::std::string* gameserver_;
  ::std::string* gameservername_;
  ::google::protobuf::uint32 whiteupdate_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetServerResp* default_instance_;
};
// -------------------------------------------------------------------

class CSEnterServerReq : public ::google::protobuf::MessageLite {
 public:
  CSEnterServerReq();
  virtual ~CSEnterServerReq();

  CSEnterServerReq(const CSEnterServerReq& from);

  inline CSEnterServerReq& operator=(const CSEnterServerReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSEnterServerReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEnterServerReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEnterServerReq* other);

  // implements Message ----------------------------------------------

  CSEnterServerReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEnterServerReq& from);
  void MergeFrom(const CSEnterServerReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required string OpenId = 2;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenIdFieldNumber = 2;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // required uint32 Retry = 3;
  inline bool has_retry() const;
  inline void clear_retry();
  static const int kRetryFieldNumber = 3;
  inline ::google::protobuf::uint32 retry() const;
  inline void set_retry(::google::protobuf::uint32 value);

  // optional string IMEI = 4;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kIMEIFieldNumber = 4;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional string Version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:fgame.CSEnterServerReq)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_retry();
  inline void clear_has_retry();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_version();
  inline void clear_has_version();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  ::std::string* openid_;
  ::std::string* imei_;
  ::std::string* version_;
  ::google::protobuf::uint32 retry_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSEnterServerReq* default_instance_;
};
// -------------------------------------------------------------------

class CSEnterServerResp : public ::google::protobuf::MessageLite {
 public:
  CSEnterServerResp();
  virtual ~CSEnterServerResp();

  CSEnterServerResp(const CSEnterServerResp& from);

  inline CSEnterServerResp& operator=(const CSEnterServerResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSEnterServerResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEnterServerResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEnterServerResp* other);

  // implements Message ----------------------------------------------

  CSEnterServerResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEnterServerResp& from);
  void MergeFrom(const CSEnterServerResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Overload = 1;
  inline bool has_overload() const;
  inline void clear_overload();
  static const int kOverloadFieldNumber = 1;
  inline ::google::protobuf::uint32 overload() const;
  inline void set_overload(::google::protobuf::uint32 value);

  // optional uint32 ForceExit = 2;
  inline bool has_forceexit() const;
  inline void clear_forceexit();
  static const int kForceExitFieldNumber = 2;
  inline ::google::protobuf::uint32 forceexit() const;
  inline void set_forceexit(::google::protobuf::uint32 value);

  // optional uint32 Wait_Num = 3;
  inline bool has_wait_num() const;
  inline void clear_wait_num();
  static const int kWaitNumFieldNumber = 3;
  inline ::google::protobuf::uint32 wait_num() const;
  inline void set_wait_num(::google::protobuf::uint32 value);

  // optional string GameServerName = 4;
  inline bool has_gameservername() const;
  inline void clear_gameservername();
  static const int kGameServerNameFieldNumber = 4;
  inline const ::std::string& gameservername() const;
  inline void set_gameservername(const ::std::string& value);
  inline void set_gameservername(const char* value);
  inline void set_gameservername(const char* value, size_t size);
  inline ::std::string* mutable_gameservername();
  inline ::std::string* release_gameservername();
  inline void set_allocated_gameservername(::std::string* gameservername);

  // optional uint32 Ts = 5;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 5;
  inline ::google::protobuf::uint32 ts() const;
  inline void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSEnterServerResp)
 private:
  inline void set_has_overload();
  inline void clear_has_overload();
  inline void set_has_forceexit();
  inline void clear_has_forceexit();
  inline void set_has_wait_num();
  inline void clear_has_wait_num();
  inline void set_has_gameservername();
  inline void clear_has_gameservername();
  inline void set_has_ts();
  inline void clear_has_ts();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 overload_;
  ::google::protobuf::uint32 forceexit_;
  ::std::string* gameservername_;
  ::google::protobuf::uint32 wait_num_;
  ::google::protobuf::uint32 ts_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSEnterServerResp* default_instance_;
};
// -------------------------------------------------------------------

class CSCanEnterReq : public ::google::protobuf::MessageLite {
 public:
  CSCanEnterReq();
  virtual ~CSCanEnterReq();

  CSCanEnterReq(const CSCanEnterReq& from);

  inline CSCanEnterReq& operator=(const CSCanEnterReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSCanEnterReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSCanEnterReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSCanEnterReq* other);

  // implements Message ----------------------------------------------

  CSCanEnterReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSCanEnterReq& from);
  void MergeFrom(const CSCanEnterReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:fgame.CSCanEnterReq)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSCanEnterReq* default_instance_;
};
// -------------------------------------------------------------------

class CSDirectEnterReq : public ::google::protobuf::MessageLite {
 public:
  CSDirectEnterReq();
  virtual ~CSDirectEnterReq();

  CSDirectEnterReq(const CSDirectEnterReq& from);

  inline CSDirectEnterReq& operator=(const CSDirectEnterReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSDirectEnterReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDirectEnterReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDirectEnterReq* other);

  // implements Message ----------------------------------------------

  CSDirectEnterReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDirectEnterReq& from);
  void MergeFrom(const CSDirectEnterReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:fgame.CSDirectEnterReq)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSDirectEnterReq* default_instance_;
};
// -------------------------------------------------------------------

class CSDircetEnterResp : public ::google::protobuf::MessageLite {
 public:
  CSDircetEnterResp();
  virtual ~CSDircetEnterResp();

  CSDircetEnterResp(const CSDircetEnterResp& from);

  inline CSDircetEnterResp& operator=(const CSDircetEnterResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSDircetEnterResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDircetEnterResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDircetEnterResp* other);

  // implements Message ----------------------------------------------

  CSDircetEnterResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDircetEnterResp& from);
  void MergeFrom(const CSDircetEnterResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSDircetEnterResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSDircetEnterResp* default_instance_;
};
// -------------------------------------------------------------------

class CSQueueReq : public ::google::protobuf::MessageLite {
 public:
  CSQueueReq();
  virtual ~CSQueueReq();

  CSQueueReq(const CSQueueReq& from);

  inline CSQueueReq& operator=(const CSQueueReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSQueueReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQueueReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQueueReq* other);

  // implements Message ----------------------------------------------

  CSQueueReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQueueReq& from);
  void MergeFrom(const CSQueueReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required uint32 Remain_Num = 2;
  inline bool has_remain_num() const;
  inline void clear_remain_num();
  static const int kRemainNumFieldNumber = 2;
  inline ::google::protobuf::uint32 remain_num() const;
  inline void set_remain_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSQueueReq)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_remain_num();
  inline void clear_has_remain_num();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  ::google::protobuf::uint32 remain_num_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSQueueReq* default_instance_;
};
// -------------------------------------------------------------------

class CSStreakWinValueReq : public ::google::protobuf::MessageLite {
 public:
  CSStreakWinValueReq();
  virtual ~CSStreakWinValueReq();

  CSStreakWinValueReq(const CSStreakWinValueReq& from);

  inline CSStreakWinValueReq& operator=(const CSStreakWinValueReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSStreakWinValueReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSStreakWinValueReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSStreakWinValueReq* other);

  // implements Message ----------------------------------------------

  CSStreakWinValueReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSStreakWinValueReq& from);
  void MergeFrom(const CSStreakWinValueReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:fgame.CSStreakWinValueReq)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSStreakWinValueReq* default_instance_;
};
// -------------------------------------------------------------------

class CSStreakWinValueResp : public ::google::protobuf::MessageLite {
 public:
  CSStreakWinValueResp();
  virtual ~CSStreakWinValueResp();

  CSStreakWinValueResp(const CSStreakWinValueResp& from);

  inline CSStreakWinValueResp& operator=(const CSStreakWinValueResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSStreakWinValueResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSStreakWinValueResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSStreakWinValueResp* other);

  // implements Message ----------------------------------------------

  CSStreakWinValueResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSStreakWinValueResp& from);
  void MergeFrom(const CSStreakWinValueResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required uint32 StreakWinValue = 2;
  inline bool has_streakwinvalue() const;
  inline void clear_streakwinvalue();
  static const int kStreakWinValueFieldNumber = 2;
  inline ::google::protobuf::uint32 streakwinvalue() const;
  inline void set_streakwinvalue(::google::protobuf::uint32 value);

  // optional uint32 GetWinValue = 3;
  inline bool has_getwinvalue() const;
  inline void clear_getwinvalue();
  static const int kGetWinValueFieldNumber = 3;
  inline ::google::protobuf::uint32 getwinvalue() const;
  inline void set_getwinvalue(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSStreakWinValueResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_streakwinvalue();
  inline void clear_has_streakwinvalue();
  inline void set_has_getwinvalue();
  inline void clear_has_getwinvalue();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 streakwinvalue_;
  ::google::protobuf::uint32 getwinvalue_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSStreakWinValueResp* default_instance_;
};
// -------------------------------------------------------------------

class CSStreakWinGetReq : public ::google::protobuf::MessageLite {
 public:
  CSStreakWinGetReq();
  virtual ~CSStreakWinGetReq();

  CSStreakWinGetReq(const CSStreakWinGetReq& from);

  inline CSStreakWinGetReq& operator=(const CSStreakWinGetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSStreakWinGetReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSStreakWinGetReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSStreakWinGetReq* other);

  // implements Message ----------------------------------------------

  CSStreakWinGetReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSStreakWinGetReq& from);
  void MergeFrom(const CSStreakWinGetReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 StreakWinValue = 1;
  inline bool has_streakwinvalue() const;
  inline void clear_streakwinvalue();
  static const int kStreakWinValueFieldNumber = 1;
  inline ::google::protobuf::uint32 streakwinvalue() const;
  inline void set_streakwinvalue(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSStreakWinGetReq)
 private:
  inline void set_has_streakwinvalue();
  inline void clear_has_streakwinvalue();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 streakwinvalue_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSStreakWinGetReq* default_instance_;
};
// -------------------------------------------------------------------

class CSStreakWinGetResp : public ::google::protobuf::MessageLite {
 public:
  CSStreakWinGetResp();
  virtual ~CSStreakWinGetResp();

  CSStreakWinGetResp(const CSStreakWinGetResp& from);

  inline CSStreakWinGetResp& operator=(const CSStreakWinGetResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSStreakWinGetResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSStreakWinGetResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSStreakWinGetResp* other);

  // implements Message ----------------------------------------------

  CSStreakWinGetResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSStreakWinGetResp& from);
  void MergeFrom(const CSStreakWinGetResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required uint32 DiamondValue = 2;
  inline bool has_diamondvalue() const;
  inline void clear_diamondvalue();
  static const int kDiamondValueFieldNumber = 2;
  inline ::google::protobuf::uint32 diamondvalue() const;
  inline void set_diamondvalue(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSStreakWinGetResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_diamondvalue();
  inline void clear_has_diamondvalue();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 diamondvalue_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSStreakWinGetResp* default_instance_;
};
// -------------------------------------------------------------------

class CSItem : public ::google::protobuf::MessageLite {
 public:
  CSItem();
  virtual ~CSItem();

  CSItem(const CSItem& from);

  inline CSItem& operator=(const CSItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSItem* other);

  // implements Message ----------------------------------------------

  CSItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSItem& from);
  void MergeFrom(const CSItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ItemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // required uint32 Count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSItem)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_count();
  inline void clear_has_count();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint32 count_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSItem* default_instance_;
};
// -------------------------------------------------------------------

class CSSycPlayerInfoReq : public ::google::protobuf::MessageLite {
 public:
  CSSycPlayerInfoReq();
  virtual ~CSSycPlayerInfoReq();

  CSSycPlayerInfoReq(const CSSycPlayerInfoReq& from);

  inline CSSycPlayerInfoReq& operator=(const CSSycPlayerInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSycPlayerInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSycPlayerInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSycPlayerInfoReq* other);

  // implements Message ----------------------------------------------

  CSSycPlayerInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSycPlayerInfoReq& from);
  void MergeFrom(const CSSycPlayerInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSSycPlayerInfoReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSycPlayerInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class CSTitleItem : public ::google::protobuf::MessageLite {
 public:
  CSTitleItem();
  virtual ~CSTitleItem();

  CSTitleItem(const CSTitleItem& from);

  inline CSTitleItem& operator=(const CSTitleItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSTitleItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSTitleItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSTitleItem* other);

  // implements Message ----------------------------------------------

  CSTitleItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSTitleItem& from);
  void MergeFrom(const CSTitleItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 Time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSTitleItem)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_time();
  inline void clear_has_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSTitleItem* default_instance_;
};
// -------------------------------------------------------------------

class CSSycPlayerInfoResp : public ::google::protobuf::MessageLite {
 public:
  CSSycPlayerInfoResp();
  virtual ~CSSycPlayerInfoResp();

  CSSycPlayerInfoResp(const CSSycPlayerInfoResp& from);

  inline CSSycPlayerInfoResp& operator=(const CSSycPlayerInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSycPlayerInfoResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSycPlayerInfoResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSycPlayerInfoResp* other);

  // implements Message ----------------------------------------------

  CSSycPlayerInfoResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSycPlayerInfoResp& from);
  void MergeFrom(const CSSycPlayerInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 PlayerTitle = 1;
  inline bool has_playertitle() const;
  inline void clear_playertitle();
  static const int kPlayerTitleFieldNumber = 1;
  inline ::google::protobuf::uint32 playertitle() const;
  inline void set_playertitle(::google::protobuf::uint32 value);

  // required uint32 Energy = 2;
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 2;
  inline ::google::protobuf::uint32 energy() const;
  inline void set_energy(::google::protobuf::uint32 value);

  // optional string Name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 ChangeNameCount = 4;
  inline bool has_changenamecount() const;
  inline void clear_changenamecount();
  static const int kChangeNameCountFieldNumber = 4;
  inline ::google::protobuf::uint32 changenamecount() const;
  inline void set_changenamecount(::google::protobuf::uint32 value);

  // optional uint32 EnergyBuyCount = 5;
  inline bool has_energybuycount() const;
  inline void clear_energybuycount();
  static const int kEnergyBuyCountFieldNumber = 5;
  inline ::google::protobuf::uint32 energybuycount() const;
  inline void set_energybuycount(::google::protobuf::uint32 value);

  // optional uint32 Diamond = 6;
  inline bool has_diamond() const;
  inline void clear_diamond();
  static const int kDiamondFieldNumber = 6;
  inline ::google::protobuf::uint32 diamond() const;
  inline void set_diamond(::google::protobuf::uint32 value);

  // optional string IconId = 7;
  inline bool has_iconid() const;
  inline void clear_iconid();
  static const int kIconIdFieldNumber = 7;
  inline const ::std::string& iconid() const;
  inline void set_iconid(const ::std::string& value);
  inline void set_iconid(const char* value);
  inline void set_iconid(const char* value, size_t size);
  inline ::std::string* mutable_iconid();
  inline ::std::string* release_iconid();
  inline void set_allocated_iconid(::std::string* iconid);

  // optional uint32 EnergySlot = 8;
  inline bool has_energyslot() const;
  inline void clear_energyslot();
  static const int kEnergySlotFieldNumber = 8;
  inline ::google::protobuf::uint32 energyslot() const;
  inline void set_energyslot(::google::protobuf::uint32 value);

  // optional uint32 Power = 9;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 9;
  inline ::google::protobuf::uint32 power() const;
  inline void set_power(::google::protobuf::uint32 value);

  // optional uint32 PowerSlot = 10;
  inline bool has_powerslot() const;
  inline void clear_powerslot();
  static const int kPowerSlotFieldNumber = 10;
  inline ::google::protobuf::uint32 powerslot() const;
  inline void set_powerslot(::google::protobuf::uint32 value);

  // repeated .fgame.CSItem Items = 11;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 11;
  inline const ::fgame::CSItem& items(int index) const;
  inline ::fgame::CSItem* mutable_items(int index);
  inline ::fgame::CSItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSItem >*
      mutable_items();

  // optional uint32 MonthCardDays = 12;
  inline bool has_monthcarddays() const;
  inline void clear_monthcarddays();
  static const int kMonthCardDaysFieldNumber = 12;
  inline ::google::protobuf::uint32 monthcarddays() const;
  inline void set_monthcarddays(::google::protobuf::uint32 value);

  // optional uint32 ShopGuide = 13;
  inline bool has_shopguide() const;
  inline void clear_shopguide();
  static const int kShopGuideFieldNumber = 13;
  inline ::google::protobuf::uint32 shopguide() const;
  inline void set_shopguide(::google::protobuf::uint32 value);

  // repeated uint32 TitleList = 14;
  inline int titlelist_size() const;
  inline void clear_titlelist();
  static const int kTitleListFieldNumber = 14;
  inline ::google::protobuf::uint32 titlelist(int index) const;
  inline void set_titlelist(int index, ::google::protobuf::uint32 value);
  inline void add_titlelist(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      titlelist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_titlelist();

  // optional uint32 RoomTicket = 15;
  inline bool has_roomticket() const;
  inline void clear_roomticket();
  static const int kRoomTicketFieldNumber = 15;
  inline ::google::protobuf::uint32 roomticket() const;
  inline void set_roomticket(::google::protobuf::uint32 value);

  // optional uint32 VipLevel = 16;
  inline bool has_viplevel() const;
  inline void clear_viplevel();
  static const int kVipLevelFieldNumber = 16;
  inline ::google::protobuf::uint32 viplevel() const;
  inline void set_viplevel(::google::protobuf::uint32 value);

  // optional string RemainTime = 17;
  inline bool has_remaintime() const;
  inline void clear_remaintime();
  static const int kRemainTimeFieldNumber = 17;
  inline const ::std::string& remaintime() const;
  inline void set_remaintime(const ::std::string& value);
  inline void set_remaintime(const char* value);
  inline void set_remaintime(const char* value, size_t size);
  inline ::std::string* mutable_remaintime();
  inline ::std::string* release_remaintime();
  inline void set_allocated_remaintime(::std::string* remaintime);

  // optional uint32 ExpLevel = 18;
  inline bool has_explevel() const;
  inline void clear_explevel();
  static const int kExpLevelFieldNumber = 18;
  inline ::google::protobuf::uint32 explevel() const;
  inline void set_explevel(::google::protobuf::uint32 value);

  // optional uint32 Exp = 19;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 19;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // repeated .fgame.CSTitleItem TitleItems = 20;
  inline int titleitems_size() const;
  inline void clear_titleitems();
  static const int kTitleItemsFieldNumber = 20;
  inline const ::fgame::CSTitleItem& titleitems(int index) const;
  inline ::fgame::CSTitleItem* mutable_titleitems(int index);
  inline ::fgame::CSTitleItem* add_titleitems();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSTitleItem >&
      titleitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSTitleItem >*
      mutable_titleitems();

  // optional uint32 Rank = 21;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 21;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // optional float WinRate = 22;
  inline bool has_winrate() const;
  inline void clear_winrate();
  static const int kWinRateFieldNumber = 22;
  inline float winrate() const;
  inline void set_winrate(float value);

  // optional uint32 Score = 23;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 23;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // optional uint32 AchievementLevel = 24;
  inline bool has_achievementlevel() const;
  inline void clear_achievementlevel();
  static const int kAchievementLevelFieldNumber = 24;
  inline ::google::protobuf::uint32 achievementlevel() const;
  inline void set_achievementlevel(::google::protobuf::uint32 value);

  // optional uint32 HonorCount = 25;
  inline bool has_honorcount() const;
  inline void clear_honorcount();
  static const int kHonorCountFieldNumber = 25;
  inline ::google::protobuf::uint32 honorcount() const;
  inline void set_honorcount(::google::protobuf::uint32 value);

  // optional uint32 PvpRound = 26;
  inline bool has_pvpround() const;
  inline void clear_pvpround();
  static const int kPvpRoundFieldNumber = 26;
  inline ::google::protobuf::uint32 pvpround() const;
  inline void set_pvpround(::google::protobuf::uint32 value);

  // optional uint32 AddExp = 27;
  inline bool has_addexp() const;
  inline void clear_addexp();
  static const int kAddExpFieldNumber = 27;
  inline ::google::protobuf::uint32 addexp() const;
  inline void set_addexp(::google::protobuf::uint32 value);

  // optional uint32 GlyphGuide = 28;
  inline bool has_glyphguide() const;
  inline void clear_glyphguide();
  static const int kGlyphGuideFieldNumber = 28;
  inline ::google::protobuf::uint32 glyphguide() const;
  inline void set_glyphguide(::google::protobuf::uint32 value);

  // optional uint32 ChatFreeCount = 29;
  inline bool has_chatfreecount() const;
  inline void clear_chatfreecount();
  static const int kChatFreeCountFieldNumber = 29;
  inline ::google::protobuf::uint32 chatfreecount() const;
  inline void set_chatfreecount(::google::protobuf::uint32 value);

  // optional uint32 TimeLeft = 30;
  inline bool has_timeleft() const;
  inline void clear_timeleft();
  static const int kTimeLeftFieldNumber = 30;
  inline ::google::protobuf::uint32 timeleft() const;
  inline void set_timeleft(::google::protobuf::uint32 value);

  // optional uint32 Area = 31;
  inline bool has_area() const;
  inline void clear_area();
  static const int kAreaFieldNumber = 31;
  inline ::google::protobuf::uint32 area() const;
  inline void set_area(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSSycPlayerInfoResp)
 private:
  inline void set_has_playertitle();
  inline void clear_has_playertitle();
  inline void set_has_energy();
  inline void clear_has_energy();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_changenamecount();
  inline void clear_has_changenamecount();
  inline void set_has_energybuycount();
  inline void clear_has_energybuycount();
  inline void set_has_diamond();
  inline void clear_has_diamond();
  inline void set_has_iconid();
  inline void clear_has_iconid();
  inline void set_has_energyslot();
  inline void clear_has_energyslot();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_powerslot();
  inline void clear_has_powerslot();
  inline void set_has_monthcarddays();
  inline void clear_has_monthcarddays();
  inline void set_has_shopguide();
  inline void clear_has_shopguide();
  inline void set_has_roomticket();
  inline void clear_has_roomticket();
  inline void set_has_viplevel();
  inline void clear_has_viplevel();
  inline void set_has_remaintime();
  inline void clear_has_remaintime();
  inline void set_has_explevel();
  inline void clear_has_explevel();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_winrate();
  inline void clear_has_winrate();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_achievementlevel();
  inline void clear_has_achievementlevel();
  inline void set_has_honorcount();
  inline void clear_has_honorcount();
  inline void set_has_pvpround();
  inline void clear_has_pvpround();
  inline void set_has_addexp();
  inline void clear_has_addexp();
  inline void set_has_glyphguide();
  inline void clear_has_glyphguide();
  inline void set_has_chatfreecount();
  inline void clear_has_chatfreecount();
  inline void set_has_timeleft();
  inline void clear_has_timeleft();
  inline void set_has_area();
  inline void clear_has_area();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 playertitle_;
  ::google::protobuf::uint32 energy_;
  ::std::string* name_;
  ::google::protobuf::uint32 changenamecount_;
  ::google::protobuf::uint32 energybuycount_;
  ::std::string* iconid_;
  ::google::protobuf::uint32 diamond_;
  ::google::protobuf::uint32 energyslot_;
  ::google::protobuf::uint32 power_;
  ::google::protobuf::uint32 powerslot_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSItem > items_;
  ::google::protobuf::uint32 monthcarddays_;
  ::google::protobuf::uint32 shopguide_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > titlelist_;
  ::google::protobuf::uint32 roomticket_;
  ::google::protobuf::uint32 viplevel_;
  ::std::string* remaintime_;
  ::google::protobuf::uint32 explevel_;
  ::google::protobuf::uint32 exp_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSTitleItem > titleitems_;
  ::google::protobuf::uint32 rank_;
  float winrate_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 achievementlevel_;
  ::google::protobuf::uint32 honorcount_;
  ::google::protobuf::uint32 pvpround_;
  ::google::protobuf::uint32 addexp_;
  ::google::protobuf::uint32 glyphguide_;
  ::google::protobuf::uint32 chatfreecount_;
  ::google::protobuf::uint32 timeleft_;
  ::google::protobuf::uint32 area_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSycPlayerInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class CSSyncPlayerDataReq : public ::google::protobuf::MessageLite {
 public:
  CSSyncPlayerDataReq();
  virtual ~CSSyncPlayerDataReq();

  CSSyncPlayerDataReq(const CSSyncPlayerDataReq& from);

  inline CSSyncPlayerDataReq& operator=(const CSSyncPlayerDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSyncPlayerDataReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSyncPlayerDataReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSyncPlayerDataReq* other);

  // implements Message ----------------------------------------------

  CSSyncPlayerDataReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSyncPlayerDataReq& from);
  void MergeFrom(const CSSyncPlayerDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string PlayerData = 1;
  inline bool has_playerdata() const;
  inline void clear_playerdata();
  static const int kPlayerDataFieldNumber = 1;
  inline const ::std::string& playerdata() const;
  inline void set_playerdata(const ::std::string& value);
  inline void set_playerdata(const char* value);
  inline void set_playerdata(const char* value, size_t size);
  inline ::std::string* mutable_playerdata();
  inline ::std::string* release_playerdata();
  inline void set_allocated_playerdata(::std::string* playerdata);

  // @@protoc_insertion_point(class_scope:fgame.CSSyncPlayerDataReq)
 private:
  inline void set_has_playerdata();
  inline void clear_has_playerdata();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* playerdata_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSyncPlayerDataReq* default_instance_;
};
// -------------------------------------------------------------------

class CSSyncPlayerDataResp : public ::google::protobuf::MessageLite {
 public:
  CSSyncPlayerDataResp();
  virtual ~CSSyncPlayerDataResp();

  CSSyncPlayerDataResp(const CSSyncPlayerDataResp& from);

  inline CSSyncPlayerDataResp& operator=(const CSSyncPlayerDataResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSyncPlayerDataResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSyncPlayerDataResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSyncPlayerDataResp* other);

  // implements Message ----------------------------------------------

  CSSyncPlayerDataResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSyncPlayerDataResp& from);
  void MergeFrom(const CSSyncPlayerDataResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSSyncPlayerDataResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSyncPlayerDataResp* default_instance_;
};
// -------------------------------------------------------------------

class CSGetPlayerDataReq : public ::google::protobuf::MessageLite {
 public:
  CSGetPlayerDataReq();
  virtual ~CSGetPlayerDataReq();

  CSGetPlayerDataReq(const CSGetPlayerDataReq& from);

  inline CSGetPlayerDataReq& operator=(const CSGetPlayerDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetPlayerDataReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetPlayerDataReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetPlayerDataReq* other);

  // implements Message ----------------------------------------------

  CSGetPlayerDataReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetPlayerDataReq& from);
  void MergeFrom(const CSGetPlayerDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSGetPlayerDataReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetPlayerDataReq* default_instance_;
};
// -------------------------------------------------------------------

class CSGetPlayerDataResp : public ::google::protobuf::MessageLite {
 public:
  CSGetPlayerDataResp();
  virtual ~CSGetPlayerDataResp();

  CSGetPlayerDataResp(const CSGetPlayerDataResp& from);

  inline CSGetPlayerDataResp& operator=(const CSGetPlayerDataResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetPlayerDataResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetPlayerDataResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetPlayerDataResp* other);

  // implements Message ----------------------------------------------

  CSGetPlayerDataResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetPlayerDataResp& from);
  void MergeFrom(const CSGetPlayerDataResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required string PlayerData = 2;
  inline bool has_playerdata() const;
  inline void clear_playerdata();
  static const int kPlayerDataFieldNumber = 2;
  inline const ::std::string& playerdata() const;
  inline void set_playerdata(const ::std::string& value);
  inline void set_playerdata(const char* value);
  inline void set_playerdata(const char* value, size_t size);
  inline ::std::string* mutable_playerdata();
  inline ::std::string* release_playerdata();
  inline void set_allocated_playerdata(::std::string* playerdata);

  // @@protoc_insertion_point(class_scope:fgame.CSGetPlayerDataResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_playerdata();
  inline void clear_has_playerdata();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* playerdata_;
  ::google::protobuf::uint32 ret_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetPlayerDataResp* default_instance_;
};
// -------------------------------------------------------------------

class CSNoticeReq : public ::google::protobuf::MessageLite {
 public:
  CSNoticeReq();
  virtual ~CSNoticeReq();

  CSNoticeReq(const CSNoticeReq& from);

  inline CSNoticeReq& operator=(const CSNoticeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSNoticeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSNoticeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSNoticeReq* other);

  // implements Message ----------------------------------------------

  CSNoticeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSNoticeReq& from);
  void MergeFrom(const CSNoticeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 NoticeType = 1;
  inline bool has_noticetype() const;
  inline void clear_noticetype();
  static const int kNoticeTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 noticetype() const;
  inline void set_noticetype(::google::protobuf::uint32 value);

  // required uint32 Serious = 2;
  inline bool has_serious() const;
  inline void clear_serious();
  static const int kSeriousFieldNumber = 2;
  inline ::google::protobuf::uint32 serious() const;
  inline void set_serious(::google::protobuf::uint32 value);

  // required string Content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional string Title = 4;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 4;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional uint32 Count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 TimeGap = 6;
  inline bool has_timegap() const;
  inline void clear_timegap();
  static const int kTimeGapFieldNumber = 6;
  inline ::google::protobuf::uint32 timegap() const;
  inline void set_timegap(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSNoticeReq)
 private:
  inline void set_has_noticetype();
  inline void clear_has_noticetype();
  inline void set_has_serious();
  inline void clear_has_serious();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_timegap();
  inline void clear_has_timegap();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 noticetype_;
  ::google::protobuf::uint32 serious_;
  ::std::string* content_;
  ::std::string* title_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 timegap_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSNoticeReq* default_instance_;
};
// -------------------------------------------------------------------

class CSChangeNameReq : public ::google::protobuf::MessageLite {
 public:
  CSChangeNameReq();
  virtual ~CSChangeNameReq();

  CSChangeNameReq(const CSChangeNameReq& from);

  inline CSChangeNameReq& operator=(const CSChangeNameReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSChangeNameReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChangeNameReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChangeNameReq* other);

  // implements Message ----------------------------------------------

  CSChangeNameReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChangeNameReq& from);
  void MergeFrom(const CSChangeNameReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 Area = 2;
  inline bool has_area() const;
  inline void clear_area();
  static const int kAreaFieldNumber = 2;
  inline ::google::protobuf::uint32 area() const;
  inline void set_area(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSChangeNameReq)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_area();
  inline void clear_has_area();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 area_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSChangeNameReq* default_instance_;
};
// -------------------------------------------------------------------

class CSChangeNameResp : public ::google::protobuf::MessageLite {
 public:
  CSChangeNameResp();
  virtual ~CSChangeNameResp();

  CSChangeNameResp(const CSChangeNameResp& from);

  inline CSChangeNameResp& operator=(const CSChangeNameResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSChangeNameResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChangeNameResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChangeNameResp* other);

  // implements Message ----------------------------------------------

  CSChangeNameResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChangeNameResp& from);
  void MergeFrom(const CSChangeNameResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSChangeNameResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSChangeNameResp* default_instance_;
};
// -------------------------------------------------------------------

class CSGMCmdReq : public ::google::protobuf::MessageLite {
 public:
  CSGMCmdReq();
  virtual ~CSGMCmdReq();

  CSGMCmdReq(const CSGMCmdReq& from);

  inline CSGMCmdReq& operator=(const CSGMCmdReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGMCmdReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGMCmdReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGMCmdReq* other);

  // implements Message ----------------------------------------------

  CSGMCmdReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGMCmdReq& from);
  void MergeFrom(const CSGMCmdReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 GMType = 1;
  inline bool has_gmtype() const;
  inline void clear_gmtype();
  static const int kGMTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 gmtype() const;
  inline void set_gmtype(::google::protobuf::uint32 value);

  // optional uint32 Value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGMCmdReq)
 private:
  inline void set_has_gmtype();
  inline void clear_has_gmtype();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gmtype_;
  ::google::protobuf::uint32 value_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGMCmdReq* default_instance_;
};
// -------------------------------------------------------------------

class CSXinShouRecodeReq : public ::google::protobuf::MessageLite {
 public:
  CSXinShouRecodeReq();
  virtual ~CSXinShouRecodeReq();

  CSXinShouRecodeReq(const CSXinShouRecodeReq& from);

  inline CSXinShouRecodeReq& operator=(const CSXinShouRecodeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSXinShouRecodeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSXinShouRecodeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSXinShouRecodeReq* other);

  // implements Message ----------------------------------------------

  CSXinShouRecodeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSXinShouRecodeReq& from);
  void MergeFrom(const CSXinShouRecodeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSXinShouRecodeReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSXinShouRecodeReq* default_instance_;
};
// -------------------------------------------------------------------

class CSXinShouRecodeResp : public ::google::protobuf::MessageLite {
 public:
  CSXinShouRecodeResp();
  virtual ~CSXinShouRecodeResp();

  CSXinShouRecodeResp(const CSXinShouRecodeResp& from);

  inline CSXinShouRecodeResp& operator=(const CSXinShouRecodeResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSXinShouRecodeResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSXinShouRecodeResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSXinShouRecodeResp* other);

  // implements Message ----------------------------------------------

  CSXinShouRecodeResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSXinShouRecodeResp& from);
  void MergeFrom(const CSXinShouRecodeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSXinShouRecodeResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSXinShouRecodeResp* default_instance_;
};
// -------------------------------------------------------------------

class CSMission : public ::google::protobuf::MessageLite {
 public:
  CSMission();
  virtual ~CSMission();

  CSMission(const CSMission& from);

  inline CSMission& operator=(const CSMission& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSMission& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMission* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMission* other);

  // implements Message ----------------------------------------------

  CSMission* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMission& from);
  void MergeFrom(const CSMission& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 MissionId = 1;
  inline bool has_missionid() const;
  inline void clear_missionid();
  static const int kMissionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 missionid() const;
  inline void set_missionid(::google::protobuf::uint32 value);

  // optional uint32 Value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // optional bool Completed = 3;
  inline bool has_completed() const;
  inline void clear_completed();
  static const int kCompletedFieldNumber = 3;
  inline bool completed() const;
  inline void set_completed(bool value);

  // optional uint32 Request = 4;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 4;
  inline ::google::protobuf::uint32 request() const;
  inline void set_request(::google::protobuf::uint32 value);

  // optional uint32 GiftId = 5;
  inline bool has_giftid() const;
  inline void clear_giftid();
  static const int kGiftIdFieldNumber = 5;
  inline ::google::protobuf::uint32 giftid() const;
  inline void set_giftid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSMission)
 private:
  inline void set_has_missionid();
  inline void clear_has_missionid();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_completed();
  inline void clear_has_completed();
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_giftid();
  inline void clear_has_giftid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 missionid_;
  ::google::protobuf::uint32 value_;
  bool completed_;
  ::google::protobuf::uint32 request_;
  ::google::protobuf::uint32 giftid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSMission* default_instance_;
};
// -------------------------------------------------------------------

class CSMissionListReq : public ::google::protobuf::MessageLite {
 public:
  CSMissionListReq();
  virtual ~CSMissionListReq();

  CSMissionListReq(const CSMissionListReq& from);

  inline CSMissionListReq& operator=(const CSMissionListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSMissionListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMissionListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMissionListReq* other);

  // implements Message ----------------------------------------------

  CSMissionListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMissionListReq& from);
  void MergeFrom(const CSMissionListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSMissionListReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSMissionListReq* default_instance_;
};
// -------------------------------------------------------------------

class CSMissionListResp : public ::google::protobuf::MessageLite {
 public:
  CSMissionListResp();
  virtual ~CSMissionListResp();

  CSMissionListResp(const CSMissionListResp& from);

  inline CSMissionListResp& operator=(const CSMissionListResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSMissionListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMissionListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMissionListResp* other);

  // implements Message ----------------------------------------------

  CSMissionListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMissionListResp& from);
  void MergeFrom(const CSMissionListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 MissionDay = 1;
  inline bool has_missionday() const;
  inline void clear_missionday();
  static const int kMissionDayFieldNumber = 1;
  inline ::google::protobuf::uint32 missionday() const;
  inline void set_missionday(::google::protobuf::uint32 value);

  // repeated .fgame.CSMission Missions = 2;
  inline int missions_size() const;
  inline void clear_missions();
  static const int kMissionsFieldNumber = 2;
  inline const ::fgame::CSMission& missions(int index) const;
  inline ::fgame::CSMission* mutable_missions(int index);
  inline ::fgame::CSMission* add_missions();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSMission >&
      missions() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSMission >*
      mutable_missions();

  // @@protoc_insertion_point(class_scope:fgame.CSMissionListResp)
 private:
  inline void set_has_missionday();
  inline void clear_has_missionday();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSMission > missions_;
  ::google::protobuf::uint32 missionday_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSMissionListResp* default_instance_;
};
// -------------------------------------------------------------------

class CSMissionCompleteReq : public ::google::protobuf::MessageLite {
 public:
  CSMissionCompleteReq();
  virtual ~CSMissionCompleteReq();

  CSMissionCompleteReq(const CSMissionCompleteReq& from);

  inline CSMissionCompleteReq& operator=(const CSMissionCompleteReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSMissionCompleteReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMissionCompleteReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMissionCompleteReq* other);

  // implements Message ----------------------------------------------

  CSMissionCompleteReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMissionCompleteReq& from);
  void MergeFrom(const CSMissionCompleteReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 MissionId = 1;
  inline bool has_missionid() const;
  inline void clear_missionid();
  static const int kMissionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 missionid() const;
  inline void set_missionid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSMissionCompleteReq)
 private:
  inline void set_has_missionid();
  inline void clear_has_missionid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 missionid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSMissionCompleteReq* default_instance_;
};
// -------------------------------------------------------------------

class CSMissionCompleteResp : public ::google::protobuf::MessageLite {
 public:
  CSMissionCompleteResp();
  virtual ~CSMissionCompleteResp();

  CSMissionCompleteResp(const CSMissionCompleteResp& from);

  inline CSMissionCompleteResp& operator=(const CSMissionCompleteResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSMissionCompleteResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMissionCompleteResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMissionCompleteResp* other);

  // implements Message ----------------------------------------------

  CSMissionCompleteResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMissionCompleteResp& from);
  void MergeFrom(const CSMissionCompleteResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .fgame.CSMission Mission = 1;
  inline bool has_mission() const;
  inline void clear_mission();
  static const int kMissionFieldNumber = 1;
  inline const ::fgame::CSMission& mission() const;
  inline ::fgame::CSMission* mutable_mission();
  inline ::fgame::CSMission* release_mission();
  inline void set_allocated_mission(::fgame::CSMission* mission);

  // @@protoc_insertion_point(class_scope:fgame.CSMissionCompleteResp)
 private:
  inline void set_has_mission();
  inline void clear_has_mission();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::fgame::CSMission* mission_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSMissionCompleteResp* default_instance_;
};
// -------------------------------------------------------------------

class CSMissionUpdateResp : public ::google::protobuf::MessageLite {
 public:
  CSMissionUpdateResp();
  virtual ~CSMissionUpdateResp();

  CSMissionUpdateResp(const CSMissionUpdateResp& from);

  inline CSMissionUpdateResp& operator=(const CSMissionUpdateResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSMissionUpdateResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMissionUpdateResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMissionUpdateResp* other);

  // implements Message ----------------------------------------------

  CSMissionUpdateResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMissionUpdateResp& from);
  void MergeFrom(const CSMissionUpdateResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 MissionId = 1;
  inline bool has_missionid() const;
  inline void clear_missionid();
  static const int kMissionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 missionid() const;
  inline void set_missionid(::google::protobuf::uint32 value);

  // required uint32 Value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSMissionUpdateResp)
 private:
  inline void set_has_missionid();
  inline void clear_has_missionid();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 missionid_;
  ::google::protobuf::uint32 value_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSMissionUpdateResp* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyNewbieGiftReq : public ::google::protobuf::MessageLite {
 public:
  CSBuyNewbieGiftReq();
  virtual ~CSBuyNewbieGiftReq();

  CSBuyNewbieGiftReq(const CSBuyNewbieGiftReq& from);

  inline CSBuyNewbieGiftReq& operator=(const CSBuyNewbieGiftReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSBuyNewbieGiftReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyNewbieGiftReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyNewbieGiftReq* other);

  // implements Message ----------------------------------------------

  CSBuyNewbieGiftReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyNewbieGiftReq& from);
  void MergeFrom(const CSBuyNewbieGiftReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSBuyNewbieGiftReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSBuyNewbieGiftReq* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyNewbieGiftResp : public ::google::protobuf::MessageLite {
 public:
  CSBuyNewbieGiftResp();
  virtual ~CSBuyNewbieGiftResp();

  CSBuyNewbieGiftResp(const CSBuyNewbieGiftResp& from);

  inline CSBuyNewbieGiftResp& operator=(const CSBuyNewbieGiftResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSBuyNewbieGiftResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyNewbieGiftResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyNewbieGiftResp* other);

  // implements Message ----------------------------------------------

  CSBuyNewbieGiftResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyNewbieGiftResp& from);
  void MergeFrom(const CSBuyNewbieGiftResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSBuyNewbieGiftResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSBuyNewbieGiftResp* default_instance_;
};
// -------------------------------------------------------------------

class CSMailInfo : public ::google::protobuf::MessageLite {
 public:
  CSMailInfo();
  virtual ~CSMailInfo();

  CSMailInfo(const CSMailInfo& from);

  inline CSMailInfo& operator=(const CSMailInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSMailInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMailInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMailInfo* other);

  // implements Message ----------------------------------------------

  CSMailInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMailInfo& from);
  void MergeFrom(const CSMailInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required string Title = 2;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 2;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // required string Content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // required string PlugIn = 4;
  inline bool has_plugin() const;
  inline void clear_plugin();
  static const int kPlugInFieldNumber = 4;
  inline const ::std::string& plugin() const;
  inline void set_plugin(const ::std::string& value);
  inline void set_plugin(const char* value);
  inline void set_plugin(const char* value, size_t size);
  inline ::std::string* mutable_plugin();
  inline ::std::string* release_plugin();
  inline void set_allocated_plugin(::std::string* plugin);

  // required uint32 SendTime = 5;
  inline bool has_sendtime() const;
  inline void clear_sendtime();
  static const int kSendTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 sendtime() const;
  inline void set_sendtime(::google::protobuf::uint32 value);

  // required uint32 OutDate = 6;
  inline bool has_outdate() const;
  inline void clear_outdate();
  static const int kOutDateFieldNumber = 6;
  inline ::google::protobuf::uint32 outdate() const;
  inline void set_outdate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSMailInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_plugin();
  inline void clear_has_plugin();
  inline void set_has_sendtime();
  inline void clear_has_sendtime();
  inline void set_has_outdate();
  inline void clear_has_outdate();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  ::std::string* content_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 sendtime_;
  ::std::string* plugin_;
  ::google::protobuf::uint32 outdate_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSMailInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSGetMailReq : public ::google::protobuf::MessageLite {
 public:
  CSGetMailReq();
  virtual ~CSGetMailReq();

  CSGetMailReq(const CSGetMailReq& from);

  inline CSGetMailReq& operator=(const CSGetMailReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetMailReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetMailReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetMailReq* other);

  // implements Message ----------------------------------------------

  CSGetMailReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetMailReq& from);
  void MergeFrom(const CSGetMailReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 GetNum = 1;
  inline bool has_getnum() const;
  inline void clear_getnum();
  static const int kGetNumFieldNumber = 1;
  inline ::google::protobuf::uint32 getnum() const;
  inline void set_getnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGetMailReq)
 private:
  inline void set_has_getnum();
  inline void clear_has_getnum();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 getnum_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetMailReq* default_instance_;
};
// -------------------------------------------------------------------

class CSGetMailResp : public ::google::protobuf::MessageLite {
 public:
  CSGetMailResp();
  virtual ~CSGetMailResp();

  CSGetMailResp(const CSGetMailResp& from);

  inline CSGetMailResp& operator=(const CSGetMailResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetMailResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetMailResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetMailResp* other);

  // implements Message ----------------------------------------------

  CSGetMailResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetMailResp& from);
  void MergeFrom(const CSGetMailResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool NewMail = 1;
  inline bool has_newmail() const;
  inline void clear_newmail();
  static const int kNewMailFieldNumber = 1;
  inline bool newmail() const;
  inline void set_newmail(bool value);

  // optional uint32 MailNO = 2;
  inline bool has_mailno() const;
  inline void clear_mailno();
  static const int kMailNOFieldNumber = 2;
  inline ::google::protobuf::uint32 mailno() const;
  inline void set_mailno(::google::protobuf::uint32 value);

  // repeated .fgame.CSMailInfo MailInfo = 3;
  inline int mailinfo_size() const;
  inline void clear_mailinfo();
  static const int kMailInfoFieldNumber = 3;
  inline const ::fgame::CSMailInfo& mailinfo(int index) const;
  inline ::fgame::CSMailInfo* mutable_mailinfo(int index);
  inline ::fgame::CSMailInfo* add_mailinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSMailInfo >&
      mailinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSMailInfo >*
      mutable_mailinfo();

  // @@protoc_insertion_point(class_scope:fgame.CSGetMailResp)
 private:
  inline void set_has_newmail();
  inline void clear_has_newmail();
  inline void set_has_mailno();
  inline void clear_has_mailno();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool newmail_;
  ::google::protobuf::uint32 mailno_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSMailInfo > mailinfo_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetMailResp* default_instance_;
};
// -------------------------------------------------------------------

class CSDelMailReq : public ::google::protobuf::MessageLite {
 public:
  CSDelMailReq();
  virtual ~CSDelMailReq();

  CSDelMailReq(const CSDelMailReq& from);

  inline CSDelMailReq& operator=(const CSDelMailReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSDelMailReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDelMailReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDelMailReq* other);

  // implements Message ----------------------------------------------

  CSDelMailReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDelMailReq& from);
  void MergeFrom(const CSDelMailReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 Id = 1;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id(int index) const;
  inline void set_id(int index, ::google::protobuf::uint32 value);
  inline void add_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_id();

  // @@protoc_insertion_point(class_scope:fgame.CSDelMailReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSDelMailReq* default_instance_;
};
// -------------------------------------------------------------------

class CSDelMailResp : public ::google::protobuf::MessageLite {
 public:
  CSDelMailResp();
  virtual ~CSDelMailResp();

  CSDelMailResp(const CSDelMailResp& from);

  inline CSDelMailResp& operator=(const CSDelMailResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSDelMailResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDelMailResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDelMailResp* other);

  // implements Message ----------------------------------------------

  CSDelMailResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDelMailResp& from);
  void MergeFrom(const CSDelMailResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 Ret = 1;
  inline int ret_size() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret(int index) const;
  inline void set_ret(int index, ::google::protobuf::uint32 value);
  inline void add_ret(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ret() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ret();

  // @@protoc_insertion_point(class_scope:fgame.CSDelMailResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ret_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSDelMailResp* default_instance_;
};
// -------------------------------------------------------------------

class CSNoticeMailReq : public ::google::protobuf::MessageLite {
 public:
  CSNoticeMailReq();
  virtual ~CSNoticeMailReq();

  CSNoticeMailReq(const CSNoticeMailReq& from);

  inline CSNoticeMailReq& operator=(const CSNoticeMailReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSNoticeMailReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSNoticeMailReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSNoticeMailReq* other);

  // implements Message ----------------------------------------------

  CSNoticeMailReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSNoticeMailReq& from);
  void MergeFrom(const CSNoticeMailReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSNoticeMailReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSNoticeMailReq* default_instance_;
};
// -------------------------------------------------------------------

class CSRechargeCallbackReq : public ::google::protobuf::MessageLite {
 public:
  CSRechargeCallbackReq();
  virtual ~CSRechargeCallbackReq();

  CSRechargeCallbackReq(const CSRechargeCallbackReq& from);

  inline CSRechargeCallbackReq& operator=(const CSRechargeCallbackReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRechargeCallbackReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRechargeCallbackReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRechargeCallbackReq* other);

  // implements Message ----------------------------------------------

  CSRechargeCallbackReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRechargeCallbackReq& from);
  void MergeFrom(const CSRechargeCallbackReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSRechargeCallbackReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSRechargeCallbackReq* default_instance_;
};
// -------------------------------------------------------------------

class CSRechargeCallbackResp : public ::google::protobuf::MessageLite {
 public:
  CSRechargeCallbackResp();
  virtual ~CSRechargeCallbackResp();

  CSRechargeCallbackResp(const CSRechargeCallbackResp& from);

  inline CSRechargeCallbackResp& operator=(const CSRechargeCallbackResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRechargeCallbackResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRechargeCallbackResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRechargeCallbackResp* other);

  // implements Message ----------------------------------------------

  CSRechargeCallbackResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRechargeCallbackResp& from);
  void MergeFrom(const CSRechargeCallbackResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required uint32 Id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required string OrderId = 3;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderIdFieldNumber = 3;
  inline const ::std::string& orderid() const;
  inline void set_orderid(const ::std::string& value);
  inline void set_orderid(const char* value);
  inline void set_orderid(const char* value, size_t size);
  inline ::std::string* mutable_orderid();
  inline ::std::string* release_orderid();
  inline void set_allocated_orderid(::std::string* orderid);

  // @@protoc_insertion_point(class_scope:fgame.CSRechargeCallbackResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_orderid();
  inline void clear_has_orderid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 id_;
  ::std::string* orderid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSRechargeCallbackResp* default_instance_;
};
// -------------------------------------------------------------------

class CSUseGiftCodeReq : public ::google::protobuf::MessageLite {
 public:
  CSUseGiftCodeReq();
  virtual ~CSUseGiftCodeReq();

  CSUseGiftCodeReq(const CSUseGiftCodeReq& from);

  inline CSUseGiftCodeReq& operator=(const CSUseGiftCodeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSUseGiftCodeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSUseGiftCodeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSUseGiftCodeReq* other);

  // implements Message ----------------------------------------------

  CSUseGiftCodeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSUseGiftCodeReq& from);
  void MergeFrom(const CSUseGiftCodeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string GiftCode = 1;
  inline bool has_giftcode() const;
  inline void clear_giftcode();
  static const int kGiftCodeFieldNumber = 1;
  inline const ::std::string& giftcode() const;
  inline void set_giftcode(const ::std::string& value);
  inline void set_giftcode(const char* value);
  inline void set_giftcode(const char* value, size_t size);
  inline ::std::string* mutable_giftcode();
  inline ::std::string* release_giftcode();
  inline void set_allocated_giftcode(::std::string* giftcode);

  // @@protoc_insertion_point(class_scope:fgame.CSUseGiftCodeReq)
 private:
  inline void set_has_giftcode();
  inline void clear_has_giftcode();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* giftcode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSUseGiftCodeReq* default_instance_;
};
// -------------------------------------------------------------------

class CSUseGiftCodeResp : public ::google::protobuf::MessageLite {
 public:
  CSUseGiftCodeResp();
  virtual ~CSUseGiftCodeResp();

  CSUseGiftCodeResp(const CSUseGiftCodeResp& from);

  inline CSUseGiftCodeResp& operator=(const CSUseGiftCodeResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSUseGiftCodeResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSUseGiftCodeResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSUseGiftCodeResp* other);

  // implements Message ----------------------------------------------

  CSUseGiftCodeResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSUseGiftCodeResp& from);
  void MergeFrom(const CSUseGiftCodeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required uint32 Reward = 2;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 2;
  inline ::google::protobuf::uint32 reward() const;
  inline void set_reward(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSUseGiftCodeResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_reward();
  inline void clear_has_reward();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 reward_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSUseGiftCodeResp* default_instance_;
};
// -------------------------------------------------------------------

class CheckPtData : public ::google::protobuf::MessageLite {
 public:
  CheckPtData();
  virtual ~CheckPtData();

  CheckPtData(const CheckPtData& from);

  inline CheckPtData& operator=(const CheckPtData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CheckPtData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CheckPtData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CheckPtData* other);

  // implements Message ----------------------------------------------

  CheckPtData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CheckPtData& from);
  void MergeFrom(const CheckPtData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 stars = 2;
  inline bool has_stars() const;
  inline void clear_stars();
  static const int kStarsFieldNumber = 2;
  inline ::google::protobuf::uint32 stars() const;
  inline void set_stars(::google::protobuf::uint32 value);

  // optional bool reward = 3;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 3;
  inline bool reward() const;
  inline void set_reward(bool value);

  // optional uint32 BattleTime = 4;
  inline bool has_battletime() const;
  inline void clear_battletime();
  static const int kBattleTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 battletime() const;
  inline void set_battletime(::google::protobuf::uint32 value);

  // optional bool FullReward = 5;
  inline bool has_fullreward() const;
  inline void clear_fullreward();
  static const int kFullRewardFieldNumber = 5;
  inline bool fullreward() const;
  inline void set_fullreward(bool value);

  // optional bool Win = 6;
  inline bool has_win() const;
  inline void clear_win();
  static const int kWinFieldNumber = 6;
  inline bool win() const;
  inline void set_win(bool value);

  // optional uint32 ChapterId = 7;
  inline bool has_chapterid() const;
  inline void clear_chapterid();
  static const int kChapterIdFieldNumber = 7;
  inline ::google::protobuf::uint32 chapterid() const;
  inline void set_chapterid(::google::protobuf::uint32 value);

  // optional bool Skip = 8;
  inline bool has_skip() const;
  inline void clear_skip();
  static const int kSkipFieldNumber = 8;
  inline bool skip() const;
  inline void set_skip(bool value);

  // optional uint32 Score = 9;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 9;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CheckPtData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_stars();
  inline void clear_has_stars();
  inline void set_has_reward();
  inline void clear_has_reward();
  inline void set_has_battletime();
  inline void clear_has_battletime();
  inline void set_has_fullreward();
  inline void clear_has_fullreward();
  inline void set_has_win();
  inline void clear_has_win();
  inline void set_has_chapterid();
  inline void clear_has_chapterid();
  inline void set_has_skip();
  inline void clear_has_skip();
  inline void set_has_score();
  inline void clear_has_score();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 stars_;
  ::google::protobuf::uint32 battletime_;
  bool reward_;
  bool fullreward_;
  bool win_;
  bool skip_;
  ::google::protobuf::uint32 chapterid_;
  ::google::protobuf::uint32 score_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CheckPtData* default_instance_;
};
// -------------------------------------------------------------------

class CSSaveCheckPtDataReq : public ::google::protobuf::MessageLite {
 public:
  CSSaveCheckPtDataReq();
  virtual ~CSSaveCheckPtDataReq();

  CSSaveCheckPtDataReq(const CSSaveCheckPtDataReq& from);

  inline CSSaveCheckPtDataReq& operator=(const CSSaveCheckPtDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSaveCheckPtDataReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSaveCheckPtDataReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSaveCheckPtDataReq* other);

  // implements Message ----------------------------------------------

  CSSaveCheckPtDataReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSaveCheckPtDataReq& from);
  void MergeFrom(const CSSaveCheckPtDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .fgame.CheckPtData CPData = 1;
  inline bool has_cpdata() const;
  inline void clear_cpdata();
  static const int kCPDataFieldNumber = 1;
  inline const ::fgame::CheckPtData& cpdata() const;
  inline ::fgame::CheckPtData* mutable_cpdata();
  inline ::fgame::CheckPtData* release_cpdata();
  inline void set_allocated_cpdata(::fgame::CheckPtData* cpdata);

  // required uint32 OpenCheckPtId = 2;
  inline bool has_opencheckptid() const;
  inline void clear_opencheckptid();
  static const int kOpenCheckPtIdFieldNumber = 2;
  inline ::google::protobuf::uint32 opencheckptid() const;
  inline void set_opencheckptid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSSaveCheckPtDataReq)
 private:
  inline void set_has_cpdata();
  inline void clear_has_cpdata();
  inline void set_has_opencheckptid();
  inline void clear_has_opencheckptid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::fgame::CheckPtData* cpdata_;
  ::google::protobuf::uint32 opencheckptid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSaveCheckPtDataReq* default_instance_;
};
// -------------------------------------------------------------------

class CSSaveCheckPtDataResp : public ::google::protobuf::MessageLite {
 public:
  CSSaveCheckPtDataResp();
  virtual ~CSSaveCheckPtDataResp();

  CSSaveCheckPtDataResp(const CSSaveCheckPtDataResp& from);

  inline CSSaveCheckPtDataResp& operator=(const CSSaveCheckPtDataResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSaveCheckPtDataResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSaveCheckPtDataResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSaveCheckPtDataResp* other);

  // implements Message ----------------------------------------------

  CSSaveCheckPtDataResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSaveCheckPtDataResp& from);
  void MergeFrom(const CSSaveCheckPtDataResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional bool reward = 2;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 2;
  inline bool reward() const;
  inline void set_reward(bool value);

  // optional bool FullReward = 3;
  inline bool has_fullreward() const;
  inline void clear_fullreward();
  static const int kFullRewardFieldNumber = 3;
  inline bool fullreward() const;
  inline void set_fullreward(bool value);

  // optional string Stars = 4;
  inline bool has_stars() const;
  inline void clear_stars();
  static const int kStarsFieldNumber = 4;
  inline const ::std::string& stars() const;
  inline void set_stars(const ::std::string& value);
  inline void set_stars(const char* value);
  inline void set_stars(const char* value, size_t size);
  inline ::std::string* mutable_stars();
  inline ::std::string* release_stars();
  inline void set_allocated_stars(::std::string* stars);

  // optional bool Win = 5;
  inline bool has_win() const;
  inline void clear_win();
  static const int kWinFieldNumber = 5;
  inline bool win() const;
  inline void set_win(bool value);

  // optional uint32 ShareId = 6;
  inline bool has_shareid() const;
  inline void clear_shareid();
  static const int kShareIdFieldNumber = 6;
  inline ::google::protobuf::uint32 shareid() const;
  inline void set_shareid(::google::protobuf::uint32 value);

  // optional uint32 SkipNum = 7;
  inline bool has_skipnum() const;
  inline void clear_skipnum();
  static const int kSkipNumFieldNumber = 7;
  inline ::google::protobuf::uint32 skipnum() const;
  inline void set_skipnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSSaveCheckPtDataResp)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_reward();
  inline void clear_has_reward();
  inline void set_has_fullreward();
  inline void clear_has_fullreward();
  inline void set_has_stars();
  inline void clear_has_stars();
  inline void set_has_win();
  inline void clear_has_win();
  inline void set_has_shareid();
  inline void clear_has_shareid();
  inline void set_has_skipnum();
  inline void clear_has_skipnum();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  bool reward_;
  bool fullreward_;
  bool win_;
  ::std::string* stars_;
  ::google::protobuf::uint32 shareid_;
  ::google::protobuf::uint32 skipnum_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSaveCheckPtDataResp* default_instance_;
};
// -------------------------------------------------------------------

class CSRetriveCheckPtRewardReq : public ::google::protobuf::MessageLite {
 public:
  CSRetriveCheckPtRewardReq();
  virtual ~CSRetriveCheckPtRewardReq();

  CSRetriveCheckPtRewardReq(const CSRetriveCheckPtRewardReq& from);

  inline CSRetriveCheckPtRewardReq& operator=(const CSRetriveCheckPtRewardReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRetriveCheckPtRewardReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRetriveCheckPtRewardReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRetriveCheckPtRewardReq* other);

  // implements Message ----------------------------------------------

  CSRetriveCheckPtRewardReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRetriveCheckPtRewardReq& from);
  void MergeFrom(const CSRetriveCheckPtRewardReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 RewardType = 2;
  inline bool has_rewardtype() const;
  inline void clear_rewardtype();
  static const int kRewardTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 rewardtype() const;
  inline void set_rewardtype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSRetriveCheckPtRewardReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_rewardtype();
  inline void clear_has_rewardtype();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 rewardtype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSRetriveCheckPtRewardReq* default_instance_;
};
// -------------------------------------------------------------------

class CSRetriveCheckPtRewardResp : public ::google::protobuf::MessageLite {
 public:
  CSRetriveCheckPtRewardResp();
  virtual ~CSRetriveCheckPtRewardResp();

  CSRetriveCheckPtRewardResp(const CSRetriveCheckPtRewardResp& from);

  inline CSRetriveCheckPtRewardResp& operator=(const CSRetriveCheckPtRewardResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRetriveCheckPtRewardResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRetriveCheckPtRewardResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRetriveCheckPtRewardResp* other);

  // implements Message ----------------------------------------------

  CSRetriveCheckPtRewardResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRetriveCheckPtRewardResp& from);
  void MergeFrom(const CSRetriveCheckPtRewardResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 RewardType = 2;
  inline bool has_rewardtype() const;
  inline void clear_rewardtype();
  static const int kRewardTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 rewardtype() const;
  inline void set_rewardtype(::google::protobuf::uint32 value);

  // optional bool Ret = 3;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 3;
  inline bool ret() const;
  inline void set_ret(bool value);

  // @@protoc_insertion_point(class_scope:fgame.CSRetriveCheckPtRewardResp)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_rewardtype();
  inline void clear_has_rewardtype();
  inline void set_has_ret();
  inline void clear_has_ret();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 rewardtype_;
  bool ret_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSRetriveCheckPtRewardResp* default_instance_;
};
// -------------------------------------------------------------------

class CSGetCheckPtDataReq : public ::google::protobuf::MessageLite {
 public:
  CSGetCheckPtDataReq();
  virtual ~CSGetCheckPtDataReq();

  CSGetCheckPtDataReq(const CSGetCheckPtDataReq& from);

  inline CSGetCheckPtDataReq& operator=(const CSGetCheckPtDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetCheckPtDataReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetCheckPtDataReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetCheckPtDataReq* other);

  // implements Message ----------------------------------------------

  CSGetCheckPtDataReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetCheckPtDataReq& from);
  void MergeFrom(const CSGetCheckPtDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSGetCheckPtDataReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetCheckPtDataReq* default_instance_;
};
// -------------------------------------------------------------------

class ChapterData : public ::google::protobuf::MessageLite {
 public:
  ChapterData();
  virtual ~ChapterData();

  ChapterData(const ChapterData& from);

  inline ChapterData& operator=(const ChapterData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ChapterData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChapterData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChapterData* other);

  // implements Message ----------------------------------------------

  ChapterData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChapterData& from);
  void MergeFrom(const ChapterData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ChapterId = 1;
  inline bool has_chapterid() const;
  inline void clear_chapterid();
  static const int kChapterIdFieldNumber = 1;
  inline ::google::protobuf::uint32 chapterid() const;
  inline void set_chapterid(::google::protobuf::uint32 value);

  // repeated .fgame.CheckPtData CpData = 2;
  inline int cpdata_size() const;
  inline void clear_cpdata();
  static const int kCpDataFieldNumber = 2;
  inline const ::fgame::CheckPtData& cpdata(int index) const;
  inline ::fgame::CheckPtData* mutable_cpdata(int index);
  inline ::fgame::CheckPtData* add_cpdata();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CheckPtData >&
      cpdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CheckPtData >*
      mutable_cpdata();

  // required uint32 Stars = 3;
  inline bool has_stars() const;
  inline void clear_stars();
  static const int kStarsFieldNumber = 3;
  inline ::google::protobuf::uint32 stars() const;
  inline void set_stars(::google::protobuf::uint32 value);

  // required uint32 Chest = 4;
  inline bool has_chest() const;
  inline void clear_chest();
  static const int kChestFieldNumber = 4;
  inline ::google::protobuf::uint32 chest() const;
  inline void set_chest(::google::protobuf::uint32 value);

  // required uint32 MaxCpId = 5;
  inline bool has_maxcpid() const;
  inline void clear_maxcpid();
  static const int kMaxCpIdFieldNumber = 5;
  inline ::google::protobuf::uint32 maxcpid() const;
  inline void set_maxcpid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.ChapterData)
 private:
  inline void set_has_chapterid();
  inline void clear_has_chapterid();
  inline void set_has_stars();
  inline void clear_has_stars();
  inline void set_has_chest();
  inline void clear_has_chest();
  inline void set_has_maxcpid();
  inline void clear_has_maxcpid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CheckPtData > cpdata_;
  ::google::protobuf::uint32 chapterid_;
  ::google::protobuf::uint32 stars_;
  ::google::protobuf::uint32 chest_;
  ::google::protobuf::uint32 maxcpid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static ChapterData* default_instance_;
};
// -------------------------------------------------------------------

class CSGetCheckPtDataResp : public ::google::protobuf::MessageLite {
 public:
  CSGetCheckPtDataResp();
  virtual ~CSGetCheckPtDataResp();

  CSGetCheckPtDataResp(const CSGetCheckPtDataResp& from);

  inline CSGetCheckPtDataResp& operator=(const CSGetCheckPtDataResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetCheckPtDataResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetCheckPtDataResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetCheckPtDataResp* other);

  // implements Message ----------------------------------------------

  CSGetCheckPtDataResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetCheckPtDataResp& from);
  void MergeFrom(const CSGetCheckPtDataResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.ChapterData Data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::fgame::ChapterData& data(int index) const;
  inline ::fgame::ChapterData* mutable_data(int index);
  inline ::fgame::ChapterData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::ChapterData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::ChapterData >*
      mutable_data();

  // optional uint32 SkipNum = 2;
  inline bool has_skipnum() const;
  inline void clear_skipnum();
  static const int kSkipNumFieldNumber = 2;
  inline ::google::protobuf::uint32 skipnum() const;
  inline void set_skipnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGetCheckPtDataResp)
 private:
  inline void set_has_skipnum();
  inline void clear_has_skipnum();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::ChapterData > data_;
  ::google::protobuf::uint32 skipnum_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetCheckPtDataResp* default_instance_;
};
// -------------------------------------------------------------------

class CSChapterUnlockReq : public ::google::protobuf::MessageLite {
 public:
  CSChapterUnlockReq();
  virtual ~CSChapterUnlockReq();

  CSChapterUnlockReq(const CSChapterUnlockReq& from);

  inline CSChapterUnlockReq& operator=(const CSChapterUnlockReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSChapterUnlockReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChapterUnlockReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChapterUnlockReq* other);

  // implements Message ----------------------------------------------

  CSChapterUnlockReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChapterUnlockReq& from);
  void MergeFrom(const CSChapterUnlockReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ChapterId = 1;
  inline bool has_chapterid() const;
  inline void clear_chapterid();
  static const int kChapterIdFieldNumber = 1;
  inline ::google::protobuf::uint32 chapterid() const;
  inline void set_chapterid(::google::protobuf::uint32 value);

  // required uint32 UnlockBy = 2;
  inline bool has_unlockby() const;
  inline void clear_unlockby();
  static const int kUnlockByFieldNumber = 2;
  inline ::google::protobuf::uint32 unlockby() const;
  inline void set_unlockby(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSChapterUnlockReq)
 private:
  inline void set_has_chapterid();
  inline void clear_has_chapterid();
  inline void set_has_unlockby();
  inline void clear_has_unlockby();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 chapterid_;
  ::google::protobuf::uint32 unlockby_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSChapterUnlockReq* default_instance_;
};
// -------------------------------------------------------------------

class CSChapterUnlockResp : public ::google::protobuf::MessageLite {
 public:
  CSChapterUnlockResp();
  virtual ~CSChapterUnlockResp();

  CSChapterUnlockResp(const CSChapterUnlockResp& from);

  inline CSChapterUnlockResp& operator=(const CSChapterUnlockResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSChapterUnlockResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChapterUnlockResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChapterUnlockResp* other);

  // implements Message ----------------------------------------------

  CSChapterUnlockResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChapterUnlockResp& from);
  void MergeFrom(const CSChapterUnlockResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ChapterId = 1;
  inline bool has_chapterid() const;
  inline void clear_chapterid();
  static const int kChapterIdFieldNumber = 1;
  inline ::google::protobuf::uint32 chapterid() const;
  inline void set_chapterid(::google::protobuf::uint32 value);

  // required uint32 UnlockBy = 2;
  inline bool has_unlockby() const;
  inline void clear_unlockby();
  static const int kUnlockByFieldNumber = 2;
  inline ::google::protobuf::uint32 unlockby() const;
  inline void set_unlockby(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSChapterUnlockResp)
 private:
  inline void set_has_chapterid();
  inline void clear_has_chapterid();
  inline void set_has_unlockby();
  inline void clear_has_unlockby();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 chapterid_;
  ::google::protobuf::uint32 unlockby_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSChapterUnlockResp* default_instance_;
};
// -------------------------------------------------------------------

class CSGetChestReq : public ::google::protobuf::MessageLite {
 public:
  CSGetChestReq();
  virtual ~CSGetChestReq();

  CSGetChestReq(const CSGetChestReq& from);

  inline CSGetChestReq& operator=(const CSGetChestReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetChestReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetChestReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetChestReq* other);

  // implements Message ----------------------------------------------

  CSGetChestReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetChestReq& from);
  void MergeFrom(const CSGetChestReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ChapterId = 1;
  inline bool has_chapterid() const;
  inline void clear_chapterid();
  static const int kChapterIdFieldNumber = 1;
  inline ::google::protobuf::uint32 chapterid() const;
  inline void set_chapterid(::google::protobuf::uint32 value);

  // required uint32 ChestId = 2;
  inline bool has_chestid() const;
  inline void clear_chestid();
  static const int kChestIdFieldNumber = 2;
  inline ::google::protobuf::uint32 chestid() const;
  inline void set_chestid(::google::protobuf::uint32 value);

  // required uint32 ChestGift = 3;
  inline bool has_chestgift() const;
  inline void clear_chestgift();
  static const int kChestGiftFieldNumber = 3;
  inline ::google::protobuf::uint32 chestgift() const;
  inline void set_chestgift(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGetChestReq)
 private:
  inline void set_has_chapterid();
  inline void clear_has_chapterid();
  inline void set_has_chestid();
  inline void clear_has_chestid();
  inline void set_has_chestgift();
  inline void clear_has_chestgift();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 chapterid_;
  ::google::protobuf::uint32 chestid_;
  ::google::protobuf::uint32 chestgift_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetChestReq* default_instance_;
};
// -------------------------------------------------------------------

class CSGetChestResp : public ::google::protobuf::MessageLite {
 public:
  CSGetChestResp();
  virtual ~CSGetChestResp();

  CSGetChestResp(const CSGetChestResp& from);

  inline CSGetChestResp& operator=(const CSGetChestResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetChestResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetChestResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetChestResp* other);

  // implements Message ----------------------------------------------

  CSGetChestResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetChestResp& from);
  void MergeFrom(const CSGetChestResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ChapterId = 1;
  inline bool has_chapterid() const;
  inline void clear_chapterid();
  static const int kChapterIdFieldNumber = 1;
  inline ::google::protobuf::uint32 chapterid() const;
  inline void set_chapterid(::google::protobuf::uint32 value);

  // required uint32 Chest = 2;
  inline bool has_chest() const;
  inline void clear_chest();
  static const int kChestFieldNumber = 2;
  inline ::google::protobuf::uint32 chest() const;
  inline void set_chest(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGetChestResp)
 private:
  inline void set_has_chapterid();
  inline void clear_has_chapterid();
  inline void set_has_chest();
  inline void clear_has_chest();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 chapterid_;
  ::google::protobuf::uint32 chest_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetChestResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPveNotifyReq : public ::google::protobuf::MessageLite {
 public:
  CSPveNotifyReq();
  virtual ~CSPveNotifyReq();

  CSPveNotifyReq(const CSPveNotifyReq& from);

  inline CSPveNotifyReq& operator=(const CSPveNotifyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPveNotifyReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPveNotifyReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPveNotifyReq* other);

  // implements Message ----------------------------------------------

  CSPveNotifyReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPveNotifyReq& from);
  void MergeFrom(const CSPveNotifyReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 CheckPoint = 1;
  inline bool has_checkpoint() const;
  inline void clear_checkpoint();
  static const int kCheckPointFieldNumber = 1;
  inline ::google::protobuf::uint32 checkpoint() const;
  inline void set_checkpoint(::google::protobuf::uint32 value);

  // required uint32 Action = 2;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 2;
  inline ::google::protobuf::uint32 action() const;
  inline void set_action(::google::protobuf::uint32 value);

  // required uint32 ChapterId = 3;
  inline bool has_chapterid() const;
  inline void clear_chapterid();
  static const int kChapterIdFieldNumber = 3;
  inline ::google::protobuf::uint32 chapterid() const;
  inline void set_chapterid(::google::protobuf::uint32 value);

  // required bool NeedPower = 4;
  inline bool has_needpower() const;
  inline void clear_needpower();
  static const int kNeedPowerFieldNumber = 4;
  inline bool needpower() const;
  inline void set_needpower(bool value);

  // optional uint32 BattleTime = 5;
  inline bool has_battletime() const;
  inline void clear_battletime();
  static const int kBattleTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 battletime() const;
  inline void set_battletime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPveNotifyReq)
 private:
  inline void set_has_checkpoint();
  inline void clear_has_checkpoint();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_chapterid();
  inline void clear_has_chapterid();
  inline void set_has_needpower();
  inline void clear_has_needpower();
  inline void set_has_battletime();
  inline void clear_has_battletime();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 checkpoint_;
  ::google::protobuf::uint32 action_;
  ::google::protobuf::uint32 chapterid_;
  bool needpower_;
  ::google::protobuf::uint32 battletime_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSPveNotifyReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPveNotifyResp : public ::google::protobuf::MessageLite {
 public:
  CSPveNotifyResp();
  virtual ~CSPveNotifyResp();

  CSPveNotifyResp(const CSPveNotifyResp& from);

  inline CSPveNotifyResp& operator=(const CSPveNotifyResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPveNotifyResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPveNotifyResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPveNotifyResp* other);

  // implements Message ----------------------------------------------

  CSPveNotifyResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPveNotifyResp& from);
  void MergeFrom(const CSPveNotifyResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool NeedPower = 1;
  inline bool has_needpower() const;
  inline void clear_needpower();
  static const int kNeedPowerFieldNumber = 1;
  inline bool needpower() const;
  inline void set_needpower(bool value);

  // @@protoc_insertion_point(class_scope:fgame.CSPveNotifyResp)
 private:
  inline void set_has_needpower();
  inline void clear_has_needpower();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool needpower_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSPveNotifyResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPveCheckAwardReq : public ::google::protobuf::MessageLite {
 public:
  CSPveCheckAwardReq();
  virtual ~CSPveCheckAwardReq();

  CSPveCheckAwardReq(const CSPveCheckAwardReq& from);

  inline CSPveCheckAwardReq& operator=(const CSPveCheckAwardReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPveCheckAwardReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPveCheckAwardReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPveCheckAwardReq* other);

  // implements Message ----------------------------------------------

  CSPveCheckAwardReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPveCheckAwardReq& from);
  void MergeFrom(const CSPveCheckAwardReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSPveCheckAwardReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSPveCheckAwardReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPveCheckAwardResp : public ::google::protobuf::MessageLite {
 public:
  CSPveCheckAwardResp();
  virtual ~CSPveCheckAwardResp();

  CSPveCheckAwardResp(const CSPveCheckAwardResp& from);

  inline CSPveCheckAwardResp& operator=(const CSPveCheckAwardResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPveCheckAwardResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPveCheckAwardResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPveCheckAwardResp* other);

  // implements Message ----------------------------------------------

  CSPveCheckAwardResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPveCheckAwardResp& from);
  void MergeFrom(const CSPveCheckAwardResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool HaveAward = 1;
  inline bool has_haveaward() const;
  inline void clear_haveaward();
  static const int kHaveAwardFieldNumber = 1;
  inline bool haveaward() const;
  inline void set_haveaward(bool value);

  // optional uint32 GiftID = 2;
  inline bool has_giftid() const;
  inline void clear_giftid();
  static const int kGiftIDFieldNumber = 2;
  inline ::google::protobuf::uint32 giftid() const;
  inline void set_giftid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPveCheckAwardResp)
 private:
  inline void set_has_haveaward();
  inline void clear_has_haveaward();
  inline void set_has_giftid();
  inline void clear_has_giftid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool haveaward_;
  ::google::protobuf::uint32 giftid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSPveCheckAwardResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvePveRank : public ::google::protobuf::MessageLite {
 public:
  CSPvePveRank();
  virtual ~CSPvePveRank();

  CSPvePveRank(const CSPvePveRank& from);

  inline CSPvePveRank& operator=(const CSPvePveRank& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvePveRank& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvePveRank* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvePveRank* other);

  // implements Message ----------------------------------------------

  CSPvePveRank* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvePveRank& from);
  void MergeFrom(const CSPvePveRank& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 CpId = 1;
  inline bool has_cpid() const;
  inline void clear_cpid();
  static const int kCpIdFieldNumber = 1;
  inline ::google::protobuf::uint32 cpid() const;
  inline void set_cpid(::google::protobuf::uint32 value);

  // repeated .fgame.CSPveRankData Data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::fgame::CSPveRankData& data(int index) const;
  inline ::fgame::CSPveRankData* mutable_data(int index);
  inline ::fgame::CSPveRankData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPveRankData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPveRankData >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:fgame.CSPvePveRank)
 private:
  inline void set_has_cpid();
  inline void clear_has_cpid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSPveRankData > data_;
  ::google::protobuf::uint32 cpid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSPvePveRank* default_instance_;
};
// -------------------------------------------------------------------

class CSPveRankData : public ::google::protobuf::MessageLite {
 public:
  CSPveRankData();
  virtual ~CSPveRankData();

  CSPveRankData(const CSPveRankData& from);

  inline CSPveRankData& operator=(const CSPveRankData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPveRankData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPveRankData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPveRankData* other);

  // implements Message ----------------------------------------------

  CSPveRankData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPveRankData& from);
  void MergeFrom(const CSPveRankData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 Rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // optional uint32 Uin = 2;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 2;
  inline ::google::protobuf::uint32 uin() const;
  inline void set_uin(::google::protobuf::uint32 value);

  // optional string Name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string Avator = 4;
  inline bool has_avator() const;
  inline void clear_avator();
  static const int kAvatorFieldNumber = 4;
  inline const ::std::string& avator() const;
  inline void set_avator(const ::std::string& value);
  inline void set_avator(const char* value);
  inline void set_avator(const char* value, size_t size);
  inline ::std::string* mutable_avator();
  inline ::std::string* release_avator();
  inline void set_allocated_avator(::std::string* avator);

  // optional uint32 Score = 5;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 5;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPveRankData)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_avator();
  inline void clear_has_avator();
  inline void set_has_score();
  inline void clear_has_score();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 rank_;
  ::google::protobuf::uint32 uin_;
  ::std::string* name_;
  ::std::string* avator_;
  ::google::protobuf::uint32 score_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSPveRankData* default_instance_;
};
// -------------------------------------------------------------------

class CSPveRankReq : public ::google::protobuf::MessageLite {
 public:
  CSPveRankReq();
  virtual ~CSPveRankReq();

  CSPveRankReq(const CSPveRankReq& from);

  inline CSPveRankReq& operator=(const CSPveRankReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPveRankReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPveRankReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPveRankReq* other);

  // implements Message ----------------------------------------------

  CSPveRankReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPveRankReq& from);
  void MergeFrom(const CSPveRankReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSPveRankReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSPveRankReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPveRankResp : public ::google::protobuf::MessageLite {
 public:
  CSPveRankResp();
  virtual ~CSPveRankResp();

  CSPveRankResp(const CSPveRankResp& from);

  inline CSPveRankResp& operator=(const CSPveRankResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPveRankResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPveRankResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPveRankResp* other);

  // implements Message ----------------------------------------------

  CSPveRankResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPveRankResp& from);
  void MergeFrom(const CSPveRankResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.CSPvePveRank Rank = 1;
  inline int rank_size() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline const ::fgame::CSPvePveRank& rank(int index) const;
  inline ::fgame::CSPvePveRank* mutable_rank(int index);
  inline ::fgame::CSPvePveRank* add_rank();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPvePveRank >&
      rank() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPvePveRank >*
      mutable_rank();

  // @@protoc_insertion_point(class_scope:fgame.CSPveRankResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSPvePveRank > rank_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSPveRankResp* default_instance_;
};
// -------------------------------------------------------------------

class CSOpenChestResp : public ::google::protobuf::MessageLite {
 public:
  CSOpenChestResp();
  virtual ~CSOpenChestResp();

  CSOpenChestResp(const CSOpenChestResp& from);

  inline CSOpenChestResp& operator=(const CSOpenChestResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSOpenChestResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOpenChestResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOpenChestResp* other);

  // implements Message ----------------------------------------------

  CSOpenChestResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOpenChestResp& from);
  void MergeFrom(const CSOpenChestResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.PropertyUpdateData UpdateData = 1;
  inline int updatedata_size() const;
  inline void clear_updatedata();
  static const int kUpdateDataFieldNumber = 1;
  inline const ::fgame::PropertyUpdateData& updatedata(int index) const;
  inline ::fgame::PropertyUpdateData* mutable_updatedata(int index);
  inline ::fgame::PropertyUpdateData* add_updatedata();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >&
      updatedata() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >*
      mutable_updatedata();

  // @@protoc_insertion_point(class_scope:fgame.CSOpenChestResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData > updatedata_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSOpenChestResp* default_instance_;
};
// -------------------------------------------------------------------

class CSSetSignatureReq : public ::google::protobuf::MessageLite {
 public:
  CSSetSignatureReq();
  virtual ~CSSetSignatureReq();

  CSSetSignatureReq(const CSSetSignatureReq& from);

  inline CSSetSignatureReq& operator=(const CSSetSignatureReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSetSignatureReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSetSignatureReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSetSignatureReq* other);

  // implements Message ----------------------------------------------

  CSSetSignatureReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSetSignatureReq& from);
  void MergeFrom(const CSSetSignatureReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Signature = 1;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 1;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const char* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:fgame.CSSetSignatureReq)
 private:
  inline void set_has_signature();
  inline void clear_has_signature();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* signature_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSetSignatureReq* default_instance_;
};
// -------------------------------------------------------------------

class CSSetSignatureResp : public ::google::protobuf::MessageLite {
 public:
  CSSetSignatureResp();
  virtual ~CSSetSignatureResp();

  CSSetSignatureResp(const CSSetSignatureResp& from);

  inline CSSetSignatureResp& operator=(const CSSetSignatureResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSetSignatureResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSetSignatureResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSetSignatureResp* other);

  // implements Message ----------------------------------------------

  CSSetSignatureResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSetSignatureResp& from);
  void MergeFrom(const CSSetSignatureResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Signature = 1;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 1;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const char* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:fgame.CSSetSignatureResp)
 private:
  inline void set_has_signature();
  inline void clear_has_signature();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* signature_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSetSignatureResp* default_instance_;
};
// -------------------------------------------------------------------

class CSSetExtraInfoVisibleReq : public ::google::protobuf::MessageLite {
 public:
  CSSetExtraInfoVisibleReq();
  virtual ~CSSetExtraInfoVisibleReq();

  CSSetExtraInfoVisibleReq(const CSSetExtraInfoVisibleReq& from);

  inline CSSetExtraInfoVisibleReq& operator=(const CSSetExtraInfoVisibleReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSetExtraInfoVisibleReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSetExtraInfoVisibleReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSetExtraInfoVisibleReq* other);

  // implements Message ----------------------------------------------

  CSSetExtraInfoVisibleReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSetExtraInfoVisibleReq& from);
  void MergeFrom(const CSSetExtraInfoVisibleReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool Visible = 1;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 1;
  inline bool visible() const;
  inline void set_visible(bool value);

  // @@protoc_insertion_point(class_scope:fgame.CSSetExtraInfoVisibleReq)
 private:
  inline void set_has_visible();
  inline void clear_has_visible();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool visible_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSetExtraInfoVisibleReq* default_instance_;
};
// -------------------------------------------------------------------

class CSSetExtraInfoVisibleResp : public ::google::protobuf::MessageLite {
 public:
  CSSetExtraInfoVisibleResp();
  virtual ~CSSetExtraInfoVisibleResp();

  CSSetExtraInfoVisibleResp(const CSSetExtraInfoVisibleResp& from);

  inline CSSetExtraInfoVisibleResp& operator=(const CSSetExtraInfoVisibleResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSSetExtraInfoVisibleResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSetExtraInfoVisibleResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSetExtraInfoVisibleResp* other);

  // implements Message ----------------------------------------------

  CSSetExtraInfoVisibleResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSetExtraInfoVisibleResp& from);
  void MergeFrom(const CSSetExtraInfoVisibleResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool Visible = 1;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 1;
  inline bool visible() const;
  inline void set_visible(bool value);

  // @@protoc_insertion_point(class_scope:fgame.CSSetExtraInfoVisibleResp)
 private:
  inline void set_has_visible();
  inline void clear_has_visible();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool visible_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSSetExtraInfoVisibleResp* default_instance_;
};
// -------------------------------------------------------------------

class CSGetExtraInfoReq : public ::google::protobuf::MessageLite {
 public:
  CSGetExtraInfoReq();
  virtual ~CSGetExtraInfoReq();

  CSGetExtraInfoReq(const CSGetExtraInfoReq& from);

  inline CSGetExtraInfoReq& operator=(const CSGetExtraInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetExtraInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetExtraInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetExtraInfoReq* other);

  // implements Message ----------------------------------------------

  CSGetExtraInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetExtraInfoReq& from);
  void MergeFrom(const CSGetExtraInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGetExtraInfoReq)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetExtraInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class CSGetExtraInfoResp : public ::google::protobuf::MessageLite {
 public:
  CSGetExtraInfoResp();
  virtual ~CSGetExtraInfoResp();

  CSGetExtraInfoResp(const CSGetExtraInfoResp& from);

  inline CSGetExtraInfoResp& operator=(const CSGetExtraInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetExtraInfoResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetExtraInfoResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetExtraInfoResp* other);

  // implements Message ----------------------------------------------

  CSGetExtraInfoResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetExtraInfoResp& from);
  void MergeFrom(const CSGetExtraInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // optional uint32 TotalPvpCount = 2;
  inline bool has_totalpvpcount() const;
  inline void clear_totalpvpcount();
  static const int kTotalPvpCountFieldNumber = 2;
  inline ::google::protobuf::uint32 totalpvpcount() const;
  inline void set_totalpvpcount(::google::protobuf::uint32 value);

  // optional uint32 TotalPveCount = 3;
  inline bool has_totalpvecount() const;
  inline void clear_totalpvecount();
  static const int kTotalPveCountFieldNumber = 3;
  inline ::google::protobuf::uint32 totalpvecount() const;
  inline void set_totalpvecount(::google::protobuf::uint32 value);

  // optional uint32 TotalPvpUseItem = 4;
  inline bool has_totalpvpuseitem() const;
  inline void clear_totalpvpuseitem();
  static const int kTotalPvpUseItemFieldNumber = 4;
  inline ::google::protobuf::uint32 totalpvpuseitem() const;
  inline void set_totalpvpuseitem(::google::protobuf::uint32 value);

  // optional uint32 TotalPveUseItem = 5;
  inline bool has_totalpveuseitem() const;
  inline void clear_totalpveuseitem();
  static const int kTotalPveUseItemFieldNumber = 5;
  inline ::google::protobuf::uint32 totalpveuseitem() const;
  inline void set_totalpveuseitem(::google::protobuf::uint32 value);

  // optional uint32 MaxPvpPoint = 6;
  inline bool has_maxpvppoint() const;
  inline void clear_maxpvppoint();
  static const int kMaxPvpPointFieldNumber = 6;
  inline ::google::protobuf::uint32 maxpvppoint() const;
  inline void set_maxpvppoint(::google::protobuf::uint32 value);

  // optional uint32 MaxPvpWinCount = 7;
  inline bool has_maxpvpwincount() const;
  inline void clear_maxpvpwincount();
  static const int kMaxPvpWinCountFieldNumber = 7;
  inline ::google::protobuf::uint32 maxpvpwincount() const;
  inline void set_maxpvpwincount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGetExtraInfoResp)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_totalpvpcount();
  inline void clear_has_totalpvpcount();
  inline void set_has_totalpvecount();
  inline void clear_has_totalpvecount();
  inline void set_has_totalpvpuseitem();
  inline void clear_has_totalpvpuseitem();
  inline void set_has_totalpveuseitem();
  inline void clear_has_totalpveuseitem();
  inline void set_has_maxpvppoint();
  inline void clear_has_maxpvppoint();
  inline void set_has_maxpvpwincount();
  inline void clear_has_maxpvpwincount();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  ::google::protobuf::uint32 totalpvpcount_;
  ::google::protobuf::uint32 totalpvecount_;
  ::google::protobuf::uint32 totalpvpuseitem_;
  ::google::protobuf::uint32 totalpveuseitem_;
  ::google::protobuf::uint32 maxpvppoint_;
  ::google::protobuf::uint32 maxpvpwincount_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetExtraInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class CSShareRewardGetResq : public ::google::protobuf::MessageLite {
 public:
  CSShareRewardGetResq();
  virtual ~CSShareRewardGetResq();

  CSShareRewardGetResq(const CSShareRewardGetResq& from);

  inline CSShareRewardGetResq& operator=(const CSShareRewardGetResq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSShareRewardGetResq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSShareRewardGetResq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSShareRewardGetResq* other);

  // implements Message ----------------------------------------------

  CSShareRewardGetResq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSShareRewardGetResq& from);
  void MergeFrom(const CSShareRewardGetResq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required uint32 ShareId = 2;
  inline bool has_shareid() const;
  inline void clear_shareid();
  static const int kShareIdFieldNumber = 2;
  inline ::google::protobuf::uint32 shareid() const;
  inline void set_shareid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSShareRewardGetResq)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_shareid();
  inline void clear_has_shareid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 shareid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSShareRewardGetResq* default_instance_;
};
// -------------------------------------------------------------------

class CSShareRewardGetReq : public ::google::protobuf::MessageLite {
 public:
  CSShareRewardGetReq();
  virtual ~CSShareRewardGetReq();

  CSShareRewardGetReq(const CSShareRewardGetReq& from);

  inline CSShareRewardGetReq& operator=(const CSShareRewardGetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSShareRewardGetReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSShareRewardGetReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSShareRewardGetReq* other);

  // implements Message ----------------------------------------------

  CSShareRewardGetReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSShareRewardGetReq& from);
  void MergeFrom(const CSShareRewardGetReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ShareId = 1;
  inline bool has_shareid() const;
  inline void clear_shareid();
  static const int kShareIdFieldNumber = 1;
  inline ::google::protobuf::uint32 shareid() const;
  inline void set_shareid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSShareRewardGetReq)
 private:
  inline void set_has_shareid();
  inline void clear_has_shareid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 shareid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSShareRewardGetReq* default_instance_;
};
// -------------------------------------------------------------------

class CSGetSevenGoalListReq : public ::google::protobuf::MessageLite {
 public:
  CSGetSevenGoalListReq();
  virtual ~CSGetSevenGoalListReq();

  CSGetSevenGoalListReq(const CSGetSevenGoalListReq& from);

  inline CSGetSevenGoalListReq& operator=(const CSGetSevenGoalListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetSevenGoalListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetSevenGoalListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetSevenGoalListReq* other);

  // implements Message ----------------------------------------------

  CSGetSevenGoalListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetSevenGoalListReq& from);
  void MergeFrom(const CSGetSevenGoalListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSGetSevenGoalListReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetSevenGoalListReq* default_instance_;
};
// -------------------------------------------------------------------

class CSGetSevenGoalListResp : public ::google::protobuf::MessageLite {
 public:
  CSGetSevenGoalListResp();
  virtual ~CSGetSevenGoalListResp();

  CSGetSevenGoalListResp(const CSGetSevenGoalListResp& from);

  inline CSGetSevenGoalListResp& operator=(const CSGetSevenGoalListResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSGetSevenGoalListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetSevenGoalListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetSevenGoalListResp* other);

  // implements Message ----------------------------------------------

  CSGetSevenGoalListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetSevenGoalListResp& from);
  void MergeFrom(const CSGetSevenGoalListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 NowDay = 1;
  inline bool has_nowday() const;
  inline void clear_nowday();
  static const int kNowDayFieldNumber = 1;
  inline ::google::protobuf::uint32 nowday() const;
  inline void set_nowday(::google::protobuf::uint32 value);

  // required bool IsRetrived = 2;
  inline bool has_isretrived() const;
  inline void clear_isretrived();
  static const int kIsRetrivedFieldNumber = 2;
  inline bool isretrived() const;
  inline void set_isretrived(bool value);

  // required uint32 Num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // required uint32 NextNum = 4;
  inline bool has_nextnum() const;
  inline void clear_nextnum();
  static const int kNextNumFieldNumber = 4;
  inline ::google::protobuf::uint32 nextnum() const;
  inline void set_nextnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSGetSevenGoalListResp)
 private:
  inline void set_has_nowday();
  inline void clear_has_nowday();
  inline void set_has_isretrived();
  inline void clear_has_isretrived();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_nextnum();
  inline void clear_has_nextnum();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 nowday_;
  bool isretrived_;
  ::google::protobuf::uint32 num_;
  ::google::protobuf::uint32 nextnum_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSGetSevenGoalListResp* default_instance_;
};
// -------------------------------------------------------------------

class CSNoticeSevenGoalResp : public ::google::protobuf::MessageLite {
 public:
  CSNoticeSevenGoalResp();
  virtual ~CSNoticeSevenGoalResp();

  CSNoticeSevenGoalResp(const CSNoticeSevenGoalResp& from);

  inline CSNoticeSevenGoalResp& operator=(const CSNoticeSevenGoalResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSNoticeSevenGoalResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSNoticeSevenGoalResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSNoticeSevenGoalResp* other);

  // implements Message ----------------------------------------------

  CSNoticeSevenGoalResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSNoticeSevenGoalResp& from);
  void MergeFrom(const CSNoticeSevenGoalResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSNoticeSevenGoalResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSNoticeSevenGoalResp* default_instance_;
};
// -------------------------------------------------------------------

class CSRetriveSevenGoalReq : public ::google::protobuf::MessageLite {
 public:
  CSRetriveSevenGoalReq();
  virtual ~CSRetriveSevenGoalReq();

  CSRetriveSevenGoalReq(const CSRetriveSevenGoalReq& from);

  inline CSRetriveSevenGoalReq& operator=(const CSRetriveSevenGoalReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRetriveSevenGoalReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRetriveSevenGoalReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRetriveSevenGoalReq* other);

  // implements Message ----------------------------------------------

  CSRetriveSevenGoalReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRetriveSevenGoalReq& from);
  void MergeFrom(const CSRetriveSevenGoalReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 NowDay = 1;
  inline bool has_nowday() const;
  inline void clear_nowday();
  static const int kNowDayFieldNumber = 1;
  inline ::google::protobuf::uint32 nowday() const;
  inline void set_nowday(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSRetriveSevenGoalReq)
 private:
  inline void set_has_nowday();
  inline void clear_has_nowday();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 nowday_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSRetriveSevenGoalReq* default_instance_;
};
// -------------------------------------------------------------------

class CSRetriveSevenGoalResp : public ::google::protobuf::MessageLite {
 public:
  CSRetriveSevenGoalResp();
  virtual ~CSRetriveSevenGoalResp();

  CSRetriveSevenGoalResp(const CSRetriveSevenGoalResp& from);

  inline CSRetriveSevenGoalResp& operator=(const CSRetriveSevenGoalResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSRetriveSevenGoalResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRetriveSevenGoalResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRetriveSevenGoalResp* other);

  // implements Message ----------------------------------------------

  CSRetriveSevenGoalResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRetriveSevenGoalResp& from);
  void MergeFrom(const CSRetriveSevenGoalResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSRetriveSevenGoalResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSRetriveSevenGoalResp* default_instance_;
};
// -------------------------------------------------------------------

class CSTopRankReq : public ::google::protobuf::MessageLite {
 public:
  CSTopRankReq();
  virtual ~CSTopRankReq();

  CSTopRankReq(const CSTopRankReq& from);

  inline CSTopRankReq& operator=(const CSTopRankReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSTopRankReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSTopRankReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSTopRankReq* other);

  // implements Message ----------------------------------------------

  CSTopRankReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSTopRankReq& from);
  void MergeFrom(const CSTopRankReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Category = 1;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 1;
  inline ::google::protobuf::uint32 category() const;
  inline void set_category(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSTopRankReq)
 private:
  inline void set_has_category();
  inline void clear_has_category();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 category_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSTopRankReq* default_instance_;
};
// -------------------------------------------------------------------

class TopRankData : public ::google::protobuf::MessageLite {
 public:
  TopRankData();
  virtual ~TopRankData();

  TopRankData(const TopRankData& from);

  inline TopRankData& operator=(const TopRankData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TopRankData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TopRankData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TopRankData* other);

  // implements Message ----------------------------------------------

  TopRankData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TopRankData& from);
  void MergeFrom(const TopRankData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 Rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // optional uint32 Uin = 2;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 2;
  inline ::google::protobuf::uint32 uin() const;
  inline void set_uin(::google::protobuf::uint32 value);

  // optional string Name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string Avator = 4;
  inline bool has_avator() const;
  inline void clear_avator();
  static const int kAvatorFieldNumber = 4;
  inline const ::std::string& avator() const;
  inline void set_avator(const ::std::string& value);
  inline void set_avator(const char* value);
  inline void set_avator(const char* value, size_t size);
  inline ::std::string* mutable_avator();
  inline ::std::string* release_avator();
  inline void set_allocated_avator(::std::string* avator);

  // optional uint32 Value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // optional bool Up = 6;
  inline bool has_up() const;
  inline void clear_up();
  static const int kUpFieldNumber = 6;
  inline bool up() const;
  inline void set_up(bool value);

  // optional uint32 Level = 7;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 7;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.TopRankData)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_avator();
  inline void clear_has_avator();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_up();
  inline void clear_has_up();
  inline void set_has_level();
  inline void clear_has_level();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 rank_;
  ::google::protobuf::uint32 uin_;
  ::std::string* name_;
  ::std::string* avator_;
  ::google::protobuf::uint32 value_;
  bool up_;
  ::google::protobuf::uint32 level_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static TopRankData* default_instance_;
};
// -------------------------------------------------------------------

class CSTopRankResp : public ::google::protobuf::MessageLite {
 public:
  CSTopRankResp();
  virtual ~CSTopRankResp();

  CSTopRankResp(const CSTopRankResp& from);

  inline CSTopRankResp& operator=(const CSTopRankResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSTopRankResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSTopRankResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSTopRankResp* other);

  // implements Message ----------------------------------------------

  CSTopRankResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSTopRankResp& from);
  void MergeFrom(const CSTopRankResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Category = 1;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 1;
  inline ::google::protobuf::uint32 category() const;
  inline void set_category(::google::protobuf::uint32 value);

  // repeated .fgame.TopRankData Data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::fgame::TopRankData& data(int index) const;
  inline ::fgame::TopRankData* mutable_data(int index);
  inline ::fgame::TopRankData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::TopRankData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::TopRankData >*
      mutable_data();

  // optional .fgame.TopRankData OwnerData = 3;
  inline bool has_ownerdata() const;
  inline void clear_ownerdata();
  static const int kOwnerDataFieldNumber = 3;
  inline const ::fgame::TopRankData& ownerdata() const;
  inline ::fgame::TopRankData* mutable_ownerdata();
  inline ::fgame::TopRankData* release_ownerdata();
  inline void set_allocated_ownerdata(::fgame::TopRankData* ownerdata);

  // @@protoc_insertion_point(class_scope:fgame.CSTopRankResp)
 private:
  inline void set_has_category();
  inline void clear_has_category();
  inline void set_has_ownerdata();
  inline void clear_has_ownerdata();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::TopRankData > data_;
  ::fgame::TopRankData* ownerdata_;
  ::google::protobuf::uint32 category_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSTopRankResp* default_instance_;
};
// -------------------------------------------------------------------

class CSTopRankTimeReq : public ::google::protobuf::MessageLite {
 public:
  CSTopRankTimeReq();
  virtual ~CSTopRankTimeReq();

  CSTopRankTimeReq(const CSTopRankTimeReq& from);

  inline CSTopRankTimeReq& operator=(const CSTopRankTimeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSTopRankTimeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSTopRankTimeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSTopRankTimeReq* other);

  // implements Message ----------------------------------------------

  CSTopRankTimeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSTopRankTimeReq& from);
  void MergeFrom(const CSTopRankTimeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Category = 1;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 1;
  inline ::google::protobuf::uint32 category() const;
  inline void set_category(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSTopRankTimeReq)
 private:
  inline void set_has_category();
  inline void clear_has_category();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 category_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSTopRankTimeReq* default_instance_;
};
// -------------------------------------------------------------------

class CSTopRankTimeResp : public ::google::protobuf::MessageLite {
 public:
  CSTopRankTimeResp();
  virtual ~CSTopRankTimeResp();

  CSTopRankTimeResp(const CSTopRankTimeResp& from);

  inline CSTopRankTimeResp& operator=(const CSTopRankTimeResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSTopRankTimeResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSTopRankTimeResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSTopRankTimeResp* other);

  // implements Message ----------------------------------------------

  CSTopRankTimeResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSTopRankTimeResp& from);
  void MergeFrom(const CSTopRankTimeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 BeginAt = 1;
  inline bool has_beginat() const;
  inline void clear_beginat();
  static const int kBeginAtFieldNumber = 1;
  inline ::google::protobuf::uint32 beginat() const;
  inline void set_beginat(::google::protobuf::uint32 value);

  // optional uint32 EndAt = 2;
  inline bool has_endat() const;
  inline void clear_endat();
  static const int kEndAtFieldNumber = 2;
  inline ::google::protobuf::uint32 endat() const;
  inline void set_endat(::google::protobuf::uint32 value);

  // optional uint32 Category = 3;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 3;
  inline ::google::protobuf::uint32 category() const;
  inline void set_category(::google::protobuf::uint32 value);

  // optional uint32 Secs = 4;
  inline bool has_secs() const;
  inline void clear_secs();
  static const int kSecsFieldNumber = 4;
  inline ::google::protobuf::uint32 secs() const;
  inline void set_secs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSTopRankTimeResp)
 private:
  inline void set_has_beginat();
  inline void clear_has_beginat();
  inline void set_has_endat();
  inline void clear_has_endat();
  inline void set_has_category();
  inline void clear_has_category();
  inline void set_has_secs();
  inline void clear_has_secs();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 beginat_;
  ::google::protobuf::uint32 endat_;
  ::google::protobuf::uint32 category_;
  ::google::protobuf::uint32 secs_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Player_2eproto();
  #endif
  friend void protobuf_AssignDesc_Player_2eproto();
  friend void protobuf_ShutdownFile_Player_2eproto();

  void InitAsDefaultInstance();
  static CSTopRankTimeResp* default_instance_;
};
// ===================================================================


// ===================================================================

// PropertyUpdateData

// required uint32 UpType = 1;
inline bool PropertyUpdateData::has_uptype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PropertyUpdateData::set_has_uptype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PropertyUpdateData::clear_has_uptype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PropertyUpdateData::clear_uptype() {
  uptype_ = 0u;
  clear_has_uptype();
}
inline ::google::protobuf::uint32 PropertyUpdateData::uptype() const {
  // @@protoc_insertion_point(field_get:fgame.PropertyUpdateData.UpType)
  return uptype_;
}
inline void PropertyUpdateData::set_uptype(::google::protobuf::uint32 value) {
  set_has_uptype();
  uptype_ = value;
  // @@protoc_insertion_point(field_set:fgame.PropertyUpdateData.UpType)
}

// optional uint32 Value = 2;
inline bool PropertyUpdateData::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PropertyUpdateData::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PropertyUpdateData::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PropertyUpdateData::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 PropertyUpdateData::value() const {
  // @@protoc_insertion_point(field_get:fgame.PropertyUpdateData.Value)
  return value_;
}
inline void PropertyUpdateData::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:fgame.PropertyUpdateData.Value)
}

// optional uint32 Value2 = 3;
inline bool PropertyUpdateData::has_value2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PropertyUpdateData::set_has_value2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PropertyUpdateData::clear_has_value2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PropertyUpdateData::clear_value2() {
  value2_ = 0u;
  clear_has_value2();
}
inline ::google::protobuf::uint32 PropertyUpdateData::value2() const {
  // @@protoc_insertion_point(field_get:fgame.PropertyUpdateData.Value2)
  return value2_;
}
inline void PropertyUpdateData::set_value2(::google::protobuf::uint32 value) {
  set_has_value2();
  value2_ = value;
  // @@protoc_insertion_point(field_set:fgame.PropertyUpdateData.Value2)
}

// optional string Extra = 4;
inline bool PropertyUpdateData::has_extra() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PropertyUpdateData::set_has_extra() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PropertyUpdateData::clear_has_extra() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PropertyUpdateData::clear_extra() {
  if (extra_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_->clear();
  }
  clear_has_extra();
}
inline const ::std::string& PropertyUpdateData::extra() const {
  // @@protoc_insertion_point(field_get:fgame.PropertyUpdateData.Extra)
  return *extra_;
}
inline void PropertyUpdateData::set_extra(const ::std::string& value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.PropertyUpdateData.Extra)
}
inline void PropertyUpdateData::set_extra(const char* value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.PropertyUpdateData.Extra)
}
inline void PropertyUpdateData::set_extra(const char* value, size_t size) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_ = new ::std::string;
  }
  extra_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.PropertyUpdateData.Extra)
}
inline ::std::string* PropertyUpdateData::mutable_extra() {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.PropertyUpdateData.Extra)
  return extra_;
}
inline ::std::string* PropertyUpdateData::release_extra() {
  clear_has_extra();
  if (extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = extra_;
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PropertyUpdateData::set_allocated_extra(::std::string* extra) {
  if (extra_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extra_;
  }
  if (extra) {
    set_has_extra();
    extra_ = extra;
  } else {
    clear_has_extra();
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.PropertyUpdateData.Extra)
}

// optional uint32 Src = 5;
inline bool PropertyUpdateData::has_src() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PropertyUpdateData::set_has_src() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PropertyUpdateData::clear_has_src() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PropertyUpdateData::clear_src() {
  src_ = 0u;
  clear_has_src();
}
inline ::google::protobuf::uint32 PropertyUpdateData::src() const {
  // @@protoc_insertion_point(field_get:fgame.PropertyUpdateData.Src)
  return src_;
}
inline void PropertyUpdateData::set_src(::google::protobuf::uint32 value) {
  set_has_src();
  src_ = value;
  // @@protoc_insertion_point(field_set:fgame.PropertyUpdateData.Src)
}

// -------------------------------------------------------------------

// CSQueryPlayerInfoReq

// required uint64 Uin = 1;
inline bool CSQueryPlayerInfoReq::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSQueryPlayerInfoReq::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSQueryPlayerInfoReq::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSQueryPlayerInfoReq::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSQueryPlayerInfoReq::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueryPlayerInfoReq.Uin)
  return uin_;
}
inline void CSQueryPlayerInfoReq::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSQueryPlayerInfoReq.Uin)
}

// -------------------------------------------------------------------

// CSQueryPlayerInfoResp

// required uint64 Uin = 1;
inline bool CSQueryPlayerInfoResp::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSQueryPlayerInfoResp::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSQueryPlayerInfoResp::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSQueryPlayerInfoResp::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSQueryPlayerInfoResp::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueryPlayerInfoResp.Uin)
  return uin_;
}
inline void CSQueryPlayerInfoResp::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSQueryPlayerInfoResp.Uin)
}

// required string Name = 2;
inline bool CSQueryPlayerInfoResp::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSQueryPlayerInfoResp::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSQueryPlayerInfoResp::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSQueryPlayerInfoResp::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSQueryPlayerInfoResp::name() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueryPlayerInfoResp.Name)
  return *name_;
}
inline void CSQueryPlayerInfoResp::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSQueryPlayerInfoResp.Name)
}
inline void CSQueryPlayerInfoResp::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSQueryPlayerInfoResp.Name)
}
inline void CSQueryPlayerInfoResp::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSQueryPlayerInfoResp.Name)
}
inline ::std::string* CSQueryPlayerInfoResp::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSQueryPlayerInfoResp.Name)
  return name_;
}
inline ::std::string* CSQueryPlayerInfoResp::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSQueryPlayerInfoResp::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSQueryPlayerInfoResp.Name)
}

// optional string Icon = 3;
inline bool CSQueryPlayerInfoResp::has_icon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSQueryPlayerInfoResp::set_has_icon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSQueryPlayerInfoResp::clear_has_icon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSQueryPlayerInfoResp::clear_icon() {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& CSQueryPlayerInfoResp::icon() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueryPlayerInfoResp.Icon)
  return *icon_;
}
inline void CSQueryPlayerInfoResp::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSQueryPlayerInfoResp.Icon)
}
inline void CSQueryPlayerInfoResp::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSQueryPlayerInfoResp.Icon)
}
inline void CSQueryPlayerInfoResp::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSQueryPlayerInfoResp.Icon)
}
inline ::std::string* CSQueryPlayerInfoResp::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSQueryPlayerInfoResp.Icon)
  return icon_;
}
inline ::std::string* CSQueryPlayerInfoResp::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSQueryPlayerInfoResp::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSQueryPlayerInfoResp.Icon)
}

// optional uint64 Title = 4;
inline bool CSQueryPlayerInfoResp::has_title() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSQueryPlayerInfoResp::set_has_title() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSQueryPlayerInfoResp::clear_has_title() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSQueryPlayerInfoResp::clear_title() {
  title_ = GOOGLE_ULONGLONG(0);
  clear_has_title();
}
inline ::google::protobuf::uint64 CSQueryPlayerInfoResp::title() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueryPlayerInfoResp.Title)
  return title_;
}
inline void CSQueryPlayerInfoResp::set_title(::google::protobuf::uint64 value) {
  set_has_title();
  title_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSQueryPlayerInfoResp.Title)
}

// optional uint32 Level = 5;
inline bool CSQueryPlayerInfoResp::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSQueryPlayerInfoResp::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSQueryPlayerInfoResp::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSQueryPlayerInfoResp::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 CSQueryPlayerInfoResp::level() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueryPlayerInfoResp.Level)
  return level_;
}
inline void CSQueryPlayerInfoResp::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSQueryPlayerInfoResp.Level)
}

// optional uint32 Score = 6;
inline bool CSQueryPlayerInfoResp::has_score() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSQueryPlayerInfoResp::set_has_score() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSQueryPlayerInfoResp::clear_has_score() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSQueryPlayerInfoResp::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 CSQueryPlayerInfoResp::score() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueryPlayerInfoResp.Score)
  return score_;
}
inline void CSQueryPlayerInfoResp::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSQueryPlayerInfoResp.Score)
}

// optional float WinRate = 7;
inline bool CSQueryPlayerInfoResp::has_winrate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSQueryPlayerInfoResp::set_has_winrate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSQueryPlayerInfoResp::clear_has_winrate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSQueryPlayerInfoResp::clear_winrate() {
  winrate_ = 0;
  clear_has_winrate();
}
inline float CSQueryPlayerInfoResp::winrate() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueryPlayerInfoResp.WinRate)
  return winrate_;
}
inline void CSQueryPlayerInfoResp::set_winrate(float value) {
  set_has_winrate();
  winrate_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSQueryPlayerInfoResp.WinRate)
}

// optional uint32 Group = 8;
inline bool CSQueryPlayerInfoResp::has_group() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSQueryPlayerInfoResp::set_has_group() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSQueryPlayerInfoResp::clear_has_group() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSQueryPlayerInfoResp::clear_group() {
  group_ = 0u;
  clear_has_group();
}
inline ::google::protobuf::uint32 CSQueryPlayerInfoResp::group() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueryPlayerInfoResp.Group)
  return group_;
}
inline void CSQueryPlayerInfoResp::set_group(::google::protobuf::uint32 value) {
  set_has_group();
  group_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSQueryPlayerInfoResp.Group)
}

// optional uint32 Rank = 9;
inline bool CSQueryPlayerInfoResp::has_rank() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSQueryPlayerInfoResp::set_has_rank() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSQueryPlayerInfoResp::clear_has_rank() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSQueryPlayerInfoResp::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 CSQueryPlayerInfoResp::rank() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueryPlayerInfoResp.Rank)
  return rank_;
}
inline void CSQueryPlayerInfoResp::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSQueryPlayerInfoResp.Rank)
}

// optional uint32 ExpLevel = 10;
inline bool CSQueryPlayerInfoResp::has_explevel() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSQueryPlayerInfoResp::set_has_explevel() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSQueryPlayerInfoResp::clear_has_explevel() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSQueryPlayerInfoResp::clear_explevel() {
  explevel_ = 0u;
  clear_has_explevel();
}
inline ::google::protobuf::uint32 CSQueryPlayerInfoResp::explevel() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueryPlayerInfoResp.ExpLevel)
  return explevel_;
}
inline void CSQueryPlayerInfoResp::set_explevel(::google::protobuf::uint32 value) {
  set_has_explevel();
  explevel_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSQueryPlayerInfoResp.ExpLevel)
}

// optional uint32 Exp = 11;
inline bool CSQueryPlayerInfoResp::has_exp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CSQueryPlayerInfoResp::set_has_exp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CSQueryPlayerInfoResp::clear_has_exp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CSQueryPlayerInfoResp::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 CSQueryPlayerInfoResp::exp() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueryPlayerInfoResp.Exp)
  return exp_;
}
inline void CSQueryPlayerInfoResp::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSQueryPlayerInfoResp.Exp)
}

// optional uint32 GlyphsLevel = 12;
inline bool CSQueryPlayerInfoResp::has_glyphslevel() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CSQueryPlayerInfoResp::set_has_glyphslevel() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CSQueryPlayerInfoResp::clear_has_glyphslevel() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CSQueryPlayerInfoResp::clear_glyphslevel() {
  glyphslevel_ = 0u;
  clear_has_glyphslevel();
}
inline ::google::protobuf::uint32 CSQueryPlayerInfoResp::glyphslevel() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueryPlayerInfoResp.GlyphsLevel)
  return glyphslevel_;
}
inline void CSQueryPlayerInfoResp::set_glyphslevel(::google::protobuf::uint32 value) {
  set_has_glyphslevel();
  glyphslevel_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSQueryPlayerInfoResp.GlyphsLevel)
}

// optional uint32 MaxCheckPoint = 13;
inline bool CSQueryPlayerInfoResp::has_maxcheckpoint() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CSQueryPlayerInfoResp::set_has_maxcheckpoint() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CSQueryPlayerInfoResp::clear_has_maxcheckpoint() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CSQueryPlayerInfoResp::clear_maxcheckpoint() {
  maxcheckpoint_ = 0u;
  clear_has_maxcheckpoint();
}
inline ::google::protobuf::uint32 CSQueryPlayerInfoResp::maxcheckpoint() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueryPlayerInfoResp.MaxCheckPoint)
  return maxcheckpoint_;
}
inline void CSQueryPlayerInfoResp::set_maxcheckpoint(::google::protobuf::uint32 value) {
  set_has_maxcheckpoint();
  maxcheckpoint_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSQueryPlayerInfoResp.MaxCheckPoint)
}

// optional string Signature = 14;
inline bool CSQueryPlayerInfoResp::has_signature() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CSQueryPlayerInfoResp::set_has_signature() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CSQueryPlayerInfoResp::clear_has_signature() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CSQueryPlayerInfoResp::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& CSQueryPlayerInfoResp::signature() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueryPlayerInfoResp.Signature)
  return *signature_;
}
inline void CSQueryPlayerInfoResp::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSQueryPlayerInfoResp.Signature)
}
inline void CSQueryPlayerInfoResp::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSQueryPlayerInfoResp.Signature)
}
inline void CSQueryPlayerInfoResp::set_signature(const char* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSQueryPlayerInfoResp.Signature)
}
inline ::std::string* CSQueryPlayerInfoResp::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSQueryPlayerInfoResp.Signature)
  return signature_;
}
inline ::std::string* CSQueryPlayerInfoResp::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSQueryPlayerInfoResp::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSQueryPlayerInfoResp.Signature)
}

// optional uint32 VipLevel = 15;
inline bool CSQueryPlayerInfoResp::has_viplevel() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CSQueryPlayerInfoResp::set_has_viplevel() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CSQueryPlayerInfoResp::clear_has_viplevel() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CSQueryPlayerInfoResp::clear_viplevel() {
  viplevel_ = 0u;
  clear_has_viplevel();
}
inline ::google::protobuf::uint32 CSQueryPlayerInfoResp::viplevel() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueryPlayerInfoResp.VipLevel)
  return viplevel_;
}
inline void CSQueryPlayerInfoResp::set_viplevel(::google::protobuf::uint32 value) {
  set_has_viplevel();
  viplevel_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSQueryPlayerInfoResp.VipLevel)
}

// optional bool Visible = 16;
inline bool CSQueryPlayerInfoResp::has_visible() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CSQueryPlayerInfoResp::set_has_visible() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CSQueryPlayerInfoResp::clear_has_visible() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CSQueryPlayerInfoResp::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool CSQueryPlayerInfoResp::visible() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueryPlayerInfoResp.Visible)
  return visible_;
}
inline void CSQueryPlayerInfoResp::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSQueryPlayerInfoResp.Visible)
}

// optional uint32 Area = 17;
inline bool CSQueryPlayerInfoResp::has_area() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CSQueryPlayerInfoResp::set_has_area() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CSQueryPlayerInfoResp::clear_has_area() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CSQueryPlayerInfoResp::clear_area() {
  area_ = 0u;
  clear_has_area();
}
inline ::google::protobuf::uint32 CSQueryPlayerInfoResp::area() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueryPlayerInfoResp.Area)
  return area_;
}
inline void CSQueryPlayerInfoResp::set_area(::google::protobuf::uint32 value) {
  set_has_area();
  area_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSQueryPlayerInfoResp.Area)
}

// -------------------------------------------------------------------

// CSShopGuideReq

// required uint32 Diamond = 1;
inline bool CSShopGuideReq::has_diamond() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSShopGuideReq::set_has_diamond() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSShopGuideReq::clear_has_diamond() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSShopGuideReq::clear_diamond() {
  diamond_ = 0u;
  clear_has_diamond();
}
inline ::google::protobuf::uint32 CSShopGuideReq::diamond() const {
  // @@protoc_insertion_point(field_get:fgame.CSShopGuideReq.Diamond)
  return diamond_;
}
inline void CSShopGuideReq::set_diamond(::google::protobuf::uint32 value) {
  set_has_diamond();
  diamond_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSShopGuideReq.Diamond)
}

// -------------------------------------------------------------------

// CSShopGuideResp

// required uint32 Ret = 1;
inline bool CSShopGuideResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSShopGuideResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSShopGuideResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSShopGuideResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSShopGuideResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSShopGuideResp.Ret)
  return ret_;
}
inline void CSShopGuideResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSShopGuideResp.Ret)
}

// required uint32 Diamond = 2;
inline bool CSShopGuideResp::has_diamond() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSShopGuideResp::set_has_diamond() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSShopGuideResp::clear_has_diamond() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSShopGuideResp::clear_diamond() {
  diamond_ = 0u;
  clear_has_diamond();
}
inline ::google::protobuf::uint32 CSShopGuideResp::diamond() const {
  // @@protoc_insertion_point(field_get:fgame.CSShopGuideResp.Diamond)
  return diamond_;
}
inline void CSShopGuideResp::set_diamond(::google::protobuf::uint32 value) {
  set_has_diamond();
  diamond_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSShopGuideResp.Diamond)
}

// -------------------------------------------------------------------

// CSTestAddDiamondReq

// required uint32 Diamond = 1;
inline bool CSTestAddDiamondReq::has_diamond() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSTestAddDiamondReq::set_has_diamond() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSTestAddDiamondReq::clear_has_diamond() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSTestAddDiamondReq::clear_diamond() {
  diamond_ = 0u;
  clear_has_diamond();
}
inline ::google::protobuf::uint32 CSTestAddDiamondReq::diamond() const {
  // @@protoc_insertion_point(field_get:fgame.CSTestAddDiamondReq.Diamond)
  return diamond_;
}
inline void CSTestAddDiamondReq::set_diamond(::google::protobuf::uint32 value) {
  set_has_diamond();
  diamond_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSTestAddDiamondReq.Diamond)
}

// -------------------------------------------------------------------

// CSSetTitleReq

// required uint32 Title = 1;
inline bool CSSetTitleReq::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSetTitleReq::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSetTitleReq::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSetTitleReq::clear_title() {
  title_ = 0u;
  clear_has_title();
}
inline ::google::protobuf::uint32 CSSetTitleReq::title() const {
  // @@protoc_insertion_point(field_get:fgame.CSSetTitleReq.Title)
  return title_;
}
inline void CSSetTitleReq::set_title(::google::protobuf::uint32 value) {
  set_has_title();
  title_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSetTitleReq.Title)
}

// -------------------------------------------------------------------

// CSSetTitleResp

// required uint32 Title = 1;
inline bool CSSetTitleResp::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSetTitleResp::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSetTitleResp::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSetTitleResp::clear_title() {
  title_ = 0u;
  clear_has_title();
}
inline ::google::protobuf::uint32 CSSetTitleResp::title() const {
  // @@protoc_insertion_point(field_get:fgame.CSSetTitleResp.Title)
  return title_;
}
inline void CSSetTitleResp::set_title(::google::protobuf::uint32 value) {
  set_has_title();
  title_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSetTitleResp.Title)
}

// -------------------------------------------------------------------

// CSShopBuyReq

// required uint32 ShopId = 1;
inline bool CSShopBuyReq::has_shopid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSShopBuyReq::set_has_shopid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSShopBuyReq::clear_has_shopid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSShopBuyReq::clear_shopid() {
  shopid_ = 0u;
  clear_has_shopid();
}
inline ::google::protobuf::uint32 CSShopBuyReq::shopid() const {
  // @@protoc_insertion_point(field_get:fgame.CSShopBuyReq.ShopId)
  return shopid_;
}
inline void CSShopBuyReq::set_shopid(::google::protobuf::uint32 value) {
  set_has_shopid();
  shopid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSShopBuyReq.ShopId)
}

// -------------------------------------------------------------------

// CSShopBuyResp

// required uint32 ShopId = 1;
inline bool CSShopBuyResp::has_shopid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSShopBuyResp::set_has_shopid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSShopBuyResp::clear_has_shopid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSShopBuyResp::clear_shopid() {
  shopid_ = 0u;
  clear_has_shopid();
}
inline ::google::protobuf::uint32 CSShopBuyResp::shopid() const {
  // @@protoc_insertion_point(field_get:fgame.CSShopBuyResp.ShopId)
  return shopid_;
}
inline void CSShopBuyResp::set_shopid(::google::protobuf::uint32 value) {
  set_has_shopid();
  shopid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSShopBuyResp.ShopId)
}

// -------------------------------------------------------------------

// CSShopListReq

// -------------------------------------------------------------------

// DiamondData

// required uint32 ShopId = 1;
inline bool DiamondData::has_shopid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiamondData::set_has_shopid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiamondData::clear_has_shopid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiamondData::clear_shopid() {
  shopid_ = 0u;
  clear_has_shopid();
}
inline ::google::protobuf::uint32 DiamondData::shopid() const {
  // @@protoc_insertion_point(field_get:fgame.DiamondData.ShopId)
  return shopid_;
}
inline void DiamondData::set_shopid(::google::protobuf::uint32 value) {
  set_has_shopid();
  shopid_ = value;
  // @@protoc_insertion_point(field_set:fgame.DiamondData.ShopId)
}

// optional bool First = 2;
inline bool DiamondData::has_first() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiamondData::set_has_first() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiamondData::clear_has_first() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiamondData::clear_first() {
  first_ = false;
  clear_has_first();
}
inline bool DiamondData::first() const {
  // @@protoc_insertion_point(field_get:fgame.DiamondData.First)
  return first_;
}
inline void DiamondData::set_first(bool value) {
  set_has_first();
  first_ = value;
  // @@protoc_insertion_point(field_set:fgame.DiamondData.First)
}

// -------------------------------------------------------------------

// GiftData

// required uint32 ShopId = 1;
inline bool GiftData::has_shopid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GiftData::set_has_shopid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GiftData::clear_has_shopid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GiftData::clear_shopid() {
  shopid_ = 0u;
  clear_has_shopid();
}
inline ::google::protobuf::uint32 GiftData::shopid() const {
  // @@protoc_insertion_point(field_get:fgame.GiftData.ShopId)
  return shopid_;
}
inline void GiftData::set_shopid(::google::protobuf::uint32 value) {
  set_has_shopid();
  shopid_ = value;
  // @@protoc_insertion_point(field_set:fgame.GiftData.ShopId)
}

// required uint32 GiftId = 2;
inline bool GiftData::has_giftid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GiftData::set_has_giftid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GiftData::clear_has_giftid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GiftData::clear_giftid() {
  giftid_ = 0u;
  clear_has_giftid();
}
inline ::google::protobuf::uint32 GiftData::giftid() const {
  // @@protoc_insertion_point(field_get:fgame.GiftData.GiftId)
  return giftid_;
}
inline void GiftData::set_giftid(::google::protobuf::uint32 value) {
  set_has_giftid();
  giftid_ = value;
  // @@protoc_insertion_point(field_set:fgame.GiftData.GiftId)
}

// required uint32 StartTime = 3;
inline bool GiftData::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GiftData::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GiftData::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GiftData::clear_starttime() {
  starttime_ = 0u;
  clear_has_starttime();
}
inline ::google::protobuf::uint32 GiftData::starttime() const {
  // @@protoc_insertion_point(field_get:fgame.GiftData.StartTime)
  return starttime_;
}
inline void GiftData::set_starttime(::google::protobuf::uint32 value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:fgame.GiftData.StartTime)
}

// required uint32 EndTime = 4;
inline bool GiftData::has_endtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GiftData::set_has_endtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GiftData::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GiftData::clear_endtime() {
  endtime_ = 0u;
  clear_has_endtime();
}
inline ::google::protobuf::uint32 GiftData::endtime() const {
  // @@protoc_insertion_point(field_get:fgame.GiftData.EndTime)
  return endtime_;
}
inline void GiftData::set_endtime(::google::protobuf::uint32 value) {
  set_has_endtime();
  endtime_ = value;
  // @@protoc_insertion_point(field_set:fgame.GiftData.EndTime)
}

// required uint32 LeftCount = 5;
inline bool GiftData::has_leftcount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GiftData::set_has_leftcount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GiftData::clear_has_leftcount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GiftData::clear_leftcount() {
  leftcount_ = 0u;
  clear_has_leftcount();
}
inline ::google::protobuf::uint32 GiftData::leftcount() const {
  // @@protoc_insertion_point(field_get:fgame.GiftData.LeftCount)
  return leftcount_;
}
inline void GiftData::set_leftcount(::google::protobuf::uint32 value) {
  set_has_leftcount();
  leftcount_ = value;
  // @@protoc_insertion_point(field_set:fgame.GiftData.LeftCount)
}

// required string GiftName = 6;
inline bool GiftData::has_giftname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GiftData::set_has_giftname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GiftData::clear_has_giftname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GiftData::clear_giftname() {
  if (giftname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    giftname_->clear();
  }
  clear_has_giftname();
}
inline const ::std::string& GiftData::giftname() const {
  // @@protoc_insertion_point(field_get:fgame.GiftData.GiftName)
  return *giftname_;
}
inline void GiftData::set_giftname(const ::std::string& value) {
  set_has_giftname();
  if (giftname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    giftname_ = new ::std::string;
  }
  giftname_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.GiftData.GiftName)
}
inline void GiftData::set_giftname(const char* value) {
  set_has_giftname();
  if (giftname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    giftname_ = new ::std::string;
  }
  giftname_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.GiftData.GiftName)
}
inline void GiftData::set_giftname(const char* value, size_t size) {
  set_has_giftname();
  if (giftname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    giftname_ = new ::std::string;
  }
  giftname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.GiftData.GiftName)
}
inline ::std::string* GiftData::mutable_giftname() {
  set_has_giftname();
  if (giftname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    giftname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.GiftData.GiftName)
  return giftname_;
}
inline ::std::string* GiftData::release_giftname() {
  clear_has_giftname();
  if (giftname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = giftname_;
    giftname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GiftData::set_allocated_giftname(::std::string* giftname) {
  if (giftname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete giftname_;
  }
  if (giftname) {
    set_has_giftname();
    giftname_ = giftname;
  } else {
    clear_has_giftname();
    giftname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.GiftData.GiftName)
}

// optional string Discount = 7;
inline bool GiftData::has_discount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GiftData::set_has_discount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GiftData::clear_has_discount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GiftData::clear_discount() {
  if (discount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    discount_->clear();
  }
  clear_has_discount();
}
inline const ::std::string& GiftData::discount() const {
  // @@protoc_insertion_point(field_get:fgame.GiftData.Discount)
  return *discount_;
}
inline void GiftData::set_discount(const ::std::string& value) {
  set_has_discount();
  if (discount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    discount_ = new ::std::string;
  }
  discount_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.GiftData.Discount)
}
inline void GiftData::set_discount(const char* value) {
  set_has_discount();
  if (discount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    discount_ = new ::std::string;
  }
  discount_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.GiftData.Discount)
}
inline void GiftData::set_discount(const char* value, size_t size) {
  set_has_discount();
  if (discount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    discount_ = new ::std::string;
  }
  discount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.GiftData.Discount)
}
inline ::std::string* GiftData::mutable_discount() {
  set_has_discount();
  if (discount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    discount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.GiftData.Discount)
  return discount_;
}
inline ::std::string* GiftData::release_discount() {
  clear_has_discount();
  if (discount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = discount_;
    discount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GiftData::set_allocated_discount(::std::string* discount) {
  if (discount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete discount_;
  }
  if (discount) {
    set_has_discount();
    discount_ = discount;
  } else {
    clear_has_discount();
    discount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.GiftData.Discount)
}

// optional uint32 Price = 8;
inline bool GiftData::has_price() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GiftData::set_has_price() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GiftData::clear_has_price() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GiftData::clear_price() {
  price_ = 0u;
  clear_has_price();
}
inline ::google::protobuf::uint32 GiftData::price() const {
  // @@protoc_insertion_point(field_get:fgame.GiftData.Price)
  return price_;
}
inline void GiftData::set_price(::google::protobuf::uint32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:fgame.GiftData.Price)
}

// required string GiftIcon = 9;
inline bool GiftData::has_gifticon() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GiftData::set_has_gifticon() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GiftData::clear_has_gifticon() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GiftData::clear_gifticon() {
  if (gifticon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gifticon_->clear();
  }
  clear_has_gifticon();
}
inline const ::std::string& GiftData::gifticon() const {
  // @@protoc_insertion_point(field_get:fgame.GiftData.GiftIcon)
  return *gifticon_;
}
inline void GiftData::set_gifticon(const ::std::string& value) {
  set_has_gifticon();
  if (gifticon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gifticon_ = new ::std::string;
  }
  gifticon_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.GiftData.GiftIcon)
}
inline void GiftData::set_gifticon(const char* value) {
  set_has_gifticon();
  if (gifticon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gifticon_ = new ::std::string;
  }
  gifticon_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.GiftData.GiftIcon)
}
inline void GiftData::set_gifticon(const char* value, size_t size) {
  set_has_gifticon();
  if (gifticon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gifticon_ = new ::std::string;
  }
  gifticon_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.GiftData.GiftIcon)
}
inline ::std::string* GiftData::mutable_gifticon() {
  set_has_gifticon();
  if (gifticon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gifticon_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.GiftData.GiftIcon)
  return gifticon_;
}
inline ::std::string* GiftData::release_gifticon() {
  clear_has_gifticon();
  if (gifticon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gifticon_;
    gifticon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GiftData::set_allocated_gifticon(::std::string* gifticon) {
  if (gifticon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gifticon_;
  }
  if (gifticon) {
    set_has_gifticon();
    gifticon_ = gifticon;
  } else {
    clear_has_gifticon();
    gifticon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.GiftData.GiftIcon)
}

// -------------------------------------------------------------------

// CSShopListResp

// repeated .fgame.DiamondData diamondList = 1;
inline int CSShopListResp::diamondlist_size() const {
  return diamondlist_.size();
}
inline void CSShopListResp::clear_diamondlist() {
  diamondlist_.Clear();
}
inline const ::fgame::DiamondData& CSShopListResp::diamondlist(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSShopListResp.diamondList)
  return diamondlist_.Get(index);
}
inline ::fgame::DiamondData* CSShopListResp::mutable_diamondlist(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSShopListResp.diamondList)
  return diamondlist_.Mutable(index);
}
inline ::fgame::DiamondData* CSShopListResp::add_diamondlist() {
  // @@protoc_insertion_point(field_add:fgame.CSShopListResp.diamondList)
  return diamondlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::DiamondData >&
CSShopListResp::diamondlist() const {
  // @@protoc_insertion_point(field_list:fgame.CSShopListResp.diamondList)
  return diamondlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::DiamondData >*
CSShopListResp::mutable_diamondlist() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSShopListResp.diamondList)
  return &diamondlist_;
}

// repeated .fgame.GiftData giftList = 2;
inline int CSShopListResp::giftlist_size() const {
  return giftlist_.size();
}
inline void CSShopListResp::clear_giftlist() {
  giftlist_.Clear();
}
inline const ::fgame::GiftData& CSShopListResp::giftlist(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSShopListResp.giftList)
  return giftlist_.Get(index);
}
inline ::fgame::GiftData* CSShopListResp::mutable_giftlist(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSShopListResp.giftList)
  return giftlist_.Mutable(index);
}
inline ::fgame::GiftData* CSShopListResp::add_giftlist() {
  // @@protoc_insertion_point(field_add:fgame.CSShopListResp.giftList)
  return giftlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::GiftData >&
CSShopListResp::giftlist() const {
  // @@protoc_insertion_point(field_list:fgame.CSShopListResp.giftList)
  return giftlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::GiftData >*
CSShopListResp::mutable_giftlist() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSShopListResp.giftList)
  return &giftlist_;
}

// -------------------------------------------------------------------

// ExchangeItemInfo

// required uint32 ItemId = 1;
inline bool ExchangeItemInfo::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExchangeItemInfo::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExchangeItemInfo::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExchangeItemInfo::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 ExchangeItemInfo::itemid() const {
  // @@protoc_insertion_point(field_get:fgame.ExchangeItemInfo.ItemId)
  return itemid_;
}
inline void ExchangeItemInfo::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:fgame.ExchangeItemInfo.ItemId)
}

// required uint32 BuyLeftCount = 2;
inline bool ExchangeItemInfo::has_buyleftcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExchangeItemInfo::set_has_buyleftcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExchangeItemInfo::clear_has_buyleftcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExchangeItemInfo::clear_buyleftcount() {
  buyleftcount_ = 0u;
  clear_has_buyleftcount();
}
inline ::google::protobuf::uint32 ExchangeItemInfo::buyleftcount() const {
  // @@protoc_insertion_point(field_get:fgame.ExchangeItemInfo.BuyLeftCount)
  return buyleftcount_;
}
inline void ExchangeItemInfo::set_buyleftcount(::google::protobuf::uint32 value) {
  set_has_buyleftcount();
  buyleftcount_ = value;
  // @@protoc_insertion_point(field_set:fgame.ExchangeItemInfo.BuyLeftCount)
}

// required uint32 RefreshTime = 3;
inline bool ExchangeItemInfo::has_refreshtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExchangeItemInfo::set_has_refreshtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExchangeItemInfo::clear_has_refreshtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExchangeItemInfo::clear_refreshtime() {
  refreshtime_ = 0u;
  clear_has_refreshtime();
}
inline ::google::protobuf::uint32 ExchangeItemInfo::refreshtime() const {
  // @@protoc_insertion_point(field_get:fgame.ExchangeItemInfo.RefreshTime)
  return refreshtime_;
}
inline void ExchangeItemInfo::set_refreshtime(::google::protobuf::uint32 value) {
  set_has_refreshtime();
  refreshtime_ = value;
  // @@protoc_insertion_point(field_set:fgame.ExchangeItemInfo.RefreshTime)
}

// -------------------------------------------------------------------

// CSExchangeItemReq

// required uint32 ItemId = 1;
inline bool CSExchangeItemReq::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSExchangeItemReq::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSExchangeItemReq::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSExchangeItemReq::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 CSExchangeItemReq::itemid() const {
  // @@protoc_insertion_point(field_get:fgame.CSExchangeItemReq.ItemId)
  return itemid_;
}
inline void CSExchangeItemReq::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSExchangeItemReq.ItemId)
}

// -------------------------------------------------------------------

// CSExchangeItemResp

// required .fgame.ExchangeItemInfo ExchangeItem = 1;
inline bool CSExchangeItemResp::has_exchangeitem() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSExchangeItemResp::set_has_exchangeitem() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSExchangeItemResp::clear_has_exchangeitem() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSExchangeItemResp::clear_exchangeitem() {
  if (exchangeitem_ != NULL) exchangeitem_->::fgame::ExchangeItemInfo::Clear();
  clear_has_exchangeitem();
}
inline const ::fgame::ExchangeItemInfo& CSExchangeItemResp::exchangeitem() const {
  // @@protoc_insertion_point(field_get:fgame.CSExchangeItemResp.ExchangeItem)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return exchangeitem_ != NULL ? *exchangeitem_ : *default_instance().exchangeitem_;
#else
  return exchangeitem_ != NULL ? *exchangeitem_ : *default_instance_->exchangeitem_;
#endif
}
inline ::fgame::ExchangeItemInfo* CSExchangeItemResp::mutable_exchangeitem() {
  set_has_exchangeitem();
  if (exchangeitem_ == NULL) exchangeitem_ = new ::fgame::ExchangeItemInfo;
  // @@protoc_insertion_point(field_mutable:fgame.CSExchangeItemResp.ExchangeItem)
  return exchangeitem_;
}
inline ::fgame::ExchangeItemInfo* CSExchangeItemResp::release_exchangeitem() {
  clear_has_exchangeitem();
  ::fgame::ExchangeItemInfo* temp = exchangeitem_;
  exchangeitem_ = NULL;
  return temp;
}
inline void CSExchangeItemResp::set_allocated_exchangeitem(::fgame::ExchangeItemInfo* exchangeitem) {
  delete exchangeitem_;
  exchangeitem_ = exchangeitem;
  if (exchangeitem) {
    set_has_exchangeitem();
  } else {
    clear_has_exchangeitem();
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSExchangeItemResp.ExchangeItem)
}

// required uint32 HonorCount = 2;
inline bool CSExchangeItemResp::has_honorcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSExchangeItemResp::set_has_honorcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSExchangeItemResp::clear_has_honorcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSExchangeItemResp::clear_honorcount() {
  honorcount_ = 0u;
  clear_has_honorcount();
}
inline ::google::protobuf::uint32 CSExchangeItemResp::honorcount() const {
  // @@protoc_insertion_point(field_get:fgame.CSExchangeItemResp.HonorCount)
  return honorcount_;
}
inline void CSExchangeItemResp::set_honorcount(::google::protobuf::uint32 value) {
  set_has_honorcount();
  honorcount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSExchangeItemResp.HonorCount)
}

// required uint32 Ret = 3;
inline bool CSExchangeItemResp::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSExchangeItemResp::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSExchangeItemResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSExchangeItemResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSExchangeItemResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSExchangeItemResp.Ret)
  return ret_;
}
inline void CSExchangeItemResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSExchangeItemResp.Ret)
}

// -------------------------------------------------------------------

// CSUpdateExchangeListReq

// -------------------------------------------------------------------

// CSUpdateExchangeListResp

// repeated .fgame.ExchangeItemInfo ExchangeItem = 1;
inline int CSUpdateExchangeListResp::exchangeitem_size() const {
  return exchangeitem_.size();
}
inline void CSUpdateExchangeListResp::clear_exchangeitem() {
  exchangeitem_.Clear();
}
inline const ::fgame::ExchangeItemInfo& CSUpdateExchangeListResp::exchangeitem(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSUpdateExchangeListResp.ExchangeItem)
  return exchangeitem_.Get(index);
}
inline ::fgame::ExchangeItemInfo* CSUpdateExchangeListResp::mutable_exchangeitem(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSUpdateExchangeListResp.ExchangeItem)
  return exchangeitem_.Mutable(index);
}
inline ::fgame::ExchangeItemInfo* CSUpdateExchangeListResp::add_exchangeitem() {
  // @@protoc_insertion_point(field_add:fgame.CSUpdateExchangeListResp.ExchangeItem)
  return exchangeitem_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::ExchangeItemInfo >&
CSUpdateExchangeListResp::exchangeitem() const {
  // @@protoc_insertion_point(field_list:fgame.CSUpdateExchangeListResp.ExchangeItem)
  return exchangeitem_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::ExchangeItemInfo >*
CSUpdateExchangeListResp::mutable_exchangeitem() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSUpdateExchangeListResp.ExchangeItem)
  return &exchangeitem_;
}

// required uint32 HonorCount = 2;
inline bool CSUpdateExchangeListResp::has_honorcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSUpdateExchangeListResp::set_has_honorcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSUpdateExchangeListResp::clear_has_honorcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSUpdateExchangeListResp::clear_honorcount() {
  honorcount_ = 0u;
  clear_has_honorcount();
}
inline ::google::protobuf::uint32 CSUpdateExchangeListResp::honorcount() const {
  // @@protoc_insertion_point(field_get:fgame.CSUpdateExchangeListResp.HonorCount)
  return honorcount_;
}
inline void CSUpdateExchangeListResp::set_honorcount(::google::protobuf::uint32 value) {
  set_has_honorcount();
  honorcount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSUpdateExchangeListResp.HonorCount)
}

// -------------------------------------------------------------------

// CSChangePlayerIconReq

// required string IconId = 1;
inline bool CSChangePlayerIconReq::has_iconid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChangePlayerIconReq::set_has_iconid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChangePlayerIconReq::clear_has_iconid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChangePlayerIconReq::clear_iconid() {
  if (iconid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iconid_->clear();
  }
  clear_has_iconid();
}
inline const ::std::string& CSChangePlayerIconReq::iconid() const {
  // @@protoc_insertion_point(field_get:fgame.CSChangePlayerIconReq.IconId)
  return *iconid_;
}
inline void CSChangePlayerIconReq::set_iconid(const ::std::string& value) {
  set_has_iconid();
  if (iconid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iconid_ = new ::std::string;
  }
  iconid_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSChangePlayerIconReq.IconId)
}
inline void CSChangePlayerIconReq::set_iconid(const char* value) {
  set_has_iconid();
  if (iconid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iconid_ = new ::std::string;
  }
  iconid_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSChangePlayerIconReq.IconId)
}
inline void CSChangePlayerIconReq::set_iconid(const char* value, size_t size) {
  set_has_iconid();
  if (iconid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iconid_ = new ::std::string;
  }
  iconid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSChangePlayerIconReq.IconId)
}
inline ::std::string* CSChangePlayerIconReq::mutable_iconid() {
  set_has_iconid();
  if (iconid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iconid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSChangePlayerIconReq.IconId)
  return iconid_;
}
inline ::std::string* CSChangePlayerIconReq::release_iconid() {
  clear_has_iconid();
  if (iconid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = iconid_;
    iconid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSChangePlayerIconReq::set_allocated_iconid(::std::string* iconid) {
  if (iconid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete iconid_;
  }
  if (iconid) {
    set_has_iconid();
    iconid_ = iconid;
  } else {
    clear_has_iconid();
    iconid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSChangePlayerIconReq.IconId)
}

// -------------------------------------------------------------------

// CSChangePlayerIconResp

// required uint32 Ret = 1;
inline bool CSChangePlayerIconResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChangePlayerIconResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChangePlayerIconResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChangePlayerIconResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSChangePlayerIconResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSChangePlayerIconResp.Ret)
  return ret_;
}
inline void CSChangePlayerIconResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSChangePlayerIconResp.Ret)
}

// required string IconId = 2;
inline bool CSChangePlayerIconResp::has_iconid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSChangePlayerIconResp::set_has_iconid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSChangePlayerIconResp::clear_has_iconid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSChangePlayerIconResp::clear_iconid() {
  if (iconid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iconid_->clear();
  }
  clear_has_iconid();
}
inline const ::std::string& CSChangePlayerIconResp::iconid() const {
  // @@protoc_insertion_point(field_get:fgame.CSChangePlayerIconResp.IconId)
  return *iconid_;
}
inline void CSChangePlayerIconResp::set_iconid(const ::std::string& value) {
  set_has_iconid();
  if (iconid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iconid_ = new ::std::string;
  }
  iconid_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSChangePlayerIconResp.IconId)
}
inline void CSChangePlayerIconResp::set_iconid(const char* value) {
  set_has_iconid();
  if (iconid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iconid_ = new ::std::string;
  }
  iconid_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSChangePlayerIconResp.IconId)
}
inline void CSChangePlayerIconResp::set_iconid(const char* value, size_t size) {
  set_has_iconid();
  if (iconid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iconid_ = new ::std::string;
  }
  iconid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSChangePlayerIconResp.IconId)
}
inline ::std::string* CSChangePlayerIconResp::mutable_iconid() {
  set_has_iconid();
  if (iconid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iconid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSChangePlayerIconResp.IconId)
  return iconid_;
}
inline ::std::string* CSChangePlayerIconResp::release_iconid() {
  clear_has_iconid();
  if (iconid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = iconid_;
    iconid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSChangePlayerIconResp::set_allocated_iconid(::std::string* iconid) {
  if (iconid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete iconid_;
  }
  if (iconid) {
    set_has_iconid();
    iconid_ = iconid;
  } else {
    clear_has_iconid();
    iconid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSChangePlayerIconResp.IconId)
}

// -------------------------------------------------------------------

// CSSetNewBieReq

// repeated uint32 NewBieId = 1;
inline int CSSetNewBieReq::newbieid_size() const {
  return newbieid_.size();
}
inline void CSSetNewBieReq::clear_newbieid() {
  newbieid_.Clear();
}
inline ::google::protobuf::uint32 CSSetNewBieReq::newbieid(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSSetNewBieReq.NewBieId)
  return newbieid_.Get(index);
}
inline void CSSetNewBieReq::set_newbieid(int index, ::google::protobuf::uint32 value) {
  newbieid_.Set(index, value);
  // @@protoc_insertion_point(field_set:fgame.CSSetNewBieReq.NewBieId)
}
inline void CSSetNewBieReq::add_newbieid(::google::protobuf::uint32 value) {
  newbieid_.Add(value);
  // @@protoc_insertion_point(field_add:fgame.CSSetNewBieReq.NewBieId)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSSetNewBieReq::newbieid() const {
  // @@protoc_insertion_point(field_list:fgame.CSSetNewBieReq.NewBieId)
  return newbieid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSSetNewBieReq::mutable_newbieid() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSSetNewBieReq.NewBieId)
  return &newbieid_;
}

// optional bool isComplete = 2;
inline bool CSSetNewBieReq::has_iscomplete() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSSetNewBieReq::set_has_iscomplete() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSSetNewBieReq::clear_has_iscomplete() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSSetNewBieReq::clear_iscomplete() {
  iscomplete_ = false;
  clear_has_iscomplete();
}
inline bool CSSetNewBieReq::iscomplete() const {
  // @@protoc_insertion_point(field_get:fgame.CSSetNewBieReq.isComplete)
  return iscomplete_;
}
inline void CSSetNewBieReq::set_iscomplete(bool value) {
  set_has_iscomplete();
  iscomplete_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSetNewBieReq.isComplete)
}

// -------------------------------------------------------------------

// CSSetNewBieResp

// -------------------------------------------------------------------

// CSGetNewBieListReq

// -------------------------------------------------------------------

// CSGetNewBieListResp

// required bool isComplete = 1;
inline bool CSGetNewBieListResp::has_iscomplete() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGetNewBieListResp::set_has_iscomplete() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGetNewBieListResp::clear_has_iscomplete() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGetNewBieListResp::clear_iscomplete() {
  iscomplete_ = false;
  clear_has_iscomplete();
}
inline bool CSGetNewBieListResp::iscomplete() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetNewBieListResp.isComplete)
  return iscomplete_;
}
inline void CSGetNewBieListResp::set_iscomplete(bool value) {
  set_has_iscomplete();
  iscomplete_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetNewBieListResp.isComplete)
}

// repeated uint32 NewBieIds = 2;
inline int CSGetNewBieListResp::newbieids_size() const {
  return newbieids_.size();
}
inline void CSGetNewBieListResp::clear_newbieids() {
  newbieids_.Clear();
}
inline ::google::protobuf::uint32 CSGetNewBieListResp::newbieids(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSGetNewBieListResp.NewBieIds)
  return newbieids_.Get(index);
}
inline void CSGetNewBieListResp::set_newbieids(int index, ::google::protobuf::uint32 value) {
  newbieids_.Set(index, value);
  // @@protoc_insertion_point(field_set:fgame.CSGetNewBieListResp.NewBieIds)
}
inline void CSGetNewBieListResp::add_newbieids(::google::protobuf::uint32 value) {
  newbieids_.Add(value);
  // @@protoc_insertion_point(field_add:fgame.CSGetNewBieListResp.NewBieIds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSGetNewBieListResp::newbieids() const {
  // @@protoc_insertion_point(field_list:fgame.CSGetNewBieListResp.NewBieIds)
  return newbieids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSGetNewBieListResp::mutable_newbieids() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSGetNewBieListResp.NewBieIds)
  return &newbieids_;
}

// -------------------------------------------------------------------

// CSSetNewBieOssReq

// required uint32 NewBieId = 1;
inline bool CSSetNewBieOssReq::has_newbieid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSetNewBieOssReq::set_has_newbieid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSetNewBieOssReq::clear_has_newbieid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSetNewBieOssReq::clear_newbieid() {
  newbieid_ = 0u;
  clear_has_newbieid();
}
inline ::google::protobuf::uint32 CSSetNewBieOssReq::newbieid() const {
  // @@protoc_insertion_point(field_get:fgame.CSSetNewBieOssReq.NewBieId)
  return newbieid_;
}
inline void CSSetNewBieOssReq::set_newbieid(::google::protobuf::uint32 value) {
  set_has_newbieid();
  newbieid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSetNewBieOssReq.NewBieId)
}

// -------------------------------------------------------------------

// CSSetNewBieOssResp

// required uint32 NewBieId = 1;
inline bool CSSetNewBieOssResp::has_newbieid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSetNewBieOssResp::set_has_newbieid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSetNewBieOssResp::clear_has_newbieid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSetNewBieOssResp::clear_newbieid() {
  newbieid_ = 0u;
  clear_has_newbieid();
}
inline ::google::protobuf::uint32 CSSetNewBieOssResp::newbieid() const {
  // @@protoc_insertion_point(field_get:fgame.CSSetNewBieOssResp.NewBieId)
  return newbieid_;
}
inline void CSSetNewBieOssResp::set_newbieid(::google::protobuf::uint32 value) {
  set_has_newbieid();
  newbieid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSetNewBieOssResp.NewBieId)
}

// -------------------------------------------------------------------

// CSOpenBigStageReq

// required uint32 PointId = 1;
inline bool CSOpenBigStageReq::has_pointid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSOpenBigStageReq::set_has_pointid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSOpenBigStageReq::clear_has_pointid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSOpenBigStageReq::clear_pointid() {
  pointid_ = 0u;
  clear_has_pointid();
}
inline ::google::protobuf::uint32 CSOpenBigStageReq::pointid() const {
  // @@protoc_insertion_point(field_get:fgame.CSOpenBigStageReq.PointId)
  return pointid_;
}
inline void CSOpenBigStageReq::set_pointid(::google::protobuf::uint32 value) {
  set_has_pointid();
  pointid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSOpenBigStageReq.PointId)
}

// -------------------------------------------------------------------

// CSOpenBigStageResp

// required uint32 Ret = 1;
inline bool CSOpenBigStageResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSOpenBigStageResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSOpenBigStageResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSOpenBigStageResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSOpenBigStageResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSOpenBigStageResp.Ret)
  return ret_;
}
inline void CSOpenBigStageResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSOpenBigStageResp.Ret)
}

// required uint32 PointId = 2;
inline bool CSOpenBigStageResp::has_pointid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSOpenBigStageResp::set_has_pointid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSOpenBigStageResp::clear_has_pointid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSOpenBigStageResp::clear_pointid() {
  pointid_ = 0u;
  clear_has_pointid();
}
inline ::google::protobuf::uint32 CSOpenBigStageResp::pointid() const {
  // @@protoc_insertion_point(field_get:fgame.CSOpenBigStageResp.PointId)
  return pointid_;
}
inline void CSOpenBigStageResp::set_pointid(::google::protobuf::uint32 value) {
  set_has_pointid();
  pointid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSOpenBigStageResp.PointId)
}

// -------------------------------------------------------------------

// CSEnterPointReq

// required uint32 PointId = 1;
inline bool CSEnterPointReq::has_pointid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEnterPointReq::set_has_pointid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEnterPointReq::clear_has_pointid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEnterPointReq::clear_pointid() {
  pointid_ = 0u;
  clear_has_pointid();
}
inline ::google::protobuf::uint32 CSEnterPointReq::pointid() const {
  // @@protoc_insertion_point(field_get:fgame.CSEnterPointReq.PointId)
  return pointid_;
}
inline void CSEnterPointReq::set_pointid(::google::protobuf::uint32 value) {
  set_has_pointid();
  pointid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSEnterPointReq.PointId)
}

// -------------------------------------------------------------------

// CSEnterPointResp

// required uint32 PointId = 1;
inline bool CSEnterPointResp::has_pointid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEnterPointResp::set_has_pointid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEnterPointResp::clear_has_pointid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEnterPointResp::clear_pointid() {
  pointid_ = 0u;
  clear_has_pointid();
}
inline ::google::protobuf::uint32 CSEnterPointResp::pointid() const {
  // @@protoc_insertion_point(field_get:fgame.CSEnterPointResp.PointId)
  return pointid_;
}
inline void CSEnterPointResp::set_pointid(::google::protobuf::uint32 value) {
  set_has_pointid();
  pointid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSEnterPointResp.PointId)
}

// required bool Ret = 2;
inline bool CSEnterPointResp::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEnterPointResp::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEnterPointResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEnterPointResp::clear_ret() {
  ret_ = false;
  clear_has_ret();
}
inline bool CSEnterPointResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSEnterPointResp.Ret)
  return ret_;
}
inline void CSEnterPointResp::set_ret(bool value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSEnterPointResp.Ret)
}

// -------------------------------------------------------------------

// CSBuyITtemReq

// required uint32 ItemId = 1;
inline bool CSBuyITtemReq::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyITtemReq::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyITtemReq::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyITtemReq::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 CSBuyITtemReq::itemid() const {
  // @@protoc_insertion_point(field_get:fgame.CSBuyITtemReq.ItemId)
  return itemid_;
}
inline void CSBuyITtemReq::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSBuyITtemReq.ItemId)
}

// required uint32 Price = 2;
inline bool CSBuyITtemReq::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBuyITtemReq::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBuyITtemReq::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBuyITtemReq::clear_price() {
  price_ = 0u;
  clear_has_price();
}
inline ::google::protobuf::uint32 CSBuyITtemReq::price() const {
  // @@protoc_insertion_point(field_get:fgame.CSBuyITtemReq.Price)
  return price_;
}
inline void CSBuyITtemReq::set_price(::google::protobuf::uint32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSBuyITtemReq.Price)
}

// required uint32 Count = 3;
inline bool CSBuyITtemReq::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBuyITtemReq::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBuyITtemReq::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBuyITtemReq::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CSBuyITtemReq::count() const {
  // @@protoc_insertion_point(field_get:fgame.CSBuyITtemReq.Count)
  return count_;
}
inline void CSBuyITtemReq::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSBuyITtemReq.Count)
}

// required uint32 From = 4;
inline bool CSBuyITtemReq::has_from() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSBuyITtemReq::set_has_from() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSBuyITtemReq::clear_has_from() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSBuyITtemReq::clear_from() {
  from_ = 0u;
  clear_has_from();
}
inline ::google::protobuf::uint32 CSBuyITtemReq::from() const {
  // @@protoc_insertion_point(field_get:fgame.CSBuyITtemReq.From)
  return from_;
}
inline void CSBuyITtemReq::set_from(::google::protobuf::uint32 value) {
  set_has_from();
  from_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSBuyITtemReq.From)
}

// -------------------------------------------------------------------

// CSBuyItemResp

// required uint32 Ret = 1;
inline bool CSBuyItemResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyItemResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyItemResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyItemResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSBuyItemResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSBuyItemResp.Ret)
  return ret_;
}
inline void CSBuyItemResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSBuyItemResp.Ret)
}

// required uint32 ItemId = 2;
inline bool CSBuyItemResp::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBuyItemResp::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBuyItemResp::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBuyItemResp::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 CSBuyItemResp::itemid() const {
  // @@protoc_insertion_point(field_get:fgame.CSBuyItemResp.ItemId)
  return itemid_;
}
inline void CSBuyItemResp::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSBuyItemResp.ItemId)
}

// required uint32 Count = 3;
inline bool CSBuyItemResp::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBuyItemResp::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBuyItemResp::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBuyItemResp::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CSBuyItemResp::count() const {
  // @@protoc_insertion_point(field_get:fgame.CSBuyItemResp.Count)
  return count_;
}
inline void CSBuyItemResp::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSBuyItemResp.Count)
}

// required uint32 Price = 4;
inline bool CSBuyItemResp::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSBuyItemResp::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSBuyItemResp::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSBuyItemResp::clear_price() {
  price_ = 0u;
  clear_has_price();
}
inline ::google::protobuf::uint32 CSBuyItemResp::price() const {
  // @@protoc_insertion_point(field_get:fgame.CSBuyItemResp.Price)
  return price_;
}
inline void CSBuyItemResp::set_price(::google::protobuf::uint32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSBuyItemResp.Price)
}

// -------------------------------------------------------------------

// CSUseItemReq

// required uint32 ItemId = 1;
inline bool CSUseItemReq::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSUseItemReq::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSUseItemReq::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSUseItemReq::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 CSUseItemReq::itemid() const {
  // @@protoc_insertion_point(field_get:fgame.CSUseItemReq.ItemId)
  return itemid_;
}
inline void CSUseItemReq::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSUseItemReq.ItemId)
}

// required uint32 Count = 2;
inline bool CSUseItemReq::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSUseItemReq::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSUseItemReq::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSUseItemReq::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CSUseItemReq::count() const {
  // @@protoc_insertion_point(field_get:fgame.CSUseItemReq.Count)
  return count_;
}
inline void CSUseItemReq::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSUseItemReq.Count)
}

// -------------------------------------------------------------------

// CSUseItemResp

// required uint32 Ret = 1;
inline bool CSUseItemResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSUseItemResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSUseItemResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSUseItemResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSUseItemResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSUseItemResp.Ret)
  return ret_;
}
inline void CSUseItemResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSUseItemResp.Ret)
}

// required uint32 ItemId = 2;
inline bool CSUseItemResp::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSUseItemResp::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSUseItemResp::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSUseItemResp::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 CSUseItemResp::itemid() const {
  // @@protoc_insertion_point(field_get:fgame.CSUseItemResp.ItemId)
  return itemid_;
}
inline void CSUseItemResp::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSUseItemResp.ItemId)
}

// -------------------------------------------------------------------

// CSBuyVipReq

// required uint32 VipLevel = 1;
inline bool CSBuyVipReq::has_viplevel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyVipReq::set_has_viplevel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyVipReq::clear_has_viplevel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyVipReq::clear_viplevel() {
  viplevel_ = 0u;
  clear_has_viplevel();
}
inline ::google::protobuf::uint32 CSBuyVipReq::viplevel() const {
  // @@protoc_insertion_point(field_get:fgame.CSBuyVipReq.VipLevel)
  return viplevel_;
}
inline void CSBuyVipReq::set_viplevel(::google::protobuf::uint32 value) {
  set_has_viplevel();
  viplevel_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSBuyVipReq.VipLevel)
}

// required uint32 Price = 2;
inline bool CSBuyVipReq::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBuyVipReq::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBuyVipReq::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBuyVipReq::clear_price() {
  price_ = 0u;
  clear_has_price();
}
inline ::google::protobuf::uint32 CSBuyVipReq::price() const {
  // @@protoc_insertion_point(field_get:fgame.CSBuyVipReq.Price)
  return price_;
}
inline void CSBuyVipReq::set_price(::google::protobuf::uint32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSBuyVipReq.Price)
}

// required uint32 Payment = 3;
inline bool CSBuyVipReq::has_payment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBuyVipReq::set_has_payment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBuyVipReq::clear_has_payment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBuyVipReq::clear_payment() {
  payment_ = 0u;
  clear_has_payment();
}
inline ::google::protobuf::uint32 CSBuyVipReq::payment() const {
  // @@protoc_insertion_point(field_get:fgame.CSBuyVipReq.Payment)
  return payment_;
}
inline void CSBuyVipReq::set_payment(::google::protobuf::uint32 value) {
  set_has_payment();
  payment_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSBuyVipReq.Payment)
}

// required uint32 TimeType = 4;
inline bool CSBuyVipReq::has_timetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSBuyVipReq::set_has_timetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSBuyVipReq::clear_has_timetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSBuyVipReq::clear_timetype() {
  timetype_ = 0u;
  clear_has_timetype();
}
inline ::google::protobuf::uint32 CSBuyVipReq::timetype() const {
  // @@protoc_insertion_point(field_get:fgame.CSBuyVipReq.TimeType)
  return timetype_;
}
inline void CSBuyVipReq::set_timetype(::google::protobuf::uint32 value) {
  set_has_timetype();
  timetype_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSBuyVipReq.TimeType)
}

// -------------------------------------------------------------------

// CSVipTimeReq

// -------------------------------------------------------------------

// CSBuyVipResp

// optional uint32 VipLevel = 1;
inline bool CSBuyVipResp::has_viplevel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyVipResp::set_has_viplevel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyVipResp::clear_has_viplevel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyVipResp::clear_viplevel() {
  viplevel_ = 0u;
  clear_has_viplevel();
}
inline ::google::protobuf::uint32 CSBuyVipResp::viplevel() const {
  // @@protoc_insertion_point(field_get:fgame.CSBuyVipResp.VipLevel)
  return viplevel_;
}
inline void CSBuyVipResp::set_viplevel(::google::protobuf::uint32 value) {
  set_has_viplevel();
  viplevel_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSBuyVipResp.VipLevel)
}

// optional string RemainTime = 2;
inline bool CSBuyVipResp::has_remaintime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBuyVipResp::set_has_remaintime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBuyVipResp::clear_has_remaintime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBuyVipResp::clear_remaintime() {
  if (remaintime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remaintime_->clear();
  }
  clear_has_remaintime();
}
inline const ::std::string& CSBuyVipResp::remaintime() const {
  // @@protoc_insertion_point(field_get:fgame.CSBuyVipResp.RemainTime)
  return *remaintime_;
}
inline void CSBuyVipResp::set_remaintime(const ::std::string& value) {
  set_has_remaintime();
  if (remaintime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remaintime_ = new ::std::string;
  }
  remaintime_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSBuyVipResp.RemainTime)
}
inline void CSBuyVipResp::set_remaintime(const char* value) {
  set_has_remaintime();
  if (remaintime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remaintime_ = new ::std::string;
  }
  remaintime_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSBuyVipResp.RemainTime)
}
inline void CSBuyVipResp::set_remaintime(const char* value, size_t size) {
  set_has_remaintime();
  if (remaintime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remaintime_ = new ::std::string;
  }
  remaintime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSBuyVipResp.RemainTime)
}
inline ::std::string* CSBuyVipResp::mutable_remaintime() {
  set_has_remaintime();
  if (remaintime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remaintime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSBuyVipResp.RemainTime)
  return remaintime_;
}
inline ::std::string* CSBuyVipResp::release_remaintime() {
  clear_has_remaintime();
  if (remaintime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remaintime_;
    remaintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSBuyVipResp::set_allocated_remaintime(::std::string* remaintime) {
  if (remaintime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remaintime_;
  }
  if (remaintime) {
    set_has_remaintime();
    remaintime_ = remaintime;
  } else {
    clear_has_remaintime();
    remaintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSBuyVipResp.RemainTime)
}

// optional uint32 Type = 3;
inline bool CSBuyVipResp::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBuyVipResp::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBuyVipResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBuyVipResp::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSBuyVipResp::type() const {
  // @@protoc_insertion_point(field_get:fgame.CSBuyVipResp.Type)
  return type_;
}
inline void CSBuyVipResp::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSBuyVipResp.Type)
}

// -------------------------------------------------------------------

// CSPropertyUpdateResp

// repeated .fgame.PropertyUpdateData UpdateData = 1;
inline int CSPropertyUpdateResp::updatedata_size() const {
  return updatedata_.size();
}
inline void CSPropertyUpdateResp::clear_updatedata() {
  updatedata_.Clear();
}
inline const ::fgame::PropertyUpdateData& CSPropertyUpdateResp::updatedata(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSPropertyUpdateResp.UpdateData)
  return updatedata_.Get(index);
}
inline ::fgame::PropertyUpdateData* CSPropertyUpdateResp::mutable_updatedata(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSPropertyUpdateResp.UpdateData)
  return updatedata_.Mutable(index);
}
inline ::fgame::PropertyUpdateData* CSPropertyUpdateResp::add_updatedata() {
  // @@protoc_insertion_point(field_add:fgame.CSPropertyUpdateResp.UpdateData)
  return updatedata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >&
CSPropertyUpdateResp::updatedata() const {
  // @@protoc_insertion_point(field_list:fgame.CSPropertyUpdateResp.UpdateData)
  return updatedata_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >*
CSPropertyUpdateResp::mutable_updatedata() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSPropertyUpdateResp.UpdateData)
  return &updatedata_;
}

// -------------------------------------------------------------------

// CSGetAchievementReq

// -------------------------------------------------------------------

// CSGetAchievementInfo

// required uint32 Id = 1;
inline bool CSGetAchievementInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGetAchievementInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGetAchievementInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGetAchievementInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSGetAchievementInfo::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetAchievementInfo.Id)
  return id_;
}
inline void CSGetAchievementInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetAchievementInfo.Id)
}

// required uint32 Status = 2;
inline bool CSGetAchievementInfo::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGetAchievementInfo::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGetAchievementInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGetAchievementInfo::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 CSGetAchievementInfo::status() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetAchievementInfo.Status)
  return status_;
}
inline void CSGetAchievementInfo::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetAchievementInfo.Status)
}

// required uint32 ReceivePlayerCount = 3;
inline bool CSGetAchievementInfo::has_receiveplayercount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSGetAchievementInfo::set_has_receiveplayercount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSGetAchievementInfo::clear_has_receiveplayercount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSGetAchievementInfo::clear_receiveplayercount() {
  receiveplayercount_ = 0u;
  clear_has_receiveplayercount();
}
inline ::google::protobuf::uint32 CSGetAchievementInfo::receiveplayercount() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetAchievementInfo.ReceivePlayerCount)
  return receiveplayercount_;
}
inline void CSGetAchievementInfo::set_receiveplayercount(::google::protobuf::uint32 value) {
  set_has_receiveplayercount();
  receiveplayercount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetAchievementInfo.ReceivePlayerCount)
}

// optional uint64 CompleteCount = 4;
inline bool CSGetAchievementInfo::has_completecount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSGetAchievementInfo::set_has_completecount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSGetAchievementInfo::clear_has_completecount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSGetAchievementInfo::clear_completecount() {
  completecount_ = GOOGLE_ULONGLONG(0);
  clear_has_completecount();
}
inline ::google::protobuf::uint64 CSGetAchievementInfo::completecount() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetAchievementInfo.CompleteCount)
  return completecount_;
}
inline void CSGetAchievementInfo::set_completecount(::google::protobuf::uint64 value) {
  set_has_completecount();
  completecount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetAchievementInfo.CompleteCount)
}

// -------------------------------------------------------------------

// CSGetAchievementResp

// repeated .fgame.CSGetAchievementInfo Data = 1;
inline int CSGetAchievementResp::data_size() const {
  return data_.size();
}
inline void CSGetAchievementResp::clear_data() {
  data_.Clear();
}
inline const ::fgame::CSGetAchievementInfo& CSGetAchievementResp::data(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSGetAchievementResp.Data)
  return data_.Get(index);
}
inline ::fgame::CSGetAchievementInfo* CSGetAchievementResp::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSGetAchievementResp.Data)
  return data_.Mutable(index);
}
inline ::fgame::CSGetAchievementInfo* CSGetAchievementResp::add_data() {
  // @@protoc_insertion_point(field_add:fgame.CSGetAchievementResp.Data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSGetAchievementInfo >&
CSGetAchievementResp::data() const {
  // @@protoc_insertion_point(field_list:fgame.CSGetAchievementResp.Data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSGetAchievementInfo >*
CSGetAchievementResp::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSGetAchievementResp.Data)
  return &data_;
}

// required uint32 AchievementPointCount = 2;
inline bool CSGetAchievementResp::has_achievementpointcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGetAchievementResp::set_has_achievementpointcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGetAchievementResp::clear_has_achievementpointcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGetAchievementResp::clear_achievementpointcount() {
  achievementpointcount_ = 0u;
  clear_has_achievementpointcount();
}
inline ::google::protobuf::uint32 CSGetAchievementResp::achievementpointcount() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetAchievementResp.AchievementPointCount)
  return achievementpointcount_;
}
inline void CSGetAchievementResp::set_achievementpointcount(::google::protobuf::uint32 value) {
  set_has_achievementpointcount();
  achievementpointcount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetAchievementResp.AchievementPointCount)
}

// required uint32 AchievementLevel = 3;
inline bool CSGetAchievementResp::has_achievementlevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSGetAchievementResp::set_has_achievementlevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSGetAchievementResp::clear_has_achievementlevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSGetAchievementResp::clear_achievementlevel() {
  achievementlevel_ = 0u;
  clear_has_achievementlevel();
}
inline ::google::protobuf::uint32 CSGetAchievementResp::achievementlevel() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetAchievementResp.AchievementLevel)
  return achievementlevel_;
}
inline void CSGetAchievementResp::set_achievementlevel(::google::protobuf::uint32 value) {
  set_has_achievementlevel();
  achievementlevel_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetAchievementResp.AchievementLevel)
}

// -------------------------------------------------------------------

// CSReceiveAchievementReq

// required uint32 AchievementId = 1;
inline bool CSReceiveAchievementReq::has_achievementid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSReceiveAchievementReq::set_has_achievementid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSReceiveAchievementReq::clear_has_achievementid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSReceiveAchievementReq::clear_achievementid() {
  achievementid_ = 0u;
  clear_has_achievementid();
}
inline ::google::protobuf::uint32 CSReceiveAchievementReq::achievementid() const {
  // @@protoc_insertion_point(field_get:fgame.CSReceiveAchievementReq.AchievementId)
  return achievementid_;
}
inline void CSReceiveAchievementReq::set_achievementid(::google::protobuf::uint32 value) {
  set_has_achievementid();
  achievementid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSReceiveAchievementReq.AchievementId)
}

// -------------------------------------------------------------------

// CSReceiveAchievementResp

// required uint32 Ret = 1;
inline bool CSReceiveAchievementResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSReceiveAchievementResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSReceiveAchievementResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSReceiveAchievementResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSReceiveAchievementResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSReceiveAchievementResp.Ret)
  return ret_;
}
inline void CSReceiveAchievementResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSReceiveAchievementResp.Ret)
}

// required uint32 AchievementId = 2;
inline bool CSReceiveAchievementResp::has_achievementid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSReceiveAchievementResp::set_has_achievementid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSReceiveAchievementResp::clear_has_achievementid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSReceiveAchievementResp::clear_achievementid() {
  achievementid_ = 0u;
  clear_has_achievementid();
}
inline ::google::protobuf::uint32 CSReceiveAchievementResp::achievementid() const {
  // @@protoc_insertion_point(field_get:fgame.CSReceiveAchievementResp.AchievementId)
  return achievementid_;
}
inline void CSReceiveAchievementResp::set_achievementid(::google::protobuf::uint32 value) {
  set_has_achievementid();
  achievementid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSReceiveAchievementResp.AchievementId)
}

// -------------------------------------------------------------------

// CSReceiveAchievementRewardReq

// required uint32 AchievementLevel = 1;
inline bool CSReceiveAchievementRewardReq::has_achievementlevel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSReceiveAchievementRewardReq::set_has_achievementlevel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSReceiveAchievementRewardReq::clear_has_achievementlevel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSReceiveAchievementRewardReq::clear_achievementlevel() {
  achievementlevel_ = 0u;
  clear_has_achievementlevel();
}
inline ::google::protobuf::uint32 CSReceiveAchievementRewardReq::achievementlevel() const {
  // @@protoc_insertion_point(field_get:fgame.CSReceiveAchievementRewardReq.AchievementLevel)
  return achievementlevel_;
}
inline void CSReceiveAchievementRewardReq::set_achievementlevel(::google::protobuf::uint32 value) {
  set_has_achievementlevel();
  achievementlevel_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSReceiveAchievementRewardReq.AchievementLevel)
}

// -------------------------------------------------------------------

// CSReceiveAchievementRewardResp

// required uint32 Ret = 1;
inline bool CSReceiveAchievementRewardResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSReceiveAchievementRewardResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSReceiveAchievementRewardResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSReceiveAchievementRewardResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSReceiveAchievementRewardResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSReceiveAchievementRewardResp.Ret)
  return ret_;
}
inline void CSReceiveAchievementRewardResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSReceiveAchievementRewardResp.Ret)
}

// required uint32 AchievementLevel = 2;
inline bool CSReceiveAchievementRewardResp::has_achievementlevel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSReceiveAchievementRewardResp::set_has_achievementlevel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSReceiveAchievementRewardResp::clear_has_achievementlevel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSReceiveAchievementRewardResp::clear_achievementlevel() {
  achievementlevel_ = 0u;
  clear_has_achievementlevel();
}
inline ::google::protobuf::uint32 CSReceiveAchievementRewardResp::achievementlevel() const {
  // @@protoc_insertion_point(field_get:fgame.CSReceiveAchievementRewardResp.AchievementLevel)
  return achievementlevel_;
}
inline void CSReceiveAchievementRewardResp::set_achievementlevel(::google::protobuf::uint32 value) {
  set_has_achievementlevel();
  achievementlevel_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSReceiveAchievementRewardResp.AchievementLevel)
}

// -------------------------------------------------------------------

// CSUpdateAchievementResp

// repeated uint32 ListIds = 1;
inline int CSUpdateAchievementResp::listids_size() const {
  return listids_.size();
}
inline void CSUpdateAchievementResp::clear_listids() {
  listids_.Clear();
}
inline ::google::protobuf::uint32 CSUpdateAchievementResp::listids(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSUpdateAchievementResp.ListIds)
  return listids_.Get(index);
}
inline void CSUpdateAchievementResp::set_listids(int index, ::google::protobuf::uint32 value) {
  listids_.Set(index, value);
  // @@protoc_insertion_point(field_set:fgame.CSUpdateAchievementResp.ListIds)
}
inline void CSUpdateAchievementResp::add_listids(::google::protobuf::uint32 value) {
  listids_.Add(value);
  // @@protoc_insertion_point(field_add:fgame.CSUpdateAchievementResp.ListIds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSUpdateAchievementResp::listids() const {
  // @@protoc_insertion_point(field_list:fgame.CSUpdateAchievementResp.ListIds)
  return listids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSUpdateAchievementResp::mutable_listids() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSUpdateAchievementResp.ListIds)
  return &listids_;
}

// -------------------------------------------------------------------

// CSSevenDaySignListReq

// -------------------------------------------------------------------

// CSSevenDayGetList

// required bool isGet = 1;
inline bool CSSevenDayGetList::has_isget() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSevenDayGetList::set_has_isget() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSevenDayGetList::clear_has_isget() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSevenDayGetList::clear_isget() {
  isget_ = false;
  clear_has_isget();
}
inline bool CSSevenDayGetList::isget() const {
  // @@protoc_insertion_point(field_get:fgame.CSSevenDayGetList.isGet)
  return isget_;
}
inline void CSSevenDayGetList::set_isget(bool value) {
  set_has_isget();
  isget_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSevenDayGetList.isGet)
}

// required bool isNewGift = 2;
inline bool CSSevenDayGetList::has_isnewgift() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSSevenDayGetList::set_has_isnewgift() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSSevenDayGetList::clear_has_isnewgift() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSSevenDayGetList::clear_isnewgift() {
  isnewgift_ = false;
  clear_has_isnewgift();
}
inline bool CSSevenDayGetList::isnewgift() const {
  // @@protoc_insertion_point(field_get:fgame.CSSevenDayGetList.isNewGift)
  return isnewgift_;
}
inline void CSSevenDayGetList::set_isnewgift(bool value) {
  set_has_isnewgift();
  isnewgift_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSevenDayGetList.isNewGift)
}

// -------------------------------------------------------------------

// CSSevenDaySignListResp

// required uint32 nowDay = 1;
inline bool CSSevenDaySignListResp::has_nowday() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSevenDaySignListResp::set_has_nowday() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSevenDaySignListResp::clear_has_nowday() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSevenDaySignListResp::clear_nowday() {
  nowday_ = 0u;
  clear_has_nowday();
}
inline ::google::protobuf::uint32 CSSevenDaySignListResp::nowday() const {
  // @@protoc_insertion_point(field_get:fgame.CSSevenDaySignListResp.nowDay)
  return nowday_;
}
inline void CSSevenDaySignListResp::set_nowday(::google::protobuf::uint32 value) {
  set_has_nowday();
  nowday_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSevenDaySignListResp.nowDay)
}

// repeated .fgame.CSSevenDayGetList getList = 2;
inline int CSSevenDaySignListResp::getlist_size() const {
  return getlist_.size();
}
inline void CSSevenDaySignListResp::clear_getlist() {
  getlist_.Clear();
}
inline const ::fgame::CSSevenDayGetList& CSSevenDaySignListResp::getlist(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSSevenDaySignListResp.getList)
  return getlist_.Get(index);
}
inline ::fgame::CSSevenDayGetList* CSSevenDaySignListResp::mutable_getlist(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSSevenDaySignListResp.getList)
  return getlist_.Mutable(index);
}
inline ::fgame::CSSevenDayGetList* CSSevenDaySignListResp::add_getlist() {
  // @@protoc_insertion_point(field_add:fgame.CSSevenDaySignListResp.getList)
  return getlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSSevenDayGetList >&
CSSevenDaySignListResp::getlist() const {
  // @@protoc_insertion_point(field_list:fgame.CSSevenDaySignListResp.getList)
  return getlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSSevenDayGetList >*
CSSevenDaySignListResp::mutable_getlist() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSSevenDaySignListResp.getList)
  return &getlist_;
}

// -------------------------------------------------------------------

// CSSevenDaySignReq

// -------------------------------------------------------------------

// CSSevenDaySignResp

// required uint32 giftId = 1;
inline bool CSSevenDaySignResp::has_giftid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSevenDaySignResp::set_has_giftid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSevenDaySignResp::clear_has_giftid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSevenDaySignResp::clear_giftid() {
  giftid_ = 0u;
  clear_has_giftid();
}
inline ::google::protobuf::uint32 CSSevenDaySignResp::giftid() const {
  // @@protoc_insertion_point(field_get:fgame.CSSevenDaySignResp.giftId)
  return giftid_;
}
inline void CSSevenDaySignResp::set_giftid(::google::protobuf::uint32 value) {
  set_has_giftid();
  giftid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSevenDaySignResp.giftId)
}

// -------------------------------------------------------------------

// CSGetServerReq

// required string OpenId = 1;
inline bool CSGetServerReq::has_openid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGetServerReq::set_has_openid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGetServerReq::clear_has_openid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGetServerReq::clear_openid() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& CSGetServerReq::openid() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetServerReq.OpenId)
  return *openid_;
}
inline void CSGetServerReq::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSGetServerReq.OpenId)
}
inline void CSGetServerReq::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSGetServerReq.OpenId)
}
inline void CSGetServerReq::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSGetServerReq.OpenId)
}
inline ::std::string* CSGetServerReq::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSGetServerReq.OpenId)
  return openid_;
}
inline ::std::string* CSGetServerReq::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSGetServerReq::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSGetServerReq.OpenId)
}

// optional uint32 LastTs = 2;
inline bool CSGetServerReq::has_lastts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGetServerReq::set_has_lastts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGetServerReq::clear_has_lastts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGetServerReq::clear_lastts() {
  lastts_ = 0u;
  clear_has_lastts();
}
inline ::google::protobuf::uint32 CSGetServerReq::lastts() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetServerReq.LastTs)
  return lastts_;
}
inline void CSGetServerReq::set_lastts(::google::protobuf::uint32 value) {
  set_has_lastts();
  lastts_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetServerReq.LastTs)
}

// optional string GameServerName = 3;
inline bool CSGetServerReq::has_gameservername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSGetServerReq::set_has_gameservername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSGetServerReq::clear_has_gameservername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSGetServerReq::clear_gameservername() {
  if (gameservername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_->clear();
  }
  clear_has_gameservername();
}
inline const ::std::string& CSGetServerReq::gameservername() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetServerReq.GameServerName)
  return *gameservername_;
}
inline void CSGetServerReq::set_gameservername(const ::std::string& value) {
  set_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_ = new ::std::string;
  }
  gameservername_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSGetServerReq.GameServerName)
}
inline void CSGetServerReq::set_gameservername(const char* value) {
  set_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_ = new ::std::string;
  }
  gameservername_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSGetServerReq.GameServerName)
}
inline void CSGetServerReq::set_gameservername(const char* value, size_t size) {
  set_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_ = new ::std::string;
  }
  gameservername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSGetServerReq.GameServerName)
}
inline ::std::string* CSGetServerReq::mutable_gameservername() {
  set_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSGetServerReq.GameServerName)
  return gameservername_;
}
inline ::std::string* CSGetServerReq::release_gameservername() {
  clear_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gameservername_;
    gameservername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSGetServerReq::set_allocated_gameservername(::std::string* gameservername) {
  if (gameservername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gameservername_;
  }
  if (gameservername) {
    set_has_gameservername();
    gameservername_ = gameservername;
  } else {
    clear_has_gameservername();
    gameservername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSGetServerReq.GameServerName)
}

// optional uint64 Uin = 4;
inline bool CSGetServerReq::has_uin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSGetServerReq::set_has_uin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSGetServerReq::clear_has_uin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSGetServerReq::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSGetServerReq::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetServerReq.Uin)
  return uin_;
}
inline void CSGetServerReq::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetServerReq.Uin)
}

// optional string Version = 5;
inline bool CSGetServerReq::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSGetServerReq::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSGetServerReq::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSGetServerReq::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& CSGetServerReq::version() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetServerReq.Version)
  return *version_;
}
inline void CSGetServerReq::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSGetServerReq.Version)
}
inline void CSGetServerReq::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSGetServerReq.Version)
}
inline void CSGetServerReq::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSGetServerReq.Version)
}
inline ::std::string* CSGetServerReq::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSGetServerReq.Version)
  return version_;
}
inline ::std::string* CSGetServerReq::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSGetServerReq::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSGetServerReq.Version)
}

// -------------------------------------------------------------------

// CSGetServerResp

// required string LoginServer = 1;
inline bool CSGetServerResp::has_loginserver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGetServerResp::set_has_loginserver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGetServerResp::clear_has_loginserver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGetServerResp::clear_loginserver() {
  if (loginserver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loginserver_->clear();
  }
  clear_has_loginserver();
}
inline const ::std::string& CSGetServerResp::loginserver() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetServerResp.LoginServer)
  return *loginserver_;
}
inline void CSGetServerResp::set_loginserver(const ::std::string& value) {
  set_has_loginserver();
  if (loginserver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loginserver_ = new ::std::string;
  }
  loginserver_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSGetServerResp.LoginServer)
}
inline void CSGetServerResp::set_loginserver(const char* value) {
  set_has_loginserver();
  if (loginserver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loginserver_ = new ::std::string;
  }
  loginserver_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSGetServerResp.LoginServer)
}
inline void CSGetServerResp::set_loginserver(const char* value, size_t size) {
  set_has_loginserver();
  if (loginserver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loginserver_ = new ::std::string;
  }
  loginserver_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSGetServerResp.LoginServer)
}
inline ::std::string* CSGetServerResp::mutable_loginserver() {
  set_has_loginserver();
  if (loginserver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loginserver_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSGetServerResp.LoginServer)
  return loginserver_;
}
inline ::std::string* CSGetServerResp::release_loginserver() {
  clear_has_loginserver();
  if (loginserver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = loginserver_;
    loginserver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSGetServerResp::set_allocated_loginserver(::std::string* loginserver) {
  if (loginserver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete loginserver_;
  }
  if (loginserver) {
    set_has_loginserver();
    loginserver_ = loginserver;
  } else {
    clear_has_loginserver();
    loginserver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSGetServerResp.LoginServer)
}

// optional string GameServer = 2;
inline bool CSGetServerResp::has_gameserver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGetServerResp::set_has_gameserver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGetServerResp::clear_has_gameserver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGetServerResp::clear_gameserver() {
  if (gameserver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameserver_->clear();
  }
  clear_has_gameserver();
}
inline const ::std::string& CSGetServerResp::gameserver() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetServerResp.GameServer)
  return *gameserver_;
}
inline void CSGetServerResp::set_gameserver(const ::std::string& value) {
  set_has_gameserver();
  if (gameserver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameserver_ = new ::std::string;
  }
  gameserver_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSGetServerResp.GameServer)
}
inline void CSGetServerResp::set_gameserver(const char* value) {
  set_has_gameserver();
  if (gameserver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameserver_ = new ::std::string;
  }
  gameserver_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSGetServerResp.GameServer)
}
inline void CSGetServerResp::set_gameserver(const char* value, size_t size) {
  set_has_gameserver();
  if (gameserver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameserver_ = new ::std::string;
  }
  gameserver_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSGetServerResp.GameServer)
}
inline ::std::string* CSGetServerResp::mutable_gameserver() {
  set_has_gameserver();
  if (gameserver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameserver_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSGetServerResp.GameServer)
  return gameserver_;
}
inline ::std::string* CSGetServerResp::release_gameserver() {
  clear_has_gameserver();
  if (gameserver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gameserver_;
    gameserver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSGetServerResp::set_allocated_gameserver(::std::string* gameserver) {
  if (gameserver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gameserver_;
  }
  if (gameserver) {
    set_has_gameserver();
    gameserver_ = gameserver;
  } else {
    clear_has_gameserver();
    gameserver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSGetServerResp.GameServer)
}

// optional string GameServerName = 3;
inline bool CSGetServerResp::has_gameservername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSGetServerResp::set_has_gameservername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSGetServerResp::clear_has_gameservername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSGetServerResp::clear_gameservername() {
  if (gameservername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_->clear();
  }
  clear_has_gameservername();
}
inline const ::std::string& CSGetServerResp::gameservername() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetServerResp.GameServerName)
  return *gameservername_;
}
inline void CSGetServerResp::set_gameservername(const ::std::string& value) {
  set_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_ = new ::std::string;
  }
  gameservername_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSGetServerResp.GameServerName)
}
inline void CSGetServerResp::set_gameservername(const char* value) {
  set_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_ = new ::std::string;
  }
  gameservername_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSGetServerResp.GameServerName)
}
inline void CSGetServerResp::set_gameservername(const char* value, size_t size) {
  set_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_ = new ::std::string;
  }
  gameservername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSGetServerResp.GameServerName)
}
inline ::std::string* CSGetServerResp::mutable_gameservername() {
  set_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSGetServerResp.GameServerName)
  return gameservername_;
}
inline ::std::string* CSGetServerResp::release_gameservername() {
  clear_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gameservername_;
    gameservername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSGetServerResp::set_allocated_gameservername(::std::string* gameservername) {
  if (gameservername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gameservername_;
  }
  if (gameservername) {
    set_has_gameservername();
    gameservername_ = gameservername;
  } else {
    clear_has_gameservername();
    gameservername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSGetServerResp.GameServerName)
}

// optional uint32 WhiteUpdate = 4;
inline bool CSGetServerResp::has_whiteupdate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSGetServerResp::set_has_whiteupdate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSGetServerResp::clear_has_whiteupdate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSGetServerResp::clear_whiteupdate() {
  whiteupdate_ = 0u;
  clear_has_whiteupdate();
}
inline ::google::protobuf::uint32 CSGetServerResp::whiteupdate() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetServerResp.WhiteUpdate)
  return whiteupdate_;
}
inline void CSGetServerResp::set_whiteupdate(::google::protobuf::uint32 value) {
  set_has_whiteupdate();
  whiteupdate_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetServerResp.WhiteUpdate)
}

// -------------------------------------------------------------------

// CSEnterServerReq

// required uint64 Uin = 1;
inline bool CSEnterServerReq::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEnterServerReq::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEnterServerReq::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEnterServerReq::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSEnterServerReq::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSEnterServerReq.Uin)
  return uin_;
}
inline void CSEnterServerReq::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSEnterServerReq.Uin)
}

// required string OpenId = 2;
inline bool CSEnterServerReq::has_openid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEnterServerReq::set_has_openid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEnterServerReq::clear_has_openid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEnterServerReq::clear_openid() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& CSEnterServerReq::openid() const {
  // @@protoc_insertion_point(field_get:fgame.CSEnterServerReq.OpenId)
  return *openid_;
}
inline void CSEnterServerReq::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSEnterServerReq.OpenId)
}
inline void CSEnterServerReq::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSEnterServerReq.OpenId)
}
inline void CSEnterServerReq::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSEnterServerReq.OpenId)
}
inline ::std::string* CSEnterServerReq::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSEnterServerReq.OpenId)
  return openid_;
}
inline ::std::string* CSEnterServerReq::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSEnterServerReq::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSEnterServerReq.OpenId)
}

// required uint32 Retry = 3;
inline bool CSEnterServerReq::has_retry() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSEnterServerReq::set_has_retry() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSEnterServerReq::clear_has_retry() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSEnterServerReq::clear_retry() {
  retry_ = 0u;
  clear_has_retry();
}
inline ::google::protobuf::uint32 CSEnterServerReq::retry() const {
  // @@protoc_insertion_point(field_get:fgame.CSEnterServerReq.Retry)
  return retry_;
}
inline void CSEnterServerReq::set_retry(::google::protobuf::uint32 value) {
  set_has_retry();
  retry_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSEnterServerReq.Retry)
}

// optional string IMEI = 4;
inline bool CSEnterServerReq::has_imei() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSEnterServerReq::set_has_imei() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSEnterServerReq::clear_has_imei() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSEnterServerReq::clear_imei() {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& CSEnterServerReq::imei() const {
  // @@protoc_insertion_point(field_get:fgame.CSEnterServerReq.IMEI)
  return *imei_;
}
inline void CSEnterServerReq::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSEnterServerReq.IMEI)
}
inline void CSEnterServerReq::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSEnterServerReq.IMEI)
}
inline void CSEnterServerReq::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSEnterServerReq.IMEI)
}
inline ::std::string* CSEnterServerReq::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSEnterServerReq.IMEI)
  return imei_;
}
inline ::std::string* CSEnterServerReq::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSEnterServerReq::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSEnterServerReq.IMEI)
}

// optional string Version = 5;
inline bool CSEnterServerReq::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSEnterServerReq::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSEnterServerReq::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSEnterServerReq::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& CSEnterServerReq::version() const {
  // @@protoc_insertion_point(field_get:fgame.CSEnterServerReq.Version)
  return *version_;
}
inline void CSEnterServerReq::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSEnterServerReq.Version)
}
inline void CSEnterServerReq::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSEnterServerReq.Version)
}
inline void CSEnterServerReq::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSEnterServerReq.Version)
}
inline ::std::string* CSEnterServerReq::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSEnterServerReq.Version)
  return version_;
}
inline ::std::string* CSEnterServerReq::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSEnterServerReq::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSEnterServerReq.Version)
}

// -------------------------------------------------------------------

// CSEnterServerResp

// required uint32 Overload = 1;
inline bool CSEnterServerResp::has_overload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEnterServerResp::set_has_overload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEnterServerResp::clear_has_overload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEnterServerResp::clear_overload() {
  overload_ = 0u;
  clear_has_overload();
}
inline ::google::protobuf::uint32 CSEnterServerResp::overload() const {
  // @@protoc_insertion_point(field_get:fgame.CSEnterServerResp.Overload)
  return overload_;
}
inline void CSEnterServerResp::set_overload(::google::protobuf::uint32 value) {
  set_has_overload();
  overload_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSEnterServerResp.Overload)
}

// optional uint32 ForceExit = 2;
inline bool CSEnterServerResp::has_forceexit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEnterServerResp::set_has_forceexit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEnterServerResp::clear_has_forceexit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEnterServerResp::clear_forceexit() {
  forceexit_ = 0u;
  clear_has_forceexit();
}
inline ::google::protobuf::uint32 CSEnterServerResp::forceexit() const {
  // @@protoc_insertion_point(field_get:fgame.CSEnterServerResp.ForceExit)
  return forceexit_;
}
inline void CSEnterServerResp::set_forceexit(::google::protobuf::uint32 value) {
  set_has_forceexit();
  forceexit_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSEnterServerResp.ForceExit)
}

// optional uint32 Wait_Num = 3;
inline bool CSEnterServerResp::has_wait_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSEnterServerResp::set_has_wait_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSEnterServerResp::clear_has_wait_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSEnterServerResp::clear_wait_num() {
  wait_num_ = 0u;
  clear_has_wait_num();
}
inline ::google::protobuf::uint32 CSEnterServerResp::wait_num() const {
  // @@protoc_insertion_point(field_get:fgame.CSEnterServerResp.Wait_Num)
  return wait_num_;
}
inline void CSEnterServerResp::set_wait_num(::google::protobuf::uint32 value) {
  set_has_wait_num();
  wait_num_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSEnterServerResp.Wait_Num)
}

// optional string GameServerName = 4;
inline bool CSEnterServerResp::has_gameservername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSEnterServerResp::set_has_gameservername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSEnterServerResp::clear_has_gameservername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSEnterServerResp::clear_gameservername() {
  if (gameservername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_->clear();
  }
  clear_has_gameservername();
}
inline const ::std::string& CSEnterServerResp::gameservername() const {
  // @@protoc_insertion_point(field_get:fgame.CSEnterServerResp.GameServerName)
  return *gameservername_;
}
inline void CSEnterServerResp::set_gameservername(const ::std::string& value) {
  set_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_ = new ::std::string;
  }
  gameservername_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSEnterServerResp.GameServerName)
}
inline void CSEnterServerResp::set_gameservername(const char* value) {
  set_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_ = new ::std::string;
  }
  gameservername_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSEnterServerResp.GameServerName)
}
inline void CSEnterServerResp::set_gameservername(const char* value, size_t size) {
  set_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_ = new ::std::string;
  }
  gameservername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSEnterServerResp.GameServerName)
}
inline ::std::string* CSEnterServerResp::mutable_gameservername() {
  set_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameservername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSEnterServerResp.GameServerName)
  return gameservername_;
}
inline ::std::string* CSEnterServerResp::release_gameservername() {
  clear_has_gameservername();
  if (gameservername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gameservername_;
    gameservername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSEnterServerResp::set_allocated_gameservername(::std::string* gameservername) {
  if (gameservername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gameservername_;
  }
  if (gameservername) {
    set_has_gameservername();
    gameservername_ = gameservername;
  } else {
    clear_has_gameservername();
    gameservername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSEnterServerResp.GameServerName)
}

// optional uint32 Ts = 5;
inline bool CSEnterServerResp::has_ts() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSEnterServerResp::set_has_ts() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSEnterServerResp::clear_has_ts() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSEnterServerResp::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 CSEnterServerResp::ts() const {
  // @@protoc_insertion_point(field_get:fgame.CSEnterServerResp.Ts)
  return ts_;
}
inline void CSEnterServerResp::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSEnterServerResp.Ts)
}

// -------------------------------------------------------------------

// CSCanEnterReq

// required uint64 Uin = 1;
inline bool CSCanEnterReq::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSCanEnterReq::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSCanEnterReq::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSCanEnterReq::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSCanEnterReq::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSCanEnterReq.Uin)
  return uin_;
}
inline void CSCanEnterReq::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSCanEnterReq.Uin)
}

// -------------------------------------------------------------------

// CSDirectEnterReq

// required uint64 Uin = 1;
inline bool CSDirectEnterReq::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDirectEnterReq::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDirectEnterReq::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDirectEnterReq::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSDirectEnterReq::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSDirectEnterReq.Uin)
  return uin_;
}
inline void CSDirectEnterReq::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSDirectEnterReq.Uin)
}

// -------------------------------------------------------------------

// CSDircetEnterResp

// required uint32 Ret = 1;
inline bool CSDircetEnterResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDircetEnterResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDircetEnterResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDircetEnterResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSDircetEnterResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSDircetEnterResp.Ret)
  return ret_;
}
inline void CSDircetEnterResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSDircetEnterResp.Ret)
}

// -------------------------------------------------------------------

// CSQueueReq

// required uint64 Uin = 1;
inline bool CSQueueReq::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSQueueReq::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSQueueReq::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSQueueReq::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSQueueReq::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueueReq.Uin)
  return uin_;
}
inline void CSQueueReq::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSQueueReq.Uin)
}

// required uint32 Remain_Num = 2;
inline bool CSQueueReq::has_remain_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSQueueReq::set_has_remain_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSQueueReq::clear_has_remain_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSQueueReq::clear_remain_num() {
  remain_num_ = 0u;
  clear_has_remain_num();
}
inline ::google::protobuf::uint32 CSQueueReq::remain_num() const {
  // @@protoc_insertion_point(field_get:fgame.CSQueueReq.Remain_Num)
  return remain_num_;
}
inline void CSQueueReq::set_remain_num(::google::protobuf::uint32 value) {
  set_has_remain_num();
  remain_num_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSQueueReq.Remain_Num)
}

// -------------------------------------------------------------------

// CSStreakWinValueReq

// required uint64 Uin = 1;
inline bool CSStreakWinValueReq::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSStreakWinValueReq::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSStreakWinValueReq::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSStreakWinValueReq::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSStreakWinValueReq::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSStreakWinValueReq.Uin)
  return uin_;
}
inline void CSStreakWinValueReq::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSStreakWinValueReq.Uin)
}

// -------------------------------------------------------------------

// CSStreakWinValueResp

// required uint32 Ret = 1;
inline bool CSStreakWinValueResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSStreakWinValueResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSStreakWinValueResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSStreakWinValueResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSStreakWinValueResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSStreakWinValueResp.Ret)
  return ret_;
}
inline void CSStreakWinValueResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSStreakWinValueResp.Ret)
}

// required uint32 StreakWinValue = 2;
inline bool CSStreakWinValueResp::has_streakwinvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSStreakWinValueResp::set_has_streakwinvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSStreakWinValueResp::clear_has_streakwinvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSStreakWinValueResp::clear_streakwinvalue() {
  streakwinvalue_ = 0u;
  clear_has_streakwinvalue();
}
inline ::google::protobuf::uint32 CSStreakWinValueResp::streakwinvalue() const {
  // @@protoc_insertion_point(field_get:fgame.CSStreakWinValueResp.StreakWinValue)
  return streakwinvalue_;
}
inline void CSStreakWinValueResp::set_streakwinvalue(::google::protobuf::uint32 value) {
  set_has_streakwinvalue();
  streakwinvalue_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSStreakWinValueResp.StreakWinValue)
}

// optional uint32 GetWinValue = 3;
inline bool CSStreakWinValueResp::has_getwinvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSStreakWinValueResp::set_has_getwinvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSStreakWinValueResp::clear_has_getwinvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSStreakWinValueResp::clear_getwinvalue() {
  getwinvalue_ = 0u;
  clear_has_getwinvalue();
}
inline ::google::protobuf::uint32 CSStreakWinValueResp::getwinvalue() const {
  // @@protoc_insertion_point(field_get:fgame.CSStreakWinValueResp.GetWinValue)
  return getwinvalue_;
}
inline void CSStreakWinValueResp::set_getwinvalue(::google::protobuf::uint32 value) {
  set_has_getwinvalue();
  getwinvalue_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSStreakWinValueResp.GetWinValue)
}

// -------------------------------------------------------------------

// CSStreakWinGetReq

// required uint32 StreakWinValue = 1;
inline bool CSStreakWinGetReq::has_streakwinvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSStreakWinGetReq::set_has_streakwinvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSStreakWinGetReq::clear_has_streakwinvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSStreakWinGetReq::clear_streakwinvalue() {
  streakwinvalue_ = 0u;
  clear_has_streakwinvalue();
}
inline ::google::protobuf::uint32 CSStreakWinGetReq::streakwinvalue() const {
  // @@protoc_insertion_point(field_get:fgame.CSStreakWinGetReq.StreakWinValue)
  return streakwinvalue_;
}
inline void CSStreakWinGetReq::set_streakwinvalue(::google::protobuf::uint32 value) {
  set_has_streakwinvalue();
  streakwinvalue_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSStreakWinGetReq.StreakWinValue)
}

// -------------------------------------------------------------------

// CSStreakWinGetResp

// required uint32 Ret = 1;
inline bool CSStreakWinGetResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSStreakWinGetResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSStreakWinGetResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSStreakWinGetResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSStreakWinGetResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSStreakWinGetResp.Ret)
  return ret_;
}
inline void CSStreakWinGetResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSStreakWinGetResp.Ret)
}

// required uint32 DiamondValue = 2;
inline bool CSStreakWinGetResp::has_diamondvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSStreakWinGetResp::set_has_diamondvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSStreakWinGetResp::clear_has_diamondvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSStreakWinGetResp::clear_diamondvalue() {
  diamondvalue_ = 0u;
  clear_has_diamondvalue();
}
inline ::google::protobuf::uint32 CSStreakWinGetResp::diamondvalue() const {
  // @@protoc_insertion_point(field_get:fgame.CSStreakWinGetResp.DiamondValue)
  return diamondvalue_;
}
inline void CSStreakWinGetResp::set_diamondvalue(::google::protobuf::uint32 value) {
  set_has_diamondvalue();
  diamondvalue_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSStreakWinGetResp.DiamondValue)
}

// -------------------------------------------------------------------

// CSItem

// required uint32 ItemId = 1;
inline bool CSItem::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSItem::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSItem::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSItem::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 CSItem::itemid() const {
  // @@protoc_insertion_point(field_get:fgame.CSItem.ItemId)
  return itemid_;
}
inline void CSItem::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSItem.ItemId)
}

// required uint32 Count = 2;
inline bool CSItem::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSItem::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSItem::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSItem::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CSItem::count() const {
  // @@protoc_insertion_point(field_get:fgame.CSItem.Count)
  return count_;
}
inline void CSItem::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSItem.Count)
}

// -------------------------------------------------------------------

// CSSycPlayerInfoReq

// -------------------------------------------------------------------

// CSTitleItem

// required uint32 Type = 1;
inline bool CSTitleItem::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSTitleItem::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSTitleItem::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSTitleItem::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSTitleItem::type() const {
  // @@protoc_insertion_point(field_get:fgame.CSTitleItem.Type)
  return type_;
}
inline void CSTitleItem::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSTitleItem.Type)
}

// required uint32 Time = 2;
inline bool CSTitleItem::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSTitleItem::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSTitleItem::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSTitleItem::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 CSTitleItem::time() const {
  // @@protoc_insertion_point(field_get:fgame.CSTitleItem.Time)
  return time_;
}
inline void CSTitleItem::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSTitleItem.Time)
}

// -------------------------------------------------------------------

// CSSycPlayerInfoResp

// required uint32 PlayerTitle = 1;
inline bool CSSycPlayerInfoResp::has_playertitle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_playertitle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSycPlayerInfoResp::clear_has_playertitle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSycPlayerInfoResp::clear_playertitle() {
  playertitle_ = 0u;
  clear_has_playertitle();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::playertitle() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.PlayerTitle)
  return playertitle_;
}
inline void CSSycPlayerInfoResp::set_playertitle(::google::protobuf::uint32 value) {
  set_has_playertitle();
  playertitle_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.PlayerTitle)
}

// required uint32 Energy = 2;
inline bool CSSycPlayerInfoResp::has_energy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_energy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSSycPlayerInfoResp::clear_has_energy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSSycPlayerInfoResp::clear_energy() {
  energy_ = 0u;
  clear_has_energy();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::energy() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.Energy)
  return energy_;
}
inline void CSSycPlayerInfoResp::set_energy(::google::protobuf::uint32 value) {
  set_has_energy();
  energy_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.Energy)
}

// optional string Name = 3;
inline bool CSSycPlayerInfoResp::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSSycPlayerInfoResp::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSSycPlayerInfoResp::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSSycPlayerInfoResp::name() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.Name)
  return *name_;
}
inline void CSSycPlayerInfoResp::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.Name)
}
inline void CSSycPlayerInfoResp::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSSycPlayerInfoResp.Name)
}
inline void CSSycPlayerInfoResp::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSSycPlayerInfoResp.Name)
}
inline ::std::string* CSSycPlayerInfoResp::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSSycPlayerInfoResp.Name)
  return name_;
}
inline ::std::string* CSSycPlayerInfoResp::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSSycPlayerInfoResp::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSSycPlayerInfoResp.Name)
}

// optional uint32 ChangeNameCount = 4;
inline bool CSSycPlayerInfoResp::has_changenamecount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_changenamecount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSSycPlayerInfoResp::clear_has_changenamecount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSSycPlayerInfoResp::clear_changenamecount() {
  changenamecount_ = 0u;
  clear_has_changenamecount();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::changenamecount() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.ChangeNameCount)
  return changenamecount_;
}
inline void CSSycPlayerInfoResp::set_changenamecount(::google::protobuf::uint32 value) {
  set_has_changenamecount();
  changenamecount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.ChangeNameCount)
}

// optional uint32 EnergyBuyCount = 5;
inline bool CSSycPlayerInfoResp::has_energybuycount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_energybuycount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSSycPlayerInfoResp::clear_has_energybuycount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSSycPlayerInfoResp::clear_energybuycount() {
  energybuycount_ = 0u;
  clear_has_energybuycount();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::energybuycount() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.EnergyBuyCount)
  return energybuycount_;
}
inline void CSSycPlayerInfoResp::set_energybuycount(::google::protobuf::uint32 value) {
  set_has_energybuycount();
  energybuycount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.EnergyBuyCount)
}

// optional uint32 Diamond = 6;
inline bool CSSycPlayerInfoResp::has_diamond() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_diamond() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSSycPlayerInfoResp::clear_has_diamond() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSSycPlayerInfoResp::clear_diamond() {
  diamond_ = 0u;
  clear_has_diamond();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::diamond() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.Diamond)
  return diamond_;
}
inline void CSSycPlayerInfoResp::set_diamond(::google::protobuf::uint32 value) {
  set_has_diamond();
  diamond_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.Diamond)
}

// optional string IconId = 7;
inline bool CSSycPlayerInfoResp::has_iconid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_iconid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSSycPlayerInfoResp::clear_has_iconid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSSycPlayerInfoResp::clear_iconid() {
  if (iconid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iconid_->clear();
  }
  clear_has_iconid();
}
inline const ::std::string& CSSycPlayerInfoResp::iconid() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.IconId)
  return *iconid_;
}
inline void CSSycPlayerInfoResp::set_iconid(const ::std::string& value) {
  set_has_iconid();
  if (iconid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iconid_ = new ::std::string;
  }
  iconid_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.IconId)
}
inline void CSSycPlayerInfoResp::set_iconid(const char* value) {
  set_has_iconid();
  if (iconid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iconid_ = new ::std::string;
  }
  iconid_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSSycPlayerInfoResp.IconId)
}
inline void CSSycPlayerInfoResp::set_iconid(const char* value, size_t size) {
  set_has_iconid();
  if (iconid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iconid_ = new ::std::string;
  }
  iconid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSSycPlayerInfoResp.IconId)
}
inline ::std::string* CSSycPlayerInfoResp::mutable_iconid() {
  set_has_iconid();
  if (iconid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iconid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSSycPlayerInfoResp.IconId)
  return iconid_;
}
inline ::std::string* CSSycPlayerInfoResp::release_iconid() {
  clear_has_iconid();
  if (iconid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = iconid_;
    iconid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSSycPlayerInfoResp::set_allocated_iconid(::std::string* iconid) {
  if (iconid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete iconid_;
  }
  if (iconid) {
    set_has_iconid();
    iconid_ = iconid;
  } else {
    clear_has_iconid();
    iconid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSSycPlayerInfoResp.IconId)
}

// optional uint32 EnergySlot = 8;
inline bool CSSycPlayerInfoResp::has_energyslot() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_energyslot() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSSycPlayerInfoResp::clear_has_energyslot() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSSycPlayerInfoResp::clear_energyslot() {
  energyslot_ = 0u;
  clear_has_energyslot();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::energyslot() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.EnergySlot)
  return energyslot_;
}
inline void CSSycPlayerInfoResp::set_energyslot(::google::protobuf::uint32 value) {
  set_has_energyslot();
  energyslot_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.EnergySlot)
}

// optional uint32 Power = 9;
inline bool CSSycPlayerInfoResp::has_power() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_power() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSSycPlayerInfoResp::clear_has_power() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSSycPlayerInfoResp::clear_power() {
  power_ = 0u;
  clear_has_power();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::power() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.Power)
  return power_;
}
inline void CSSycPlayerInfoResp::set_power(::google::protobuf::uint32 value) {
  set_has_power();
  power_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.Power)
}

// optional uint32 PowerSlot = 10;
inline bool CSSycPlayerInfoResp::has_powerslot() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_powerslot() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSSycPlayerInfoResp::clear_has_powerslot() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSSycPlayerInfoResp::clear_powerslot() {
  powerslot_ = 0u;
  clear_has_powerslot();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::powerslot() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.PowerSlot)
  return powerslot_;
}
inline void CSSycPlayerInfoResp::set_powerslot(::google::protobuf::uint32 value) {
  set_has_powerslot();
  powerslot_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.PowerSlot)
}

// repeated .fgame.CSItem Items = 11;
inline int CSSycPlayerInfoResp::items_size() const {
  return items_.size();
}
inline void CSSycPlayerInfoResp::clear_items() {
  items_.Clear();
}
inline const ::fgame::CSItem& CSSycPlayerInfoResp::items(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.Items)
  return items_.Get(index);
}
inline ::fgame::CSItem* CSSycPlayerInfoResp::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSSycPlayerInfoResp.Items)
  return items_.Mutable(index);
}
inline ::fgame::CSItem* CSSycPlayerInfoResp::add_items() {
  // @@protoc_insertion_point(field_add:fgame.CSSycPlayerInfoResp.Items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSItem >&
CSSycPlayerInfoResp::items() const {
  // @@protoc_insertion_point(field_list:fgame.CSSycPlayerInfoResp.Items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSItem >*
CSSycPlayerInfoResp::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSSycPlayerInfoResp.Items)
  return &items_;
}

// optional uint32 MonthCardDays = 12;
inline bool CSSycPlayerInfoResp::has_monthcarddays() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_monthcarddays() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CSSycPlayerInfoResp::clear_has_monthcarddays() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CSSycPlayerInfoResp::clear_monthcarddays() {
  monthcarddays_ = 0u;
  clear_has_monthcarddays();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::monthcarddays() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.MonthCardDays)
  return monthcarddays_;
}
inline void CSSycPlayerInfoResp::set_monthcarddays(::google::protobuf::uint32 value) {
  set_has_monthcarddays();
  monthcarddays_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.MonthCardDays)
}

// optional uint32 ShopGuide = 13;
inline bool CSSycPlayerInfoResp::has_shopguide() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_shopguide() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CSSycPlayerInfoResp::clear_has_shopguide() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CSSycPlayerInfoResp::clear_shopguide() {
  shopguide_ = 0u;
  clear_has_shopguide();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::shopguide() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.ShopGuide)
  return shopguide_;
}
inline void CSSycPlayerInfoResp::set_shopguide(::google::protobuf::uint32 value) {
  set_has_shopguide();
  shopguide_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.ShopGuide)
}

// repeated uint32 TitleList = 14;
inline int CSSycPlayerInfoResp::titlelist_size() const {
  return titlelist_.size();
}
inline void CSSycPlayerInfoResp::clear_titlelist() {
  titlelist_.Clear();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::titlelist(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.TitleList)
  return titlelist_.Get(index);
}
inline void CSSycPlayerInfoResp::set_titlelist(int index, ::google::protobuf::uint32 value) {
  titlelist_.Set(index, value);
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.TitleList)
}
inline void CSSycPlayerInfoResp::add_titlelist(::google::protobuf::uint32 value) {
  titlelist_.Add(value);
  // @@protoc_insertion_point(field_add:fgame.CSSycPlayerInfoResp.TitleList)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSSycPlayerInfoResp::titlelist() const {
  // @@protoc_insertion_point(field_list:fgame.CSSycPlayerInfoResp.TitleList)
  return titlelist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSSycPlayerInfoResp::mutable_titlelist() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSSycPlayerInfoResp.TitleList)
  return &titlelist_;
}

// optional uint32 RoomTicket = 15;
inline bool CSSycPlayerInfoResp::has_roomticket() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_roomticket() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CSSycPlayerInfoResp::clear_has_roomticket() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CSSycPlayerInfoResp::clear_roomticket() {
  roomticket_ = 0u;
  clear_has_roomticket();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::roomticket() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.RoomTicket)
  return roomticket_;
}
inline void CSSycPlayerInfoResp::set_roomticket(::google::protobuf::uint32 value) {
  set_has_roomticket();
  roomticket_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.RoomTicket)
}

// optional uint32 VipLevel = 16;
inline bool CSSycPlayerInfoResp::has_viplevel() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_viplevel() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CSSycPlayerInfoResp::clear_has_viplevel() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CSSycPlayerInfoResp::clear_viplevel() {
  viplevel_ = 0u;
  clear_has_viplevel();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::viplevel() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.VipLevel)
  return viplevel_;
}
inline void CSSycPlayerInfoResp::set_viplevel(::google::protobuf::uint32 value) {
  set_has_viplevel();
  viplevel_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.VipLevel)
}

// optional string RemainTime = 17;
inline bool CSSycPlayerInfoResp::has_remaintime() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_remaintime() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CSSycPlayerInfoResp::clear_has_remaintime() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CSSycPlayerInfoResp::clear_remaintime() {
  if (remaintime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remaintime_->clear();
  }
  clear_has_remaintime();
}
inline const ::std::string& CSSycPlayerInfoResp::remaintime() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.RemainTime)
  return *remaintime_;
}
inline void CSSycPlayerInfoResp::set_remaintime(const ::std::string& value) {
  set_has_remaintime();
  if (remaintime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remaintime_ = new ::std::string;
  }
  remaintime_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.RemainTime)
}
inline void CSSycPlayerInfoResp::set_remaintime(const char* value) {
  set_has_remaintime();
  if (remaintime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remaintime_ = new ::std::string;
  }
  remaintime_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSSycPlayerInfoResp.RemainTime)
}
inline void CSSycPlayerInfoResp::set_remaintime(const char* value, size_t size) {
  set_has_remaintime();
  if (remaintime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remaintime_ = new ::std::string;
  }
  remaintime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSSycPlayerInfoResp.RemainTime)
}
inline ::std::string* CSSycPlayerInfoResp::mutable_remaintime() {
  set_has_remaintime();
  if (remaintime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remaintime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSSycPlayerInfoResp.RemainTime)
  return remaintime_;
}
inline ::std::string* CSSycPlayerInfoResp::release_remaintime() {
  clear_has_remaintime();
  if (remaintime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remaintime_;
    remaintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSSycPlayerInfoResp::set_allocated_remaintime(::std::string* remaintime) {
  if (remaintime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remaintime_;
  }
  if (remaintime) {
    set_has_remaintime();
    remaintime_ = remaintime;
  } else {
    clear_has_remaintime();
    remaintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSSycPlayerInfoResp.RemainTime)
}

// optional uint32 ExpLevel = 18;
inline bool CSSycPlayerInfoResp::has_explevel() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_explevel() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CSSycPlayerInfoResp::clear_has_explevel() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CSSycPlayerInfoResp::clear_explevel() {
  explevel_ = 0u;
  clear_has_explevel();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::explevel() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.ExpLevel)
  return explevel_;
}
inline void CSSycPlayerInfoResp::set_explevel(::google::protobuf::uint32 value) {
  set_has_explevel();
  explevel_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.ExpLevel)
}

// optional uint32 Exp = 19;
inline bool CSSycPlayerInfoResp::has_exp() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_exp() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CSSycPlayerInfoResp::clear_has_exp() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CSSycPlayerInfoResp::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::exp() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.Exp)
  return exp_;
}
inline void CSSycPlayerInfoResp::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.Exp)
}

// repeated .fgame.CSTitleItem TitleItems = 20;
inline int CSSycPlayerInfoResp::titleitems_size() const {
  return titleitems_.size();
}
inline void CSSycPlayerInfoResp::clear_titleitems() {
  titleitems_.Clear();
}
inline const ::fgame::CSTitleItem& CSSycPlayerInfoResp::titleitems(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.TitleItems)
  return titleitems_.Get(index);
}
inline ::fgame::CSTitleItem* CSSycPlayerInfoResp::mutable_titleitems(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSSycPlayerInfoResp.TitleItems)
  return titleitems_.Mutable(index);
}
inline ::fgame::CSTitleItem* CSSycPlayerInfoResp::add_titleitems() {
  // @@protoc_insertion_point(field_add:fgame.CSSycPlayerInfoResp.TitleItems)
  return titleitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSTitleItem >&
CSSycPlayerInfoResp::titleitems() const {
  // @@protoc_insertion_point(field_list:fgame.CSSycPlayerInfoResp.TitleItems)
  return titleitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSTitleItem >*
CSSycPlayerInfoResp::mutable_titleitems() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSSycPlayerInfoResp.TitleItems)
  return &titleitems_;
}

// optional uint32 Rank = 21;
inline bool CSSycPlayerInfoResp::has_rank() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_rank() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CSSycPlayerInfoResp::clear_has_rank() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CSSycPlayerInfoResp::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::rank() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.Rank)
  return rank_;
}
inline void CSSycPlayerInfoResp::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.Rank)
}

// optional float WinRate = 22;
inline bool CSSycPlayerInfoResp::has_winrate() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_winrate() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CSSycPlayerInfoResp::clear_has_winrate() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CSSycPlayerInfoResp::clear_winrate() {
  winrate_ = 0;
  clear_has_winrate();
}
inline float CSSycPlayerInfoResp::winrate() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.WinRate)
  return winrate_;
}
inline void CSSycPlayerInfoResp::set_winrate(float value) {
  set_has_winrate();
  winrate_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.WinRate)
}

// optional uint32 Score = 23;
inline bool CSSycPlayerInfoResp::has_score() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_score() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CSSycPlayerInfoResp::clear_has_score() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CSSycPlayerInfoResp::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::score() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.Score)
  return score_;
}
inline void CSSycPlayerInfoResp::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.Score)
}

// optional uint32 AchievementLevel = 24;
inline bool CSSycPlayerInfoResp::has_achievementlevel() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_achievementlevel() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CSSycPlayerInfoResp::clear_has_achievementlevel() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CSSycPlayerInfoResp::clear_achievementlevel() {
  achievementlevel_ = 0u;
  clear_has_achievementlevel();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::achievementlevel() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.AchievementLevel)
  return achievementlevel_;
}
inline void CSSycPlayerInfoResp::set_achievementlevel(::google::protobuf::uint32 value) {
  set_has_achievementlevel();
  achievementlevel_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.AchievementLevel)
}

// optional uint32 HonorCount = 25;
inline bool CSSycPlayerInfoResp::has_honorcount() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_honorcount() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CSSycPlayerInfoResp::clear_has_honorcount() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CSSycPlayerInfoResp::clear_honorcount() {
  honorcount_ = 0u;
  clear_has_honorcount();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::honorcount() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.HonorCount)
  return honorcount_;
}
inline void CSSycPlayerInfoResp::set_honorcount(::google::protobuf::uint32 value) {
  set_has_honorcount();
  honorcount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.HonorCount)
}

// optional uint32 PvpRound = 26;
inline bool CSSycPlayerInfoResp::has_pvpround() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_pvpround() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CSSycPlayerInfoResp::clear_has_pvpround() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CSSycPlayerInfoResp::clear_pvpround() {
  pvpround_ = 0u;
  clear_has_pvpround();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::pvpround() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.PvpRound)
  return pvpround_;
}
inline void CSSycPlayerInfoResp::set_pvpround(::google::protobuf::uint32 value) {
  set_has_pvpround();
  pvpround_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.PvpRound)
}

// optional uint32 AddExp = 27;
inline bool CSSycPlayerInfoResp::has_addexp() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_addexp() {
  _has_bits_[0] |= 0x04000000u;
}
inline void CSSycPlayerInfoResp::clear_has_addexp() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void CSSycPlayerInfoResp::clear_addexp() {
  addexp_ = 0u;
  clear_has_addexp();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::addexp() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.AddExp)
  return addexp_;
}
inline void CSSycPlayerInfoResp::set_addexp(::google::protobuf::uint32 value) {
  set_has_addexp();
  addexp_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.AddExp)
}

// optional uint32 GlyphGuide = 28;
inline bool CSSycPlayerInfoResp::has_glyphguide() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_glyphguide() {
  _has_bits_[0] |= 0x08000000u;
}
inline void CSSycPlayerInfoResp::clear_has_glyphguide() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void CSSycPlayerInfoResp::clear_glyphguide() {
  glyphguide_ = 0u;
  clear_has_glyphguide();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::glyphguide() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.GlyphGuide)
  return glyphguide_;
}
inline void CSSycPlayerInfoResp::set_glyphguide(::google::protobuf::uint32 value) {
  set_has_glyphguide();
  glyphguide_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.GlyphGuide)
}

// optional uint32 ChatFreeCount = 29;
inline bool CSSycPlayerInfoResp::has_chatfreecount() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_chatfreecount() {
  _has_bits_[0] |= 0x10000000u;
}
inline void CSSycPlayerInfoResp::clear_has_chatfreecount() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void CSSycPlayerInfoResp::clear_chatfreecount() {
  chatfreecount_ = 0u;
  clear_has_chatfreecount();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::chatfreecount() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.ChatFreeCount)
  return chatfreecount_;
}
inline void CSSycPlayerInfoResp::set_chatfreecount(::google::protobuf::uint32 value) {
  set_has_chatfreecount();
  chatfreecount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.ChatFreeCount)
}

// optional uint32 TimeLeft = 30;
inline bool CSSycPlayerInfoResp::has_timeleft() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_timeleft() {
  _has_bits_[0] |= 0x20000000u;
}
inline void CSSycPlayerInfoResp::clear_has_timeleft() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void CSSycPlayerInfoResp::clear_timeleft() {
  timeleft_ = 0u;
  clear_has_timeleft();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::timeleft() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.TimeLeft)
  return timeleft_;
}
inline void CSSycPlayerInfoResp::set_timeleft(::google::protobuf::uint32 value) {
  set_has_timeleft();
  timeleft_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.TimeLeft)
}

// optional uint32 Area = 31;
inline bool CSSycPlayerInfoResp::has_area() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void CSSycPlayerInfoResp::set_has_area() {
  _has_bits_[0] |= 0x40000000u;
}
inline void CSSycPlayerInfoResp::clear_has_area() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void CSSycPlayerInfoResp::clear_area() {
  area_ = 0u;
  clear_has_area();
}
inline ::google::protobuf::uint32 CSSycPlayerInfoResp::area() const {
  // @@protoc_insertion_point(field_get:fgame.CSSycPlayerInfoResp.Area)
  return area_;
}
inline void CSSycPlayerInfoResp::set_area(::google::protobuf::uint32 value) {
  set_has_area();
  area_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSycPlayerInfoResp.Area)
}

// -------------------------------------------------------------------

// CSSyncPlayerDataReq

// required string PlayerData = 1;
inline bool CSSyncPlayerDataReq::has_playerdata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSyncPlayerDataReq::set_has_playerdata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSyncPlayerDataReq::clear_has_playerdata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSyncPlayerDataReq::clear_playerdata() {
  if (playerdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playerdata_->clear();
  }
  clear_has_playerdata();
}
inline const ::std::string& CSSyncPlayerDataReq::playerdata() const {
  // @@protoc_insertion_point(field_get:fgame.CSSyncPlayerDataReq.PlayerData)
  return *playerdata_;
}
inline void CSSyncPlayerDataReq::set_playerdata(const ::std::string& value) {
  set_has_playerdata();
  if (playerdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playerdata_ = new ::std::string;
  }
  playerdata_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSSyncPlayerDataReq.PlayerData)
}
inline void CSSyncPlayerDataReq::set_playerdata(const char* value) {
  set_has_playerdata();
  if (playerdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playerdata_ = new ::std::string;
  }
  playerdata_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSSyncPlayerDataReq.PlayerData)
}
inline void CSSyncPlayerDataReq::set_playerdata(const char* value, size_t size) {
  set_has_playerdata();
  if (playerdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playerdata_ = new ::std::string;
  }
  playerdata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSSyncPlayerDataReq.PlayerData)
}
inline ::std::string* CSSyncPlayerDataReq::mutable_playerdata() {
  set_has_playerdata();
  if (playerdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playerdata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSSyncPlayerDataReq.PlayerData)
  return playerdata_;
}
inline ::std::string* CSSyncPlayerDataReq::release_playerdata() {
  clear_has_playerdata();
  if (playerdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = playerdata_;
    playerdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSSyncPlayerDataReq::set_allocated_playerdata(::std::string* playerdata) {
  if (playerdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete playerdata_;
  }
  if (playerdata) {
    set_has_playerdata();
    playerdata_ = playerdata;
  } else {
    clear_has_playerdata();
    playerdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSSyncPlayerDataReq.PlayerData)
}

// -------------------------------------------------------------------

// CSSyncPlayerDataResp

// required uint32 Ret = 1;
inline bool CSSyncPlayerDataResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSyncPlayerDataResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSyncPlayerDataResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSyncPlayerDataResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSSyncPlayerDataResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSSyncPlayerDataResp.Ret)
  return ret_;
}
inline void CSSyncPlayerDataResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSyncPlayerDataResp.Ret)
}

// -------------------------------------------------------------------

// CSGetPlayerDataReq

// -------------------------------------------------------------------

// CSGetPlayerDataResp

// required uint32 Ret = 1;
inline bool CSGetPlayerDataResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGetPlayerDataResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGetPlayerDataResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGetPlayerDataResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSGetPlayerDataResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetPlayerDataResp.Ret)
  return ret_;
}
inline void CSGetPlayerDataResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetPlayerDataResp.Ret)
}

// required string PlayerData = 2;
inline bool CSGetPlayerDataResp::has_playerdata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGetPlayerDataResp::set_has_playerdata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGetPlayerDataResp::clear_has_playerdata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGetPlayerDataResp::clear_playerdata() {
  if (playerdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playerdata_->clear();
  }
  clear_has_playerdata();
}
inline const ::std::string& CSGetPlayerDataResp::playerdata() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetPlayerDataResp.PlayerData)
  return *playerdata_;
}
inline void CSGetPlayerDataResp::set_playerdata(const ::std::string& value) {
  set_has_playerdata();
  if (playerdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playerdata_ = new ::std::string;
  }
  playerdata_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSGetPlayerDataResp.PlayerData)
}
inline void CSGetPlayerDataResp::set_playerdata(const char* value) {
  set_has_playerdata();
  if (playerdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playerdata_ = new ::std::string;
  }
  playerdata_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSGetPlayerDataResp.PlayerData)
}
inline void CSGetPlayerDataResp::set_playerdata(const char* value, size_t size) {
  set_has_playerdata();
  if (playerdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playerdata_ = new ::std::string;
  }
  playerdata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSGetPlayerDataResp.PlayerData)
}
inline ::std::string* CSGetPlayerDataResp::mutable_playerdata() {
  set_has_playerdata();
  if (playerdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playerdata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSGetPlayerDataResp.PlayerData)
  return playerdata_;
}
inline ::std::string* CSGetPlayerDataResp::release_playerdata() {
  clear_has_playerdata();
  if (playerdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = playerdata_;
    playerdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSGetPlayerDataResp::set_allocated_playerdata(::std::string* playerdata) {
  if (playerdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete playerdata_;
  }
  if (playerdata) {
    set_has_playerdata();
    playerdata_ = playerdata;
  } else {
    clear_has_playerdata();
    playerdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSGetPlayerDataResp.PlayerData)
}

// -------------------------------------------------------------------

// CSNoticeReq

// required uint32 NoticeType = 1;
inline bool CSNoticeReq::has_noticetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSNoticeReq::set_has_noticetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSNoticeReq::clear_has_noticetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSNoticeReq::clear_noticetype() {
  noticetype_ = 0u;
  clear_has_noticetype();
}
inline ::google::protobuf::uint32 CSNoticeReq::noticetype() const {
  // @@protoc_insertion_point(field_get:fgame.CSNoticeReq.NoticeType)
  return noticetype_;
}
inline void CSNoticeReq::set_noticetype(::google::protobuf::uint32 value) {
  set_has_noticetype();
  noticetype_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSNoticeReq.NoticeType)
}

// required uint32 Serious = 2;
inline bool CSNoticeReq::has_serious() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSNoticeReq::set_has_serious() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSNoticeReq::clear_has_serious() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSNoticeReq::clear_serious() {
  serious_ = 0u;
  clear_has_serious();
}
inline ::google::protobuf::uint32 CSNoticeReq::serious() const {
  // @@protoc_insertion_point(field_get:fgame.CSNoticeReq.Serious)
  return serious_;
}
inline void CSNoticeReq::set_serious(::google::protobuf::uint32 value) {
  set_has_serious();
  serious_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSNoticeReq.Serious)
}

// required string Content = 3;
inline bool CSNoticeReq::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSNoticeReq::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSNoticeReq::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSNoticeReq::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& CSNoticeReq::content() const {
  // @@protoc_insertion_point(field_get:fgame.CSNoticeReq.Content)
  return *content_;
}
inline void CSNoticeReq::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSNoticeReq.Content)
}
inline void CSNoticeReq::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSNoticeReq.Content)
}
inline void CSNoticeReq::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSNoticeReq.Content)
}
inline ::std::string* CSNoticeReq::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSNoticeReq.Content)
  return content_;
}
inline ::std::string* CSNoticeReq::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSNoticeReq::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSNoticeReq.Content)
}

// optional string Title = 4;
inline bool CSNoticeReq::has_title() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSNoticeReq::set_has_title() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSNoticeReq::clear_has_title() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSNoticeReq::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& CSNoticeReq::title() const {
  // @@protoc_insertion_point(field_get:fgame.CSNoticeReq.Title)
  return *title_;
}
inline void CSNoticeReq::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSNoticeReq.Title)
}
inline void CSNoticeReq::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSNoticeReq.Title)
}
inline void CSNoticeReq::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSNoticeReq.Title)
}
inline ::std::string* CSNoticeReq::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSNoticeReq.Title)
  return title_;
}
inline ::std::string* CSNoticeReq::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSNoticeReq::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSNoticeReq.Title)
}

// optional uint32 Count = 5;
inline bool CSNoticeReq::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSNoticeReq::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSNoticeReq::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSNoticeReq::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CSNoticeReq::count() const {
  // @@protoc_insertion_point(field_get:fgame.CSNoticeReq.Count)
  return count_;
}
inline void CSNoticeReq::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSNoticeReq.Count)
}

// optional uint32 TimeGap = 6;
inline bool CSNoticeReq::has_timegap() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSNoticeReq::set_has_timegap() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSNoticeReq::clear_has_timegap() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSNoticeReq::clear_timegap() {
  timegap_ = 0u;
  clear_has_timegap();
}
inline ::google::protobuf::uint32 CSNoticeReq::timegap() const {
  // @@protoc_insertion_point(field_get:fgame.CSNoticeReq.TimeGap)
  return timegap_;
}
inline void CSNoticeReq::set_timegap(::google::protobuf::uint32 value) {
  set_has_timegap();
  timegap_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSNoticeReq.TimeGap)
}

// -------------------------------------------------------------------

// CSChangeNameReq

// optional string Name = 1;
inline bool CSChangeNameReq::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChangeNameReq::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChangeNameReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChangeNameReq::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSChangeNameReq::name() const {
  // @@protoc_insertion_point(field_get:fgame.CSChangeNameReq.Name)
  return *name_;
}
inline void CSChangeNameReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSChangeNameReq.Name)
}
inline void CSChangeNameReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSChangeNameReq.Name)
}
inline void CSChangeNameReq::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSChangeNameReq.Name)
}
inline ::std::string* CSChangeNameReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSChangeNameReq.Name)
  return name_;
}
inline ::std::string* CSChangeNameReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSChangeNameReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSChangeNameReq.Name)
}

// optional uint32 Area = 2;
inline bool CSChangeNameReq::has_area() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSChangeNameReq::set_has_area() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSChangeNameReq::clear_has_area() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSChangeNameReq::clear_area() {
  area_ = 0u;
  clear_has_area();
}
inline ::google::protobuf::uint32 CSChangeNameReq::area() const {
  // @@protoc_insertion_point(field_get:fgame.CSChangeNameReq.Area)
  return area_;
}
inline void CSChangeNameReq::set_area(::google::protobuf::uint32 value) {
  set_has_area();
  area_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSChangeNameReq.Area)
}

// -------------------------------------------------------------------

// CSChangeNameResp

// required uint32 Ret = 1;
inline bool CSChangeNameResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChangeNameResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChangeNameResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChangeNameResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSChangeNameResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSChangeNameResp.Ret)
  return ret_;
}
inline void CSChangeNameResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSChangeNameResp.Ret)
}

// -------------------------------------------------------------------

// CSGMCmdReq

// required uint32 GMType = 1;
inline bool CSGMCmdReq::has_gmtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGMCmdReq::set_has_gmtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGMCmdReq::clear_has_gmtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGMCmdReq::clear_gmtype() {
  gmtype_ = 0u;
  clear_has_gmtype();
}
inline ::google::protobuf::uint32 CSGMCmdReq::gmtype() const {
  // @@protoc_insertion_point(field_get:fgame.CSGMCmdReq.GMType)
  return gmtype_;
}
inline void CSGMCmdReq::set_gmtype(::google::protobuf::uint32 value) {
  set_has_gmtype();
  gmtype_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGMCmdReq.GMType)
}

// optional uint32 Value = 2;
inline bool CSGMCmdReq::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGMCmdReq::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGMCmdReq::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGMCmdReq::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 CSGMCmdReq::value() const {
  // @@protoc_insertion_point(field_get:fgame.CSGMCmdReq.Value)
  return value_;
}
inline void CSGMCmdReq::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGMCmdReq.Value)
}

// -------------------------------------------------------------------

// CSXinShouRecodeReq

// required uint32 Id = 1;
inline bool CSXinShouRecodeReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSXinShouRecodeReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSXinShouRecodeReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSXinShouRecodeReq::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSXinShouRecodeReq::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSXinShouRecodeReq.Id)
  return id_;
}
inline void CSXinShouRecodeReq::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSXinShouRecodeReq.Id)
}

// -------------------------------------------------------------------

// CSXinShouRecodeResp

// -------------------------------------------------------------------

// CSMission

// required uint32 MissionId = 1;
inline bool CSMission::has_missionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMission::set_has_missionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMission::clear_has_missionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMission::clear_missionid() {
  missionid_ = 0u;
  clear_has_missionid();
}
inline ::google::protobuf::uint32 CSMission::missionid() const {
  // @@protoc_insertion_point(field_get:fgame.CSMission.MissionId)
  return missionid_;
}
inline void CSMission::set_missionid(::google::protobuf::uint32 value) {
  set_has_missionid();
  missionid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSMission.MissionId)
}

// optional uint32 Value = 2;
inline bool CSMission::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMission::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMission::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMission::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 CSMission::value() const {
  // @@protoc_insertion_point(field_get:fgame.CSMission.Value)
  return value_;
}
inline void CSMission::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSMission.Value)
}

// optional bool Completed = 3;
inline bool CSMission::has_completed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMission::set_has_completed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMission::clear_has_completed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMission::clear_completed() {
  completed_ = false;
  clear_has_completed();
}
inline bool CSMission::completed() const {
  // @@protoc_insertion_point(field_get:fgame.CSMission.Completed)
  return completed_;
}
inline void CSMission::set_completed(bool value) {
  set_has_completed();
  completed_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSMission.Completed)
}

// optional uint32 Request = 4;
inline bool CSMission::has_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSMission::set_has_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSMission::clear_has_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSMission::clear_request() {
  request_ = 0u;
  clear_has_request();
}
inline ::google::protobuf::uint32 CSMission::request() const {
  // @@protoc_insertion_point(field_get:fgame.CSMission.Request)
  return request_;
}
inline void CSMission::set_request(::google::protobuf::uint32 value) {
  set_has_request();
  request_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSMission.Request)
}

// optional uint32 GiftId = 5;
inline bool CSMission::has_giftid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSMission::set_has_giftid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSMission::clear_has_giftid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSMission::clear_giftid() {
  giftid_ = 0u;
  clear_has_giftid();
}
inline ::google::protobuf::uint32 CSMission::giftid() const {
  // @@protoc_insertion_point(field_get:fgame.CSMission.GiftId)
  return giftid_;
}
inline void CSMission::set_giftid(::google::protobuf::uint32 value) {
  set_has_giftid();
  giftid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSMission.GiftId)
}

// -------------------------------------------------------------------

// CSMissionListReq

// -------------------------------------------------------------------

// CSMissionListResp

// optional uint32 MissionDay = 1;
inline bool CSMissionListResp::has_missionday() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMissionListResp::set_has_missionday() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMissionListResp::clear_has_missionday() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMissionListResp::clear_missionday() {
  missionday_ = 0u;
  clear_has_missionday();
}
inline ::google::protobuf::uint32 CSMissionListResp::missionday() const {
  // @@protoc_insertion_point(field_get:fgame.CSMissionListResp.MissionDay)
  return missionday_;
}
inline void CSMissionListResp::set_missionday(::google::protobuf::uint32 value) {
  set_has_missionday();
  missionday_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSMissionListResp.MissionDay)
}

// repeated .fgame.CSMission Missions = 2;
inline int CSMissionListResp::missions_size() const {
  return missions_.size();
}
inline void CSMissionListResp::clear_missions() {
  missions_.Clear();
}
inline const ::fgame::CSMission& CSMissionListResp::missions(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSMissionListResp.Missions)
  return missions_.Get(index);
}
inline ::fgame::CSMission* CSMissionListResp::mutable_missions(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSMissionListResp.Missions)
  return missions_.Mutable(index);
}
inline ::fgame::CSMission* CSMissionListResp::add_missions() {
  // @@protoc_insertion_point(field_add:fgame.CSMissionListResp.Missions)
  return missions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSMission >&
CSMissionListResp::missions() const {
  // @@protoc_insertion_point(field_list:fgame.CSMissionListResp.Missions)
  return missions_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSMission >*
CSMissionListResp::mutable_missions() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSMissionListResp.Missions)
  return &missions_;
}

// -------------------------------------------------------------------

// CSMissionCompleteReq

// required uint32 MissionId = 1;
inline bool CSMissionCompleteReq::has_missionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMissionCompleteReq::set_has_missionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMissionCompleteReq::clear_has_missionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMissionCompleteReq::clear_missionid() {
  missionid_ = 0u;
  clear_has_missionid();
}
inline ::google::protobuf::uint32 CSMissionCompleteReq::missionid() const {
  // @@protoc_insertion_point(field_get:fgame.CSMissionCompleteReq.MissionId)
  return missionid_;
}
inline void CSMissionCompleteReq::set_missionid(::google::protobuf::uint32 value) {
  set_has_missionid();
  missionid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSMissionCompleteReq.MissionId)
}

// -------------------------------------------------------------------

// CSMissionCompleteResp

// required .fgame.CSMission Mission = 1;
inline bool CSMissionCompleteResp::has_mission() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMissionCompleteResp::set_has_mission() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMissionCompleteResp::clear_has_mission() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMissionCompleteResp::clear_mission() {
  if (mission_ != NULL) mission_->::fgame::CSMission::Clear();
  clear_has_mission();
}
inline const ::fgame::CSMission& CSMissionCompleteResp::mission() const {
  // @@protoc_insertion_point(field_get:fgame.CSMissionCompleteResp.Mission)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return mission_ != NULL ? *mission_ : *default_instance().mission_;
#else
  return mission_ != NULL ? *mission_ : *default_instance_->mission_;
#endif
}
inline ::fgame::CSMission* CSMissionCompleteResp::mutable_mission() {
  set_has_mission();
  if (mission_ == NULL) mission_ = new ::fgame::CSMission;
  // @@protoc_insertion_point(field_mutable:fgame.CSMissionCompleteResp.Mission)
  return mission_;
}
inline ::fgame::CSMission* CSMissionCompleteResp::release_mission() {
  clear_has_mission();
  ::fgame::CSMission* temp = mission_;
  mission_ = NULL;
  return temp;
}
inline void CSMissionCompleteResp::set_allocated_mission(::fgame::CSMission* mission) {
  delete mission_;
  mission_ = mission;
  if (mission) {
    set_has_mission();
  } else {
    clear_has_mission();
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSMissionCompleteResp.Mission)
}

// -------------------------------------------------------------------

// CSMissionUpdateResp

// required uint32 MissionId = 1;
inline bool CSMissionUpdateResp::has_missionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMissionUpdateResp::set_has_missionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMissionUpdateResp::clear_has_missionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMissionUpdateResp::clear_missionid() {
  missionid_ = 0u;
  clear_has_missionid();
}
inline ::google::protobuf::uint32 CSMissionUpdateResp::missionid() const {
  // @@protoc_insertion_point(field_get:fgame.CSMissionUpdateResp.MissionId)
  return missionid_;
}
inline void CSMissionUpdateResp::set_missionid(::google::protobuf::uint32 value) {
  set_has_missionid();
  missionid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSMissionUpdateResp.MissionId)
}

// required uint32 Value = 2;
inline bool CSMissionUpdateResp::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMissionUpdateResp::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMissionUpdateResp::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMissionUpdateResp::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 CSMissionUpdateResp::value() const {
  // @@protoc_insertion_point(field_get:fgame.CSMissionUpdateResp.Value)
  return value_;
}
inline void CSMissionUpdateResp::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSMissionUpdateResp.Value)
}

// -------------------------------------------------------------------

// CSBuyNewbieGiftReq

// required uint32 Id = 1;
inline bool CSBuyNewbieGiftReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyNewbieGiftReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyNewbieGiftReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyNewbieGiftReq::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSBuyNewbieGiftReq::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSBuyNewbieGiftReq.Id)
  return id_;
}
inline void CSBuyNewbieGiftReq::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSBuyNewbieGiftReq.Id)
}

// -------------------------------------------------------------------

// CSBuyNewbieGiftResp

// required uint32 Ret = 1;
inline bool CSBuyNewbieGiftResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyNewbieGiftResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyNewbieGiftResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyNewbieGiftResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSBuyNewbieGiftResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSBuyNewbieGiftResp.Ret)
  return ret_;
}
inline void CSBuyNewbieGiftResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSBuyNewbieGiftResp.Ret)
}

// -------------------------------------------------------------------

// CSMailInfo

// required uint32 Id = 1;
inline bool CSMailInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMailInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMailInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMailInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSMailInfo::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSMailInfo.Id)
  return id_;
}
inline void CSMailInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSMailInfo.Id)
}

// required string Title = 2;
inline bool CSMailInfo::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMailInfo::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMailInfo::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMailInfo::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& CSMailInfo::title() const {
  // @@protoc_insertion_point(field_get:fgame.CSMailInfo.Title)
  return *title_;
}
inline void CSMailInfo::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSMailInfo.Title)
}
inline void CSMailInfo::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSMailInfo.Title)
}
inline void CSMailInfo::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSMailInfo.Title)
}
inline ::std::string* CSMailInfo::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSMailInfo.Title)
  return title_;
}
inline ::std::string* CSMailInfo::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSMailInfo::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSMailInfo.Title)
}

// required string Content = 3;
inline bool CSMailInfo::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMailInfo::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMailInfo::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMailInfo::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& CSMailInfo::content() const {
  // @@protoc_insertion_point(field_get:fgame.CSMailInfo.Content)
  return *content_;
}
inline void CSMailInfo::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSMailInfo.Content)
}
inline void CSMailInfo::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSMailInfo.Content)
}
inline void CSMailInfo::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSMailInfo.Content)
}
inline ::std::string* CSMailInfo::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSMailInfo.Content)
  return content_;
}
inline ::std::string* CSMailInfo::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSMailInfo::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSMailInfo.Content)
}

// required string PlugIn = 4;
inline bool CSMailInfo::has_plugin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSMailInfo::set_has_plugin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSMailInfo::clear_has_plugin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSMailInfo::clear_plugin() {
  if (plugin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    plugin_->clear();
  }
  clear_has_plugin();
}
inline const ::std::string& CSMailInfo::plugin() const {
  // @@protoc_insertion_point(field_get:fgame.CSMailInfo.PlugIn)
  return *plugin_;
}
inline void CSMailInfo::set_plugin(const ::std::string& value) {
  set_has_plugin();
  if (plugin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    plugin_ = new ::std::string;
  }
  plugin_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSMailInfo.PlugIn)
}
inline void CSMailInfo::set_plugin(const char* value) {
  set_has_plugin();
  if (plugin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    plugin_ = new ::std::string;
  }
  plugin_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSMailInfo.PlugIn)
}
inline void CSMailInfo::set_plugin(const char* value, size_t size) {
  set_has_plugin();
  if (plugin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    plugin_ = new ::std::string;
  }
  plugin_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSMailInfo.PlugIn)
}
inline ::std::string* CSMailInfo::mutable_plugin() {
  set_has_plugin();
  if (plugin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    plugin_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSMailInfo.PlugIn)
  return plugin_;
}
inline ::std::string* CSMailInfo::release_plugin() {
  clear_has_plugin();
  if (plugin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = plugin_;
    plugin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSMailInfo::set_allocated_plugin(::std::string* plugin) {
  if (plugin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete plugin_;
  }
  if (plugin) {
    set_has_plugin();
    plugin_ = plugin;
  } else {
    clear_has_plugin();
    plugin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSMailInfo.PlugIn)
}

// required uint32 SendTime = 5;
inline bool CSMailInfo::has_sendtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSMailInfo::set_has_sendtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSMailInfo::clear_has_sendtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSMailInfo::clear_sendtime() {
  sendtime_ = 0u;
  clear_has_sendtime();
}
inline ::google::protobuf::uint32 CSMailInfo::sendtime() const {
  // @@protoc_insertion_point(field_get:fgame.CSMailInfo.SendTime)
  return sendtime_;
}
inline void CSMailInfo::set_sendtime(::google::protobuf::uint32 value) {
  set_has_sendtime();
  sendtime_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSMailInfo.SendTime)
}

// required uint32 OutDate = 6;
inline bool CSMailInfo::has_outdate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSMailInfo::set_has_outdate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSMailInfo::clear_has_outdate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSMailInfo::clear_outdate() {
  outdate_ = 0u;
  clear_has_outdate();
}
inline ::google::protobuf::uint32 CSMailInfo::outdate() const {
  // @@protoc_insertion_point(field_get:fgame.CSMailInfo.OutDate)
  return outdate_;
}
inline void CSMailInfo::set_outdate(::google::protobuf::uint32 value) {
  set_has_outdate();
  outdate_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSMailInfo.OutDate)
}

// -------------------------------------------------------------------

// CSGetMailReq

// required uint32 GetNum = 1;
inline bool CSGetMailReq::has_getnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGetMailReq::set_has_getnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGetMailReq::clear_has_getnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGetMailReq::clear_getnum() {
  getnum_ = 0u;
  clear_has_getnum();
}
inline ::google::protobuf::uint32 CSGetMailReq::getnum() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetMailReq.GetNum)
  return getnum_;
}
inline void CSGetMailReq::set_getnum(::google::protobuf::uint32 value) {
  set_has_getnum();
  getnum_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetMailReq.GetNum)
}

// -------------------------------------------------------------------

// CSGetMailResp

// optional bool NewMail = 1;
inline bool CSGetMailResp::has_newmail() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGetMailResp::set_has_newmail() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGetMailResp::clear_has_newmail() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGetMailResp::clear_newmail() {
  newmail_ = false;
  clear_has_newmail();
}
inline bool CSGetMailResp::newmail() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetMailResp.NewMail)
  return newmail_;
}
inline void CSGetMailResp::set_newmail(bool value) {
  set_has_newmail();
  newmail_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetMailResp.NewMail)
}

// optional uint32 MailNO = 2;
inline bool CSGetMailResp::has_mailno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGetMailResp::set_has_mailno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGetMailResp::clear_has_mailno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGetMailResp::clear_mailno() {
  mailno_ = 0u;
  clear_has_mailno();
}
inline ::google::protobuf::uint32 CSGetMailResp::mailno() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetMailResp.MailNO)
  return mailno_;
}
inline void CSGetMailResp::set_mailno(::google::protobuf::uint32 value) {
  set_has_mailno();
  mailno_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetMailResp.MailNO)
}

// repeated .fgame.CSMailInfo MailInfo = 3;
inline int CSGetMailResp::mailinfo_size() const {
  return mailinfo_.size();
}
inline void CSGetMailResp::clear_mailinfo() {
  mailinfo_.Clear();
}
inline const ::fgame::CSMailInfo& CSGetMailResp::mailinfo(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSGetMailResp.MailInfo)
  return mailinfo_.Get(index);
}
inline ::fgame::CSMailInfo* CSGetMailResp::mutable_mailinfo(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSGetMailResp.MailInfo)
  return mailinfo_.Mutable(index);
}
inline ::fgame::CSMailInfo* CSGetMailResp::add_mailinfo() {
  // @@protoc_insertion_point(field_add:fgame.CSGetMailResp.MailInfo)
  return mailinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSMailInfo >&
CSGetMailResp::mailinfo() const {
  // @@protoc_insertion_point(field_list:fgame.CSGetMailResp.MailInfo)
  return mailinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSMailInfo >*
CSGetMailResp::mutable_mailinfo() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSGetMailResp.MailInfo)
  return &mailinfo_;
}

// -------------------------------------------------------------------

// CSDelMailReq

// repeated uint32 Id = 1;
inline int CSDelMailReq::id_size() const {
  return id_.size();
}
inline void CSDelMailReq::clear_id() {
  id_.Clear();
}
inline ::google::protobuf::uint32 CSDelMailReq::id(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSDelMailReq.Id)
  return id_.Get(index);
}
inline void CSDelMailReq::set_id(int index, ::google::protobuf::uint32 value) {
  id_.Set(index, value);
  // @@protoc_insertion_point(field_set:fgame.CSDelMailReq.Id)
}
inline void CSDelMailReq::add_id(::google::protobuf::uint32 value) {
  id_.Add(value);
  // @@protoc_insertion_point(field_add:fgame.CSDelMailReq.Id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSDelMailReq::id() const {
  // @@protoc_insertion_point(field_list:fgame.CSDelMailReq.Id)
  return id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSDelMailReq::mutable_id() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSDelMailReq.Id)
  return &id_;
}

// -------------------------------------------------------------------

// CSDelMailResp

// repeated uint32 Ret = 1;
inline int CSDelMailResp::ret_size() const {
  return ret_.size();
}
inline void CSDelMailResp::clear_ret() {
  ret_.Clear();
}
inline ::google::protobuf::uint32 CSDelMailResp::ret(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSDelMailResp.Ret)
  return ret_.Get(index);
}
inline void CSDelMailResp::set_ret(int index, ::google::protobuf::uint32 value) {
  ret_.Set(index, value);
  // @@protoc_insertion_point(field_set:fgame.CSDelMailResp.Ret)
}
inline void CSDelMailResp::add_ret(::google::protobuf::uint32 value) {
  ret_.Add(value);
  // @@protoc_insertion_point(field_add:fgame.CSDelMailResp.Ret)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSDelMailResp::ret() const {
  // @@protoc_insertion_point(field_list:fgame.CSDelMailResp.Ret)
  return ret_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSDelMailResp::mutable_ret() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSDelMailResp.Ret)
  return &ret_;
}

// -------------------------------------------------------------------

// CSNoticeMailReq

// -------------------------------------------------------------------

// CSRechargeCallbackReq

// required uint32 Id = 1;
inline bool CSRechargeCallbackReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRechargeCallbackReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRechargeCallbackReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRechargeCallbackReq::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSRechargeCallbackReq::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSRechargeCallbackReq.Id)
  return id_;
}
inline void CSRechargeCallbackReq::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRechargeCallbackReq.Id)
}

// -------------------------------------------------------------------

// CSRechargeCallbackResp

// required uint32 Ret = 1;
inline bool CSRechargeCallbackResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRechargeCallbackResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRechargeCallbackResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRechargeCallbackResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSRechargeCallbackResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSRechargeCallbackResp.Ret)
  return ret_;
}
inline void CSRechargeCallbackResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRechargeCallbackResp.Ret)
}

// required uint32 Id = 2;
inline bool CSRechargeCallbackResp::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRechargeCallbackResp::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRechargeCallbackResp::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRechargeCallbackResp::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSRechargeCallbackResp::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSRechargeCallbackResp.Id)
  return id_;
}
inline void CSRechargeCallbackResp::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRechargeCallbackResp.Id)
}

// required string OrderId = 3;
inline bool CSRechargeCallbackResp::has_orderid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSRechargeCallbackResp::set_has_orderid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSRechargeCallbackResp::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSRechargeCallbackResp::clear_orderid() {
  if (orderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_->clear();
  }
  clear_has_orderid();
}
inline const ::std::string& CSRechargeCallbackResp::orderid() const {
  // @@protoc_insertion_point(field_get:fgame.CSRechargeCallbackResp.OrderId)
  return *orderid_;
}
inline void CSRechargeCallbackResp::set_orderid(const ::std::string& value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSRechargeCallbackResp.OrderId)
}
inline void CSRechargeCallbackResp::set_orderid(const char* value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSRechargeCallbackResp.OrderId)
}
inline void CSRechargeCallbackResp::set_orderid(const char* value, size_t size) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSRechargeCallbackResp.OrderId)
}
inline ::std::string* CSRechargeCallbackResp::mutable_orderid() {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSRechargeCallbackResp.OrderId)
  return orderid_;
}
inline ::std::string* CSRechargeCallbackResp::release_orderid() {
  clear_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = orderid_;
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSRechargeCallbackResp::set_allocated_orderid(::std::string* orderid) {
  if (orderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete orderid_;
  }
  if (orderid) {
    set_has_orderid();
    orderid_ = orderid;
  } else {
    clear_has_orderid();
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSRechargeCallbackResp.OrderId)
}

// -------------------------------------------------------------------

// CSUseGiftCodeReq

// required string GiftCode = 1;
inline bool CSUseGiftCodeReq::has_giftcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSUseGiftCodeReq::set_has_giftcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSUseGiftCodeReq::clear_has_giftcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSUseGiftCodeReq::clear_giftcode() {
  if (giftcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    giftcode_->clear();
  }
  clear_has_giftcode();
}
inline const ::std::string& CSUseGiftCodeReq::giftcode() const {
  // @@protoc_insertion_point(field_get:fgame.CSUseGiftCodeReq.GiftCode)
  return *giftcode_;
}
inline void CSUseGiftCodeReq::set_giftcode(const ::std::string& value) {
  set_has_giftcode();
  if (giftcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    giftcode_ = new ::std::string;
  }
  giftcode_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSUseGiftCodeReq.GiftCode)
}
inline void CSUseGiftCodeReq::set_giftcode(const char* value) {
  set_has_giftcode();
  if (giftcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    giftcode_ = new ::std::string;
  }
  giftcode_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSUseGiftCodeReq.GiftCode)
}
inline void CSUseGiftCodeReq::set_giftcode(const char* value, size_t size) {
  set_has_giftcode();
  if (giftcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    giftcode_ = new ::std::string;
  }
  giftcode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSUseGiftCodeReq.GiftCode)
}
inline ::std::string* CSUseGiftCodeReq::mutable_giftcode() {
  set_has_giftcode();
  if (giftcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    giftcode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSUseGiftCodeReq.GiftCode)
  return giftcode_;
}
inline ::std::string* CSUseGiftCodeReq::release_giftcode() {
  clear_has_giftcode();
  if (giftcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = giftcode_;
    giftcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSUseGiftCodeReq::set_allocated_giftcode(::std::string* giftcode) {
  if (giftcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete giftcode_;
  }
  if (giftcode) {
    set_has_giftcode();
    giftcode_ = giftcode;
  } else {
    clear_has_giftcode();
    giftcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSUseGiftCodeReq.GiftCode)
}

// -------------------------------------------------------------------

// CSUseGiftCodeResp

// required uint32 Ret = 1;
inline bool CSUseGiftCodeResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSUseGiftCodeResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSUseGiftCodeResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSUseGiftCodeResp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSUseGiftCodeResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSUseGiftCodeResp.Ret)
  return ret_;
}
inline void CSUseGiftCodeResp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSUseGiftCodeResp.Ret)
}

// required uint32 Reward = 2;
inline bool CSUseGiftCodeResp::has_reward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSUseGiftCodeResp::set_has_reward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSUseGiftCodeResp::clear_has_reward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSUseGiftCodeResp::clear_reward() {
  reward_ = 0u;
  clear_has_reward();
}
inline ::google::protobuf::uint32 CSUseGiftCodeResp::reward() const {
  // @@protoc_insertion_point(field_get:fgame.CSUseGiftCodeResp.Reward)
  return reward_;
}
inline void CSUseGiftCodeResp::set_reward(::google::protobuf::uint32 value) {
  set_has_reward();
  reward_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSUseGiftCodeResp.Reward)
}

// -------------------------------------------------------------------

// CheckPtData

// optional uint32 id = 1;
inline bool CheckPtData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckPtData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckPtData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckPtData::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CheckPtData::id() const {
  // @@protoc_insertion_point(field_get:fgame.CheckPtData.id)
  return id_;
}
inline void CheckPtData::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CheckPtData.id)
}

// optional uint32 stars = 2;
inline bool CheckPtData::has_stars() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckPtData::set_has_stars() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckPtData::clear_has_stars() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckPtData::clear_stars() {
  stars_ = 0u;
  clear_has_stars();
}
inline ::google::protobuf::uint32 CheckPtData::stars() const {
  // @@protoc_insertion_point(field_get:fgame.CheckPtData.stars)
  return stars_;
}
inline void CheckPtData::set_stars(::google::protobuf::uint32 value) {
  set_has_stars();
  stars_ = value;
  // @@protoc_insertion_point(field_set:fgame.CheckPtData.stars)
}

// optional bool reward = 3;
inline bool CheckPtData::has_reward() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckPtData::set_has_reward() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckPtData::clear_has_reward() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckPtData::clear_reward() {
  reward_ = false;
  clear_has_reward();
}
inline bool CheckPtData::reward() const {
  // @@protoc_insertion_point(field_get:fgame.CheckPtData.reward)
  return reward_;
}
inline void CheckPtData::set_reward(bool value) {
  set_has_reward();
  reward_ = value;
  // @@protoc_insertion_point(field_set:fgame.CheckPtData.reward)
}

// optional uint32 BattleTime = 4;
inline bool CheckPtData::has_battletime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CheckPtData::set_has_battletime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CheckPtData::clear_has_battletime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CheckPtData::clear_battletime() {
  battletime_ = 0u;
  clear_has_battletime();
}
inline ::google::protobuf::uint32 CheckPtData::battletime() const {
  // @@protoc_insertion_point(field_get:fgame.CheckPtData.BattleTime)
  return battletime_;
}
inline void CheckPtData::set_battletime(::google::protobuf::uint32 value) {
  set_has_battletime();
  battletime_ = value;
  // @@protoc_insertion_point(field_set:fgame.CheckPtData.BattleTime)
}

// optional bool FullReward = 5;
inline bool CheckPtData::has_fullreward() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CheckPtData::set_has_fullreward() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CheckPtData::clear_has_fullreward() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CheckPtData::clear_fullreward() {
  fullreward_ = false;
  clear_has_fullreward();
}
inline bool CheckPtData::fullreward() const {
  // @@protoc_insertion_point(field_get:fgame.CheckPtData.FullReward)
  return fullreward_;
}
inline void CheckPtData::set_fullreward(bool value) {
  set_has_fullreward();
  fullreward_ = value;
  // @@protoc_insertion_point(field_set:fgame.CheckPtData.FullReward)
}

// optional bool Win = 6;
inline bool CheckPtData::has_win() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CheckPtData::set_has_win() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CheckPtData::clear_has_win() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CheckPtData::clear_win() {
  win_ = false;
  clear_has_win();
}
inline bool CheckPtData::win() const {
  // @@protoc_insertion_point(field_get:fgame.CheckPtData.Win)
  return win_;
}
inline void CheckPtData::set_win(bool value) {
  set_has_win();
  win_ = value;
  // @@protoc_insertion_point(field_set:fgame.CheckPtData.Win)
}

// optional uint32 ChapterId = 7;
inline bool CheckPtData::has_chapterid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CheckPtData::set_has_chapterid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CheckPtData::clear_has_chapterid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CheckPtData::clear_chapterid() {
  chapterid_ = 0u;
  clear_has_chapterid();
}
inline ::google::protobuf::uint32 CheckPtData::chapterid() const {
  // @@protoc_insertion_point(field_get:fgame.CheckPtData.ChapterId)
  return chapterid_;
}
inline void CheckPtData::set_chapterid(::google::protobuf::uint32 value) {
  set_has_chapterid();
  chapterid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CheckPtData.ChapterId)
}

// optional bool Skip = 8;
inline bool CheckPtData::has_skip() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CheckPtData::set_has_skip() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CheckPtData::clear_has_skip() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CheckPtData::clear_skip() {
  skip_ = false;
  clear_has_skip();
}
inline bool CheckPtData::skip() const {
  // @@protoc_insertion_point(field_get:fgame.CheckPtData.Skip)
  return skip_;
}
inline void CheckPtData::set_skip(bool value) {
  set_has_skip();
  skip_ = value;
  // @@protoc_insertion_point(field_set:fgame.CheckPtData.Skip)
}

// optional uint32 Score = 9;
inline bool CheckPtData::has_score() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CheckPtData::set_has_score() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CheckPtData::clear_has_score() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CheckPtData::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 CheckPtData::score() const {
  // @@protoc_insertion_point(field_get:fgame.CheckPtData.Score)
  return score_;
}
inline void CheckPtData::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:fgame.CheckPtData.Score)
}

// -------------------------------------------------------------------

// CSSaveCheckPtDataReq

// required .fgame.CheckPtData CPData = 1;
inline bool CSSaveCheckPtDataReq::has_cpdata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSaveCheckPtDataReq::set_has_cpdata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSaveCheckPtDataReq::clear_has_cpdata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSaveCheckPtDataReq::clear_cpdata() {
  if (cpdata_ != NULL) cpdata_->::fgame::CheckPtData::Clear();
  clear_has_cpdata();
}
inline const ::fgame::CheckPtData& CSSaveCheckPtDataReq::cpdata() const {
  // @@protoc_insertion_point(field_get:fgame.CSSaveCheckPtDataReq.CPData)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cpdata_ != NULL ? *cpdata_ : *default_instance().cpdata_;
#else
  return cpdata_ != NULL ? *cpdata_ : *default_instance_->cpdata_;
#endif
}
inline ::fgame::CheckPtData* CSSaveCheckPtDataReq::mutable_cpdata() {
  set_has_cpdata();
  if (cpdata_ == NULL) cpdata_ = new ::fgame::CheckPtData;
  // @@protoc_insertion_point(field_mutable:fgame.CSSaveCheckPtDataReq.CPData)
  return cpdata_;
}
inline ::fgame::CheckPtData* CSSaveCheckPtDataReq::release_cpdata() {
  clear_has_cpdata();
  ::fgame::CheckPtData* temp = cpdata_;
  cpdata_ = NULL;
  return temp;
}
inline void CSSaveCheckPtDataReq::set_allocated_cpdata(::fgame::CheckPtData* cpdata) {
  delete cpdata_;
  cpdata_ = cpdata;
  if (cpdata) {
    set_has_cpdata();
  } else {
    clear_has_cpdata();
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSSaveCheckPtDataReq.CPData)
}

// required uint32 OpenCheckPtId = 2;
inline bool CSSaveCheckPtDataReq::has_opencheckptid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSSaveCheckPtDataReq::set_has_opencheckptid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSSaveCheckPtDataReq::clear_has_opencheckptid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSSaveCheckPtDataReq::clear_opencheckptid() {
  opencheckptid_ = 0u;
  clear_has_opencheckptid();
}
inline ::google::protobuf::uint32 CSSaveCheckPtDataReq::opencheckptid() const {
  // @@protoc_insertion_point(field_get:fgame.CSSaveCheckPtDataReq.OpenCheckPtId)
  return opencheckptid_;
}
inline void CSSaveCheckPtDataReq::set_opencheckptid(::google::protobuf::uint32 value) {
  set_has_opencheckptid();
  opencheckptid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSaveCheckPtDataReq.OpenCheckPtId)
}

// -------------------------------------------------------------------

// CSSaveCheckPtDataResp

// optional uint32 id = 1;
inline bool CSSaveCheckPtDataResp::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSaveCheckPtDataResp::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSaveCheckPtDataResp::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSaveCheckPtDataResp::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSSaveCheckPtDataResp::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSSaveCheckPtDataResp.id)
  return id_;
}
inline void CSSaveCheckPtDataResp::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSaveCheckPtDataResp.id)
}

// optional bool reward = 2;
inline bool CSSaveCheckPtDataResp::has_reward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSSaveCheckPtDataResp::set_has_reward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSSaveCheckPtDataResp::clear_has_reward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSSaveCheckPtDataResp::clear_reward() {
  reward_ = false;
  clear_has_reward();
}
inline bool CSSaveCheckPtDataResp::reward() const {
  // @@protoc_insertion_point(field_get:fgame.CSSaveCheckPtDataResp.reward)
  return reward_;
}
inline void CSSaveCheckPtDataResp::set_reward(bool value) {
  set_has_reward();
  reward_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSaveCheckPtDataResp.reward)
}

// optional bool FullReward = 3;
inline bool CSSaveCheckPtDataResp::has_fullreward() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSSaveCheckPtDataResp::set_has_fullreward() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSSaveCheckPtDataResp::clear_has_fullreward() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSSaveCheckPtDataResp::clear_fullreward() {
  fullreward_ = false;
  clear_has_fullreward();
}
inline bool CSSaveCheckPtDataResp::fullreward() const {
  // @@protoc_insertion_point(field_get:fgame.CSSaveCheckPtDataResp.FullReward)
  return fullreward_;
}
inline void CSSaveCheckPtDataResp::set_fullreward(bool value) {
  set_has_fullreward();
  fullreward_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSaveCheckPtDataResp.FullReward)
}

// optional string Stars = 4;
inline bool CSSaveCheckPtDataResp::has_stars() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSSaveCheckPtDataResp::set_has_stars() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSSaveCheckPtDataResp::clear_has_stars() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSSaveCheckPtDataResp::clear_stars() {
  if (stars_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stars_->clear();
  }
  clear_has_stars();
}
inline const ::std::string& CSSaveCheckPtDataResp::stars() const {
  // @@protoc_insertion_point(field_get:fgame.CSSaveCheckPtDataResp.Stars)
  return *stars_;
}
inline void CSSaveCheckPtDataResp::set_stars(const ::std::string& value) {
  set_has_stars();
  if (stars_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stars_ = new ::std::string;
  }
  stars_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSSaveCheckPtDataResp.Stars)
}
inline void CSSaveCheckPtDataResp::set_stars(const char* value) {
  set_has_stars();
  if (stars_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stars_ = new ::std::string;
  }
  stars_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSSaveCheckPtDataResp.Stars)
}
inline void CSSaveCheckPtDataResp::set_stars(const char* value, size_t size) {
  set_has_stars();
  if (stars_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stars_ = new ::std::string;
  }
  stars_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSSaveCheckPtDataResp.Stars)
}
inline ::std::string* CSSaveCheckPtDataResp::mutable_stars() {
  set_has_stars();
  if (stars_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stars_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSSaveCheckPtDataResp.Stars)
  return stars_;
}
inline ::std::string* CSSaveCheckPtDataResp::release_stars() {
  clear_has_stars();
  if (stars_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = stars_;
    stars_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSSaveCheckPtDataResp::set_allocated_stars(::std::string* stars) {
  if (stars_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stars_;
  }
  if (stars) {
    set_has_stars();
    stars_ = stars;
  } else {
    clear_has_stars();
    stars_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSSaveCheckPtDataResp.Stars)
}

// optional bool Win = 5;
inline bool CSSaveCheckPtDataResp::has_win() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSSaveCheckPtDataResp::set_has_win() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSSaveCheckPtDataResp::clear_has_win() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSSaveCheckPtDataResp::clear_win() {
  win_ = false;
  clear_has_win();
}
inline bool CSSaveCheckPtDataResp::win() const {
  // @@protoc_insertion_point(field_get:fgame.CSSaveCheckPtDataResp.Win)
  return win_;
}
inline void CSSaveCheckPtDataResp::set_win(bool value) {
  set_has_win();
  win_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSaveCheckPtDataResp.Win)
}

// optional uint32 ShareId = 6;
inline bool CSSaveCheckPtDataResp::has_shareid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSSaveCheckPtDataResp::set_has_shareid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSSaveCheckPtDataResp::clear_has_shareid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSSaveCheckPtDataResp::clear_shareid() {
  shareid_ = 0u;
  clear_has_shareid();
}
inline ::google::protobuf::uint32 CSSaveCheckPtDataResp::shareid() const {
  // @@protoc_insertion_point(field_get:fgame.CSSaveCheckPtDataResp.ShareId)
  return shareid_;
}
inline void CSSaveCheckPtDataResp::set_shareid(::google::protobuf::uint32 value) {
  set_has_shareid();
  shareid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSaveCheckPtDataResp.ShareId)
}

// optional uint32 SkipNum = 7;
inline bool CSSaveCheckPtDataResp::has_skipnum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSSaveCheckPtDataResp::set_has_skipnum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSSaveCheckPtDataResp::clear_has_skipnum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSSaveCheckPtDataResp::clear_skipnum() {
  skipnum_ = 0u;
  clear_has_skipnum();
}
inline ::google::protobuf::uint32 CSSaveCheckPtDataResp::skipnum() const {
  // @@protoc_insertion_point(field_get:fgame.CSSaveCheckPtDataResp.SkipNum)
  return skipnum_;
}
inline void CSSaveCheckPtDataResp::set_skipnum(::google::protobuf::uint32 value) {
  set_has_skipnum();
  skipnum_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSaveCheckPtDataResp.SkipNum)
}

// -------------------------------------------------------------------

// CSRetriveCheckPtRewardReq

// required uint32 Id = 1;
inline bool CSRetriveCheckPtRewardReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRetriveCheckPtRewardReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRetriveCheckPtRewardReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRetriveCheckPtRewardReq::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSRetriveCheckPtRewardReq::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSRetriveCheckPtRewardReq.Id)
  return id_;
}
inline void CSRetriveCheckPtRewardReq::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRetriveCheckPtRewardReq.Id)
}

// required uint32 RewardType = 2;
inline bool CSRetriveCheckPtRewardReq::has_rewardtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRetriveCheckPtRewardReq::set_has_rewardtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRetriveCheckPtRewardReq::clear_has_rewardtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRetriveCheckPtRewardReq::clear_rewardtype() {
  rewardtype_ = 0u;
  clear_has_rewardtype();
}
inline ::google::protobuf::uint32 CSRetriveCheckPtRewardReq::rewardtype() const {
  // @@protoc_insertion_point(field_get:fgame.CSRetriveCheckPtRewardReq.RewardType)
  return rewardtype_;
}
inline void CSRetriveCheckPtRewardReq::set_rewardtype(::google::protobuf::uint32 value) {
  set_has_rewardtype();
  rewardtype_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRetriveCheckPtRewardReq.RewardType)
}

// -------------------------------------------------------------------

// CSRetriveCheckPtRewardResp

// required uint32 Id = 1;
inline bool CSRetriveCheckPtRewardResp::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRetriveCheckPtRewardResp::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRetriveCheckPtRewardResp::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRetriveCheckPtRewardResp::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSRetriveCheckPtRewardResp::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSRetriveCheckPtRewardResp.Id)
  return id_;
}
inline void CSRetriveCheckPtRewardResp::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRetriveCheckPtRewardResp.Id)
}

// required uint32 RewardType = 2;
inline bool CSRetriveCheckPtRewardResp::has_rewardtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRetriveCheckPtRewardResp::set_has_rewardtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRetriveCheckPtRewardResp::clear_has_rewardtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRetriveCheckPtRewardResp::clear_rewardtype() {
  rewardtype_ = 0u;
  clear_has_rewardtype();
}
inline ::google::protobuf::uint32 CSRetriveCheckPtRewardResp::rewardtype() const {
  // @@protoc_insertion_point(field_get:fgame.CSRetriveCheckPtRewardResp.RewardType)
  return rewardtype_;
}
inline void CSRetriveCheckPtRewardResp::set_rewardtype(::google::protobuf::uint32 value) {
  set_has_rewardtype();
  rewardtype_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRetriveCheckPtRewardResp.RewardType)
}

// optional bool Ret = 3;
inline bool CSRetriveCheckPtRewardResp::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSRetriveCheckPtRewardResp::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSRetriveCheckPtRewardResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSRetriveCheckPtRewardResp::clear_ret() {
  ret_ = false;
  clear_has_ret();
}
inline bool CSRetriveCheckPtRewardResp::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSRetriveCheckPtRewardResp.Ret)
  return ret_;
}
inline void CSRetriveCheckPtRewardResp::set_ret(bool value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRetriveCheckPtRewardResp.Ret)
}

// -------------------------------------------------------------------

// CSGetCheckPtDataReq

// -------------------------------------------------------------------

// ChapterData

// required uint32 ChapterId = 1;
inline bool ChapterData::has_chapterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChapterData::set_has_chapterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChapterData::clear_has_chapterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChapterData::clear_chapterid() {
  chapterid_ = 0u;
  clear_has_chapterid();
}
inline ::google::protobuf::uint32 ChapterData::chapterid() const {
  // @@protoc_insertion_point(field_get:fgame.ChapterData.ChapterId)
  return chapterid_;
}
inline void ChapterData::set_chapterid(::google::protobuf::uint32 value) {
  set_has_chapterid();
  chapterid_ = value;
  // @@protoc_insertion_point(field_set:fgame.ChapterData.ChapterId)
}

// repeated .fgame.CheckPtData CpData = 2;
inline int ChapterData::cpdata_size() const {
  return cpdata_.size();
}
inline void ChapterData::clear_cpdata() {
  cpdata_.Clear();
}
inline const ::fgame::CheckPtData& ChapterData::cpdata(int index) const {
  // @@protoc_insertion_point(field_get:fgame.ChapterData.CpData)
  return cpdata_.Get(index);
}
inline ::fgame::CheckPtData* ChapterData::mutable_cpdata(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.ChapterData.CpData)
  return cpdata_.Mutable(index);
}
inline ::fgame::CheckPtData* ChapterData::add_cpdata() {
  // @@protoc_insertion_point(field_add:fgame.ChapterData.CpData)
  return cpdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CheckPtData >&
ChapterData::cpdata() const {
  // @@protoc_insertion_point(field_list:fgame.ChapterData.CpData)
  return cpdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CheckPtData >*
ChapterData::mutable_cpdata() {
  // @@protoc_insertion_point(field_mutable_list:fgame.ChapterData.CpData)
  return &cpdata_;
}

// required uint32 Stars = 3;
inline bool ChapterData::has_stars() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChapterData::set_has_stars() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChapterData::clear_has_stars() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChapterData::clear_stars() {
  stars_ = 0u;
  clear_has_stars();
}
inline ::google::protobuf::uint32 ChapterData::stars() const {
  // @@protoc_insertion_point(field_get:fgame.ChapterData.Stars)
  return stars_;
}
inline void ChapterData::set_stars(::google::protobuf::uint32 value) {
  set_has_stars();
  stars_ = value;
  // @@protoc_insertion_point(field_set:fgame.ChapterData.Stars)
}

// required uint32 Chest = 4;
inline bool ChapterData::has_chest() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChapterData::set_has_chest() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChapterData::clear_has_chest() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChapterData::clear_chest() {
  chest_ = 0u;
  clear_has_chest();
}
inline ::google::protobuf::uint32 ChapterData::chest() const {
  // @@protoc_insertion_point(field_get:fgame.ChapterData.Chest)
  return chest_;
}
inline void ChapterData::set_chest(::google::protobuf::uint32 value) {
  set_has_chest();
  chest_ = value;
  // @@protoc_insertion_point(field_set:fgame.ChapterData.Chest)
}

// required uint32 MaxCpId = 5;
inline bool ChapterData::has_maxcpid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChapterData::set_has_maxcpid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChapterData::clear_has_maxcpid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChapterData::clear_maxcpid() {
  maxcpid_ = 0u;
  clear_has_maxcpid();
}
inline ::google::protobuf::uint32 ChapterData::maxcpid() const {
  // @@protoc_insertion_point(field_get:fgame.ChapterData.MaxCpId)
  return maxcpid_;
}
inline void ChapterData::set_maxcpid(::google::protobuf::uint32 value) {
  set_has_maxcpid();
  maxcpid_ = value;
  // @@protoc_insertion_point(field_set:fgame.ChapterData.MaxCpId)
}

// -------------------------------------------------------------------

// CSGetCheckPtDataResp

// repeated .fgame.ChapterData Data = 1;
inline int CSGetCheckPtDataResp::data_size() const {
  return data_.size();
}
inline void CSGetCheckPtDataResp::clear_data() {
  data_.Clear();
}
inline const ::fgame::ChapterData& CSGetCheckPtDataResp::data(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSGetCheckPtDataResp.Data)
  return data_.Get(index);
}
inline ::fgame::ChapterData* CSGetCheckPtDataResp::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSGetCheckPtDataResp.Data)
  return data_.Mutable(index);
}
inline ::fgame::ChapterData* CSGetCheckPtDataResp::add_data() {
  // @@protoc_insertion_point(field_add:fgame.CSGetCheckPtDataResp.Data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::ChapterData >&
CSGetCheckPtDataResp::data() const {
  // @@protoc_insertion_point(field_list:fgame.CSGetCheckPtDataResp.Data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::ChapterData >*
CSGetCheckPtDataResp::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSGetCheckPtDataResp.Data)
  return &data_;
}

// optional uint32 SkipNum = 2;
inline bool CSGetCheckPtDataResp::has_skipnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGetCheckPtDataResp::set_has_skipnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGetCheckPtDataResp::clear_has_skipnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGetCheckPtDataResp::clear_skipnum() {
  skipnum_ = 0u;
  clear_has_skipnum();
}
inline ::google::protobuf::uint32 CSGetCheckPtDataResp::skipnum() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetCheckPtDataResp.SkipNum)
  return skipnum_;
}
inline void CSGetCheckPtDataResp::set_skipnum(::google::protobuf::uint32 value) {
  set_has_skipnum();
  skipnum_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetCheckPtDataResp.SkipNum)
}

// -------------------------------------------------------------------

// CSChapterUnlockReq

// required uint32 ChapterId = 1;
inline bool CSChapterUnlockReq::has_chapterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChapterUnlockReq::set_has_chapterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChapterUnlockReq::clear_has_chapterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChapterUnlockReq::clear_chapterid() {
  chapterid_ = 0u;
  clear_has_chapterid();
}
inline ::google::protobuf::uint32 CSChapterUnlockReq::chapterid() const {
  // @@protoc_insertion_point(field_get:fgame.CSChapterUnlockReq.ChapterId)
  return chapterid_;
}
inline void CSChapterUnlockReq::set_chapterid(::google::protobuf::uint32 value) {
  set_has_chapterid();
  chapterid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSChapterUnlockReq.ChapterId)
}

// required uint32 UnlockBy = 2;
inline bool CSChapterUnlockReq::has_unlockby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSChapterUnlockReq::set_has_unlockby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSChapterUnlockReq::clear_has_unlockby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSChapterUnlockReq::clear_unlockby() {
  unlockby_ = 0u;
  clear_has_unlockby();
}
inline ::google::protobuf::uint32 CSChapterUnlockReq::unlockby() const {
  // @@protoc_insertion_point(field_get:fgame.CSChapterUnlockReq.UnlockBy)
  return unlockby_;
}
inline void CSChapterUnlockReq::set_unlockby(::google::protobuf::uint32 value) {
  set_has_unlockby();
  unlockby_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSChapterUnlockReq.UnlockBy)
}

// -------------------------------------------------------------------

// CSChapterUnlockResp

// required uint32 ChapterId = 1;
inline bool CSChapterUnlockResp::has_chapterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChapterUnlockResp::set_has_chapterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChapterUnlockResp::clear_has_chapterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChapterUnlockResp::clear_chapterid() {
  chapterid_ = 0u;
  clear_has_chapterid();
}
inline ::google::protobuf::uint32 CSChapterUnlockResp::chapterid() const {
  // @@protoc_insertion_point(field_get:fgame.CSChapterUnlockResp.ChapterId)
  return chapterid_;
}
inline void CSChapterUnlockResp::set_chapterid(::google::protobuf::uint32 value) {
  set_has_chapterid();
  chapterid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSChapterUnlockResp.ChapterId)
}

// required uint32 UnlockBy = 2;
inline bool CSChapterUnlockResp::has_unlockby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSChapterUnlockResp::set_has_unlockby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSChapterUnlockResp::clear_has_unlockby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSChapterUnlockResp::clear_unlockby() {
  unlockby_ = 0u;
  clear_has_unlockby();
}
inline ::google::protobuf::uint32 CSChapterUnlockResp::unlockby() const {
  // @@protoc_insertion_point(field_get:fgame.CSChapterUnlockResp.UnlockBy)
  return unlockby_;
}
inline void CSChapterUnlockResp::set_unlockby(::google::protobuf::uint32 value) {
  set_has_unlockby();
  unlockby_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSChapterUnlockResp.UnlockBy)
}

// -------------------------------------------------------------------

// CSGetChestReq

// required uint32 ChapterId = 1;
inline bool CSGetChestReq::has_chapterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGetChestReq::set_has_chapterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGetChestReq::clear_has_chapterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGetChestReq::clear_chapterid() {
  chapterid_ = 0u;
  clear_has_chapterid();
}
inline ::google::protobuf::uint32 CSGetChestReq::chapterid() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetChestReq.ChapterId)
  return chapterid_;
}
inline void CSGetChestReq::set_chapterid(::google::protobuf::uint32 value) {
  set_has_chapterid();
  chapterid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetChestReq.ChapterId)
}

// required uint32 ChestId = 2;
inline bool CSGetChestReq::has_chestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGetChestReq::set_has_chestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGetChestReq::clear_has_chestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGetChestReq::clear_chestid() {
  chestid_ = 0u;
  clear_has_chestid();
}
inline ::google::protobuf::uint32 CSGetChestReq::chestid() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetChestReq.ChestId)
  return chestid_;
}
inline void CSGetChestReq::set_chestid(::google::protobuf::uint32 value) {
  set_has_chestid();
  chestid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetChestReq.ChestId)
}

// required uint32 ChestGift = 3;
inline bool CSGetChestReq::has_chestgift() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSGetChestReq::set_has_chestgift() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSGetChestReq::clear_has_chestgift() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSGetChestReq::clear_chestgift() {
  chestgift_ = 0u;
  clear_has_chestgift();
}
inline ::google::protobuf::uint32 CSGetChestReq::chestgift() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetChestReq.ChestGift)
  return chestgift_;
}
inline void CSGetChestReq::set_chestgift(::google::protobuf::uint32 value) {
  set_has_chestgift();
  chestgift_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetChestReq.ChestGift)
}

// -------------------------------------------------------------------

// CSGetChestResp

// required uint32 ChapterId = 1;
inline bool CSGetChestResp::has_chapterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGetChestResp::set_has_chapterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGetChestResp::clear_has_chapterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGetChestResp::clear_chapterid() {
  chapterid_ = 0u;
  clear_has_chapterid();
}
inline ::google::protobuf::uint32 CSGetChestResp::chapterid() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetChestResp.ChapterId)
  return chapterid_;
}
inline void CSGetChestResp::set_chapterid(::google::protobuf::uint32 value) {
  set_has_chapterid();
  chapterid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetChestResp.ChapterId)
}

// required uint32 Chest = 2;
inline bool CSGetChestResp::has_chest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGetChestResp::set_has_chest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGetChestResp::clear_has_chest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGetChestResp::clear_chest() {
  chest_ = 0u;
  clear_has_chest();
}
inline ::google::protobuf::uint32 CSGetChestResp::chest() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetChestResp.Chest)
  return chest_;
}
inline void CSGetChestResp::set_chest(::google::protobuf::uint32 value) {
  set_has_chest();
  chest_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetChestResp.Chest)
}

// -------------------------------------------------------------------

// CSPveNotifyReq

// required uint32 CheckPoint = 1;
inline bool CSPveNotifyReq::has_checkpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPveNotifyReq::set_has_checkpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPveNotifyReq::clear_has_checkpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPveNotifyReq::clear_checkpoint() {
  checkpoint_ = 0u;
  clear_has_checkpoint();
}
inline ::google::protobuf::uint32 CSPveNotifyReq::checkpoint() const {
  // @@protoc_insertion_point(field_get:fgame.CSPveNotifyReq.CheckPoint)
  return checkpoint_;
}
inline void CSPveNotifyReq::set_checkpoint(::google::protobuf::uint32 value) {
  set_has_checkpoint();
  checkpoint_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPveNotifyReq.CheckPoint)
}

// required uint32 Action = 2;
inline bool CSPveNotifyReq::has_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPveNotifyReq::set_has_action() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPveNotifyReq::clear_has_action() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPveNotifyReq::clear_action() {
  action_ = 0u;
  clear_has_action();
}
inline ::google::protobuf::uint32 CSPveNotifyReq::action() const {
  // @@protoc_insertion_point(field_get:fgame.CSPveNotifyReq.Action)
  return action_;
}
inline void CSPveNotifyReq::set_action(::google::protobuf::uint32 value) {
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPveNotifyReq.Action)
}

// required uint32 ChapterId = 3;
inline bool CSPveNotifyReq::has_chapterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPveNotifyReq::set_has_chapterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPveNotifyReq::clear_has_chapterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPveNotifyReq::clear_chapterid() {
  chapterid_ = 0u;
  clear_has_chapterid();
}
inline ::google::protobuf::uint32 CSPveNotifyReq::chapterid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPveNotifyReq.ChapterId)
  return chapterid_;
}
inline void CSPveNotifyReq::set_chapterid(::google::protobuf::uint32 value) {
  set_has_chapterid();
  chapterid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPveNotifyReq.ChapterId)
}

// required bool NeedPower = 4;
inline bool CSPveNotifyReq::has_needpower() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPveNotifyReq::set_has_needpower() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPveNotifyReq::clear_has_needpower() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPveNotifyReq::clear_needpower() {
  needpower_ = false;
  clear_has_needpower();
}
inline bool CSPveNotifyReq::needpower() const {
  // @@protoc_insertion_point(field_get:fgame.CSPveNotifyReq.NeedPower)
  return needpower_;
}
inline void CSPveNotifyReq::set_needpower(bool value) {
  set_has_needpower();
  needpower_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPveNotifyReq.NeedPower)
}

// optional uint32 BattleTime = 5;
inline bool CSPveNotifyReq::has_battletime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPveNotifyReq::set_has_battletime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPveNotifyReq::clear_has_battletime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPveNotifyReq::clear_battletime() {
  battletime_ = 0u;
  clear_has_battletime();
}
inline ::google::protobuf::uint32 CSPveNotifyReq::battletime() const {
  // @@protoc_insertion_point(field_get:fgame.CSPveNotifyReq.BattleTime)
  return battletime_;
}
inline void CSPveNotifyReq::set_battletime(::google::protobuf::uint32 value) {
  set_has_battletime();
  battletime_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPveNotifyReq.BattleTime)
}

// -------------------------------------------------------------------

// CSPveNotifyResp

// required bool NeedPower = 1;
inline bool CSPveNotifyResp::has_needpower() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPveNotifyResp::set_has_needpower() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPveNotifyResp::clear_has_needpower() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPveNotifyResp::clear_needpower() {
  needpower_ = false;
  clear_has_needpower();
}
inline bool CSPveNotifyResp::needpower() const {
  // @@protoc_insertion_point(field_get:fgame.CSPveNotifyResp.NeedPower)
  return needpower_;
}
inline void CSPveNotifyResp::set_needpower(bool value) {
  set_has_needpower();
  needpower_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPveNotifyResp.NeedPower)
}

// -------------------------------------------------------------------

// CSPveCheckAwardReq

// -------------------------------------------------------------------

// CSPveCheckAwardResp

// required bool HaveAward = 1;
inline bool CSPveCheckAwardResp::has_haveaward() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPveCheckAwardResp::set_has_haveaward() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPveCheckAwardResp::clear_has_haveaward() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPveCheckAwardResp::clear_haveaward() {
  haveaward_ = false;
  clear_has_haveaward();
}
inline bool CSPveCheckAwardResp::haveaward() const {
  // @@protoc_insertion_point(field_get:fgame.CSPveCheckAwardResp.HaveAward)
  return haveaward_;
}
inline void CSPveCheckAwardResp::set_haveaward(bool value) {
  set_has_haveaward();
  haveaward_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPveCheckAwardResp.HaveAward)
}

// optional uint32 GiftID = 2;
inline bool CSPveCheckAwardResp::has_giftid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPveCheckAwardResp::set_has_giftid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPveCheckAwardResp::clear_has_giftid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPveCheckAwardResp::clear_giftid() {
  giftid_ = 0u;
  clear_has_giftid();
}
inline ::google::protobuf::uint32 CSPveCheckAwardResp::giftid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPveCheckAwardResp.GiftID)
  return giftid_;
}
inline void CSPveCheckAwardResp::set_giftid(::google::protobuf::uint32 value) {
  set_has_giftid();
  giftid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPveCheckAwardResp.GiftID)
}

// -------------------------------------------------------------------

// CSPvePveRank

// required uint32 CpId = 1;
inline bool CSPvePveRank::has_cpid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvePveRank::set_has_cpid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvePveRank::clear_has_cpid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvePveRank::clear_cpid() {
  cpid_ = 0u;
  clear_has_cpid();
}
inline ::google::protobuf::uint32 CSPvePveRank::cpid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvePveRank.CpId)
  return cpid_;
}
inline void CSPvePveRank::set_cpid(::google::protobuf::uint32 value) {
  set_has_cpid();
  cpid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvePveRank.CpId)
}

// repeated .fgame.CSPveRankData Data = 2;
inline int CSPvePveRank::data_size() const {
  return data_.size();
}
inline void CSPvePveRank::clear_data() {
  data_.Clear();
}
inline const ::fgame::CSPveRankData& CSPvePveRank::data(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSPvePveRank.Data)
  return data_.Get(index);
}
inline ::fgame::CSPveRankData* CSPvePveRank::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSPvePveRank.Data)
  return data_.Mutable(index);
}
inline ::fgame::CSPveRankData* CSPvePveRank::add_data() {
  // @@protoc_insertion_point(field_add:fgame.CSPvePveRank.Data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPveRankData >&
CSPvePveRank::data() const {
  // @@protoc_insertion_point(field_list:fgame.CSPvePveRank.Data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPveRankData >*
CSPvePveRank::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSPvePveRank.Data)
  return &data_;
}

// -------------------------------------------------------------------

// CSPveRankData

// optional uint32 Rank = 1;
inline bool CSPveRankData::has_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPveRankData::set_has_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPveRankData::clear_has_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPveRankData::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 CSPveRankData::rank() const {
  // @@protoc_insertion_point(field_get:fgame.CSPveRankData.Rank)
  return rank_;
}
inline void CSPveRankData::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPveRankData.Rank)
}

// optional uint32 Uin = 2;
inline bool CSPveRankData::has_uin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPveRankData::set_has_uin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPveRankData::clear_has_uin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPveRankData::clear_uin() {
  uin_ = 0u;
  clear_has_uin();
}
inline ::google::protobuf::uint32 CSPveRankData::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPveRankData.Uin)
  return uin_;
}
inline void CSPveRankData::set_uin(::google::protobuf::uint32 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPveRankData.Uin)
}

// optional string Name = 3;
inline bool CSPveRankData::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPveRankData::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPveRankData::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPveRankData::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSPveRankData::name() const {
  // @@protoc_insertion_point(field_get:fgame.CSPveRankData.Name)
  return *name_;
}
inline void CSPveRankData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPveRankData.Name)
}
inline void CSPveRankData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPveRankData.Name)
}
inline void CSPveRankData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPveRankData.Name)
}
inline ::std::string* CSPveRankData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPveRankData.Name)
  return name_;
}
inline ::std::string* CSPveRankData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPveRankData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPveRankData.Name)
}

// optional string Avator = 4;
inline bool CSPveRankData::has_avator() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPveRankData::set_has_avator() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPveRankData::clear_has_avator() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPveRankData::clear_avator() {
  if (avator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avator_->clear();
  }
  clear_has_avator();
}
inline const ::std::string& CSPveRankData::avator() const {
  // @@protoc_insertion_point(field_get:fgame.CSPveRankData.Avator)
  return *avator_;
}
inline void CSPveRankData::set_avator(const ::std::string& value) {
  set_has_avator();
  if (avator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avator_ = new ::std::string;
  }
  avator_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPveRankData.Avator)
}
inline void CSPveRankData::set_avator(const char* value) {
  set_has_avator();
  if (avator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avator_ = new ::std::string;
  }
  avator_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPveRankData.Avator)
}
inline void CSPveRankData::set_avator(const char* value, size_t size) {
  set_has_avator();
  if (avator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avator_ = new ::std::string;
  }
  avator_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPveRankData.Avator)
}
inline ::std::string* CSPveRankData::mutable_avator() {
  set_has_avator();
  if (avator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avator_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPveRankData.Avator)
  return avator_;
}
inline ::std::string* CSPveRankData::release_avator() {
  clear_has_avator();
  if (avator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avator_;
    avator_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPveRankData::set_allocated_avator(::std::string* avator) {
  if (avator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avator_;
  }
  if (avator) {
    set_has_avator();
    avator_ = avator;
  } else {
    clear_has_avator();
    avator_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPveRankData.Avator)
}

// optional uint32 Score = 5;
inline bool CSPveRankData::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPveRankData::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPveRankData::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPveRankData::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 CSPveRankData::score() const {
  // @@protoc_insertion_point(field_get:fgame.CSPveRankData.Score)
  return score_;
}
inline void CSPveRankData::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPveRankData.Score)
}

// -------------------------------------------------------------------

// CSPveRankReq

// -------------------------------------------------------------------

// CSPveRankResp

// repeated .fgame.CSPvePveRank Rank = 1;
inline int CSPveRankResp::rank_size() const {
  return rank_.size();
}
inline void CSPveRankResp::clear_rank() {
  rank_.Clear();
}
inline const ::fgame::CSPvePveRank& CSPveRankResp::rank(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSPveRankResp.Rank)
  return rank_.Get(index);
}
inline ::fgame::CSPvePveRank* CSPveRankResp::mutable_rank(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSPveRankResp.Rank)
  return rank_.Mutable(index);
}
inline ::fgame::CSPvePveRank* CSPveRankResp::add_rank() {
  // @@protoc_insertion_point(field_add:fgame.CSPveRankResp.Rank)
  return rank_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPvePveRank >&
CSPveRankResp::rank() const {
  // @@protoc_insertion_point(field_list:fgame.CSPveRankResp.Rank)
  return rank_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPvePveRank >*
CSPveRankResp::mutable_rank() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSPveRankResp.Rank)
  return &rank_;
}

// -------------------------------------------------------------------

// CSOpenChestResp

// repeated .fgame.PropertyUpdateData UpdateData = 1;
inline int CSOpenChestResp::updatedata_size() const {
  return updatedata_.size();
}
inline void CSOpenChestResp::clear_updatedata() {
  updatedata_.Clear();
}
inline const ::fgame::PropertyUpdateData& CSOpenChestResp::updatedata(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSOpenChestResp.UpdateData)
  return updatedata_.Get(index);
}
inline ::fgame::PropertyUpdateData* CSOpenChestResp::mutable_updatedata(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSOpenChestResp.UpdateData)
  return updatedata_.Mutable(index);
}
inline ::fgame::PropertyUpdateData* CSOpenChestResp::add_updatedata() {
  // @@protoc_insertion_point(field_add:fgame.CSOpenChestResp.UpdateData)
  return updatedata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >&
CSOpenChestResp::updatedata() const {
  // @@protoc_insertion_point(field_list:fgame.CSOpenChestResp.UpdateData)
  return updatedata_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >*
CSOpenChestResp::mutable_updatedata() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSOpenChestResp.UpdateData)
  return &updatedata_;
}

// -------------------------------------------------------------------

// CSSetSignatureReq

// required string Signature = 1;
inline bool CSSetSignatureReq::has_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSetSignatureReq::set_has_signature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSetSignatureReq::clear_has_signature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSetSignatureReq::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& CSSetSignatureReq::signature() const {
  // @@protoc_insertion_point(field_get:fgame.CSSetSignatureReq.Signature)
  return *signature_;
}
inline void CSSetSignatureReq::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSSetSignatureReq.Signature)
}
inline void CSSetSignatureReq::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSSetSignatureReq.Signature)
}
inline void CSSetSignatureReq::set_signature(const char* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSSetSignatureReq.Signature)
}
inline ::std::string* CSSetSignatureReq::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSSetSignatureReq.Signature)
  return signature_;
}
inline ::std::string* CSSetSignatureReq::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSSetSignatureReq::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSSetSignatureReq.Signature)
}

// -------------------------------------------------------------------

// CSSetSignatureResp

// required string Signature = 1;
inline bool CSSetSignatureResp::has_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSetSignatureResp::set_has_signature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSetSignatureResp::clear_has_signature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSetSignatureResp::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& CSSetSignatureResp::signature() const {
  // @@protoc_insertion_point(field_get:fgame.CSSetSignatureResp.Signature)
  return *signature_;
}
inline void CSSetSignatureResp::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSSetSignatureResp.Signature)
}
inline void CSSetSignatureResp::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSSetSignatureResp.Signature)
}
inline void CSSetSignatureResp::set_signature(const char* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSSetSignatureResp.Signature)
}
inline ::std::string* CSSetSignatureResp::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSSetSignatureResp.Signature)
  return signature_;
}
inline ::std::string* CSSetSignatureResp::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSSetSignatureResp::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSSetSignatureResp.Signature)
}

// -------------------------------------------------------------------

// CSSetExtraInfoVisibleReq

// required bool Visible = 1;
inline bool CSSetExtraInfoVisibleReq::has_visible() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSetExtraInfoVisibleReq::set_has_visible() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSetExtraInfoVisibleReq::clear_has_visible() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSetExtraInfoVisibleReq::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool CSSetExtraInfoVisibleReq::visible() const {
  // @@protoc_insertion_point(field_get:fgame.CSSetExtraInfoVisibleReq.Visible)
  return visible_;
}
inline void CSSetExtraInfoVisibleReq::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSetExtraInfoVisibleReq.Visible)
}

// -------------------------------------------------------------------

// CSSetExtraInfoVisibleResp

// required bool Visible = 1;
inline bool CSSetExtraInfoVisibleResp::has_visible() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSetExtraInfoVisibleResp::set_has_visible() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSetExtraInfoVisibleResp::clear_has_visible() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSetExtraInfoVisibleResp::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool CSSetExtraInfoVisibleResp::visible() const {
  // @@protoc_insertion_point(field_get:fgame.CSSetExtraInfoVisibleResp.Visible)
  return visible_;
}
inline void CSSetExtraInfoVisibleResp::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSSetExtraInfoVisibleResp.Visible)
}

// -------------------------------------------------------------------

// CSGetExtraInfoReq

// required uint64 Uin = 1;
inline bool CSGetExtraInfoReq::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGetExtraInfoReq::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGetExtraInfoReq::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGetExtraInfoReq::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSGetExtraInfoReq::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetExtraInfoReq.Uin)
  return uin_;
}
inline void CSGetExtraInfoReq::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetExtraInfoReq.Uin)
}

// -------------------------------------------------------------------

// CSGetExtraInfoResp

// optional uint64 Uin = 1;
inline bool CSGetExtraInfoResp::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGetExtraInfoResp::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGetExtraInfoResp::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGetExtraInfoResp::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSGetExtraInfoResp::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetExtraInfoResp.Uin)
  return uin_;
}
inline void CSGetExtraInfoResp::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetExtraInfoResp.Uin)
}

// optional uint32 TotalPvpCount = 2;
inline bool CSGetExtraInfoResp::has_totalpvpcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGetExtraInfoResp::set_has_totalpvpcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGetExtraInfoResp::clear_has_totalpvpcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGetExtraInfoResp::clear_totalpvpcount() {
  totalpvpcount_ = 0u;
  clear_has_totalpvpcount();
}
inline ::google::protobuf::uint32 CSGetExtraInfoResp::totalpvpcount() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetExtraInfoResp.TotalPvpCount)
  return totalpvpcount_;
}
inline void CSGetExtraInfoResp::set_totalpvpcount(::google::protobuf::uint32 value) {
  set_has_totalpvpcount();
  totalpvpcount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetExtraInfoResp.TotalPvpCount)
}

// optional uint32 TotalPveCount = 3;
inline bool CSGetExtraInfoResp::has_totalpvecount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSGetExtraInfoResp::set_has_totalpvecount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSGetExtraInfoResp::clear_has_totalpvecount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSGetExtraInfoResp::clear_totalpvecount() {
  totalpvecount_ = 0u;
  clear_has_totalpvecount();
}
inline ::google::protobuf::uint32 CSGetExtraInfoResp::totalpvecount() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetExtraInfoResp.TotalPveCount)
  return totalpvecount_;
}
inline void CSGetExtraInfoResp::set_totalpvecount(::google::protobuf::uint32 value) {
  set_has_totalpvecount();
  totalpvecount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetExtraInfoResp.TotalPveCount)
}

// optional uint32 TotalPvpUseItem = 4;
inline bool CSGetExtraInfoResp::has_totalpvpuseitem() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSGetExtraInfoResp::set_has_totalpvpuseitem() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSGetExtraInfoResp::clear_has_totalpvpuseitem() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSGetExtraInfoResp::clear_totalpvpuseitem() {
  totalpvpuseitem_ = 0u;
  clear_has_totalpvpuseitem();
}
inline ::google::protobuf::uint32 CSGetExtraInfoResp::totalpvpuseitem() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetExtraInfoResp.TotalPvpUseItem)
  return totalpvpuseitem_;
}
inline void CSGetExtraInfoResp::set_totalpvpuseitem(::google::protobuf::uint32 value) {
  set_has_totalpvpuseitem();
  totalpvpuseitem_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetExtraInfoResp.TotalPvpUseItem)
}

// optional uint32 TotalPveUseItem = 5;
inline bool CSGetExtraInfoResp::has_totalpveuseitem() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSGetExtraInfoResp::set_has_totalpveuseitem() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSGetExtraInfoResp::clear_has_totalpveuseitem() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSGetExtraInfoResp::clear_totalpveuseitem() {
  totalpveuseitem_ = 0u;
  clear_has_totalpveuseitem();
}
inline ::google::protobuf::uint32 CSGetExtraInfoResp::totalpveuseitem() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetExtraInfoResp.TotalPveUseItem)
  return totalpveuseitem_;
}
inline void CSGetExtraInfoResp::set_totalpveuseitem(::google::protobuf::uint32 value) {
  set_has_totalpveuseitem();
  totalpveuseitem_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetExtraInfoResp.TotalPveUseItem)
}

// optional uint32 MaxPvpPoint = 6;
inline bool CSGetExtraInfoResp::has_maxpvppoint() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSGetExtraInfoResp::set_has_maxpvppoint() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSGetExtraInfoResp::clear_has_maxpvppoint() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSGetExtraInfoResp::clear_maxpvppoint() {
  maxpvppoint_ = 0u;
  clear_has_maxpvppoint();
}
inline ::google::protobuf::uint32 CSGetExtraInfoResp::maxpvppoint() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetExtraInfoResp.MaxPvpPoint)
  return maxpvppoint_;
}
inline void CSGetExtraInfoResp::set_maxpvppoint(::google::protobuf::uint32 value) {
  set_has_maxpvppoint();
  maxpvppoint_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetExtraInfoResp.MaxPvpPoint)
}

// optional uint32 MaxPvpWinCount = 7;
inline bool CSGetExtraInfoResp::has_maxpvpwincount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSGetExtraInfoResp::set_has_maxpvpwincount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSGetExtraInfoResp::clear_has_maxpvpwincount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSGetExtraInfoResp::clear_maxpvpwincount() {
  maxpvpwincount_ = 0u;
  clear_has_maxpvpwincount();
}
inline ::google::protobuf::uint32 CSGetExtraInfoResp::maxpvpwincount() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetExtraInfoResp.MaxPvpWinCount)
  return maxpvpwincount_;
}
inline void CSGetExtraInfoResp::set_maxpvpwincount(::google::protobuf::uint32 value) {
  set_has_maxpvpwincount();
  maxpvpwincount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetExtraInfoResp.MaxPvpWinCount)
}

// -------------------------------------------------------------------

// CSShareRewardGetResq

// required uint32 Ret = 1;
inline bool CSShareRewardGetResq::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSShareRewardGetResq::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSShareRewardGetResq::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSShareRewardGetResq::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 CSShareRewardGetResq::ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSShareRewardGetResq.Ret)
  return ret_;
}
inline void CSShareRewardGetResq::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSShareRewardGetResq.Ret)
}

// required uint32 ShareId = 2;
inline bool CSShareRewardGetResq::has_shareid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSShareRewardGetResq::set_has_shareid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSShareRewardGetResq::clear_has_shareid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSShareRewardGetResq::clear_shareid() {
  shareid_ = 0u;
  clear_has_shareid();
}
inline ::google::protobuf::uint32 CSShareRewardGetResq::shareid() const {
  // @@protoc_insertion_point(field_get:fgame.CSShareRewardGetResq.ShareId)
  return shareid_;
}
inline void CSShareRewardGetResq::set_shareid(::google::protobuf::uint32 value) {
  set_has_shareid();
  shareid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSShareRewardGetResq.ShareId)
}

// -------------------------------------------------------------------

// CSShareRewardGetReq

// required uint32 ShareId = 1;
inline bool CSShareRewardGetReq::has_shareid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSShareRewardGetReq::set_has_shareid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSShareRewardGetReq::clear_has_shareid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSShareRewardGetReq::clear_shareid() {
  shareid_ = 0u;
  clear_has_shareid();
}
inline ::google::protobuf::uint32 CSShareRewardGetReq::shareid() const {
  // @@protoc_insertion_point(field_get:fgame.CSShareRewardGetReq.ShareId)
  return shareid_;
}
inline void CSShareRewardGetReq::set_shareid(::google::protobuf::uint32 value) {
  set_has_shareid();
  shareid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSShareRewardGetReq.ShareId)
}

// -------------------------------------------------------------------

// CSGetSevenGoalListReq

// -------------------------------------------------------------------

// CSGetSevenGoalListResp

// required uint32 NowDay = 1;
inline bool CSGetSevenGoalListResp::has_nowday() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGetSevenGoalListResp::set_has_nowday() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGetSevenGoalListResp::clear_has_nowday() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGetSevenGoalListResp::clear_nowday() {
  nowday_ = 0u;
  clear_has_nowday();
}
inline ::google::protobuf::uint32 CSGetSevenGoalListResp::nowday() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetSevenGoalListResp.NowDay)
  return nowday_;
}
inline void CSGetSevenGoalListResp::set_nowday(::google::protobuf::uint32 value) {
  set_has_nowday();
  nowday_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetSevenGoalListResp.NowDay)
}

// required bool IsRetrived = 2;
inline bool CSGetSevenGoalListResp::has_isretrived() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGetSevenGoalListResp::set_has_isretrived() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGetSevenGoalListResp::clear_has_isretrived() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGetSevenGoalListResp::clear_isretrived() {
  isretrived_ = false;
  clear_has_isretrived();
}
inline bool CSGetSevenGoalListResp::isretrived() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetSevenGoalListResp.IsRetrived)
  return isretrived_;
}
inline void CSGetSevenGoalListResp::set_isretrived(bool value) {
  set_has_isretrived();
  isretrived_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetSevenGoalListResp.IsRetrived)
}

// required uint32 Num = 3;
inline bool CSGetSevenGoalListResp::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSGetSevenGoalListResp::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSGetSevenGoalListResp::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSGetSevenGoalListResp::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 CSGetSevenGoalListResp::num() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetSevenGoalListResp.Num)
  return num_;
}
inline void CSGetSevenGoalListResp::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetSevenGoalListResp.Num)
}

// required uint32 NextNum = 4;
inline bool CSGetSevenGoalListResp::has_nextnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSGetSevenGoalListResp::set_has_nextnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSGetSevenGoalListResp::clear_has_nextnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSGetSevenGoalListResp::clear_nextnum() {
  nextnum_ = 0u;
  clear_has_nextnum();
}
inline ::google::protobuf::uint32 CSGetSevenGoalListResp::nextnum() const {
  // @@protoc_insertion_point(field_get:fgame.CSGetSevenGoalListResp.NextNum)
  return nextnum_;
}
inline void CSGetSevenGoalListResp::set_nextnum(::google::protobuf::uint32 value) {
  set_has_nextnum();
  nextnum_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSGetSevenGoalListResp.NextNum)
}

// -------------------------------------------------------------------

// CSNoticeSevenGoalResp

// -------------------------------------------------------------------

// CSRetriveSevenGoalReq

// required uint32 NowDay = 1;
inline bool CSRetriveSevenGoalReq::has_nowday() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRetriveSevenGoalReq::set_has_nowday() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRetriveSevenGoalReq::clear_has_nowday() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRetriveSevenGoalReq::clear_nowday() {
  nowday_ = 0u;
  clear_has_nowday();
}
inline ::google::protobuf::uint32 CSRetriveSevenGoalReq::nowday() const {
  // @@protoc_insertion_point(field_get:fgame.CSRetriveSevenGoalReq.NowDay)
  return nowday_;
}
inline void CSRetriveSevenGoalReq::set_nowday(::google::protobuf::uint32 value) {
  set_has_nowday();
  nowday_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSRetriveSevenGoalReq.NowDay)
}

// -------------------------------------------------------------------

// CSRetriveSevenGoalResp

// -------------------------------------------------------------------

// CSTopRankReq

// required uint32 Category = 1;
inline bool CSTopRankReq::has_category() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSTopRankReq::set_has_category() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSTopRankReq::clear_has_category() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSTopRankReq::clear_category() {
  category_ = 0u;
  clear_has_category();
}
inline ::google::protobuf::uint32 CSTopRankReq::category() const {
  // @@protoc_insertion_point(field_get:fgame.CSTopRankReq.Category)
  return category_;
}
inline void CSTopRankReq::set_category(::google::protobuf::uint32 value) {
  set_has_category();
  category_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSTopRankReq.Category)
}

// -------------------------------------------------------------------

// TopRankData

// optional uint32 Rank = 1;
inline bool TopRankData::has_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopRankData::set_has_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopRankData::clear_has_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopRankData::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 TopRankData::rank() const {
  // @@protoc_insertion_point(field_get:fgame.TopRankData.Rank)
  return rank_;
}
inline void TopRankData::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:fgame.TopRankData.Rank)
}

// optional uint32 Uin = 2;
inline bool TopRankData::has_uin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopRankData::set_has_uin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopRankData::clear_has_uin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopRankData::clear_uin() {
  uin_ = 0u;
  clear_has_uin();
}
inline ::google::protobuf::uint32 TopRankData::uin() const {
  // @@protoc_insertion_point(field_get:fgame.TopRankData.Uin)
  return uin_;
}
inline void TopRankData::set_uin(::google::protobuf::uint32 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.TopRankData.Uin)
}

// optional string Name = 3;
inline bool TopRankData::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopRankData::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopRankData::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopRankData::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TopRankData::name() const {
  // @@protoc_insertion_point(field_get:fgame.TopRankData.Name)
  return *name_;
}
inline void TopRankData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.TopRankData.Name)
}
inline void TopRankData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.TopRankData.Name)
}
inline void TopRankData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.TopRankData.Name)
}
inline ::std::string* TopRankData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.TopRankData.Name)
  return name_;
}
inline ::std::string* TopRankData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TopRankData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.TopRankData.Name)
}

// optional string Avator = 4;
inline bool TopRankData::has_avator() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopRankData::set_has_avator() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopRankData::clear_has_avator() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopRankData::clear_avator() {
  if (avator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avator_->clear();
  }
  clear_has_avator();
}
inline const ::std::string& TopRankData::avator() const {
  // @@protoc_insertion_point(field_get:fgame.TopRankData.Avator)
  return *avator_;
}
inline void TopRankData::set_avator(const ::std::string& value) {
  set_has_avator();
  if (avator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avator_ = new ::std::string;
  }
  avator_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.TopRankData.Avator)
}
inline void TopRankData::set_avator(const char* value) {
  set_has_avator();
  if (avator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avator_ = new ::std::string;
  }
  avator_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.TopRankData.Avator)
}
inline void TopRankData::set_avator(const char* value, size_t size) {
  set_has_avator();
  if (avator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avator_ = new ::std::string;
  }
  avator_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.TopRankData.Avator)
}
inline ::std::string* TopRankData::mutable_avator() {
  set_has_avator();
  if (avator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avator_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.TopRankData.Avator)
  return avator_;
}
inline ::std::string* TopRankData::release_avator() {
  clear_has_avator();
  if (avator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avator_;
    avator_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TopRankData::set_allocated_avator(::std::string* avator) {
  if (avator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avator_;
  }
  if (avator) {
    set_has_avator();
    avator_ = avator;
  } else {
    clear_has_avator();
    avator_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.TopRankData.Avator)
}

// optional uint32 Value = 5;
inline bool TopRankData::has_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TopRankData::set_has_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TopRankData::clear_has_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TopRankData::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 TopRankData::value() const {
  // @@protoc_insertion_point(field_get:fgame.TopRankData.Value)
  return value_;
}
inline void TopRankData::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:fgame.TopRankData.Value)
}

// optional bool Up = 6;
inline bool TopRankData::has_up() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TopRankData::set_has_up() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TopRankData::clear_has_up() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TopRankData::clear_up() {
  up_ = false;
  clear_has_up();
}
inline bool TopRankData::up() const {
  // @@protoc_insertion_point(field_get:fgame.TopRankData.Up)
  return up_;
}
inline void TopRankData::set_up(bool value) {
  set_has_up();
  up_ = value;
  // @@protoc_insertion_point(field_set:fgame.TopRankData.Up)
}

// optional uint32 Level = 7;
inline bool TopRankData::has_level() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TopRankData::set_has_level() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TopRankData::clear_has_level() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TopRankData::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 TopRankData::level() const {
  // @@protoc_insertion_point(field_get:fgame.TopRankData.Level)
  return level_;
}
inline void TopRankData::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:fgame.TopRankData.Level)
}

// -------------------------------------------------------------------

// CSTopRankResp

// required uint32 Category = 1;
inline bool CSTopRankResp::has_category() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSTopRankResp::set_has_category() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSTopRankResp::clear_has_category() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSTopRankResp::clear_category() {
  category_ = 0u;
  clear_has_category();
}
inline ::google::protobuf::uint32 CSTopRankResp::category() const {
  // @@protoc_insertion_point(field_get:fgame.CSTopRankResp.Category)
  return category_;
}
inline void CSTopRankResp::set_category(::google::protobuf::uint32 value) {
  set_has_category();
  category_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSTopRankResp.Category)
}

// repeated .fgame.TopRankData Data = 2;
inline int CSTopRankResp::data_size() const {
  return data_.size();
}
inline void CSTopRankResp::clear_data() {
  data_.Clear();
}
inline const ::fgame::TopRankData& CSTopRankResp::data(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSTopRankResp.Data)
  return data_.Get(index);
}
inline ::fgame::TopRankData* CSTopRankResp::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSTopRankResp.Data)
  return data_.Mutable(index);
}
inline ::fgame::TopRankData* CSTopRankResp::add_data() {
  // @@protoc_insertion_point(field_add:fgame.CSTopRankResp.Data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::TopRankData >&
CSTopRankResp::data() const {
  // @@protoc_insertion_point(field_list:fgame.CSTopRankResp.Data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::TopRankData >*
CSTopRankResp::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSTopRankResp.Data)
  return &data_;
}

// optional .fgame.TopRankData OwnerData = 3;
inline bool CSTopRankResp::has_ownerdata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSTopRankResp::set_has_ownerdata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSTopRankResp::clear_has_ownerdata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSTopRankResp::clear_ownerdata() {
  if (ownerdata_ != NULL) ownerdata_->::fgame::TopRankData::Clear();
  clear_has_ownerdata();
}
inline const ::fgame::TopRankData& CSTopRankResp::ownerdata() const {
  // @@protoc_insertion_point(field_get:fgame.CSTopRankResp.OwnerData)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ownerdata_ != NULL ? *ownerdata_ : *default_instance().ownerdata_;
#else
  return ownerdata_ != NULL ? *ownerdata_ : *default_instance_->ownerdata_;
#endif
}
inline ::fgame::TopRankData* CSTopRankResp::mutable_ownerdata() {
  set_has_ownerdata();
  if (ownerdata_ == NULL) ownerdata_ = new ::fgame::TopRankData;
  // @@protoc_insertion_point(field_mutable:fgame.CSTopRankResp.OwnerData)
  return ownerdata_;
}
inline ::fgame::TopRankData* CSTopRankResp::release_ownerdata() {
  clear_has_ownerdata();
  ::fgame::TopRankData* temp = ownerdata_;
  ownerdata_ = NULL;
  return temp;
}
inline void CSTopRankResp::set_allocated_ownerdata(::fgame::TopRankData* ownerdata) {
  delete ownerdata_;
  ownerdata_ = ownerdata;
  if (ownerdata) {
    set_has_ownerdata();
  } else {
    clear_has_ownerdata();
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSTopRankResp.OwnerData)
}

// -------------------------------------------------------------------

// CSTopRankTimeReq

// required uint32 Category = 1;
inline bool CSTopRankTimeReq::has_category() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSTopRankTimeReq::set_has_category() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSTopRankTimeReq::clear_has_category() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSTopRankTimeReq::clear_category() {
  category_ = 0u;
  clear_has_category();
}
inline ::google::protobuf::uint32 CSTopRankTimeReq::category() const {
  // @@protoc_insertion_point(field_get:fgame.CSTopRankTimeReq.Category)
  return category_;
}
inline void CSTopRankTimeReq::set_category(::google::protobuf::uint32 value) {
  set_has_category();
  category_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSTopRankTimeReq.Category)
}

// -------------------------------------------------------------------

// CSTopRankTimeResp

// optional uint32 BeginAt = 1;
inline bool CSTopRankTimeResp::has_beginat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSTopRankTimeResp::set_has_beginat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSTopRankTimeResp::clear_has_beginat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSTopRankTimeResp::clear_beginat() {
  beginat_ = 0u;
  clear_has_beginat();
}
inline ::google::protobuf::uint32 CSTopRankTimeResp::beginat() const {
  // @@protoc_insertion_point(field_get:fgame.CSTopRankTimeResp.BeginAt)
  return beginat_;
}
inline void CSTopRankTimeResp::set_beginat(::google::protobuf::uint32 value) {
  set_has_beginat();
  beginat_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSTopRankTimeResp.BeginAt)
}

// optional uint32 EndAt = 2;
inline bool CSTopRankTimeResp::has_endat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSTopRankTimeResp::set_has_endat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSTopRankTimeResp::clear_has_endat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSTopRankTimeResp::clear_endat() {
  endat_ = 0u;
  clear_has_endat();
}
inline ::google::protobuf::uint32 CSTopRankTimeResp::endat() const {
  // @@protoc_insertion_point(field_get:fgame.CSTopRankTimeResp.EndAt)
  return endat_;
}
inline void CSTopRankTimeResp::set_endat(::google::protobuf::uint32 value) {
  set_has_endat();
  endat_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSTopRankTimeResp.EndAt)
}

// optional uint32 Category = 3;
inline bool CSTopRankTimeResp::has_category() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSTopRankTimeResp::set_has_category() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSTopRankTimeResp::clear_has_category() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSTopRankTimeResp::clear_category() {
  category_ = 0u;
  clear_has_category();
}
inline ::google::protobuf::uint32 CSTopRankTimeResp::category() const {
  // @@protoc_insertion_point(field_get:fgame.CSTopRankTimeResp.Category)
  return category_;
}
inline void CSTopRankTimeResp::set_category(::google::protobuf::uint32 value) {
  set_has_category();
  category_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSTopRankTimeResp.Category)
}

// optional uint32 Secs = 4;
inline bool CSTopRankTimeResp::has_secs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSTopRankTimeResp::set_has_secs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSTopRankTimeResp::clear_has_secs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSTopRankTimeResp::clear_secs() {
  secs_ = 0u;
  clear_has_secs();
}
inline ::google::protobuf::uint32 CSTopRankTimeResp::secs() const {
  // @@protoc_insertion_point(field_get:fgame.CSTopRankTimeResp.Secs)
  return secs_;
}
inline void CSTopRankTimeResp::set_secs(::google::protobuf::uint32 value) {
  set_has_secs();
  secs_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSTopRankTimeResp.Secs)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fgame

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Player_2eproto__INCLUDED
