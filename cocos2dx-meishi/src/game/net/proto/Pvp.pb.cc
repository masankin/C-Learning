// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Pvp.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Pvp.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace fgame {

void protobuf_ShutdownFile_Pvp_2eproto() {
  delete CSPvpMatchReq::default_instance_;
  delete CSPropData::default_instance_;
  delete CSPlayInfo::default_instance_;
  delete CSPvpMatchResp::default_instance_;
  delete CSPvpStopMatchReq::default_instance_;
  delete CSPvpStopMatchResp::default_instance_;
  delete CSPvpAppearCreepReq::default_instance_;
  delete CSPvpAppearCreepResp::default_instance_;
  delete CSPvpObserverReq::default_instance_;
  delete CSPvpObserverResp::default_instance_;
  delete CSPvpStartReq::default_instance_;
  delete CSPlayerPoint::default_instance_;
  delete CSPvpStartResp::default_instance_;
  delete CSPvpFightReq::default_instance_;
  delete CSPvpFightResp::default_instance_;
  delete CSPvpUpgradeReq::default_instance_;
  delete CSPvpUpgradeResp::default_instance_;
  delete CSPvpEndReq::default_instance_;
  delete CSPlayerPvpResult::default_instance_;
  delete CSPvpEndResp::default_instance_;
  delete CSPvpLeaveReq::default_instance_;
  delete CSPvpLeaveResp::default_instance_;
  delete CSPvpGetAwardResp::default_instance_;
  delete CSFormationList::default_instance_;
  delete CSMapData::default_instance_;
  delete CSPvpMapReq::default_instance_;
  delete CSPvpMapResp::default_instance_;
  delete CSPvpPingReq::default_instance_;
  delete CSPvpPingResp::default_instance_;
  delete CSPvpUseItemReq::default_instance_;
  delete CSPvpUseItemResp::default_instance_;
  delete CSPvpUseSkillReq::default_instance_;
  delete PvpAssistantInfo::default_instance_;
  delete CSPvpAssistantInfoResp::default_instance_;
  delete CSPvpUseSkillResp::default_instance_;
  delete CSPvpRankingGetListReq::default_instance_;
  delete CSPvpRankingPlayerInfo::default_instance_;
  delete CSPvpRankingGetListResp::default_instance_;
  delete CSPvpRankingPlayerInfoReq::default_instance_;
  delete CSPvpRankingPlayerInfoResp::default_instance_;
  delete CSPvpResultReq::default_instance_;
  delete CSPvpResultResp::default_instance_;
  delete CSPvpSelfRankListReq::default_instance_;
  delete CSPvpSelfRankListResp::default_instance_;
  delete CSPvpChatReq::default_instance_;
  delete CSPvpChatResp::default_instance_;
  delete CSPvpRecoverItemReq::default_instance_;
  delete CSPvpRecoverItemResp::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_Pvp_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_Pvp_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::fgame::protobuf_AddDesc_Base_2eproto();
  ::fgame::protobuf_AddDesc_Player_2eproto();
  CSPvpMatchReq::default_instance_ = new CSPvpMatchReq();
  CSPropData::default_instance_ = new CSPropData();
  CSPlayInfo::default_instance_ = new CSPlayInfo();
  CSPvpMatchResp::default_instance_ = new CSPvpMatchResp();
  CSPvpStopMatchReq::default_instance_ = new CSPvpStopMatchReq();
  CSPvpStopMatchResp::default_instance_ = new CSPvpStopMatchResp();
  CSPvpAppearCreepReq::default_instance_ = new CSPvpAppearCreepReq();
  CSPvpAppearCreepResp::default_instance_ = new CSPvpAppearCreepResp();
  CSPvpObserverReq::default_instance_ = new CSPvpObserverReq();
  CSPvpObserverResp::default_instance_ = new CSPvpObserverResp();
  CSPvpStartReq::default_instance_ = new CSPvpStartReq();
  CSPlayerPoint::default_instance_ = new CSPlayerPoint();
  CSPvpStartResp::default_instance_ = new CSPvpStartResp();
  CSPvpFightReq::default_instance_ = new CSPvpFightReq();
  CSPvpFightResp::default_instance_ = new CSPvpFightResp();
  CSPvpUpgradeReq::default_instance_ = new CSPvpUpgradeReq();
  CSPvpUpgradeResp::default_instance_ = new CSPvpUpgradeResp();
  CSPvpEndReq::default_instance_ = new CSPvpEndReq();
  CSPlayerPvpResult::default_instance_ = new CSPlayerPvpResult();
  CSPvpEndResp::default_instance_ = new CSPvpEndResp();
  CSPvpLeaveReq::default_instance_ = new CSPvpLeaveReq();
  CSPvpLeaveResp::default_instance_ = new CSPvpLeaveResp();
  CSPvpGetAwardResp::default_instance_ = new CSPvpGetAwardResp();
  CSFormationList::default_instance_ = new CSFormationList();
  CSMapData::default_instance_ = new CSMapData();
  CSPvpMapReq::default_instance_ = new CSPvpMapReq();
  CSPvpMapResp::default_instance_ = new CSPvpMapResp();
  CSPvpPingReq::default_instance_ = new CSPvpPingReq();
  CSPvpPingResp::default_instance_ = new CSPvpPingResp();
  CSPvpUseItemReq::default_instance_ = new CSPvpUseItemReq();
  CSPvpUseItemResp::default_instance_ = new CSPvpUseItemResp();
  CSPvpUseSkillReq::default_instance_ = new CSPvpUseSkillReq();
  PvpAssistantInfo::default_instance_ = new PvpAssistantInfo();
  CSPvpAssistantInfoResp::default_instance_ = new CSPvpAssistantInfoResp();
  CSPvpUseSkillResp::default_instance_ = new CSPvpUseSkillResp();
  CSPvpRankingGetListReq::default_instance_ = new CSPvpRankingGetListReq();
  CSPvpRankingPlayerInfo::default_instance_ = new CSPvpRankingPlayerInfo();
  CSPvpRankingGetListResp::default_instance_ = new CSPvpRankingGetListResp();
  CSPvpRankingPlayerInfoReq::default_instance_ = new CSPvpRankingPlayerInfoReq();
  CSPvpRankingPlayerInfoResp::default_instance_ = new CSPvpRankingPlayerInfoResp();
  CSPvpResultReq::default_instance_ = new CSPvpResultReq();
  CSPvpResultResp::default_instance_ = new CSPvpResultResp();
  CSPvpSelfRankListReq::default_instance_ = new CSPvpSelfRankListReq();
  CSPvpSelfRankListResp::default_instance_ = new CSPvpSelfRankListResp();
  CSPvpChatReq::default_instance_ = new CSPvpChatReq();
  CSPvpChatResp::default_instance_ = new CSPvpChatResp();
  CSPvpRecoverItemReq::default_instance_ = new CSPvpRecoverItemReq();
  CSPvpRecoverItemResp::default_instance_ = new CSPvpRecoverItemResp();
  CSPvpMatchReq::default_instance_->InitAsDefaultInstance();
  CSPropData::default_instance_->InitAsDefaultInstance();
  CSPlayInfo::default_instance_->InitAsDefaultInstance();
  CSPvpMatchResp::default_instance_->InitAsDefaultInstance();
  CSPvpStopMatchReq::default_instance_->InitAsDefaultInstance();
  CSPvpStopMatchResp::default_instance_->InitAsDefaultInstance();
  CSPvpAppearCreepReq::default_instance_->InitAsDefaultInstance();
  CSPvpAppearCreepResp::default_instance_->InitAsDefaultInstance();
  CSPvpObserverReq::default_instance_->InitAsDefaultInstance();
  CSPvpObserverResp::default_instance_->InitAsDefaultInstance();
  CSPvpStartReq::default_instance_->InitAsDefaultInstance();
  CSPlayerPoint::default_instance_->InitAsDefaultInstance();
  CSPvpStartResp::default_instance_->InitAsDefaultInstance();
  CSPvpFightReq::default_instance_->InitAsDefaultInstance();
  CSPvpFightResp::default_instance_->InitAsDefaultInstance();
  CSPvpUpgradeReq::default_instance_->InitAsDefaultInstance();
  CSPvpUpgradeResp::default_instance_->InitAsDefaultInstance();
  CSPvpEndReq::default_instance_->InitAsDefaultInstance();
  CSPlayerPvpResult::default_instance_->InitAsDefaultInstance();
  CSPvpEndResp::default_instance_->InitAsDefaultInstance();
  CSPvpLeaveReq::default_instance_->InitAsDefaultInstance();
  CSPvpLeaveResp::default_instance_->InitAsDefaultInstance();
  CSPvpGetAwardResp::default_instance_->InitAsDefaultInstance();
  CSFormationList::default_instance_->InitAsDefaultInstance();
  CSMapData::default_instance_->InitAsDefaultInstance();
  CSPvpMapReq::default_instance_->InitAsDefaultInstance();
  CSPvpMapResp::default_instance_->InitAsDefaultInstance();
  CSPvpPingReq::default_instance_->InitAsDefaultInstance();
  CSPvpPingResp::default_instance_->InitAsDefaultInstance();
  CSPvpUseItemReq::default_instance_->InitAsDefaultInstance();
  CSPvpUseItemResp::default_instance_->InitAsDefaultInstance();
  CSPvpUseSkillReq::default_instance_->InitAsDefaultInstance();
  PvpAssistantInfo::default_instance_->InitAsDefaultInstance();
  CSPvpAssistantInfoResp::default_instance_->InitAsDefaultInstance();
  CSPvpUseSkillResp::default_instance_->InitAsDefaultInstance();
  CSPvpRankingGetListReq::default_instance_->InitAsDefaultInstance();
  CSPvpRankingPlayerInfo::default_instance_->InitAsDefaultInstance();
  CSPvpRankingGetListResp::default_instance_->InitAsDefaultInstance();
  CSPvpRankingPlayerInfoReq::default_instance_->InitAsDefaultInstance();
  CSPvpRankingPlayerInfoResp::default_instance_->InitAsDefaultInstance();
  CSPvpResultReq::default_instance_->InitAsDefaultInstance();
  CSPvpResultResp::default_instance_->InitAsDefaultInstance();
  CSPvpSelfRankListReq::default_instance_->InitAsDefaultInstance();
  CSPvpSelfRankListResp::default_instance_->InitAsDefaultInstance();
  CSPvpChatReq::default_instance_->InitAsDefaultInstance();
  CSPvpChatResp::default_instance_->InitAsDefaultInstance();
  CSPvpRecoverItemReq::default_instance_->InitAsDefaultInstance();
  CSPvpRecoverItemResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Pvp_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_Pvp_2eproto_once_);
void protobuf_AddDesc_Pvp_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_Pvp_2eproto_once_,
                 &protobuf_AddDesc_Pvp_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Pvp_2eproto {
  StaticDescriptorInitializer_Pvp_2eproto() {
    protobuf_AddDesc_Pvp_2eproto();
  }
} static_descriptor_initializer_Pvp_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int CSPvpMatchReq::kTypeFieldNumber;
const int CSPvpMatchReq::kModeFieldNumber;
#endif  // !_MSC_VER

CSPvpMatchReq::CSPvpMatchReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpMatchReq)
}

void CSPvpMatchReq::InitAsDefaultInstance() {
}

CSPvpMatchReq::CSPvpMatchReq(const CSPvpMatchReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpMatchReq)
}

void CSPvpMatchReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  mode_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpMatchReq::~CSPvpMatchReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpMatchReq)
  SharedDtor();
}

void CSPvpMatchReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpMatchReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpMatchReq& CSPvpMatchReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpMatchReq* CSPvpMatchReq::default_instance_ = NULL;

CSPvpMatchReq* CSPvpMatchReq::New() const {
  return new CSPvpMatchReq;
}

void CSPvpMatchReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpMatchReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(type_, mode_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpMatchReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpMatchReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Mode;
        break;
      }

      // optional uint32 Mode = 2;
      case 2: {
        if (tag == 16) {
         parse_Mode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mode_)));
          set_has_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpMatchReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpMatchReq)
  return false;
#undef DO_
}

void CSPvpMatchReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpMatchReq)
  // required uint32 Type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  // optional uint32 Mode = 2;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->mode(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpMatchReq)
}

int CSPvpMatchReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // optional uint32 Mode = 2;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mode());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpMatchReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpMatchReq*>(&from));
}

void CSPvpMatchReq::MergeFrom(const CSPvpMatchReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_mode()) {
      set_mode(from.mode());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpMatchReq::CopyFrom(const CSPvpMatchReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpMatchReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPvpMatchReq::Swap(CSPvpMatchReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(mode_, other->mode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpMatchReq::GetTypeName() const {
  return "fgame.CSPvpMatchReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPropData::kItemIdFieldNumber;
const int CSPropData::kCountFieldNumber;
#endif  // !_MSC_VER

CSPropData::CSPropData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPropData)
}

void CSPropData::InitAsDefaultInstance() {
}

CSPropData::CSPropData(const CSPropData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPropData)
}

void CSPropData::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0;
  count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPropData::~CSPropData() {
  // @@protoc_insertion_point(destructor:fgame.CSPropData)
  SharedDtor();
}

void CSPropData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPropData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPropData& CSPropData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPropData* CSPropData::default_instance_ = NULL;

CSPropData* CSPropData::New() const {
  return new CSPropData;
}

void CSPropData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPropData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(itemid_, count_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPropData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPropData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ItemId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Count;
        break;
      }

      // required int32 Count = 2;
      case 2: {
        if (tag == 16) {
         parse_Count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPropData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPropData)
  return false;
#undef DO_
}

void CSPropData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPropData)
  // required int32 ItemId = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->itemid(), output);
  }

  // required int32 Count = 2;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->count(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPropData)
}

int CSPropData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ItemId = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // required int32 Count = 2;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPropData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPropData*>(&from));
}

void CSPropData::MergeFrom(const CSPropData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPropData::CopyFrom(const CSPropData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPropData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSPropData::Swap(CSPropData* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPropData::GetTypeName() const {
  return "fgame.CSPropData";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPlayInfo::kUinFieldNumber;
const int CSPlayInfo::kNameFieldNumber;
const int CSPlayInfo::kPropDataFieldNumber;
#endif  // !_MSC_VER

CSPlayInfo::CSPlayInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPlayInfo)
}

void CSPlayInfo::InitAsDefaultInstance() {
}

CSPlayInfo::CSPlayInfo(const CSPlayInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPlayInfo)
}

void CSPlayInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  uin_ = GOOGLE_LONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPlayInfo::~CSPlayInfo() {
  // @@protoc_insertion_point(destructor:fgame.CSPlayInfo)
  SharedDtor();
}

void CSPlayInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPlayInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPlayInfo& CSPlayInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPlayInfo* CSPlayInfo::default_instance_ = NULL;

CSPlayInfo* CSPlayInfo::New() const {
  return new CSPlayInfo;
}

void CSPlayInfo::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    uin_ = GOOGLE_LONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
  }
  propdata_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPlayInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPlayInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Name;
        break;
      }

      // required string Name = 2;
      case 2: {
        if (tag == 18) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_PropData;
        break;
      }

      // repeated .fgame.CSPropData PropData = 3;
      case 3: {
        if (tag == 26) {
         parse_PropData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_propdata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_PropData;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPlayInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPlayInfo)
  return false;
#undef DO_
}

void CSPlayInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPlayInfo)
  // required int64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->uin(), output);
  }

  // required string Name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // repeated .fgame.CSPropData PropData = 3;
  for (int i = 0; i < this->propdata_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->propdata(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPlayInfo)
}

int CSPlayInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->uin());
    }

    // required string Name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  // repeated .fgame.CSPropData PropData = 3;
  total_size += 1 * this->propdata_size();
  for (int i = 0; i < this->propdata_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->propdata(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPlayInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPlayInfo*>(&from));
}

void CSPlayInfo::MergeFrom(const CSPlayInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  propdata_.MergeFrom(from.propdata_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPlayInfo::CopyFrom(const CSPlayInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPlayInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->propdata())) return false;
  return true;
}

void CSPlayInfo::Swap(CSPlayInfo* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(name_, other->name_);
    propdata_.Swap(&other->propdata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPlayInfo::GetTypeName() const {
  return "fgame.CSPlayInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpMatchResp::kMatchRetFieldNumber;
const int CSPvpMatchResp::kPlayInfoFieldNumber;
const int CSPvpMatchResp::kTypeFieldNumber;
const int CSPvpMatchResp::kFlagFieldNumber;
const int CSPvpMatchResp::kRoomIdFieldNumber;
const int CSPvpMatchResp::kOpenerFieldNumber;
#endif  // !_MSC_VER

CSPvpMatchResp::CSPvpMatchResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpMatchResp)
}

void CSPvpMatchResp::InitAsDefaultInstance() {
}

CSPvpMatchResp::CSPvpMatchResp(const CSPvpMatchResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpMatchResp)
}

void CSPvpMatchResp::SharedCtor() {
  _cached_size_ = 0;
  match_ret_ = 0u;
  type_ = 0u;
  flag_ = 0u;
  roomid_ = 0u;
  opener_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpMatchResp::~CSPvpMatchResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpMatchResp)
  SharedDtor();
}

void CSPvpMatchResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpMatchResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpMatchResp& CSPvpMatchResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpMatchResp* CSPvpMatchResp::default_instance_ = NULL;

CSPvpMatchResp* CSPvpMatchResp::New() const {
  return new CSPvpMatchResp;
}

void CSPvpMatchResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpMatchResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 61) {
    ZR_(match_ret_, opener_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  playinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpMatchResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpMatchResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Match_Ret = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &match_ret_)));
          set_has_match_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_PlayInfo;
        break;
      }

      // repeated .fgame.CSPlayInfo PlayInfo = 2;
      case 2: {
        if (tag == 18) {
         parse_PlayInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_playinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_PlayInfo;
        if (input->ExpectTag(24)) goto parse_Type;
        break;
      }

      // required uint32 Type = 3;
      case 3: {
        if (tag == 24) {
         parse_Type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Flag;
        break;
      }

      // optional uint32 Flag = 4;
      case 4: {
        if (tag == 32) {
         parse_Flag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flag_)));
          set_has_flag();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_RoomId;
        break;
      }

      // optional uint32 RoomId = 5;
      case 5: {
        if (tag == 40) {
         parse_RoomId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_Opener;
        break;
      }

      // optional uint32 Opener = 6;
      case 6: {
        if (tag == 48) {
         parse_Opener:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &opener_)));
          set_has_opener();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpMatchResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpMatchResp)
  return false;
#undef DO_
}

void CSPvpMatchResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpMatchResp)
  // required uint32 Match_Ret = 1;
  if (has_match_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->match_ret(), output);
  }

  // repeated .fgame.CSPlayInfo PlayInfo = 2;
  for (int i = 0; i < this->playinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->playinfo(i), output);
  }

  // required uint32 Type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->type(), output);
  }

  // optional uint32 Flag = 4;
  if (has_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->flag(), output);
  }

  // optional uint32 RoomId = 5;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->roomid(), output);
  }

  // optional uint32 Opener = 6;
  if (has_opener()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->opener(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpMatchResp)
}

int CSPvpMatchResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Match_Ret = 1;
    if (has_match_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->match_ret());
    }

    // required uint32 Type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // optional uint32 Flag = 4;
    if (has_flag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flag());
    }

    // optional uint32 RoomId = 5;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

    // optional uint32 Opener = 6;
    if (has_opener()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->opener());
    }

  }
  // repeated .fgame.CSPlayInfo PlayInfo = 2;
  total_size += 1 * this->playinfo_size();
  for (int i = 0; i < this->playinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->playinfo(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpMatchResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpMatchResp*>(&from));
}

void CSPvpMatchResp::MergeFrom(const CSPvpMatchResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  playinfo_.MergeFrom(from.playinfo_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_match_ret()) {
      set_match_ret(from.match_ret());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_flag()) {
      set_flag(from.flag());
    }
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_opener()) {
      set_opener(from.opener());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpMatchResp::CopyFrom(const CSPvpMatchResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpMatchResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->playinfo())) return false;
  return true;
}

void CSPvpMatchResp::Swap(CSPvpMatchResp* other) {
  if (other != this) {
    std::swap(match_ret_, other->match_ret_);
    playinfo_.Swap(&other->playinfo_);
    std::swap(type_, other->type_);
    std::swap(flag_, other->flag_);
    std::swap(roomid_, other->roomid_);
    std::swap(opener_, other->opener_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpMatchResp::GetTypeName() const {
  return "fgame.CSPvpMatchResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpStopMatchReq::kTypeFieldNumber;
const int CSPvpStopMatchReq::kModeFieldNumber;
#endif  // !_MSC_VER

CSPvpStopMatchReq::CSPvpStopMatchReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpStopMatchReq)
}

void CSPvpStopMatchReq::InitAsDefaultInstance() {
}

CSPvpStopMatchReq::CSPvpStopMatchReq(const CSPvpStopMatchReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpStopMatchReq)
}

void CSPvpStopMatchReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  mode_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpStopMatchReq::~CSPvpStopMatchReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpStopMatchReq)
  SharedDtor();
}

void CSPvpStopMatchReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpStopMatchReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpStopMatchReq& CSPvpStopMatchReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpStopMatchReq* CSPvpStopMatchReq::default_instance_ = NULL;

CSPvpStopMatchReq* CSPvpStopMatchReq::New() const {
  return new CSPvpStopMatchReq;
}

void CSPvpStopMatchReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpStopMatchReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(type_, mode_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpStopMatchReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpStopMatchReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Mode;
        break;
      }

      // optional uint32 Mode = 2;
      case 2: {
        if (tag == 16) {
         parse_Mode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mode_)));
          set_has_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpStopMatchReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpStopMatchReq)
  return false;
#undef DO_
}

void CSPvpStopMatchReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpStopMatchReq)
  // required uint32 Type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  // optional uint32 Mode = 2;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->mode(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpStopMatchReq)
}

int CSPvpStopMatchReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // optional uint32 Mode = 2;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mode());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpStopMatchReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpStopMatchReq*>(&from));
}

void CSPvpStopMatchReq::MergeFrom(const CSPvpStopMatchReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_mode()) {
      set_mode(from.mode());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpStopMatchReq::CopyFrom(const CSPvpStopMatchReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpStopMatchReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPvpStopMatchReq::Swap(CSPvpStopMatchReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(mode_, other->mode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpStopMatchReq::GetTypeName() const {
  return "fgame.CSPvpStopMatchReq";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSPvpStopMatchResp::CSPvpStopMatchResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpStopMatchResp)
}

void CSPvpStopMatchResp::InitAsDefaultInstance() {
}

CSPvpStopMatchResp::CSPvpStopMatchResp(const CSPvpStopMatchResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpStopMatchResp)
}

void CSPvpStopMatchResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpStopMatchResp::~CSPvpStopMatchResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpStopMatchResp)
  SharedDtor();
}

void CSPvpStopMatchResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpStopMatchResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpStopMatchResp& CSPvpStopMatchResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpStopMatchResp* CSPvpStopMatchResp::default_instance_ = NULL;

CSPvpStopMatchResp* CSPvpStopMatchResp::New() const {
  return new CSPvpStopMatchResp;
}

void CSPvpStopMatchResp::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpStopMatchResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpStopMatchResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpStopMatchResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpStopMatchResp)
  return false;
#undef DO_
}

void CSPvpStopMatchResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpStopMatchResp)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpStopMatchResp)
}

int CSPvpStopMatchResp::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpStopMatchResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpStopMatchResp*>(&from));
}

void CSPvpStopMatchResp::MergeFrom(const CSPvpStopMatchResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpStopMatchResp::CopyFrom(const CSPvpStopMatchResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpStopMatchResp::IsInitialized() const {

  return true;
}

void CSPvpStopMatchResp::Swap(CSPvpStopMatchResp* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpStopMatchResp::GetTypeName() const {
  return "fgame.CSPvpStopMatchResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpAppearCreepReq::kCreepIdFieldNumber;
const int CSPvpAppearCreepReq::kTsFieldNumber;
const int CSPvpAppearCreepReq::kDataIdFieldNumber;
const int CSPvpAppearCreepReq::kRoomIdFieldNumber;
const int CSPvpAppearCreepReq::kMsgNoFieldNumber;
#endif  // !_MSC_VER

CSPvpAppearCreepReq::CSPvpAppearCreepReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpAppearCreepReq)
}

void CSPvpAppearCreepReq::InitAsDefaultInstance() {
}

CSPvpAppearCreepReq::CSPvpAppearCreepReq(const CSPvpAppearCreepReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpAppearCreepReq)
}

void CSPvpAppearCreepReq::SharedCtor() {
  _cached_size_ = 0;
  creepid_ = 0u;
  ts_ = 0;
  dataid_ = 0u;
  roomid_ = 0u;
  msgno_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpAppearCreepReq::~CSPvpAppearCreepReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpAppearCreepReq)
  SharedDtor();
}

void CSPvpAppearCreepReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpAppearCreepReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpAppearCreepReq& CSPvpAppearCreepReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpAppearCreepReq* CSPvpAppearCreepReq::default_instance_ = NULL;

CSPvpAppearCreepReq* CSPvpAppearCreepReq::New() const {
  return new CSPvpAppearCreepReq;
}

void CSPvpAppearCreepReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpAppearCreepReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(ts_, msgno_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpAppearCreepReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpAppearCreepReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 CreepId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &creepid_)));
          set_has_creepid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_Ts;
        break;
      }

      // required double Ts = 2;
      case 2: {
        if (tag == 17) {
         parse_Ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_DataId;
        break;
      }

      // required uint32 DataId = 3;
      case 3: {
        if (tag == 24) {
         parse_DataId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dataid_)));
          set_has_dataid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_RoomId;
        break;
      }

      // optional uint32 RoomId = 4;
      case 4: {
        if (tag == 32) {
         parse_RoomId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_MsgNo;
        break;
      }

      // optional uint32 MsgNo = 5;
      case 5: {
        if (tag == 40) {
         parse_MsgNo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msgno_)));
          set_has_msgno();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpAppearCreepReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpAppearCreepReq)
  return false;
#undef DO_
}

void CSPvpAppearCreepReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpAppearCreepReq)
  // required uint32 CreepId = 1;
  if (has_creepid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->creepid(), output);
  }

  // required double Ts = 2;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->ts(), output);
  }

  // required uint32 DataId = 3;
  if (has_dataid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->dataid(), output);
  }

  // optional uint32 RoomId = 4;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->roomid(), output);
  }

  // optional uint32 MsgNo = 5;
  if (has_msgno()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->msgno(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpAppearCreepReq)
}

int CSPvpAppearCreepReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 CreepId = 1;
    if (has_creepid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->creepid());
    }

    // required double Ts = 2;
    if (has_ts()) {
      total_size += 1 + 8;
    }

    // required uint32 DataId = 3;
    if (has_dataid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dataid());
    }

    // optional uint32 RoomId = 4;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

    // optional uint32 MsgNo = 5;
    if (has_msgno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msgno());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpAppearCreepReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpAppearCreepReq*>(&from));
}

void CSPvpAppearCreepReq::MergeFrom(const CSPvpAppearCreepReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_creepid()) {
      set_creepid(from.creepid());
    }
    if (from.has_ts()) {
      set_ts(from.ts());
    }
    if (from.has_dataid()) {
      set_dataid(from.dataid());
    }
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_msgno()) {
      set_msgno(from.msgno());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpAppearCreepReq::CopyFrom(const CSPvpAppearCreepReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpAppearCreepReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSPvpAppearCreepReq::Swap(CSPvpAppearCreepReq* other) {
  if (other != this) {
    std::swap(creepid_, other->creepid_);
    std::swap(ts_, other->ts_);
    std::swap(dataid_, other->dataid_);
    std::swap(roomid_, other->roomid_);
    std::swap(msgno_, other->msgno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpAppearCreepReq::GetTypeName() const {
  return "fgame.CSPvpAppearCreepReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpAppearCreepResp::kCreepIdFieldNumber;
const int CSPvpAppearCreepResp::kTsFieldNumber;
const int CSPvpAppearCreepResp::kDataIdFieldNumber;
#endif  // !_MSC_VER

CSPvpAppearCreepResp::CSPvpAppearCreepResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpAppearCreepResp)
}

void CSPvpAppearCreepResp::InitAsDefaultInstance() {
}

CSPvpAppearCreepResp::CSPvpAppearCreepResp(const CSPvpAppearCreepResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpAppearCreepResp)
}

void CSPvpAppearCreepResp::SharedCtor() {
  _cached_size_ = 0;
  creepid_ = 0u;
  ts_ = 0;
  dataid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpAppearCreepResp::~CSPvpAppearCreepResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpAppearCreepResp)
  SharedDtor();
}

void CSPvpAppearCreepResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpAppearCreepResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpAppearCreepResp& CSPvpAppearCreepResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpAppearCreepResp* CSPvpAppearCreepResp::default_instance_ = NULL;

CSPvpAppearCreepResp* CSPvpAppearCreepResp::New() const {
  return new CSPvpAppearCreepResp;
}

void CSPvpAppearCreepResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpAppearCreepResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ts_, dataid_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpAppearCreepResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpAppearCreepResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 CreepId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &creepid_)));
          set_has_creepid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_Ts;
        break;
      }

      // required double Ts = 2;
      case 2: {
        if (tag == 17) {
         parse_Ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_DataId;
        break;
      }

      // required uint32 DataId = 3;
      case 3: {
        if (tag == 24) {
         parse_DataId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dataid_)));
          set_has_dataid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpAppearCreepResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpAppearCreepResp)
  return false;
#undef DO_
}

void CSPvpAppearCreepResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpAppearCreepResp)
  // required uint32 CreepId = 1;
  if (has_creepid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->creepid(), output);
  }

  // required double Ts = 2;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->ts(), output);
  }

  // required uint32 DataId = 3;
  if (has_dataid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->dataid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpAppearCreepResp)
}

int CSPvpAppearCreepResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 CreepId = 1;
    if (has_creepid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->creepid());
    }

    // required double Ts = 2;
    if (has_ts()) {
      total_size += 1 + 8;
    }

    // required uint32 DataId = 3;
    if (has_dataid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dataid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpAppearCreepResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpAppearCreepResp*>(&from));
}

void CSPvpAppearCreepResp::MergeFrom(const CSPvpAppearCreepResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_creepid()) {
      set_creepid(from.creepid());
    }
    if (from.has_ts()) {
      set_ts(from.ts());
    }
    if (from.has_dataid()) {
      set_dataid(from.dataid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpAppearCreepResp::CopyFrom(const CSPvpAppearCreepResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpAppearCreepResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSPvpAppearCreepResp::Swap(CSPvpAppearCreepResp* other) {
  if (other != this) {
    std::swap(creepid_, other->creepid_);
    std::swap(ts_, other->ts_);
    std::swap(dataid_, other->dataid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpAppearCreepResp::GetTypeName() const {
  return "fgame.CSPvpAppearCreepResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpObserverReq::kRoomIdFieldNumber;
const int CSPvpObserverReq::kMsgNoFieldNumber;
const int CSPvpObserverReq::kUinFieldNumber;
#endif  // !_MSC_VER

CSPvpObserverReq::CSPvpObserverReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpObserverReq)
}

void CSPvpObserverReq::InitAsDefaultInstance() {
}

CSPvpObserverReq::CSPvpObserverReq(const CSPvpObserverReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpObserverReq)
}

void CSPvpObserverReq::SharedCtor() {
  _cached_size_ = 0;
  roomid_ = 0u;
  msgno_ = 0u;
  uin_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpObserverReq::~CSPvpObserverReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpObserverReq)
  SharedDtor();
}

void CSPvpObserverReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpObserverReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpObserverReq& CSPvpObserverReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpObserverReq* CSPvpObserverReq::default_instance_ = NULL;

CSPvpObserverReq* CSPvpObserverReq::New() const {
  return new CSPvpObserverReq;
}

void CSPvpObserverReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpObserverReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(roomid_, uin_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpObserverReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpObserverReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 RoomId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_MsgNo;
        break;
      }

      // optional uint32 MsgNo = 2;
      case 2: {
        if (tag == 16) {
         parse_MsgNo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msgno_)));
          set_has_msgno();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Uin;
        break;
      }

      // optional int64 Uin = 3;
      case 3: {
        if (tag == 24) {
         parse_Uin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpObserverReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpObserverReq)
  return false;
#undef DO_
}

void CSPvpObserverReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpObserverReq)
  // optional uint32 RoomId = 1;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->roomid(), output);
  }

  // optional uint32 MsgNo = 2;
  if (has_msgno()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->msgno(), output);
  }

  // optional int64 Uin = 3;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->uin(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpObserverReq)
}

int CSPvpObserverReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 RoomId = 1;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

    // optional uint32 MsgNo = 2;
    if (has_msgno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msgno());
    }

    // optional int64 Uin = 3;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->uin());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpObserverReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpObserverReq*>(&from));
}

void CSPvpObserverReq::MergeFrom(const CSPvpObserverReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_msgno()) {
      set_msgno(from.msgno());
    }
    if (from.has_uin()) {
      set_uin(from.uin());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpObserverReq::CopyFrom(const CSPvpObserverReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpObserverReq::IsInitialized() const {

  return true;
}

void CSPvpObserverReq::Swap(CSPvpObserverReq* other) {
  if (other != this) {
    std::swap(roomid_, other->roomid_);
    std::swap(msgno_, other->msgno_);
    std::swap(uin_, other->uin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpObserverReq::GetTypeName() const {
  return "fgame.CSPvpObserverReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpObserverResp::kUinFieldNumber;
#endif  // !_MSC_VER

CSPvpObserverResp::CSPvpObserverResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpObserverResp)
}

void CSPvpObserverResp::InitAsDefaultInstance() {
}

CSPvpObserverResp::CSPvpObserverResp(const CSPvpObserverResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpObserverResp)
}

void CSPvpObserverResp::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpObserverResp::~CSPvpObserverResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpObserverResp)
  SharedDtor();
}

void CSPvpObserverResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpObserverResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpObserverResp& CSPvpObserverResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpObserverResp* CSPvpObserverResp::default_instance_ = NULL;

CSPvpObserverResp* CSPvpObserverResp::New() const {
  return new CSPvpObserverResp;
}

void CSPvpObserverResp::Clear() {
  uin_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpObserverResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpObserverResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpObserverResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpObserverResp)
  return false;
#undef DO_
}

void CSPvpObserverResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpObserverResp)
  // optional int64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->uin(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpObserverResp)
}

int CSPvpObserverResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->uin());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpObserverResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpObserverResp*>(&from));
}

void CSPvpObserverResp::MergeFrom(const CSPvpObserverResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpObserverResp::CopyFrom(const CSPvpObserverResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpObserverResp::IsInitialized() const {

  return true;
}

void CSPvpObserverResp::Swap(CSPvpObserverResp* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpObserverResp::GetTypeName() const {
  return "fgame.CSPvpObserverResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpStartReq::kTypeFieldNumber;
const int CSPvpStartReq::kRoomIdFieldNumber;
const int CSPvpStartReq::kMsgNoFieldNumber;
#endif  // !_MSC_VER

CSPvpStartReq::CSPvpStartReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpStartReq)
}

void CSPvpStartReq::InitAsDefaultInstance() {
}

CSPvpStartReq::CSPvpStartReq(const CSPvpStartReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpStartReq)
}

void CSPvpStartReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  roomid_ = 0u;
  msgno_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpStartReq::~CSPvpStartReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpStartReq)
  SharedDtor();
}

void CSPvpStartReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpStartReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpStartReq& CSPvpStartReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpStartReq* CSPvpStartReq::default_instance_ = NULL;

CSPvpStartReq* CSPvpStartReq::New() const {
  return new CSPvpStartReq;
}

void CSPvpStartReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpStartReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(type_, msgno_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpStartReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpStartReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_RoomId;
        break;
      }

      // optional uint32 RoomId = 2;
      case 2: {
        if (tag == 16) {
         parse_RoomId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_MsgNo;
        break;
      }

      // optional uint32 MsgNo = 3;
      case 3: {
        if (tag == 24) {
         parse_MsgNo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msgno_)));
          set_has_msgno();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpStartReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpStartReq)
  return false;
#undef DO_
}

void CSPvpStartReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpStartReq)
  // required uint32 Type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  // optional uint32 RoomId = 2;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->roomid(), output);
  }

  // optional uint32 MsgNo = 3;
  if (has_msgno()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->msgno(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpStartReq)
}

int CSPvpStartReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // optional uint32 RoomId = 2;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

    // optional uint32 MsgNo = 3;
    if (has_msgno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msgno());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpStartReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpStartReq*>(&from));
}

void CSPvpStartReq::MergeFrom(const CSPvpStartReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_msgno()) {
      set_msgno(from.msgno());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpStartReq::CopyFrom(const CSPvpStartReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpStartReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPvpStartReq::Swap(CSPvpStartReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(roomid_, other->roomid_);
    std::swap(msgno_, other->msgno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpStartReq::GetTypeName() const {
  return "fgame.CSPvpStartReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPlayerPoint::kUinFieldNumber;
const int CSPlayerPoint::kCampFieldNumber;
const int CSPlayerPoint::kNameFieldNumber;
const int CSPlayerPoint::kIconFieldNumber;
const int CSPlayerPoint::kPointFieldNumber;
#endif  // !_MSC_VER

CSPlayerPoint::CSPlayerPoint()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPlayerPoint)
}

void CSPlayerPoint::InitAsDefaultInstance() {
}

CSPlayerPoint::CSPlayerPoint(const CSPlayerPoint& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPlayerPoint)
}

void CSPlayerPoint::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  uin_ = GOOGLE_LONGLONG(0);
  camp_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  point_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPlayerPoint::~CSPlayerPoint() {
  // @@protoc_insertion_point(destructor:fgame.CSPlayerPoint)
  SharedDtor();
}

void CSPlayerPoint::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPlayerPoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPlayerPoint& CSPlayerPoint::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPlayerPoint* CSPlayerPoint::default_instance_ = NULL;

CSPlayerPoint* CSPlayerPoint::New() const {
  return new CSPlayerPoint;
}

void CSPlayerPoint::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPlayerPoint*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(camp_, point_);
    uin_ = GOOGLE_LONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_icon()) {
      if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        icon_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPlayerPoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPlayerPoint)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Camp;
        break;
      }

      // required uint32 Camp = 2;
      case 2: {
        if (tag == 16) {
         parse_Camp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &camp_)));
          set_has_camp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_Name;
        break;
      }

      // optional string Name = 3;
      case 3: {
        if (tag == 26) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_Icon;
        break;
      }

      // optional string Icon = 4;
      case 4: {
        if (tag == 34) {
         parse_Icon:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_icon()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_Point;
        break;
      }

      // optional uint32 Point = 5;
      case 5: {
        if (tag == 40) {
         parse_Point:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &point_)));
          set_has_point();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPlayerPoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPlayerPoint)
  return false;
#undef DO_
}

void CSPlayerPoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPlayerPoint)
  // required int64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->uin(), output);
  }

  // required uint32 Camp = 2;
  if (has_camp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->camp(), output);
  }

  // optional string Name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // optional string Icon = 4;
  if (has_icon()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->icon(), output);
  }

  // optional uint32 Point = 5;
  if (has_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->point(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPlayerPoint)
}

int CSPlayerPoint::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->uin());
    }

    // required uint32 Camp = 2;
    if (has_camp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->camp());
    }

    // optional string Name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string Icon = 4;
    if (has_icon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->icon());
    }

    // optional uint32 Point = 5;
    if (has_point()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->point());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPlayerPoint::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPlayerPoint*>(&from));
}

void CSPlayerPoint::MergeFrom(const CSPlayerPoint& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_camp()) {
      set_camp(from.camp());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_icon()) {
      set_icon(from.icon());
    }
    if (from.has_point()) {
      set_point(from.point());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPlayerPoint::CopyFrom(const CSPlayerPoint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPlayerPoint::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSPlayerPoint::Swap(CSPlayerPoint* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(camp_, other->camp_);
    std::swap(name_, other->name_);
    std::swap(icon_, other->icon_);
    std::swap(point_, other->point_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPlayerPoint::GetTypeName() const {
  return "fgame.CSPlayerPoint";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpStartResp::kMapIdFieldNumber;
const int CSPvpStartResp::kTypeFieldNumber;
const int CSPvpStartResp::kTsFieldNumber;
const int CSPvpStartResp::kPointsFieldNumber;
#endif  // !_MSC_VER

CSPvpStartResp::CSPvpStartResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpStartResp)
}

void CSPvpStartResp::InitAsDefaultInstance() {
}

CSPvpStartResp::CSPvpStartResp(const CSPvpStartResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpStartResp)
}

void CSPvpStartResp::SharedCtor() {
  _cached_size_ = 0;
  mapid_ = 0u;
  type_ = 0u;
  ts_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpStartResp::~CSPvpStartResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpStartResp)
  SharedDtor();
}

void CSPvpStartResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpStartResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpStartResp& CSPvpStartResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpStartResp* CSPvpStartResp::default_instance_ = NULL;

CSPvpStartResp* CSPvpStartResp::New() const {
  return new CSPvpStartResp;
}

void CSPvpStartResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpStartResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(mapid_, ts_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  points_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpStartResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpStartResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 MapId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mapid_)));
          set_has_mapid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Type;
        break;
      }

      // required uint32 Type = 2;
      case 2: {
        if (tag == 16) {
         parse_Type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_Ts;
        break;
      }

      // required double Ts = 3;
      case 3: {
        if (tag == 25) {
         parse_Ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_Points;
        break;
      }

      // repeated .fgame.CSPlayerPoint Points = 4;
      case 4: {
        if (tag == 34) {
         parse_Points:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_points()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_Points;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpStartResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpStartResp)
  return false;
#undef DO_
}

void CSPvpStartResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpStartResp)
  // required uint32 MapId = 1;
  if (has_mapid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->mapid(), output);
  }

  // required uint32 Type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->type(), output);
  }

  // required double Ts = 3;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->ts(), output);
  }

  // repeated .fgame.CSPlayerPoint Points = 4;
  for (int i = 0; i < this->points_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->points(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpStartResp)
}

int CSPvpStartResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 MapId = 1;
    if (has_mapid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mapid());
    }

    // required uint32 Type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required double Ts = 3;
    if (has_ts()) {
      total_size += 1 + 8;
    }

  }
  // repeated .fgame.CSPlayerPoint Points = 4;
  total_size += 1 * this->points_size();
  for (int i = 0; i < this->points_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->points(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpStartResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpStartResp*>(&from));
}

void CSPvpStartResp::MergeFrom(const CSPvpStartResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  points_.MergeFrom(from.points_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mapid()) {
      set_mapid(from.mapid());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_ts()) {
      set_ts(from.ts());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpStartResp::CopyFrom(const CSPvpStartResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpStartResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->points())) return false;
  return true;
}

void CSPvpStartResp::Swap(CSPvpStartResp* other) {
  if (other != this) {
    std::swap(mapid_, other->mapid_);
    std::swap(type_, other->type_);
    std::swap(ts_, other->ts_);
    points_.Swap(&other->points_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpStartResp::GetTypeName() const {
  return "fgame.CSPvpStartResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpFightReq::kUinFieldNumber;
const int CSPvpFightReq::kSrcFieldNumber;
const int CSPvpFightReq::kDestFieldNumber;
const int CSPvpFightReq::kNumFieldNumber;
const int CSPvpFightReq::kTsFieldNumber;
const int CSPvpFightReq::kFormationIdFieldNumber;
const int CSPvpFightReq::kRoomIdFieldNumber;
const int CSPvpFightReq::kMsgNoFieldNumber;
#endif  // !_MSC_VER

CSPvpFightReq::CSPvpFightReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpFightReq)
}

void CSPvpFightReq::InitAsDefaultInstance() {
}

CSPvpFightReq::CSPvpFightReq(const CSPvpFightReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpFightReq)
}

void CSPvpFightReq::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_LONGLONG(0);
  src_ = 0u;
  dest_ = 0u;
  num_ = 0u;
  ts_ = 0;
  formationid_ = 0u;
  roomid_ = 0u;
  msgno_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpFightReq::~CSPvpFightReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpFightReq)
  SharedDtor();
}

void CSPvpFightReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpFightReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpFightReq& CSPvpFightReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpFightReq* CSPvpFightReq::default_instance_ = NULL;

CSPvpFightReq* CSPvpFightReq::New() const {
  return new CSPvpFightReq;
}

void CSPvpFightReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpFightReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(uin_, msgno_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpFightReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpFightReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Src;
        break;
      }

      // required uint32 Src = 2;
      case 2: {
        if (tag == 16) {
         parse_Src:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &src_)));
          set_has_src();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Dest;
        break;
      }

      // required uint32 Dest = 3;
      case 3: {
        if (tag == 24) {
         parse_Dest:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dest_)));
          set_has_dest();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Num;
        break;
      }

      // required uint32 Num = 4;
      case 4: {
        if (tag == 32) {
         parse_Num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_Ts;
        break;
      }

      // required double Ts = 5;
      case 5: {
        if (tag == 41) {
         parse_Ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_FormationId;
        break;
      }

      // required uint32 FormationId = 6;
      case 6: {
        if (tag == 48) {
         parse_FormationId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &formationid_)));
          set_has_formationid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_RoomId;
        break;
      }

      // optional uint32 RoomId = 7;
      case 7: {
        if (tag == 56) {
         parse_RoomId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_MsgNo;
        break;
      }

      // optional uint32 MsgNo = 8;
      case 8: {
        if (tag == 64) {
         parse_MsgNo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msgno_)));
          set_has_msgno();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpFightReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpFightReq)
  return false;
#undef DO_
}

void CSPvpFightReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpFightReq)
  // required int64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->uin(), output);
  }

  // required uint32 Src = 2;
  if (has_src()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->src(), output);
  }

  // required uint32 Dest = 3;
  if (has_dest()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->dest(), output);
  }

  // required uint32 Num = 4;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->num(), output);
  }

  // required double Ts = 5;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->ts(), output);
  }

  // required uint32 FormationId = 6;
  if (has_formationid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->formationid(), output);
  }

  // optional uint32 RoomId = 7;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->roomid(), output);
  }

  // optional uint32 MsgNo = 8;
  if (has_msgno()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->msgno(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpFightReq)
}

int CSPvpFightReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->uin());
    }

    // required uint32 Src = 2;
    if (has_src()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->src());
    }

    // required uint32 Dest = 3;
    if (has_dest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dest());
    }

    // required uint32 Num = 4;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num());
    }

    // required double Ts = 5;
    if (has_ts()) {
      total_size += 1 + 8;
    }

    // required uint32 FormationId = 6;
    if (has_formationid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->formationid());
    }

    // optional uint32 RoomId = 7;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

    // optional uint32 MsgNo = 8;
    if (has_msgno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msgno());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpFightReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpFightReq*>(&from));
}

void CSPvpFightReq::MergeFrom(const CSPvpFightReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_src()) {
      set_src(from.src());
    }
    if (from.has_dest()) {
      set_dest(from.dest());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
    if (from.has_ts()) {
      set_ts(from.ts());
    }
    if (from.has_formationid()) {
      set_formationid(from.formationid());
    }
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_msgno()) {
      set_msgno(from.msgno());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpFightReq::CopyFrom(const CSPvpFightReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpFightReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void CSPvpFightReq::Swap(CSPvpFightReq* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(src_, other->src_);
    std::swap(dest_, other->dest_);
    std::swap(num_, other->num_);
    std::swap(ts_, other->ts_);
    std::swap(formationid_, other->formationid_);
    std::swap(roomid_, other->roomid_);
    std::swap(msgno_, other->msgno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpFightReq::GetTypeName() const {
  return "fgame.CSPvpFightReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpFightResp::kUinFieldNumber;
const int CSPvpFightResp::kSrcFieldNumber;
const int CSPvpFightResp::kDestFieldNumber;
const int CSPvpFightResp::kNumFieldNumber;
const int CSPvpFightResp::kTsFieldNumber;
const int CSPvpFightResp::kFormationIdFieldNumber;
#endif  // !_MSC_VER

CSPvpFightResp::CSPvpFightResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpFightResp)
}

void CSPvpFightResp::InitAsDefaultInstance() {
}

CSPvpFightResp::CSPvpFightResp(const CSPvpFightResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpFightResp)
}

void CSPvpFightResp::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_LONGLONG(0);
  src_ = 0u;
  dest_ = 0u;
  num_ = 0u;
  ts_ = 0;
  formationid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpFightResp::~CSPvpFightResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpFightResp)
  SharedDtor();
}

void CSPvpFightResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpFightResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpFightResp& CSPvpFightResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpFightResp* CSPvpFightResp::default_instance_ = NULL;

CSPvpFightResp* CSPvpFightResp::New() const {
  return new CSPvpFightResp;
}

void CSPvpFightResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpFightResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(uin_, formationid_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpFightResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpFightResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Src;
        break;
      }

      // required uint32 Src = 2;
      case 2: {
        if (tag == 16) {
         parse_Src:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &src_)));
          set_has_src();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Dest;
        break;
      }

      // required uint32 Dest = 3;
      case 3: {
        if (tag == 24) {
         parse_Dest:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dest_)));
          set_has_dest();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Num;
        break;
      }

      // required uint32 Num = 4;
      case 4: {
        if (tag == 32) {
         parse_Num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_Ts;
        break;
      }

      // required double Ts = 5;
      case 5: {
        if (tag == 41) {
         parse_Ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_FormationId;
        break;
      }

      // required uint32 FormationId = 6;
      case 6: {
        if (tag == 48) {
         parse_FormationId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &formationid_)));
          set_has_formationid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpFightResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpFightResp)
  return false;
#undef DO_
}

void CSPvpFightResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpFightResp)
  // required int64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->uin(), output);
  }

  // required uint32 Src = 2;
  if (has_src()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->src(), output);
  }

  // required uint32 Dest = 3;
  if (has_dest()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->dest(), output);
  }

  // required uint32 Num = 4;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->num(), output);
  }

  // required double Ts = 5;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->ts(), output);
  }

  // required uint32 FormationId = 6;
  if (has_formationid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->formationid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpFightResp)
}

int CSPvpFightResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->uin());
    }

    // required uint32 Src = 2;
    if (has_src()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->src());
    }

    // required uint32 Dest = 3;
    if (has_dest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dest());
    }

    // required uint32 Num = 4;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num());
    }

    // required double Ts = 5;
    if (has_ts()) {
      total_size += 1 + 8;
    }

    // required uint32 FormationId = 6;
    if (has_formationid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->formationid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpFightResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpFightResp*>(&from));
}

void CSPvpFightResp::MergeFrom(const CSPvpFightResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_src()) {
      set_src(from.src());
    }
    if (from.has_dest()) {
      set_dest(from.dest());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
    if (from.has_ts()) {
      set_ts(from.ts());
    }
    if (from.has_formationid()) {
      set_formationid(from.formationid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpFightResp::CopyFrom(const CSPvpFightResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpFightResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void CSPvpFightResp::Swap(CSPvpFightResp* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(src_, other->src_);
    std::swap(dest_, other->dest_);
    std::swap(num_, other->num_);
    std::swap(ts_, other->ts_);
    std::swap(formationid_, other->formationid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpFightResp::GetTypeName() const {
  return "fgame.CSPvpFightResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpUpgradeReq::kUinFieldNumber;
const int CSPvpUpgradeReq::kBuildIdFieldNumber;
const int CSPvpUpgradeReq::kTsFieldNumber;
const int CSPvpUpgradeReq::kLevelFieldNumber;
const int CSPvpUpgradeReq::kRoomIdFieldNumber;
const int CSPvpUpgradeReq::kMsgNoFieldNumber;
#endif  // !_MSC_VER

CSPvpUpgradeReq::CSPvpUpgradeReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpUpgradeReq)
}

void CSPvpUpgradeReq::InitAsDefaultInstance() {
}

CSPvpUpgradeReq::CSPvpUpgradeReq(const CSPvpUpgradeReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpUpgradeReq)
}

void CSPvpUpgradeReq::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_LONGLONG(0);
  buildid_ = 0u;
  ts_ = 0;
  level_ = 0u;
  roomid_ = 0u;
  msgno_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpUpgradeReq::~CSPvpUpgradeReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpUpgradeReq)
  SharedDtor();
}

void CSPvpUpgradeReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpUpgradeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpUpgradeReq& CSPvpUpgradeReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpUpgradeReq* CSPvpUpgradeReq::default_instance_ = NULL;

CSPvpUpgradeReq* CSPvpUpgradeReq::New() const {
  return new CSPvpUpgradeReq;
}

void CSPvpUpgradeReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpUpgradeReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(uin_, msgno_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpUpgradeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpUpgradeReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_BuildId;
        break;
      }

      // required uint32 BuildId = 2;
      case 2: {
        if (tag == 16) {
         parse_BuildId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buildid_)));
          set_has_buildid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_Ts;
        break;
      }

      // required double Ts = 3;
      case 3: {
        if (tag == 25) {
         parse_Ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Level;
        break;
      }

      // optional uint32 Level = 4;
      case 4: {
        if (tag == 32) {
         parse_Level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_RoomId;
        break;
      }

      // optional uint32 RoomId = 5;
      case 5: {
        if (tag == 40) {
         parse_RoomId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_MsgNo;
        break;
      }

      // optional uint32 MsgNo = 6;
      case 6: {
        if (tag == 48) {
         parse_MsgNo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msgno_)));
          set_has_msgno();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpUpgradeReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpUpgradeReq)
  return false;
#undef DO_
}

void CSPvpUpgradeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpUpgradeReq)
  // required int64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->uin(), output);
  }

  // required uint32 BuildId = 2;
  if (has_buildid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->buildid(), output);
  }

  // required double Ts = 3;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->ts(), output);
  }

  // optional uint32 Level = 4;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->level(), output);
  }

  // optional uint32 RoomId = 5;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->roomid(), output);
  }

  // optional uint32 MsgNo = 6;
  if (has_msgno()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->msgno(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpUpgradeReq)
}

int CSPvpUpgradeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->uin());
    }

    // required uint32 BuildId = 2;
    if (has_buildid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buildid());
    }

    // required double Ts = 3;
    if (has_ts()) {
      total_size += 1 + 8;
    }

    // optional uint32 Level = 4;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->level());
    }

    // optional uint32 RoomId = 5;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

    // optional uint32 MsgNo = 6;
    if (has_msgno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msgno());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpUpgradeReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpUpgradeReq*>(&from));
}

void CSPvpUpgradeReq::MergeFrom(const CSPvpUpgradeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_buildid()) {
      set_buildid(from.buildid());
    }
    if (from.has_ts()) {
      set_ts(from.ts());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_msgno()) {
      set_msgno(from.msgno());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpUpgradeReq::CopyFrom(const CSPvpUpgradeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpUpgradeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSPvpUpgradeReq::Swap(CSPvpUpgradeReq* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(buildid_, other->buildid_);
    std::swap(ts_, other->ts_);
    std::swap(level_, other->level_);
    std::swap(roomid_, other->roomid_);
    std::swap(msgno_, other->msgno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpUpgradeReq::GetTypeName() const {
  return "fgame.CSPvpUpgradeReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpUpgradeResp::kUinFieldNumber;
const int CSPvpUpgradeResp::kBuildIdFieldNumber;
const int CSPvpUpgradeResp::kTsFieldNumber;
const int CSPvpUpgradeResp::kLevelFieldNumber;
#endif  // !_MSC_VER

CSPvpUpgradeResp::CSPvpUpgradeResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpUpgradeResp)
}

void CSPvpUpgradeResp::InitAsDefaultInstance() {
}

CSPvpUpgradeResp::CSPvpUpgradeResp(const CSPvpUpgradeResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpUpgradeResp)
}

void CSPvpUpgradeResp::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_LONGLONG(0);
  buildid_ = 0u;
  ts_ = 0;
  level_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpUpgradeResp::~CSPvpUpgradeResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpUpgradeResp)
  SharedDtor();
}

void CSPvpUpgradeResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpUpgradeResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpUpgradeResp& CSPvpUpgradeResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpUpgradeResp* CSPvpUpgradeResp::default_instance_ = NULL;

CSPvpUpgradeResp* CSPvpUpgradeResp::New() const {
  return new CSPvpUpgradeResp;
}

void CSPvpUpgradeResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpUpgradeResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(uin_, level_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpUpgradeResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpUpgradeResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_BuildId;
        break;
      }

      // required uint32 BuildId = 2;
      case 2: {
        if (tag == 16) {
         parse_BuildId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buildid_)));
          set_has_buildid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_Ts;
        break;
      }

      // required double Ts = 3;
      case 3: {
        if (tag == 25) {
         parse_Ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Level;
        break;
      }

      // optional uint32 Level = 4;
      case 4: {
        if (tag == 32) {
         parse_Level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpUpgradeResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpUpgradeResp)
  return false;
#undef DO_
}

void CSPvpUpgradeResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpUpgradeResp)
  // required int64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->uin(), output);
  }

  // required uint32 BuildId = 2;
  if (has_buildid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->buildid(), output);
  }

  // required double Ts = 3;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->ts(), output);
  }

  // optional uint32 Level = 4;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->level(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpUpgradeResp)
}

int CSPvpUpgradeResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->uin());
    }

    // required uint32 BuildId = 2;
    if (has_buildid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buildid());
    }

    // required double Ts = 3;
    if (has_ts()) {
      total_size += 1 + 8;
    }

    // optional uint32 Level = 4;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->level());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpUpgradeResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpUpgradeResp*>(&from));
}

void CSPvpUpgradeResp::MergeFrom(const CSPvpUpgradeResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_buildid()) {
      set_buildid(from.buildid());
    }
    if (from.has_ts()) {
      set_ts(from.ts());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpUpgradeResp::CopyFrom(const CSPvpUpgradeResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpUpgradeResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSPvpUpgradeResp::Swap(CSPvpUpgradeResp* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(buildid_, other->buildid_);
    std::swap(ts_, other->ts_);
    std::swap(level_, other->level_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpUpgradeResp::GetTypeName() const {
  return "fgame.CSPvpUpgradeResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpEndReq::kWinFieldNumber;
const int CSPvpEndReq::kTsFieldNumber;
const int CSPvpEndReq::kRoomIdFieldNumber;
const int CSPvpEndReq::kMsgNoFieldNumber;
#endif  // !_MSC_VER

CSPvpEndReq::CSPvpEndReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpEndReq)
}

void CSPvpEndReq::InitAsDefaultInstance() {
}

CSPvpEndReq::CSPvpEndReq(const CSPvpEndReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpEndReq)
}

void CSPvpEndReq::SharedCtor() {
  _cached_size_ = 0;
  win_ = GOOGLE_LONGLONG(0);
  ts_ = 0;
  roomid_ = 0u;
  msgno_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpEndReq::~CSPvpEndReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpEndReq)
  SharedDtor();
}

void CSPvpEndReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpEndReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpEndReq& CSPvpEndReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpEndReq* CSPvpEndReq::default_instance_ = NULL;

CSPvpEndReq* CSPvpEndReq::New() const {
  return new CSPvpEndReq;
}

void CSPvpEndReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpEndReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(win_, msgno_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpEndReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpEndReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 Win = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &win_)));
          set_has_win();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_Ts;
        break;
      }

      // required double Ts = 2;
      case 2: {
        if (tag == 17) {
         parse_Ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_RoomId;
        break;
      }

      // optional uint32 RoomId = 3;
      case 3: {
        if (tag == 24) {
         parse_RoomId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_MsgNo;
        break;
      }

      // optional uint32 MsgNo = 4;
      case 4: {
        if (tag == 32) {
         parse_MsgNo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msgno_)));
          set_has_msgno();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpEndReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpEndReq)
  return false;
#undef DO_
}

void CSPvpEndReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpEndReq)
  // required int64 Win = 1;
  if (has_win()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->win(), output);
  }

  // required double Ts = 2;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->ts(), output);
  }

  // optional uint32 RoomId = 3;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->roomid(), output);
  }

  // optional uint32 MsgNo = 4;
  if (has_msgno()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->msgno(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpEndReq)
}

int CSPvpEndReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 Win = 1;
    if (has_win()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->win());
    }

    // required double Ts = 2;
    if (has_ts()) {
      total_size += 1 + 8;
    }

    // optional uint32 RoomId = 3;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

    // optional uint32 MsgNo = 4;
    if (has_msgno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msgno());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpEndReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpEndReq*>(&from));
}

void CSPvpEndReq::MergeFrom(const CSPvpEndReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_win()) {
      set_win(from.win());
    }
    if (from.has_ts()) {
      set_ts(from.ts());
    }
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_msgno()) {
      set_msgno(from.msgno());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpEndReq::CopyFrom(const CSPvpEndReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpEndReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSPvpEndReq::Swap(CSPvpEndReq* other) {
  if (other != this) {
    std::swap(win_, other->win_);
    std::swap(ts_, other->ts_);
    std::swap(roomid_, other->roomid_);
    std::swap(msgno_, other->msgno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpEndReq::GetTypeName() const {
  return "fgame.CSPvpEndReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPlayerPvpResult::kUinFieldNumber;
const int CSPlayerPvpResult::kNameFieldNumber;
const int CSPlayerPvpResult::kPrevScoreFieldNumber;
const int CSPlayerPvpResult::kAddScoreFieldNumber;
const int CSPlayerPvpResult::kWinRateFieldNumber;
const int CSPlayerPvpResult::kTitleFieldNumber;
const int CSPlayerPvpResult::kNewRankFieldNumber;
const int CSPlayerPvpResult::kWinCountFieldNumber;
const int CSPlayerPvpResult::kPrevPointFieldNumber;
const int CSPlayerPvpResult::kAddPointFieldNumber;
const int CSPlayerPvpResult::kExtraScoreFieldNumber;
const int CSPlayerPvpResult::kVipLevelFieldNumber;
#endif  // !_MSC_VER

CSPlayerPvpResult::CSPlayerPvpResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPlayerPvpResult)
}

void CSPlayerPvpResult::InitAsDefaultInstance() {
}

CSPlayerPvpResult::CSPlayerPvpResult(const CSPlayerPvpResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPlayerPvpResult)
}

void CSPlayerPvpResult::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  uin_ = GOOGLE_LONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  prevscore_ = 0u;
  addscore_ = 0u;
  winrate_ = 0;
  title_ = 0u;
  newrank_ = 0u;
  wincount_ = 0u;
  prevpoint_ = 0;
  addpoint_ = 0;
  extrascore_ = 0u;
  viplevel_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPlayerPvpResult::~CSPlayerPvpResult() {
  // @@protoc_insertion_point(destructor:fgame.CSPlayerPvpResult)
  SharedDtor();
}

void CSPlayerPvpResult::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPlayerPvpResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPlayerPvpResult& CSPlayerPvpResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPlayerPvpResult* CSPlayerPvpResult::default_instance_ = NULL;

CSPlayerPvpResult* CSPlayerPvpResult::New() const {
  return new CSPlayerPvpResult;
}

void CSPlayerPvpResult::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPlayerPvpResult*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(prevscore_, wincount_);
    uin_ = GOOGLE_LONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
  }
  ZR_(prevpoint_, viplevel_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPlayerPvpResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPlayerPvpResult)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Name;
        break;
      }

      // required string Name = 2;
      case 2: {
        if (tag == 18) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_PrevScore;
        break;
      }

      // required uint32 PrevScore = 3;
      case 3: {
        if (tag == 24) {
         parse_PrevScore:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &prevscore_)));
          set_has_prevscore();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_AddScore;
        break;
      }

      // required uint32 AddScore = 4;
      case 4: {
        if (tag == 32) {
         parse_AddScore:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &addscore_)));
          set_has_addscore();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_WinRate;
        break;
      }

      // required int32 WinRate = 5;
      case 5: {
        if (tag == 40) {
         parse_WinRate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &winrate_)));
          set_has_winrate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_Title;
        break;
      }

      // optional uint32 Title = 6;
      case 6: {
        if (tag == 48) {
         parse_Title:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &title_)));
          set_has_title();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_NewRank;
        break;
      }

      // optional uint32 NewRank = 7;
      case 7: {
        if (tag == 56) {
         parse_NewRank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &newrank_)));
          set_has_newrank();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_WinCount;
        break;
      }

      // optional uint32 WinCount = 8;
      case 8: {
        if (tag == 64) {
         parse_WinCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &wincount_)));
          set_has_wincount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_PrevPoint;
        break;
      }

      // optional int32 PrevPoint = 9;
      case 9: {
        if (tag == 72) {
         parse_PrevPoint:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &prevpoint_)));
          set_has_prevpoint();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_AddPoint;
        break;
      }

      // optional int32 AddPoint = 10;
      case 10: {
        if (tag == 80) {
         parse_AddPoint:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &addpoint_)));
          set_has_addpoint();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_ExtraScore;
        break;
      }

      // optional uint32 ExtraScore = 11;
      case 11: {
        if (tag == 88) {
         parse_ExtraScore:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &extrascore_)));
          set_has_extrascore();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_VipLevel;
        break;
      }

      // optional uint32 VipLevel = 12;
      case 12: {
        if (tag == 96) {
         parse_VipLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &viplevel_)));
          set_has_viplevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPlayerPvpResult)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPlayerPvpResult)
  return false;
#undef DO_
}

void CSPlayerPvpResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPlayerPvpResult)
  // required int64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->uin(), output);
  }

  // required string Name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // required uint32 PrevScore = 3;
  if (has_prevscore()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->prevscore(), output);
  }

  // required uint32 AddScore = 4;
  if (has_addscore()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->addscore(), output);
  }

  // required int32 WinRate = 5;
  if (has_winrate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->winrate(), output);
  }

  // optional uint32 Title = 6;
  if (has_title()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->title(), output);
  }

  // optional uint32 NewRank = 7;
  if (has_newrank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->newrank(), output);
  }

  // optional uint32 WinCount = 8;
  if (has_wincount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->wincount(), output);
  }

  // optional int32 PrevPoint = 9;
  if (has_prevpoint()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->prevpoint(), output);
  }

  // optional int32 AddPoint = 10;
  if (has_addpoint()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->addpoint(), output);
  }

  // optional uint32 ExtraScore = 11;
  if (has_extrascore()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->extrascore(), output);
  }

  // optional uint32 VipLevel = 12;
  if (has_viplevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->viplevel(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPlayerPvpResult)
}

int CSPlayerPvpResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->uin());
    }

    // required string Name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required uint32 PrevScore = 3;
    if (has_prevscore()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->prevscore());
    }

    // required uint32 AddScore = 4;
    if (has_addscore()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->addscore());
    }

    // required int32 WinRate = 5;
    if (has_winrate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->winrate());
    }

    // optional uint32 Title = 6;
    if (has_title()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->title());
    }

    // optional uint32 NewRank = 7;
    if (has_newrank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->newrank());
    }

    // optional uint32 WinCount = 8;
    if (has_wincount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->wincount());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 PrevPoint = 9;
    if (has_prevpoint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->prevpoint());
    }

    // optional int32 AddPoint = 10;
    if (has_addpoint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->addpoint());
    }

    // optional uint32 ExtraScore = 11;
    if (has_extrascore()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->extrascore());
    }

    // optional uint32 VipLevel = 12;
    if (has_viplevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->viplevel());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPlayerPvpResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPlayerPvpResult*>(&from));
}

void CSPlayerPvpResult::MergeFrom(const CSPlayerPvpResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_prevscore()) {
      set_prevscore(from.prevscore());
    }
    if (from.has_addscore()) {
      set_addscore(from.addscore());
    }
    if (from.has_winrate()) {
      set_winrate(from.winrate());
    }
    if (from.has_title()) {
      set_title(from.title());
    }
    if (from.has_newrank()) {
      set_newrank(from.newrank());
    }
    if (from.has_wincount()) {
      set_wincount(from.wincount());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_prevpoint()) {
      set_prevpoint(from.prevpoint());
    }
    if (from.has_addpoint()) {
      set_addpoint(from.addpoint());
    }
    if (from.has_extrascore()) {
      set_extrascore(from.extrascore());
    }
    if (from.has_viplevel()) {
      set_viplevel(from.viplevel());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPlayerPvpResult::CopyFrom(const CSPlayerPvpResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPlayerPvpResult::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void CSPlayerPvpResult::Swap(CSPlayerPvpResult* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(name_, other->name_);
    std::swap(prevscore_, other->prevscore_);
    std::swap(addscore_, other->addscore_);
    std::swap(winrate_, other->winrate_);
    std::swap(title_, other->title_);
    std::swap(newrank_, other->newrank_);
    std::swap(wincount_, other->wincount_);
    std::swap(prevpoint_, other->prevpoint_);
    std::swap(addpoint_, other->addpoint_);
    std::swap(extrascore_, other->extrascore_);
    std::swap(viplevel_, other->viplevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPlayerPvpResult::GetTypeName() const {
  return "fgame.CSPlayerPvpResult";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpEndResp::kWinFieldNumber;
const int CSPvpEndResp::kTsFieldNumber;
const int CSPvpEndResp::kResultFieldNumber;
const int CSPvpEndResp::kUpdateDataFieldNumber;
const int CSPvpEndResp::kShareIdFieldNumber;
#endif  // !_MSC_VER

CSPvpEndResp::CSPvpEndResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpEndResp)
}

void CSPvpEndResp::InitAsDefaultInstance() {
}

CSPvpEndResp::CSPvpEndResp(const CSPvpEndResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpEndResp)
}

void CSPvpEndResp::SharedCtor() {
  _cached_size_ = 0;
  win_ = GOOGLE_LONGLONG(0);
  ts_ = 0;
  shareid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpEndResp::~CSPvpEndResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpEndResp)
  SharedDtor();
}

void CSPvpEndResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpEndResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpEndResp& CSPvpEndResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpEndResp* CSPvpEndResp::default_instance_ = NULL;

CSPvpEndResp* CSPvpEndResp::New() const {
  return new CSPvpEndResp;
}

void CSPvpEndResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpEndResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 19) {
    ZR_(win_, ts_);
    shareid_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  result_.Clear();
  updatedata_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpEndResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpEndResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 Win = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &win_)));
          set_has_win();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_Ts;
        break;
      }

      // required double Ts = 2;
      case 2: {
        if (tag == 17) {
         parse_Ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_Result;
        break;
      }

      // repeated .fgame.CSPlayerPvpResult Result = 3;
      case 3: {
        if (tag == 26) {
         parse_Result:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_result()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_Result;
        if (input->ExpectTag(34)) goto parse_UpdateData;
        break;
      }

      // repeated .fgame.PropertyUpdateData UpdateData = 4;
      case 4: {
        if (tag == 34) {
         parse_UpdateData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_updatedata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_UpdateData;
        if (input->ExpectTag(40)) goto parse_ShareId;
        break;
      }

      // optional uint32 ShareId = 5;
      case 5: {
        if (tag == 40) {
         parse_ShareId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shareid_)));
          set_has_shareid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpEndResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpEndResp)
  return false;
#undef DO_
}

void CSPvpEndResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpEndResp)
  // required int64 Win = 1;
  if (has_win()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->win(), output);
  }

  // required double Ts = 2;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->ts(), output);
  }

  // repeated .fgame.CSPlayerPvpResult Result = 3;
  for (int i = 0; i < this->result_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->result(i), output);
  }

  // repeated .fgame.PropertyUpdateData UpdateData = 4;
  for (int i = 0; i < this->updatedata_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->updatedata(i), output);
  }

  // optional uint32 ShareId = 5;
  if (has_shareid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->shareid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpEndResp)
}

int CSPvpEndResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 Win = 1;
    if (has_win()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->win());
    }

    // required double Ts = 2;
    if (has_ts()) {
      total_size += 1 + 8;
    }

    // optional uint32 ShareId = 5;
    if (has_shareid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shareid());
    }

  }
  // repeated .fgame.CSPlayerPvpResult Result = 3;
  total_size += 1 * this->result_size();
  for (int i = 0; i < this->result_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->result(i));
  }

  // repeated .fgame.PropertyUpdateData UpdateData = 4;
  total_size += 1 * this->updatedata_size();
  for (int i = 0; i < this->updatedata_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->updatedata(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpEndResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpEndResp*>(&from));
}

void CSPvpEndResp::MergeFrom(const CSPvpEndResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  result_.MergeFrom(from.result_);
  updatedata_.MergeFrom(from.updatedata_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_win()) {
      set_win(from.win());
    }
    if (from.has_ts()) {
      set_ts(from.ts());
    }
    if (from.has_shareid()) {
      set_shareid(from.shareid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpEndResp::CopyFrom(const CSPvpEndResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpEndResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->result())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->updatedata())) return false;
  return true;
}

void CSPvpEndResp::Swap(CSPvpEndResp* other) {
  if (other != this) {
    std::swap(win_, other->win_);
    std::swap(ts_, other->ts_);
    result_.Swap(&other->result_);
    updatedata_.Swap(&other->updatedata_);
    std::swap(shareid_, other->shareid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpEndResp::GetTypeName() const {
  return "fgame.CSPvpEndResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpLeaveReq::kRoomIdFieldNumber;
const int CSPvpLeaveReq::kMsgNoFieldNumber;
const int CSPvpLeaveReq::kModeFieldNumber;
#endif  // !_MSC_VER

CSPvpLeaveReq::CSPvpLeaveReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpLeaveReq)
}

void CSPvpLeaveReq::InitAsDefaultInstance() {
}

CSPvpLeaveReq::CSPvpLeaveReq(const CSPvpLeaveReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpLeaveReq)
}

void CSPvpLeaveReq::SharedCtor() {
  _cached_size_ = 0;
  roomid_ = 0u;
  msgno_ = 0u;
  mode_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpLeaveReq::~CSPvpLeaveReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpLeaveReq)
  SharedDtor();
}

void CSPvpLeaveReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpLeaveReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpLeaveReq& CSPvpLeaveReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpLeaveReq* CSPvpLeaveReq::default_instance_ = NULL;

CSPvpLeaveReq* CSPvpLeaveReq::New() const {
  return new CSPvpLeaveReq;
}

void CSPvpLeaveReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpLeaveReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(roomid_, mode_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpLeaveReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpLeaveReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 RoomId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_MsgNo;
        break;
      }

      // optional uint32 MsgNo = 2;
      case 2: {
        if (tag == 16) {
         parse_MsgNo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msgno_)));
          set_has_msgno();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Mode;
        break;
      }

      // optional uint32 Mode = 3;
      case 3: {
        if (tag == 24) {
         parse_Mode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mode_)));
          set_has_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpLeaveReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpLeaveReq)
  return false;
#undef DO_
}

void CSPvpLeaveReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpLeaveReq)
  // optional uint32 RoomId = 1;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->roomid(), output);
  }

  // optional uint32 MsgNo = 2;
  if (has_msgno()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->msgno(), output);
  }

  // optional uint32 Mode = 3;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->mode(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpLeaveReq)
}

int CSPvpLeaveReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 RoomId = 1;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

    // optional uint32 MsgNo = 2;
    if (has_msgno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msgno());
    }

    // optional uint32 Mode = 3;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mode());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpLeaveReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpLeaveReq*>(&from));
}

void CSPvpLeaveReq::MergeFrom(const CSPvpLeaveReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_msgno()) {
      set_msgno(from.msgno());
    }
    if (from.has_mode()) {
      set_mode(from.mode());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpLeaveReq::CopyFrom(const CSPvpLeaveReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpLeaveReq::IsInitialized() const {

  return true;
}

void CSPvpLeaveReq::Swap(CSPvpLeaveReq* other) {
  if (other != this) {
    std::swap(roomid_, other->roomid_);
    std::swap(msgno_, other->msgno_);
    std::swap(mode_, other->mode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpLeaveReq::GetTypeName() const {
  return "fgame.CSPvpLeaveReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpLeaveResp::kUinFieldNumber;
#endif  // !_MSC_VER

CSPvpLeaveResp::CSPvpLeaveResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpLeaveResp)
}

void CSPvpLeaveResp::InitAsDefaultInstance() {
}

CSPvpLeaveResp::CSPvpLeaveResp(const CSPvpLeaveResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpLeaveResp)
}

void CSPvpLeaveResp::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpLeaveResp::~CSPvpLeaveResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpLeaveResp)
  SharedDtor();
}

void CSPvpLeaveResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpLeaveResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpLeaveResp& CSPvpLeaveResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpLeaveResp* CSPvpLeaveResp::default_instance_ = NULL;

CSPvpLeaveResp* CSPvpLeaveResp::New() const {
  return new CSPvpLeaveResp;
}

void CSPvpLeaveResp::Clear() {
  uin_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpLeaveResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpLeaveResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpLeaveResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpLeaveResp)
  return false;
#undef DO_
}

void CSPvpLeaveResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpLeaveResp)
  // required int64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->uin(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpLeaveResp)
}

int CSPvpLeaveResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->uin());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpLeaveResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpLeaveResp*>(&from));
}

void CSPvpLeaveResp::MergeFrom(const CSPvpLeaveResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpLeaveResp::CopyFrom(const CSPvpLeaveResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpLeaveResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPvpLeaveResp::Swap(CSPvpLeaveResp* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpLeaveResp::GetTypeName() const {
  return "fgame.CSPvpLeaveResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpGetAwardResp::kAwardTypeFieldNumber;
const int CSPvpGetAwardResp::kUpdateDataFieldNumber;
#endif  // !_MSC_VER

CSPvpGetAwardResp::CSPvpGetAwardResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpGetAwardResp)
}

void CSPvpGetAwardResp::InitAsDefaultInstance() {
}

CSPvpGetAwardResp::CSPvpGetAwardResp(const CSPvpGetAwardResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpGetAwardResp)
}

void CSPvpGetAwardResp::SharedCtor() {
  _cached_size_ = 0;
  awardtype_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpGetAwardResp::~CSPvpGetAwardResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpGetAwardResp)
  SharedDtor();
}

void CSPvpGetAwardResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpGetAwardResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpGetAwardResp& CSPvpGetAwardResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpGetAwardResp* CSPvpGetAwardResp::default_instance_ = NULL;

CSPvpGetAwardResp* CSPvpGetAwardResp::New() const {
  return new CSPvpGetAwardResp;
}

void CSPvpGetAwardResp::Clear() {
  awardtype_ = 0;
  updatedata_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpGetAwardResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpGetAwardResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 AwardType = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &awardtype_)));
          set_has_awardtype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_UpdateData;
        break;
      }

      // repeated .fgame.PropertyUpdateData UpdateData = 2;
      case 2: {
        if (tag == 18) {
         parse_UpdateData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_updatedata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_UpdateData;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpGetAwardResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpGetAwardResp)
  return false;
#undef DO_
}

void CSPvpGetAwardResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpGetAwardResp)
  // required int32 AwardType = 1;
  if (has_awardtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->awardtype(), output);
  }

  // repeated .fgame.PropertyUpdateData UpdateData = 2;
  for (int i = 0; i < this->updatedata_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->updatedata(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpGetAwardResp)
}

int CSPvpGetAwardResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 AwardType = 1;
    if (has_awardtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->awardtype());
    }

  }
  // repeated .fgame.PropertyUpdateData UpdateData = 2;
  total_size += 1 * this->updatedata_size();
  for (int i = 0; i < this->updatedata_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->updatedata(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpGetAwardResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpGetAwardResp*>(&from));
}

void CSPvpGetAwardResp::MergeFrom(const CSPvpGetAwardResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  updatedata_.MergeFrom(from.updatedata_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_awardtype()) {
      set_awardtype(from.awardtype());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpGetAwardResp::CopyFrom(const CSPvpGetAwardResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpGetAwardResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->updatedata())) return false;
  return true;
}

void CSPvpGetAwardResp::Swap(CSPvpGetAwardResp* other) {
  if (other != this) {
    std::swap(awardtype_, other->awardtype_);
    updatedata_.Swap(&other->updatedata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpGetAwardResp::GetTypeName() const {
  return "fgame.CSPvpGetAwardResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSFormationList::kIdFieldNumber;
#endif  // !_MSC_VER

CSFormationList::CSFormationList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSFormationList)
}

void CSFormationList::InitAsDefaultInstance() {
}

CSFormationList::CSFormationList(const CSFormationList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSFormationList)
}

void CSFormationList::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSFormationList::~CSFormationList() {
  // @@protoc_insertion_point(destructor:fgame.CSFormationList)
  SharedDtor();
}

void CSFormationList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSFormationList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSFormationList& CSFormationList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSFormationList* CSFormationList::default_instance_ = NULL;

CSFormationList* CSFormationList::New() const {
  return new CSFormationList;
}

void CSFormationList::Clear() {
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSFormationList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSFormationList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSFormationList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSFormationList)
  return false;
#undef DO_
}

void CSFormationList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSFormationList)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSFormationList)
}

int CSFormationList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSFormationList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSFormationList*>(&from));
}

void CSFormationList::MergeFrom(const CSFormationList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSFormationList::CopyFrom(const CSFormationList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSFormationList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSFormationList::Swap(CSFormationList* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSFormationList::GetTypeName() const {
  return "fgame.CSFormationList";
}


// ===================================================================

#ifndef _MSC_VER
const int CSMapData::kBuildIdFieldNumber;
const int CSMapData::kTypeFieldNumber;
const int CSMapData::kLevelFieldNumber;
const int CSMapData::kCampFieldNumber;
const int CSMapData::kNumFieldNumber;
const int CSMapData::kListFieldNumber;
#endif  // !_MSC_VER

CSMapData::CSMapData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSMapData)
}

void CSMapData::InitAsDefaultInstance() {
}

CSMapData::CSMapData(const CSMapData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSMapData)
}

void CSMapData::SharedCtor() {
  _cached_size_ = 0;
  buildid_ = 0u;
  type_ = 0u;
  level_ = 0u;
  camp_ = 0u;
  num_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSMapData::~CSMapData() {
  // @@protoc_insertion_point(destructor:fgame.CSMapData)
  SharedDtor();
}

void CSMapData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSMapData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSMapData& CSMapData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSMapData* CSMapData::default_instance_ = NULL;

CSMapData* CSMapData::New() const {
  return new CSMapData;
}

void CSMapData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSMapData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(buildid_, camp_);
    num_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSMapData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSMapData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 BuildId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buildid_)));
          set_has_buildid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Type;
        break;
      }

      // required uint32 Type = 2;
      case 2: {
        if (tag == 16) {
         parse_Type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Level;
        break;
      }

      // required uint32 Level = 3;
      case 3: {
        if (tag == 24) {
         parse_Level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Camp;
        break;
      }

      // required uint32 Camp = 4;
      case 4: {
        if (tag == 32) {
         parse_Camp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &camp_)));
          set_has_camp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_Num;
        break;
      }

      // required uint32 Num = 5;
      case 5: {
        if (tag == 40) {
         parse_Num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_List;
        break;
      }

      // repeated .fgame.CSFormationList List = 6;
      case 6: {
        if (tag == 50) {
         parse_List:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_List;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSMapData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSMapData)
  return false;
#undef DO_
}

void CSMapData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSMapData)
  // required uint32 BuildId = 1;
  if (has_buildid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->buildid(), output);
  }

  // required uint32 Type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->type(), output);
  }

  // required uint32 Level = 3;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->level(), output);
  }

  // required uint32 Camp = 4;
  if (has_camp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->camp(), output);
  }

  // required uint32 Num = 5;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->num(), output);
  }

  // repeated .fgame.CSFormationList List = 6;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSMapData)
}

int CSMapData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 BuildId = 1;
    if (has_buildid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buildid());
    }

    // required uint32 Type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required uint32 Level = 3;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->level());
    }

    // required uint32 Camp = 4;
    if (has_camp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->camp());
    }

    // required uint32 Num = 5;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num());
    }

  }
  // repeated .fgame.CSFormationList List = 6;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSMapData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSMapData*>(&from));
}

void CSMapData::MergeFrom(const CSMapData& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_buildid()) {
      set_buildid(from.buildid());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_camp()) {
      set_camp(from.camp());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSMapData::CopyFrom(const CSMapData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSMapData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->list())) return false;
  return true;
}

void CSMapData::Swap(CSMapData* other) {
  if (other != this) {
    std::swap(buildid_, other->buildid_);
    std::swap(type_, other->type_);
    std::swap(level_, other->level_);
    std::swap(camp_, other->camp_);
    std::swap(num_, other->num_);
    list_.Swap(&other->list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSMapData::GetTypeName() const {
  return "fgame.CSMapData";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpMapReq::kDataFieldNumber;
const int CSPvpMapReq::kTsFieldNumber;
const int CSPvpMapReq::kRoomIdFieldNumber;
const int CSPvpMapReq::kMsgNoFieldNumber;
#endif  // !_MSC_VER

CSPvpMapReq::CSPvpMapReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpMapReq)
}

void CSPvpMapReq::InitAsDefaultInstance() {
}

CSPvpMapReq::CSPvpMapReq(const CSPvpMapReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpMapReq)
}

void CSPvpMapReq::SharedCtor() {
  _cached_size_ = 0;
  ts_ = 0;
  roomid_ = 0u;
  msgno_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpMapReq::~CSPvpMapReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpMapReq)
  SharedDtor();
}

void CSPvpMapReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpMapReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpMapReq& CSPvpMapReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpMapReq* CSPvpMapReq::default_instance_ = NULL;

CSPvpMapReq* CSPvpMapReq::New() const {
  return new CSPvpMapReq;
}

void CSPvpMapReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpMapReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ts_, msgno_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpMapReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpMapReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.CSMapData Data = 1;
      case 1: {
        if (tag == 10) {
         parse_Data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_Data;
        if (input->ExpectTag(17)) goto parse_Ts;
        break;
      }

      // required double Ts = 2;
      case 2: {
        if (tag == 17) {
         parse_Ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_RoomId;
        break;
      }

      // optional uint32 RoomId = 3;
      case 3: {
        if (tag == 24) {
         parse_RoomId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_MsgNo;
        break;
      }

      // optional uint32 MsgNo = 4;
      case 4: {
        if (tag == 32) {
         parse_MsgNo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msgno_)));
          set_has_msgno();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpMapReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpMapReq)
  return false;
#undef DO_
}

void CSPvpMapReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpMapReq)
  // repeated .fgame.CSMapData Data = 1;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->data(i), output);
  }

  // required double Ts = 2;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->ts(), output);
  }

  // optional uint32 RoomId = 3;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->roomid(), output);
  }

  // optional uint32 MsgNo = 4;
  if (has_msgno()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->msgno(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpMapReq)
}

int CSPvpMapReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required double Ts = 2;
    if (has_ts()) {
      total_size += 1 + 8;
    }

    // optional uint32 RoomId = 3;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

    // optional uint32 MsgNo = 4;
    if (has_msgno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msgno());
    }

  }
  // repeated .fgame.CSMapData Data = 1;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpMapReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpMapReq*>(&from));
}

void CSPvpMapReq::MergeFrom(const CSPvpMapReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_ts()) {
      set_ts(from.ts());
    }
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_msgno()) {
      set_msgno(from.msgno());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpMapReq::CopyFrom(const CSPvpMapReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpMapReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->data())) return false;
  return true;
}

void CSPvpMapReq::Swap(CSPvpMapReq* other) {
  if (other != this) {
    data_.Swap(&other->data_);
    std::swap(ts_, other->ts_);
    std::swap(roomid_, other->roomid_);
    std::swap(msgno_, other->msgno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpMapReq::GetTypeName() const {
  return "fgame.CSPvpMapReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpMapResp::kDataFieldNumber;
const int CSPvpMapResp::kTsFieldNumber;
#endif  // !_MSC_VER

CSPvpMapResp::CSPvpMapResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpMapResp)
}

void CSPvpMapResp::InitAsDefaultInstance() {
}

CSPvpMapResp::CSPvpMapResp(const CSPvpMapResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpMapResp)
}

void CSPvpMapResp::SharedCtor() {
  _cached_size_ = 0;
  ts_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpMapResp::~CSPvpMapResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpMapResp)
  SharedDtor();
}

void CSPvpMapResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpMapResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpMapResp& CSPvpMapResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpMapResp* CSPvpMapResp::default_instance_ = NULL;

CSPvpMapResp* CSPvpMapResp::New() const {
  return new CSPvpMapResp;
}

void CSPvpMapResp::Clear() {
  ts_ = 0;
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpMapResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpMapResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.CSMapData Data = 1;
      case 1: {
        if (tag == 10) {
         parse_Data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_Data;
        if (input->ExpectTag(17)) goto parse_Ts;
        break;
      }

      // required double Ts = 2;
      case 2: {
        if (tag == 17) {
         parse_Ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpMapResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpMapResp)
  return false;
#undef DO_
}

void CSPvpMapResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpMapResp)
  // repeated .fgame.CSMapData Data = 1;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->data(i), output);
  }

  // required double Ts = 2;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->ts(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpMapResp)
}

int CSPvpMapResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required double Ts = 2;
    if (has_ts()) {
      total_size += 1 + 8;
    }

  }
  // repeated .fgame.CSMapData Data = 1;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpMapResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpMapResp*>(&from));
}

void CSPvpMapResp::MergeFrom(const CSPvpMapResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_ts()) {
      set_ts(from.ts());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpMapResp::CopyFrom(const CSPvpMapResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpMapResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->data())) return false;
  return true;
}

void CSPvpMapResp::Swap(CSPvpMapResp* other) {
  if (other != this) {
    data_.Swap(&other->data_);
    std::swap(ts_, other->ts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpMapResp::GetTypeName() const {
  return "fgame.CSPvpMapResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpPingReq::kTsFieldNumber;
const int CSPvpPingReq::kRoomIdFieldNumber;
const int CSPvpPingReq::kMsgNoFieldNumber;
#endif  // !_MSC_VER

CSPvpPingReq::CSPvpPingReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpPingReq)
}

void CSPvpPingReq::InitAsDefaultInstance() {
}

CSPvpPingReq::CSPvpPingReq(const CSPvpPingReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpPingReq)
}

void CSPvpPingReq::SharedCtor() {
  _cached_size_ = 0;
  ts_ = 0;
  roomid_ = 0u;
  msgno_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpPingReq::~CSPvpPingReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpPingReq)
  SharedDtor();
}

void CSPvpPingReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpPingReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpPingReq& CSPvpPingReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpPingReq* CSPvpPingReq::default_instance_ = NULL;

CSPvpPingReq* CSPvpPingReq::New() const {
  return new CSPvpPingReq;
}

void CSPvpPingReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpPingReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ts_, msgno_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpPingReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpPingReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double Ts = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_RoomId;
        break;
      }

      // optional uint32 RoomId = 2;
      case 2: {
        if (tag == 16) {
         parse_RoomId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_MsgNo;
        break;
      }

      // optional uint32 MsgNo = 3;
      case 3: {
        if (tag == 24) {
         parse_MsgNo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msgno_)));
          set_has_msgno();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpPingReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpPingReq)
  return false;
#undef DO_
}

void CSPvpPingReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpPingReq)
  // required double Ts = 1;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->ts(), output);
  }

  // optional uint32 RoomId = 2;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->roomid(), output);
  }

  // optional uint32 MsgNo = 3;
  if (has_msgno()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->msgno(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpPingReq)
}

int CSPvpPingReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double Ts = 1;
    if (has_ts()) {
      total_size += 1 + 8;
    }

    // optional uint32 RoomId = 2;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

    // optional uint32 MsgNo = 3;
    if (has_msgno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msgno());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpPingReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpPingReq*>(&from));
}

void CSPvpPingReq::MergeFrom(const CSPvpPingReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ts()) {
      set_ts(from.ts());
    }
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_msgno()) {
      set_msgno(from.msgno());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpPingReq::CopyFrom(const CSPvpPingReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpPingReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPvpPingReq::Swap(CSPvpPingReq* other) {
  if (other != this) {
    std::swap(ts_, other->ts_);
    std::swap(roomid_, other->roomid_);
    std::swap(msgno_, other->msgno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpPingReq::GetTypeName() const {
  return "fgame.CSPvpPingReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpPingResp::kHostFieldNumber;
const int CSPvpPingResp::kTsFieldNumber;
#endif  // !_MSC_VER

CSPvpPingResp::CSPvpPingResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpPingResp)
}

void CSPvpPingResp::InitAsDefaultInstance() {
}

CSPvpPingResp::CSPvpPingResp(const CSPvpPingResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpPingResp)
}

void CSPvpPingResp::SharedCtor() {
  _cached_size_ = 0;
  host_ = GOOGLE_LONGLONG(0);
  ts_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpPingResp::~CSPvpPingResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpPingResp)
  SharedDtor();
}

void CSPvpPingResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpPingResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpPingResp& CSPvpPingResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpPingResp* CSPvpPingResp::default_instance_ = NULL;

CSPvpPingResp* CSPvpPingResp::New() const {
  return new CSPvpPingResp;
}

void CSPvpPingResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpPingResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(host_, ts_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpPingResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpPingResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 Host = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &host_)));
          set_has_host();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_Ts;
        break;
      }

      // required double Ts = 2;
      case 2: {
        if (tag == 17) {
         parse_Ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpPingResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpPingResp)
  return false;
#undef DO_
}

void CSPvpPingResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpPingResp)
  // required int64 Host = 1;
  if (has_host()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->host(), output);
  }

  // required double Ts = 2;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->ts(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpPingResp)
}

int CSPvpPingResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 Host = 1;
    if (has_host()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->host());
    }

    // required double Ts = 2;
    if (has_ts()) {
      total_size += 1 + 8;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpPingResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpPingResp*>(&from));
}

void CSPvpPingResp::MergeFrom(const CSPvpPingResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_host()) {
      set_host(from.host());
    }
    if (from.has_ts()) {
      set_ts(from.ts());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpPingResp::CopyFrom(const CSPvpPingResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpPingResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSPvpPingResp::Swap(CSPvpPingResp* other) {
  if (other != this) {
    std::swap(host_, other->host_);
    std::swap(ts_, other->ts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpPingResp::GetTypeName() const {
  return "fgame.CSPvpPingResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpUseItemReq::kItemIdFieldNumber;
const int CSPvpUseItemReq::kTsFieldNumber;
const int CSPvpUseItemReq::kXFieldNumber;
const int CSPvpUseItemReq::kYFieldNumber;
const int CSPvpUseItemReq::kBuildIdFieldNumber;
const int CSPvpUseItemReq::kRoomIdFieldNumber;
const int CSPvpUseItemReq::kMsgNoFieldNumber;
#endif  // !_MSC_VER

CSPvpUseItemReq::CSPvpUseItemReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpUseItemReq)
}

void CSPvpUseItemReq::InitAsDefaultInstance() {
}

CSPvpUseItemReq::CSPvpUseItemReq(const CSPvpUseItemReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpUseItemReq)
}

void CSPvpUseItemReq::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0;
  ts_ = 0;
  x_ = 0u;
  y_ = 0u;
  buildid_ = 0u;
  roomid_ = 0u;
  msgno_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpUseItemReq::~CSPvpUseItemReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpUseItemReq)
  SharedDtor();
}

void CSPvpUseItemReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpUseItemReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpUseItemReq& CSPvpUseItemReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpUseItemReq* CSPvpUseItemReq::default_instance_ = NULL;

CSPvpUseItemReq* CSPvpUseItemReq::New() const {
  return new CSPvpUseItemReq;
}

void CSPvpUseItemReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpUseItemReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(ts_, msgno_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpUseItemReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpUseItemReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ItemId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_Ts;
        break;
      }

      // required double Ts = 2;
      case 2: {
        if (tag == 17) {
         parse_Ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_X;
        break;
      }

      // optional uint32 X = 3;
      case 3: {
        if (tag == 24) {
         parse_X:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Y;
        break;
      }

      // optional uint32 Y = 4;
      case 4: {
        if (tag == 32) {
         parse_Y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_BuildId;
        break;
      }

      // optional uint32 BuildId = 5;
      case 5: {
        if (tag == 40) {
         parse_BuildId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buildid_)));
          set_has_buildid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_RoomId;
        break;
      }

      // optional uint32 RoomId = 6;
      case 6: {
        if (tag == 48) {
         parse_RoomId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_MsgNo;
        break;
      }

      // optional uint32 MsgNo = 7;
      case 7: {
        if (tag == 56) {
         parse_MsgNo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msgno_)));
          set_has_msgno();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpUseItemReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpUseItemReq)
  return false;
#undef DO_
}

void CSPvpUseItemReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpUseItemReq)
  // required int32 ItemId = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->itemid(), output);
  }

  // required double Ts = 2;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->ts(), output);
  }

  // optional uint32 X = 3;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->x(), output);
  }

  // optional uint32 Y = 4;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->y(), output);
  }

  // optional uint32 BuildId = 5;
  if (has_buildid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->buildid(), output);
  }

  // optional uint32 RoomId = 6;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->roomid(), output);
  }

  // optional uint32 MsgNo = 7;
  if (has_msgno()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->msgno(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpUseItemReq)
}

int CSPvpUseItemReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ItemId = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // required double Ts = 2;
    if (has_ts()) {
      total_size += 1 + 8;
    }

    // optional uint32 X = 3;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->x());
    }

    // optional uint32 Y = 4;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->y());
    }

    // optional uint32 BuildId = 5;
    if (has_buildid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buildid());
    }

    // optional uint32 RoomId = 6;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

    // optional uint32 MsgNo = 7;
    if (has_msgno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msgno());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpUseItemReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpUseItemReq*>(&from));
}

void CSPvpUseItemReq::MergeFrom(const CSPvpUseItemReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_ts()) {
      set_ts(from.ts());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_buildid()) {
      set_buildid(from.buildid());
    }
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_msgno()) {
      set_msgno(from.msgno());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpUseItemReq::CopyFrom(const CSPvpUseItemReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpUseItemReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSPvpUseItemReq::Swap(CSPvpUseItemReq* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(ts_, other->ts_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(buildid_, other->buildid_);
    std::swap(roomid_, other->roomid_);
    std::swap(msgno_, other->msgno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpUseItemReq::GetTypeName() const {
  return "fgame.CSPvpUseItemReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpUseItemResp::kUinFieldNumber;
const int CSPvpUseItemResp::kItemIdFieldNumber;
const int CSPvpUseItemResp::kTsFieldNumber;
const int CSPvpUseItemResp::kXFieldNumber;
const int CSPvpUseItemResp::kYFieldNumber;
const int CSPvpUseItemResp::kBuildIdFieldNumber;
#endif  // !_MSC_VER

CSPvpUseItemResp::CSPvpUseItemResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpUseItemResp)
}

void CSPvpUseItemResp::InitAsDefaultInstance() {
}

CSPvpUseItemResp::CSPvpUseItemResp(const CSPvpUseItemResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpUseItemResp)
}

void CSPvpUseItemResp::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_LONGLONG(0);
  itemid_ = 0;
  ts_ = 0;
  x_ = 0u;
  y_ = 0u;
  buildid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpUseItemResp::~CSPvpUseItemResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpUseItemResp)
  SharedDtor();
}

void CSPvpUseItemResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpUseItemResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpUseItemResp& CSPvpUseItemResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpUseItemResp* CSPvpUseItemResp::default_instance_ = NULL;

CSPvpUseItemResp* CSPvpUseItemResp::New() const {
  return new CSPvpUseItemResp;
}

void CSPvpUseItemResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpUseItemResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(uin_, buildid_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpUseItemResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpUseItemResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ItemId;
        break;
      }

      // required int32 ItemId = 2;
      case 2: {
        if (tag == 16) {
         parse_ItemId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_Ts;
        break;
      }

      // required double Ts = 3;
      case 3: {
        if (tag == 25) {
         parse_Ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_X;
        break;
      }

      // optional uint32 X = 4;
      case 4: {
        if (tag == 32) {
         parse_X:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_Y;
        break;
      }

      // optional uint32 Y = 5;
      case 5: {
        if (tag == 40) {
         parse_Y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_BuildId;
        break;
      }

      // optional uint32 BuildId = 6;
      case 6: {
        if (tag == 48) {
         parse_BuildId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buildid_)));
          set_has_buildid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpUseItemResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpUseItemResp)
  return false;
#undef DO_
}

void CSPvpUseItemResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpUseItemResp)
  // required int64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->uin(), output);
  }

  // required int32 ItemId = 2;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->itemid(), output);
  }

  // required double Ts = 3;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->ts(), output);
  }

  // optional uint32 X = 4;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->x(), output);
  }

  // optional uint32 Y = 5;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->y(), output);
  }

  // optional uint32 BuildId = 6;
  if (has_buildid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->buildid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpUseItemResp)
}

int CSPvpUseItemResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->uin());
    }

    // required int32 ItemId = 2;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // required double Ts = 3;
    if (has_ts()) {
      total_size += 1 + 8;
    }

    // optional uint32 X = 4;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->x());
    }

    // optional uint32 Y = 5;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->y());
    }

    // optional uint32 BuildId = 6;
    if (has_buildid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buildid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpUseItemResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpUseItemResp*>(&from));
}

void CSPvpUseItemResp::MergeFrom(const CSPvpUseItemResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_ts()) {
      set_ts(from.ts());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_buildid()) {
      set_buildid(from.buildid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpUseItemResp::CopyFrom(const CSPvpUseItemResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpUseItemResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSPvpUseItemResp::Swap(CSPvpUseItemResp* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(itemid_, other->itemid_);
    std::swap(ts_, other->ts_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(buildid_, other->buildid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpUseItemResp::GetTypeName() const {
  return "fgame.CSPvpUseItemResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpUseSkillReq::kCampIDFieldNumber;
const int CSPvpUseSkillReq::kSkillIDFieldNumber;
const int CSPvpUseSkillReq::kRollNumFieldNumber;
#endif  // !_MSC_VER

CSPvpUseSkillReq::CSPvpUseSkillReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpUseSkillReq)
}

void CSPvpUseSkillReq::InitAsDefaultInstance() {
}

CSPvpUseSkillReq::CSPvpUseSkillReq(const CSPvpUseSkillReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpUseSkillReq)
}

void CSPvpUseSkillReq::SharedCtor() {
  _cached_size_ = 0;
  campid_ = 0u;
  skillid_ = 0u;
  rollnum_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpUseSkillReq::~CSPvpUseSkillReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpUseSkillReq)
  SharedDtor();
}

void CSPvpUseSkillReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpUseSkillReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpUseSkillReq& CSPvpUseSkillReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpUseSkillReq* CSPvpUseSkillReq::default_instance_ = NULL;

CSPvpUseSkillReq* CSPvpUseSkillReq::New() const {
  return new CSPvpUseSkillReq;
}

void CSPvpUseSkillReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpUseSkillReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(campid_, rollnum_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpUseSkillReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpUseSkillReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 CampID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &campid_)));
          set_has_campid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_SkillID;
        break;
      }

      // required uint32 SkillID = 2;
      case 2: {
        if (tag == 16) {
         parse_SkillID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &skillid_)));
          set_has_skillid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_RollNum;
        break;
      }

      // required uint32 RollNum = 3;
      case 3: {
        if (tag == 24) {
         parse_RollNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rollnum_)));
          set_has_rollnum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpUseSkillReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpUseSkillReq)
  return false;
#undef DO_
}

void CSPvpUseSkillReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpUseSkillReq)
  // required uint32 CampID = 1;
  if (has_campid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->campid(), output);
  }

  // required uint32 SkillID = 2;
  if (has_skillid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->skillid(), output);
  }

  // required uint32 RollNum = 3;
  if (has_rollnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->rollnum(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpUseSkillReq)
}

int CSPvpUseSkillReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 CampID = 1;
    if (has_campid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->campid());
    }

    // required uint32 SkillID = 2;
    if (has_skillid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->skillid());
    }

    // required uint32 RollNum = 3;
    if (has_rollnum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rollnum());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpUseSkillReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpUseSkillReq*>(&from));
}

void CSPvpUseSkillReq::MergeFrom(const CSPvpUseSkillReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_campid()) {
      set_campid(from.campid());
    }
    if (from.has_skillid()) {
      set_skillid(from.skillid());
    }
    if (from.has_rollnum()) {
      set_rollnum(from.rollnum());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpUseSkillReq::CopyFrom(const CSPvpUseSkillReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpUseSkillReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSPvpUseSkillReq::Swap(CSPvpUseSkillReq* other) {
  if (other != this) {
    std::swap(campid_, other->campid_);
    std::swap(skillid_, other->skillid_);
    std::swap(rollnum_, other->rollnum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpUseSkillReq::GetTypeName() const {
  return "fgame.CSPvpUseSkillReq";
}


// ===================================================================

#ifndef _MSC_VER
const int PvpAssistantInfo::kAssistantIdFieldNumber;
const int PvpAssistantInfo::kLevelFieldNumber;
const int PvpAssistantInfo::kQualityFieldNumber;
const int PvpAssistantInfo::kActiveSkillsFieldNumber;
const int PvpAssistantInfo::kPassiveSkillsFieldNumber;
const int PvpAssistantInfo::kCampIDFieldNumber;
#endif  // !_MSC_VER

PvpAssistantInfo::PvpAssistantInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.PvpAssistantInfo)
}

void PvpAssistantInfo::InitAsDefaultInstance() {
}

PvpAssistantInfo::PvpAssistantInfo(const PvpAssistantInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.PvpAssistantInfo)
}

void PvpAssistantInfo::SharedCtor() {
  _cached_size_ = 0;
  assistantid_ = 0u;
  level_ = 0u;
  quality_ = 0u;
  campid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PvpAssistantInfo::~PvpAssistantInfo() {
  // @@protoc_insertion_point(destructor:fgame.PvpAssistantInfo)
  SharedDtor();
}

void PvpAssistantInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PvpAssistantInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PvpAssistantInfo& PvpAssistantInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

PvpAssistantInfo* PvpAssistantInfo::default_instance_ = NULL;

PvpAssistantInfo* PvpAssistantInfo::New() const {
  return new PvpAssistantInfo;
}

void PvpAssistantInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PvpAssistantInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(assistantid_, level_);
  ZR_(quality_, campid_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  activeskills_.Clear();
  passiveskills_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PvpAssistantInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.PvpAssistantInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 AssistantId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &assistantid_)));
          set_has_assistantid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Level;
        break;
      }

      // required uint32 Level = 2;
      case 2: {
        if (tag == 16) {
         parse_Level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Quality;
        break;
      }

      // required uint32 Quality = 3;
      case 3: {
        if (tag == 24) {
         parse_Quality:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &quality_)));
          set_has_quality();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_ActiveSkills;
        break;
      }

      // repeated uint32 ActiveSkills = 4;
      case 4: {
        if (tag == 32) {
         parse_ActiveSkills:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_activeskills())));
        } else if (tag == 34) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_activeskills())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_ActiveSkills;
        if (input->ExpectTag(40)) goto parse_PassiveSkills;
        break;
      }

      // repeated uint32 PassiveSkills = 5;
      case 5: {
        if (tag == 40) {
         parse_PassiveSkills:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 40, input, this->mutable_passiveskills())));
        } else if (tag == 42) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_passiveskills())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_PassiveSkills;
        if (input->ExpectTag(48)) goto parse_CampID;
        break;
      }

      // required uint32 CampID = 6;
      case 6: {
        if (tag == 48) {
         parse_CampID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &campid_)));
          set_has_campid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.PvpAssistantInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.PvpAssistantInfo)
  return false;
#undef DO_
}

void PvpAssistantInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.PvpAssistantInfo)
  // required uint32 AssistantId = 1;
  if (has_assistantid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->assistantid(), output);
  }

  // required uint32 Level = 2;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->level(), output);
  }

  // required uint32 Quality = 3;
  if (has_quality()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->quality(), output);
  }

  // repeated uint32 ActiveSkills = 4;
  for (int i = 0; i < this->activeskills_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->activeskills(i), output);
  }

  // repeated uint32 PassiveSkills = 5;
  for (int i = 0; i < this->passiveskills_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      5, this->passiveskills(i), output);
  }

  // required uint32 CampID = 6;
  if (has_campid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->campid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.PvpAssistantInfo)
}

int PvpAssistantInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 AssistantId = 1;
    if (has_assistantid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->assistantid());
    }

    // required uint32 Level = 2;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->level());
    }

    // required uint32 Quality = 3;
    if (has_quality()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->quality());
    }

    // required uint32 CampID = 6;
    if (has_campid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->campid());
    }

  }
  // repeated uint32 ActiveSkills = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->activeskills_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->activeskills(i));
    }
    total_size += 1 * this->activeskills_size() + data_size;
  }

  // repeated uint32 PassiveSkills = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->passiveskills_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->passiveskills(i));
    }
    total_size += 1 * this->passiveskills_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PvpAssistantInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PvpAssistantInfo*>(&from));
}

void PvpAssistantInfo::MergeFrom(const PvpAssistantInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  activeskills_.MergeFrom(from.activeskills_);
  passiveskills_.MergeFrom(from.passiveskills_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_assistantid()) {
      set_assistantid(from.assistantid());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_quality()) {
      set_quality(from.quality());
    }
    if (from.has_campid()) {
      set_campid(from.campid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PvpAssistantInfo::CopyFrom(const PvpAssistantInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PvpAssistantInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000027) != 0x00000027) return false;

  return true;
}

void PvpAssistantInfo::Swap(PvpAssistantInfo* other) {
  if (other != this) {
    std::swap(assistantid_, other->assistantid_);
    std::swap(level_, other->level_);
    std::swap(quality_, other->quality_);
    activeskills_.Swap(&other->activeskills_);
    passiveskills_.Swap(&other->passiveskills_);
    std::swap(campid_, other->campid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PvpAssistantInfo::GetTypeName() const {
  return "fgame.PvpAssistantInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpAssistantInfoResp::kInfoFieldNumber;
#endif  // !_MSC_VER

CSPvpAssistantInfoResp::CSPvpAssistantInfoResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpAssistantInfoResp)
}

void CSPvpAssistantInfoResp::InitAsDefaultInstance() {
}

CSPvpAssistantInfoResp::CSPvpAssistantInfoResp(const CSPvpAssistantInfoResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpAssistantInfoResp)
}

void CSPvpAssistantInfoResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpAssistantInfoResp::~CSPvpAssistantInfoResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpAssistantInfoResp)
  SharedDtor();
}

void CSPvpAssistantInfoResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpAssistantInfoResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpAssistantInfoResp& CSPvpAssistantInfoResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpAssistantInfoResp* CSPvpAssistantInfoResp::default_instance_ = NULL;

CSPvpAssistantInfoResp* CSPvpAssistantInfoResp::New() const {
  return new CSPvpAssistantInfoResp;
}

void CSPvpAssistantInfoResp::Clear() {
  info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpAssistantInfoResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpAssistantInfoResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.PvpAssistantInfo Info = 1;
      case 1: {
        if (tag == 10) {
         parse_Info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_Info;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpAssistantInfoResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpAssistantInfoResp)
  return false;
#undef DO_
}

void CSPvpAssistantInfoResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpAssistantInfoResp)
  // repeated .fgame.PvpAssistantInfo Info = 1;
  for (int i = 0; i < this->info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->info(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpAssistantInfoResp)
}

int CSPvpAssistantInfoResp::ByteSize() const {
  int total_size = 0;

  // repeated .fgame.PvpAssistantInfo Info = 1;
  total_size += 1 * this->info_size();
  for (int i = 0; i < this->info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->info(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpAssistantInfoResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpAssistantInfoResp*>(&from));
}

void CSPvpAssistantInfoResp::MergeFrom(const CSPvpAssistantInfoResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  info_.MergeFrom(from.info_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpAssistantInfoResp::CopyFrom(const CSPvpAssistantInfoResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpAssistantInfoResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->info())) return false;
  return true;
}

void CSPvpAssistantInfoResp::Swap(CSPvpAssistantInfoResp* other) {
  if (other != this) {
    info_.Swap(&other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpAssistantInfoResp::GetTypeName() const {
  return "fgame.CSPvpAssistantInfoResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpUseSkillResp::kOkFieldNumber;
const int CSPvpUseSkillResp::kCampIDFieldNumber;
const int CSPvpUseSkillResp::kSkillIDFieldNumber;
const int CSPvpUseSkillResp::kRandomNumbersFieldNumber;
#endif  // !_MSC_VER

CSPvpUseSkillResp::CSPvpUseSkillResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpUseSkillResp)
}

void CSPvpUseSkillResp::InitAsDefaultInstance() {
}

CSPvpUseSkillResp::CSPvpUseSkillResp(const CSPvpUseSkillResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpUseSkillResp)
}

void CSPvpUseSkillResp::SharedCtor() {
  _cached_size_ = 0;
  ok_ = false;
  campid_ = 0u;
  skillid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpUseSkillResp::~CSPvpUseSkillResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpUseSkillResp)
  SharedDtor();
}

void CSPvpUseSkillResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpUseSkillResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpUseSkillResp& CSPvpUseSkillResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpUseSkillResp* CSPvpUseSkillResp::default_instance_ = NULL;

CSPvpUseSkillResp* CSPvpUseSkillResp::New() const {
  return new CSPvpUseSkillResp;
}

void CSPvpUseSkillResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpUseSkillResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(ok_, campid_);
    skillid_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  randomnumbers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpUseSkillResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpUseSkillResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool Ok = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ok_)));
          set_has_ok();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_CampID;
        break;
      }

      // required uint32 CampID = 2;
      case 2: {
        if (tag == 16) {
         parse_CampID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &campid_)));
          set_has_campid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_SkillID;
        break;
      }

      // required uint32 SkillID = 3;
      case 3: {
        if (tag == 24) {
         parse_SkillID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &skillid_)));
          set_has_skillid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_RandomNumbers;
        break;
      }

      // repeated uint32 RandomNumbers = 4;
      case 4: {
        if (tag == 32) {
         parse_RandomNumbers:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_randomnumbers())));
        } else if (tag == 34) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_randomnumbers())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_RandomNumbers;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpUseSkillResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpUseSkillResp)
  return false;
#undef DO_
}

void CSPvpUseSkillResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpUseSkillResp)
  // required bool Ok = 1;
  if (has_ok()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->ok(), output);
  }

  // required uint32 CampID = 2;
  if (has_campid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->campid(), output);
  }

  // required uint32 SkillID = 3;
  if (has_skillid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->skillid(), output);
  }

  // repeated uint32 RandomNumbers = 4;
  for (int i = 0; i < this->randomnumbers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->randomnumbers(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpUseSkillResp)
}

int CSPvpUseSkillResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool Ok = 1;
    if (has_ok()) {
      total_size += 1 + 1;
    }

    // required uint32 CampID = 2;
    if (has_campid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->campid());
    }

    // required uint32 SkillID = 3;
    if (has_skillid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->skillid());
    }

  }
  // repeated uint32 RandomNumbers = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->randomnumbers_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->randomnumbers(i));
    }
    total_size += 1 * this->randomnumbers_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpUseSkillResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpUseSkillResp*>(&from));
}

void CSPvpUseSkillResp::MergeFrom(const CSPvpUseSkillResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  randomnumbers_.MergeFrom(from.randomnumbers_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ok()) {
      set_ok(from.ok());
    }
    if (from.has_campid()) {
      set_campid(from.campid());
    }
    if (from.has_skillid()) {
      set_skillid(from.skillid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpUseSkillResp::CopyFrom(const CSPvpUseSkillResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpUseSkillResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSPvpUseSkillResp::Swap(CSPvpUseSkillResp* other) {
  if (other != this) {
    std::swap(ok_, other->ok_);
    std::swap(campid_, other->campid_);
    std::swap(skillid_, other->skillid_);
    randomnumbers_.Swap(&other->randomnumbers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpUseSkillResp::GetTypeName() const {
  return "fgame.CSPvpUseSkillResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpRankingGetListReq::kGroundIDFieldNumber;
const int CSPvpRankingGetListReq::kTopNSizeFieldNumber;
#endif  // !_MSC_VER

CSPvpRankingGetListReq::CSPvpRankingGetListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpRankingGetListReq)
}

void CSPvpRankingGetListReq::InitAsDefaultInstance() {
}

CSPvpRankingGetListReq::CSPvpRankingGetListReq(const CSPvpRankingGetListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpRankingGetListReq)
}

void CSPvpRankingGetListReq::SharedCtor() {
  _cached_size_ = 0;
  groundid_ = 0u;
  topnsize_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpRankingGetListReq::~CSPvpRankingGetListReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpRankingGetListReq)
  SharedDtor();
}

void CSPvpRankingGetListReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpRankingGetListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpRankingGetListReq& CSPvpRankingGetListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpRankingGetListReq* CSPvpRankingGetListReq::default_instance_ = NULL;

CSPvpRankingGetListReq* CSPvpRankingGetListReq::New() const {
  return new CSPvpRankingGetListReq;
}

void CSPvpRankingGetListReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpRankingGetListReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(groundid_, topnsize_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpRankingGetListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpRankingGetListReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 GroundID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &groundid_)));
          set_has_groundid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_TopNSize;
        break;
      }

      // optional uint32 TopNSize = 2;
      case 2: {
        if (tag == 16) {
         parse_TopNSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &topnsize_)));
          set_has_topnsize();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpRankingGetListReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpRankingGetListReq)
  return false;
#undef DO_
}

void CSPvpRankingGetListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpRankingGetListReq)
  // required uint32 GroundID = 1;
  if (has_groundid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->groundid(), output);
  }

  // optional uint32 TopNSize = 2;
  if (has_topnsize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->topnsize(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpRankingGetListReq)
}

int CSPvpRankingGetListReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 GroundID = 1;
    if (has_groundid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->groundid());
    }

    // optional uint32 TopNSize = 2;
    if (has_topnsize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->topnsize());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpRankingGetListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpRankingGetListReq*>(&from));
}

void CSPvpRankingGetListReq::MergeFrom(const CSPvpRankingGetListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_groundid()) {
      set_groundid(from.groundid());
    }
    if (from.has_topnsize()) {
      set_topnsize(from.topnsize());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpRankingGetListReq::CopyFrom(const CSPvpRankingGetListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpRankingGetListReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPvpRankingGetListReq::Swap(CSPvpRankingGetListReq* other) {
  if (other != this) {
    std::swap(groundid_, other->groundid_);
    std::swap(topnsize_, other->topnsize_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpRankingGetListReq::GetTypeName() const {
  return "fgame.CSPvpRankingGetListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpRankingPlayerInfo::kOrderFieldNumber;
const int CSPvpRankingPlayerInfo::kIdFieldNumber;
const int CSPvpRankingPlayerInfo::kNameFieldNumber;
const int CSPvpRankingPlayerInfo::kPointFieldNumber;
const int CSPvpRankingPlayerInfo::kWinRateFieldNumber;
const int CSPvpRankingPlayerInfo::kGroupFieldNumber;
const int CSPvpRankingPlayerInfo::kScoreFieldNumber;
const int CSPvpRankingPlayerInfo::kVipLevelFieldNumber;
const int CSPvpRankingPlayerInfo::kAreaFieldNumber;
#endif  // !_MSC_VER

CSPvpRankingPlayerInfo::CSPvpRankingPlayerInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpRankingPlayerInfo)
}

void CSPvpRankingPlayerInfo::InitAsDefaultInstance() {
}

CSPvpRankingPlayerInfo::CSPvpRankingPlayerInfo(const CSPvpRankingPlayerInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpRankingPlayerInfo)
}

void CSPvpRankingPlayerInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  order_ = 0u;
  id_ = GOOGLE_ULONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  point_ = 0u;
  winrate_ = 0;
  group_ = 0u;
  score_ = 0u;
  viplevel_ = 0u;
  area_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpRankingPlayerInfo::~CSPvpRankingPlayerInfo() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpRankingPlayerInfo)
  SharedDtor();
}

void CSPvpRankingPlayerInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpRankingPlayerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpRankingPlayerInfo& CSPvpRankingPlayerInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpRankingPlayerInfo* CSPvpRankingPlayerInfo::default_instance_ = NULL;

CSPvpRankingPlayerInfo* CSPvpRankingPlayerInfo::New() const {
  return new CSPvpRankingPlayerInfo;
}

void CSPvpRankingPlayerInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpRankingPlayerInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(id_, point_);
    ZR_(winrate_, viplevel_);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
  }
  area_ = 0u;

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpRankingPlayerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpRankingPlayerInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Order = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &order_)));
          set_has_order();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Id;
        break;
      }

      // required uint64 Id = 2;
      case 2: {
        if (tag == 16) {
         parse_Id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_Name;
        break;
      }

      // optional string Name = 3;
      case 3: {
        if (tag == 26) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Point;
        break;
      }

      // optional uint32 Point = 4;
      case 4: {
        if (tag == 32) {
         parse_Point:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &point_)));
          set_has_point();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_WinRate;
        break;
      }

      // optional float WinRate = 5;
      case 5: {
        if (tag == 45) {
         parse_WinRate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &winrate_)));
          set_has_winrate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_Group;
        break;
      }

      // optional uint32 Group = 6;
      case 6: {
        if (tag == 48) {
         parse_Group:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_)));
          set_has_group();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_Score;
        break;
      }

      // optional uint32 Score = 7;
      case 7: {
        if (tag == 56) {
         parse_Score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_VipLevel;
        break;
      }

      // optional uint32 VipLevel = 8;
      case 8: {
        if (tag == 64) {
         parse_VipLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &viplevel_)));
          set_has_viplevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_Area;
        break;
      }

      // optional uint32 Area = 9;
      case 9: {
        if (tag == 72) {
         parse_Area:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &area_)));
          set_has_area();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpRankingPlayerInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpRankingPlayerInfo)
  return false;
#undef DO_
}

void CSPvpRankingPlayerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpRankingPlayerInfo)
  // required uint32 Order = 1;
  if (has_order()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->order(), output);
  }

  // required uint64 Id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->id(), output);
  }

  // optional string Name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // optional uint32 Point = 4;
  if (has_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->point(), output);
  }

  // optional float WinRate = 5;
  if (has_winrate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->winrate(), output);
  }

  // optional uint32 Group = 6;
  if (has_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->group(), output);
  }

  // optional uint32 Score = 7;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->score(), output);
  }

  // optional uint32 VipLevel = 8;
  if (has_viplevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->viplevel(), output);
  }

  // optional uint32 Area = 9;
  if (has_area()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->area(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpRankingPlayerInfo)
}

int CSPvpRankingPlayerInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Order = 1;
    if (has_order()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->order());
    }

    // required uint64 Id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

    // optional string Name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional uint32 Point = 4;
    if (has_point()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->point());
    }

    // optional float WinRate = 5;
    if (has_winrate()) {
      total_size += 1 + 4;
    }

    // optional uint32 Group = 6;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group());
    }

    // optional uint32 Score = 7;
    if (has_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->score());
    }

    // optional uint32 VipLevel = 8;
    if (has_viplevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->viplevel());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 Area = 9;
    if (has_area()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->area());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpRankingPlayerInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpRankingPlayerInfo*>(&from));
}

void CSPvpRankingPlayerInfo::MergeFrom(const CSPvpRankingPlayerInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_order()) {
      set_order(from.order());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_point()) {
      set_point(from.point());
    }
    if (from.has_winrate()) {
      set_winrate(from.winrate());
    }
    if (from.has_group()) {
      set_group(from.group());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
    if (from.has_viplevel()) {
      set_viplevel(from.viplevel());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_area()) {
      set_area(from.area());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpRankingPlayerInfo::CopyFrom(const CSPvpRankingPlayerInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpRankingPlayerInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSPvpRankingPlayerInfo::Swap(CSPvpRankingPlayerInfo* other) {
  if (other != this) {
    std::swap(order_, other->order_);
    std::swap(id_, other->id_);
    std::swap(name_, other->name_);
    std::swap(point_, other->point_);
    std::swap(winrate_, other->winrate_);
    std::swap(group_, other->group_);
    std::swap(score_, other->score_);
    std::swap(viplevel_, other->viplevel_);
    std::swap(area_, other->area_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpRankingPlayerInfo::GetTypeName() const {
  return "fgame.CSPvpRankingPlayerInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpRankingGetListResp::kGroundIDFieldNumber;
const int CSPvpRankingGetListResp::kPlayerListFieldNumber;
#endif  // !_MSC_VER

CSPvpRankingGetListResp::CSPvpRankingGetListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpRankingGetListResp)
}

void CSPvpRankingGetListResp::InitAsDefaultInstance() {
}

CSPvpRankingGetListResp::CSPvpRankingGetListResp(const CSPvpRankingGetListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpRankingGetListResp)
}

void CSPvpRankingGetListResp::SharedCtor() {
  _cached_size_ = 0;
  groundid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpRankingGetListResp::~CSPvpRankingGetListResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpRankingGetListResp)
  SharedDtor();
}

void CSPvpRankingGetListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpRankingGetListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpRankingGetListResp& CSPvpRankingGetListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpRankingGetListResp* CSPvpRankingGetListResp::default_instance_ = NULL;

CSPvpRankingGetListResp* CSPvpRankingGetListResp::New() const {
  return new CSPvpRankingGetListResp;
}

void CSPvpRankingGetListResp::Clear() {
  groundid_ = 0u;
  playerlist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpRankingGetListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpRankingGetListResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 GroundID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &groundid_)));
          set_has_groundid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_PlayerList;
        break;
      }

      // repeated .fgame.CSPvpRankingPlayerInfo PlayerList = 2;
      case 2: {
        if (tag == 18) {
         parse_PlayerList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_playerlist()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_PlayerList;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpRankingGetListResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpRankingGetListResp)
  return false;
#undef DO_
}

void CSPvpRankingGetListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpRankingGetListResp)
  // required uint32 GroundID = 1;
  if (has_groundid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->groundid(), output);
  }

  // repeated .fgame.CSPvpRankingPlayerInfo PlayerList = 2;
  for (int i = 0; i < this->playerlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->playerlist(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpRankingGetListResp)
}

int CSPvpRankingGetListResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 GroundID = 1;
    if (has_groundid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->groundid());
    }

  }
  // repeated .fgame.CSPvpRankingPlayerInfo PlayerList = 2;
  total_size += 1 * this->playerlist_size();
  for (int i = 0; i < this->playerlist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->playerlist(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpRankingGetListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpRankingGetListResp*>(&from));
}

void CSPvpRankingGetListResp::MergeFrom(const CSPvpRankingGetListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  playerlist_.MergeFrom(from.playerlist_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_groundid()) {
      set_groundid(from.groundid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpRankingGetListResp::CopyFrom(const CSPvpRankingGetListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpRankingGetListResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->playerlist())) return false;
  return true;
}

void CSPvpRankingGetListResp::Swap(CSPvpRankingGetListResp* other) {
  if (other != this) {
    std::swap(groundid_, other->groundid_);
    playerlist_.Swap(&other->playerlist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpRankingGetListResp::GetTypeName() const {
  return "fgame.CSPvpRankingGetListResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpRankingPlayerInfoReq::kUinFieldNumber;
#endif  // !_MSC_VER

CSPvpRankingPlayerInfoReq::CSPvpRankingPlayerInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpRankingPlayerInfoReq)
}

void CSPvpRankingPlayerInfoReq::InitAsDefaultInstance() {
}

CSPvpRankingPlayerInfoReq::CSPvpRankingPlayerInfoReq(const CSPvpRankingPlayerInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpRankingPlayerInfoReq)
}

void CSPvpRankingPlayerInfoReq::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpRankingPlayerInfoReq::~CSPvpRankingPlayerInfoReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpRankingPlayerInfoReq)
  SharedDtor();
}

void CSPvpRankingPlayerInfoReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpRankingPlayerInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpRankingPlayerInfoReq& CSPvpRankingPlayerInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpRankingPlayerInfoReq* CSPvpRankingPlayerInfoReq::default_instance_ = NULL;

CSPvpRankingPlayerInfoReq* CSPvpRankingPlayerInfoReq::New() const {
  return new CSPvpRankingPlayerInfoReq;
}

void CSPvpRankingPlayerInfoReq::Clear() {
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpRankingPlayerInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpRankingPlayerInfoReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpRankingPlayerInfoReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpRankingPlayerInfoReq)
  return false;
#undef DO_
}

void CSPvpRankingPlayerInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpRankingPlayerInfoReq)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpRankingPlayerInfoReq)
}

int CSPvpRankingPlayerInfoReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpRankingPlayerInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpRankingPlayerInfoReq*>(&from));
}

void CSPvpRankingPlayerInfoReq::MergeFrom(const CSPvpRankingPlayerInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpRankingPlayerInfoReq::CopyFrom(const CSPvpRankingPlayerInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpRankingPlayerInfoReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPvpRankingPlayerInfoReq::Swap(CSPvpRankingPlayerInfoReq* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpRankingPlayerInfoReq::GetTypeName() const {
  return "fgame.CSPvpRankingPlayerInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpRankingPlayerInfoResp::kRankInfoFieldNumber;
const int CSPvpRankingPlayerInfoResp::kTotalRoundFieldNumber;
#endif  // !_MSC_VER

CSPvpRankingPlayerInfoResp::CSPvpRankingPlayerInfoResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpRankingPlayerInfoResp)
}

void CSPvpRankingPlayerInfoResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  rankinfo_ = const_cast< ::fgame::CSPvpRankingPlayerInfo*>(
      ::fgame::CSPvpRankingPlayerInfo::internal_default_instance());
#else
  rankinfo_ = const_cast< ::fgame::CSPvpRankingPlayerInfo*>(&::fgame::CSPvpRankingPlayerInfo::default_instance());
#endif
}

CSPvpRankingPlayerInfoResp::CSPvpRankingPlayerInfoResp(const CSPvpRankingPlayerInfoResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpRankingPlayerInfoResp)
}

void CSPvpRankingPlayerInfoResp::SharedCtor() {
  _cached_size_ = 0;
  rankinfo_ = NULL;
  totalround_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpRankingPlayerInfoResp::~CSPvpRankingPlayerInfoResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpRankingPlayerInfoResp)
  SharedDtor();
}

void CSPvpRankingPlayerInfoResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete rankinfo_;
  }
}

void CSPvpRankingPlayerInfoResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpRankingPlayerInfoResp& CSPvpRankingPlayerInfoResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpRankingPlayerInfoResp* CSPvpRankingPlayerInfoResp::default_instance_ = NULL;

CSPvpRankingPlayerInfoResp* CSPvpRankingPlayerInfoResp::New() const {
  return new CSPvpRankingPlayerInfoResp;
}

void CSPvpRankingPlayerInfoResp::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_rankinfo()) {
      if (rankinfo_ != NULL) rankinfo_->::fgame::CSPvpRankingPlayerInfo::Clear();
    }
    totalround_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpRankingPlayerInfoResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpRankingPlayerInfoResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .fgame.CSPvpRankingPlayerInfo RankInfo = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rankinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_TotalRound;
        break;
      }

      // optional uint32 TotalRound = 2;
      case 2: {
        if (tag == 16) {
         parse_TotalRound:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &totalround_)));
          set_has_totalround();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpRankingPlayerInfoResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpRankingPlayerInfoResp)
  return false;
#undef DO_
}

void CSPvpRankingPlayerInfoResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpRankingPlayerInfoResp)
  // required .fgame.CSPvpRankingPlayerInfo RankInfo = 1;
  if (has_rankinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->rankinfo(), output);
  }

  // optional uint32 TotalRound = 2;
  if (has_totalround()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->totalround(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpRankingPlayerInfoResp)
}

int CSPvpRankingPlayerInfoResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .fgame.CSPvpRankingPlayerInfo RankInfo = 1;
    if (has_rankinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rankinfo());
    }

    // optional uint32 TotalRound = 2;
    if (has_totalround()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->totalround());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpRankingPlayerInfoResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpRankingPlayerInfoResp*>(&from));
}

void CSPvpRankingPlayerInfoResp::MergeFrom(const CSPvpRankingPlayerInfoResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rankinfo()) {
      mutable_rankinfo()->::fgame::CSPvpRankingPlayerInfo::MergeFrom(from.rankinfo());
    }
    if (from.has_totalround()) {
      set_totalround(from.totalround());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpRankingPlayerInfoResp::CopyFrom(const CSPvpRankingPlayerInfoResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpRankingPlayerInfoResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_rankinfo()) {
    if (!this->rankinfo().IsInitialized()) return false;
  }
  return true;
}

void CSPvpRankingPlayerInfoResp::Swap(CSPvpRankingPlayerInfoResp* other) {
  if (other != this) {
    std::swap(rankinfo_, other->rankinfo_);
    std::swap(totalround_, other->totalround_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpRankingPlayerInfoResp::GetTypeName() const {
  return "fgame.CSPvpRankingPlayerInfoResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSPvpResultReq::CSPvpResultReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpResultReq)
}

void CSPvpResultReq::InitAsDefaultInstance() {
}

CSPvpResultReq::CSPvpResultReq(const CSPvpResultReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpResultReq)
}

void CSPvpResultReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpResultReq::~CSPvpResultReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpResultReq)
  SharedDtor();
}

void CSPvpResultReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpResultReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpResultReq& CSPvpResultReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpResultReq* CSPvpResultReq::default_instance_ = NULL;

CSPvpResultReq* CSPvpResultReq::New() const {
  return new CSPvpResultReq;
}

void CSPvpResultReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpResultReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpResultReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpResultReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpResultReq)
  return false;
#undef DO_
}

void CSPvpResultReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpResultReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpResultReq)
}

int CSPvpResultReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpResultReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpResultReq*>(&from));
}

void CSPvpResultReq::MergeFrom(const CSPvpResultReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpResultReq::CopyFrom(const CSPvpResultReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpResultReq::IsInitialized() const {

  return true;
}

void CSPvpResultReq::Swap(CSPvpResultReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpResultReq::GetTypeName() const {
  return "fgame.CSPvpResultReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpResultResp::kResultFieldNumber;
#endif  // !_MSC_VER

CSPvpResultResp::CSPvpResultResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpResultResp)
}

void CSPvpResultResp::InitAsDefaultInstance() {
}

CSPvpResultResp::CSPvpResultResp(const CSPvpResultResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpResultResp)
}

void CSPvpResultResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpResultResp::~CSPvpResultResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpResultResp)
  SharedDtor();
}

void CSPvpResultResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpResultResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpResultResp& CSPvpResultResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpResultResp* CSPvpResultResp::default_instance_ = NULL;

CSPvpResultResp* CSPvpResultResp::New() const {
  return new CSPvpResultResp;
}

void CSPvpResultResp::Clear() {
  result_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpResultResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpResultResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.CSPvpEndResp Result = 1;
      case 1: {
        if (tag == 10) {
         parse_Result:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_result()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_Result;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpResultResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpResultResp)
  return false;
#undef DO_
}

void CSPvpResultResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpResultResp)
  // repeated .fgame.CSPvpEndResp Result = 1;
  for (int i = 0; i < this->result_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->result(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpResultResp)
}

int CSPvpResultResp::ByteSize() const {
  int total_size = 0;

  // repeated .fgame.CSPvpEndResp Result = 1;
  total_size += 1 * this->result_size();
  for (int i = 0; i < this->result_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->result(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpResultResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpResultResp*>(&from));
}

void CSPvpResultResp::MergeFrom(const CSPvpResultResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  result_.MergeFrom(from.result_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpResultResp::CopyFrom(const CSPvpResultResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpResultResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->result())) return false;
  return true;
}

void CSPvpResultResp::Swap(CSPvpResultResp* other) {
  if (other != this) {
    result_.Swap(&other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpResultResp::GetTypeName() const {
  return "fgame.CSPvpResultResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSPvpSelfRankListReq::CSPvpSelfRankListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpSelfRankListReq)
}

void CSPvpSelfRankListReq::InitAsDefaultInstance() {
}

CSPvpSelfRankListReq::CSPvpSelfRankListReq(const CSPvpSelfRankListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpSelfRankListReq)
}

void CSPvpSelfRankListReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpSelfRankListReq::~CSPvpSelfRankListReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpSelfRankListReq)
  SharedDtor();
}

void CSPvpSelfRankListReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpSelfRankListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpSelfRankListReq& CSPvpSelfRankListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpSelfRankListReq* CSPvpSelfRankListReq::default_instance_ = NULL;

CSPvpSelfRankListReq* CSPvpSelfRankListReq::New() const {
  return new CSPvpSelfRankListReq;
}

void CSPvpSelfRankListReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpSelfRankListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpSelfRankListReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpSelfRankListReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpSelfRankListReq)
  return false;
#undef DO_
}

void CSPvpSelfRankListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpSelfRankListReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpSelfRankListReq)
}

int CSPvpSelfRankListReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpSelfRankListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpSelfRankListReq*>(&from));
}

void CSPvpSelfRankListReq::MergeFrom(const CSPvpSelfRankListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpSelfRankListReq::CopyFrom(const CSPvpSelfRankListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpSelfRankListReq::IsInitialized() const {

  return true;
}

void CSPvpSelfRankListReq::Swap(CSPvpSelfRankListReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpSelfRankListReq::GetTypeName() const {
  return "fgame.CSPvpSelfRankListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpSelfRankListResp::kPlayerListFieldNumber;
#endif  // !_MSC_VER

CSPvpSelfRankListResp::CSPvpSelfRankListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpSelfRankListResp)
}

void CSPvpSelfRankListResp::InitAsDefaultInstance() {
}

CSPvpSelfRankListResp::CSPvpSelfRankListResp(const CSPvpSelfRankListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpSelfRankListResp)
}

void CSPvpSelfRankListResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpSelfRankListResp::~CSPvpSelfRankListResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpSelfRankListResp)
  SharedDtor();
}

void CSPvpSelfRankListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpSelfRankListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpSelfRankListResp& CSPvpSelfRankListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpSelfRankListResp* CSPvpSelfRankListResp::default_instance_ = NULL;

CSPvpSelfRankListResp* CSPvpSelfRankListResp::New() const {
  return new CSPvpSelfRankListResp;
}

void CSPvpSelfRankListResp::Clear() {
  playerlist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpSelfRankListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpSelfRankListResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .fgame.CSPvpRankingPlayerInfo PlayerList = 1;
      case 1: {
        if (tag == 10) {
         parse_PlayerList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_playerlist()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_PlayerList;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpSelfRankListResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpSelfRankListResp)
  return false;
#undef DO_
}

void CSPvpSelfRankListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpSelfRankListResp)
  // repeated .fgame.CSPvpRankingPlayerInfo PlayerList = 1;
  for (int i = 0; i < this->playerlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->playerlist(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpSelfRankListResp)
}

int CSPvpSelfRankListResp::ByteSize() const {
  int total_size = 0;

  // repeated .fgame.CSPvpRankingPlayerInfo PlayerList = 1;
  total_size += 1 * this->playerlist_size();
  for (int i = 0; i < this->playerlist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->playerlist(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpSelfRankListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpSelfRankListResp*>(&from));
}

void CSPvpSelfRankListResp::MergeFrom(const CSPvpSelfRankListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  playerlist_.MergeFrom(from.playerlist_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpSelfRankListResp::CopyFrom(const CSPvpSelfRankListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpSelfRankListResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->playerlist())) return false;
  return true;
}

void CSPvpSelfRankListResp::Swap(CSPvpSelfRankListResp* other) {
  if (other != this) {
    playerlist_.Swap(&other->playerlist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpSelfRankListResp::GetTypeName() const {
  return "fgame.CSPvpSelfRankListResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpChatReq::kChannelFieldNumber;
const int CSPvpChatReq::kContentFieldNumber;
const int CSPvpChatReq::kIdFieldNumber;
const int CSPvpChatReq::kIsBuyFieldNumber;
#endif  // !_MSC_VER

CSPvpChatReq::CSPvpChatReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpChatReq)
}

void CSPvpChatReq::InitAsDefaultInstance() {
}

CSPvpChatReq::CSPvpChatReq(const CSPvpChatReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpChatReq)
}

void CSPvpChatReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  channel_ = 0u;
  content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_ = 0u;
  isbuy_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpChatReq::~CSPvpChatReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpChatReq)
  SharedDtor();
}

void CSPvpChatReq::SharedDtor() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpChatReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpChatReq& CSPvpChatReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpChatReq* CSPvpChatReq::default_instance_ = NULL;

CSPvpChatReq* CSPvpChatReq::New() const {
  return new CSPvpChatReq;
}

void CSPvpChatReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpChatReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(channel_, isbuy_);
    if (has_content()) {
      if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        content_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpChatReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpChatReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Channel = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &channel_)));
          set_has_channel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Content;
        break;
      }

      // optional string Content = 2;
      case 2: {
        if (tag == 18) {
         parse_Content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_content()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Id;
        break;
      }

      // optional uint32 Id = 3;
      case 3: {
        if (tag == 24) {
         parse_Id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_isBuy;
        break;
      }

      // optional uint32 isBuy = 4;
      case 4: {
        if (tag == 32) {
         parse_isBuy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &isbuy_)));
          set_has_isbuy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpChatReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpChatReq)
  return false;
#undef DO_
}

void CSPvpChatReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpChatReq)
  // required uint32 Channel = 1;
  if (has_channel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->channel(), output);
  }

  // optional string Content = 2;
  if (has_content()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->content(), output);
  }

  // optional uint32 Id = 3;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->id(), output);
  }

  // optional uint32 isBuy = 4;
  if (has_isbuy()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->isbuy(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpChatReq)
}

int CSPvpChatReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Channel = 1;
    if (has_channel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->channel());
    }

    // optional string Content = 2;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->content());
    }

    // optional uint32 Id = 3;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional uint32 isBuy = 4;
    if (has_isbuy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->isbuy());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpChatReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpChatReq*>(&from));
}

void CSPvpChatReq::MergeFrom(const CSPvpChatReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_channel()) {
      set_channel(from.channel());
    }
    if (from.has_content()) {
      set_content(from.content());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_isbuy()) {
      set_isbuy(from.isbuy());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpChatReq::CopyFrom(const CSPvpChatReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpChatReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPvpChatReq::Swap(CSPvpChatReq* other) {
  if (other != this) {
    std::swap(channel_, other->channel_);
    std::swap(content_, other->content_);
    std::swap(id_, other->id_);
    std::swap(isbuy_, other->isbuy_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpChatReq::GetTypeName() const {
  return "fgame.CSPvpChatReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpChatResp::kChannelFieldNumber;
const int CSPvpChatResp::kUinFieldNumber;
const int CSPvpChatResp::kNameFieldNumber;
const int CSPvpChatResp::kTitleFieldNumber;
const int CSPvpChatResp::kContentFieldNumber;
const int CSPvpChatResp::kIdFieldNumber;
const int CSPvpChatResp::kIconFieldNumber;
const int CSPvpChatResp::kVipLevelFieldNumber;
#endif  // !_MSC_VER

CSPvpChatResp::CSPvpChatResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpChatResp)
}

void CSPvpChatResp::InitAsDefaultInstance() {
}

CSPvpChatResp::CSPvpChatResp(const CSPvpChatResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpChatResp)
}

void CSPvpChatResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  channel_ = 0u;
  uin_ = GOOGLE_ULONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  title_ = 0u;
  content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_ = 0u;
  icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  viplevel_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpChatResp::~CSPvpChatResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpChatResp)
  SharedDtor();
}

void CSPvpChatResp::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpChatResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpChatResp& CSPvpChatResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpChatResp* CSPvpChatResp::default_instance_ = NULL;

CSPvpChatResp* CSPvpChatResp::New() const {
  return new CSPvpChatResp;
}

void CSPvpChatResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpChatResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(uin_, title_);
    ZR_(id_, viplevel_);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_content()) {
      if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        content_->clear();
      }
    }
    if (has_icon()) {
      if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        icon_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpChatResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpChatResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Channel = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &channel_)));
          set_has_channel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Uin;
        break;
      }

      // required uint64 Uin = 2;
      case 2: {
        if (tag == 16) {
         parse_Uin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_Name;
        break;
      }

      // optional string Name = 3;
      case 3: {
        if (tag == 26) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Title;
        break;
      }

      // optional uint32 Title = 4;
      case 4: {
        if (tag == 32) {
         parse_Title:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &title_)));
          set_has_title();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_Content;
        break;
      }

      // optional string Content = 5;
      case 5: {
        if (tag == 42) {
         parse_Content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_content()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_Id;
        break;
      }

      // optional uint32 Id = 6;
      case 6: {
        if (tag == 48) {
         parse_Id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_Icon;
        break;
      }

      // optional string Icon = 7;
      case 7: {
        if (tag == 58) {
         parse_Icon:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_icon()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_VipLevel;
        break;
      }

      // optional uint32 VipLevel = 8;
      case 8: {
        if (tag == 64) {
         parse_VipLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &viplevel_)));
          set_has_viplevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpChatResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpChatResp)
  return false;
#undef DO_
}

void CSPvpChatResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpChatResp)
  // required uint32 Channel = 1;
  if (has_channel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->channel(), output);
  }

  // required uint64 Uin = 2;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->uin(), output);
  }

  // optional string Name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // optional uint32 Title = 4;
  if (has_title()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->title(), output);
  }

  // optional string Content = 5;
  if (has_content()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->content(), output);
  }

  // optional uint32 Id = 6;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->id(), output);
  }

  // optional string Icon = 7;
  if (has_icon()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->icon(), output);
  }

  // optional uint32 VipLevel = 8;
  if (has_viplevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->viplevel(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpChatResp)
}

int CSPvpChatResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Channel = 1;
    if (has_channel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->channel());
    }

    // required uint64 Uin = 2;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

    // optional string Name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional uint32 Title = 4;
    if (has_title()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->title());
    }

    // optional string Content = 5;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->content());
    }

    // optional uint32 Id = 6;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional string Icon = 7;
    if (has_icon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->icon());
    }

    // optional uint32 VipLevel = 8;
    if (has_viplevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->viplevel());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpChatResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpChatResp*>(&from));
}

void CSPvpChatResp::MergeFrom(const CSPvpChatResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_channel()) {
      set_channel(from.channel());
    }
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_title()) {
      set_title(from.title());
    }
    if (from.has_content()) {
      set_content(from.content());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_icon()) {
      set_icon(from.icon());
    }
    if (from.has_viplevel()) {
      set_viplevel(from.viplevel());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpChatResp::CopyFrom(const CSPvpChatResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpChatResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSPvpChatResp::Swap(CSPvpChatResp* other) {
  if (other != this) {
    std::swap(channel_, other->channel_);
    std::swap(uin_, other->uin_);
    std::swap(name_, other->name_);
    std::swap(title_, other->title_);
    std::swap(content_, other->content_);
    std::swap(id_, other->id_);
    std::swap(icon_, other->icon_);
    std::swap(viplevel_, other->viplevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpChatResp::GetTypeName() const {
  return "fgame.CSPvpChatResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpRecoverItemReq::kUinFieldNumber;
const int CSPvpRecoverItemReq::kItemIdFieldNumber;
#endif  // !_MSC_VER

CSPvpRecoverItemReq::CSPvpRecoverItemReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpRecoverItemReq)
}

void CSPvpRecoverItemReq::InitAsDefaultInstance() {
}

CSPvpRecoverItemReq::CSPvpRecoverItemReq(const CSPvpRecoverItemReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpRecoverItemReq)
}

void CSPvpRecoverItemReq::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  itemid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpRecoverItemReq::~CSPvpRecoverItemReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpRecoverItemReq)
  SharedDtor();
}

void CSPvpRecoverItemReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpRecoverItemReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpRecoverItemReq& CSPvpRecoverItemReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpRecoverItemReq* CSPvpRecoverItemReq::default_instance_ = NULL;

CSPvpRecoverItemReq* CSPvpRecoverItemReq::New() const {
  return new CSPvpRecoverItemReq;
}

void CSPvpRecoverItemReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpRecoverItemReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(uin_, itemid_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpRecoverItemReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpRecoverItemReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ItemId;
        break;
      }

      // required uint32 ItemId = 2;
      case 2: {
        if (tag == 16) {
         parse_ItemId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpRecoverItemReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpRecoverItemReq)
  return false;
#undef DO_
}

void CSPvpRecoverItemReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpRecoverItemReq)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  // required uint32 ItemId = 2;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->itemid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpRecoverItemReq)
}

int CSPvpRecoverItemReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

    // required uint32 ItemId = 2;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpRecoverItemReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpRecoverItemReq*>(&from));
}

void CSPvpRecoverItemReq::MergeFrom(const CSPvpRecoverItemReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpRecoverItemReq::CopyFrom(const CSPvpRecoverItemReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpRecoverItemReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSPvpRecoverItemReq::Swap(CSPvpRecoverItemReq* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(itemid_, other->itemid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpRecoverItemReq::GetTypeName() const {
  return "fgame.CSPvpRecoverItemReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPvpRecoverItemResp::kUinFieldNumber;
const int CSPvpRecoverItemResp::kItemIdFieldNumber;
const int CSPvpRecoverItemResp::kNumFieldNumber;
#endif  // !_MSC_VER

CSPvpRecoverItemResp::CSPvpRecoverItemResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPvpRecoverItemResp)
}

void CSPvpRecoverItemResp::InitAsDefaultInstance() {
}

CSPvpRecoverItemResp::CSPvpRecoverItemResp(const CSPvpRecoverItemResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPvpRecoverItemResp)
}

void CSPvpRecoverItemResp::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  itemid_ = 0u;
  num_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPvpRecoverItemResp::~CSPvpRecoverItemResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPvpRecoverItemResp)
  SharedDtor();
}

void CSPvpRecoverItemResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPvpRecoverItemResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPvpRecoverItemResp& CSPvpRecoverItemResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Pvp_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Pvp_2eproto();
#endif
  return *default_instance_;
}

CSPvpRecoverItemResp* CSPvpRecoverItemResp::default_instance_ = NULL;

CSPvpRecoverItemResp* CSPvpRecoverItemResp::New() const {
  return new CSPvpRecoverItemResp;
}

void CSPvpRecoverItemResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPvpRecoverItemResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(uin_, num_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPvpRecoverItemResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPvpRecoverItemResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ItemId;
        break;
      }

      // required uint32 ItemId = 2;
      case 2: {
        if (tag == 16) {
         parse_ItemId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Num;
        break;
      }

      // required uint32 Num = 3;
      case 3: {
        if (tag == 24) {
         parse_Num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPvpRecoverItemResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPvpRecoverItemResp)
  return false;
#undef DO_
}

void CSPvpRecoverItemResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPvpRecoverItemResp)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  // required uint32 ItemId = 2;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->itemid(), output);
  }

  // required uint32 Num = 3;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->num(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPvpRecoverItemResp)
}

int CSPvpRecoverItemResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

    // required uint32 ItemId = 2;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemid());
    }

    // required uint32 Num = 3;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPvpRecoverItemResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPvpRecoverItemResp*>(&from));
}

void CSPvpRecoverItemResp::MergeFrom(const CSPvpRecoverItemResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPvpRecoverItemResp::CopyFrom(const CSPvpRecoverItemResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPvpRecoverItemResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSPvpRecoverItemResp::Swap(CSPvpRecoverItemResp* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(itemid_, other->itemid_);
    std::swap(num_, other->num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPvpRecoverItemResp::GetTypeName() const {
  return "fgame.CSPvpRecoverItemResp";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fgame

// @@protoc_insertion_point(global_scope)
