// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Pvp.proto

#ifndef PROTOBUF_Pvp_2eproto__INCLUDED
#define PROTOBUF_Pvp_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "Base.pb.h"
#include "Player.pb.h"
// @@protoc_insertion_point(includes)

namespace fgame {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Pvp_2eproto();
void protobuf_AssignDesc_Pvp_2eproto();
void protobuf_ShutdownFile_Pvp_2eproto();

class CSPvpMatchReq;
class CSPropData;
class CSPlayInfo;
class CSPvpMatchResp;
class CSPvpStopMatchReq;
class CSPvpStopMatchResp;
class CSPvpAppearCreepReq;
class CSPvpAppearCreepResp;
class CSPvpObserverReq;
class CSPvpObserverResp;
class CSPvpStartReq;
class CSPlayerPoint;
class CSPvpStartResp;
class CSPvpFightReq;
class CSPvpFightResp;
class CSPvpUpgradeReq;
class CSPvpUpgradeResp;
class CSPvpEndReq;
class CSPlayerPvpResult;
class CSPvpEndResp;
class CSPvpLeaveReq;
class CSPvpLeaveResp;
class CSPvpGetAwardResp;
class CSFormationList;
class CSMapData;
class CSPvpMapReq;
class CSPvpMapResp;
class CSPvpPingReq;
class CSPvpPingResp;
class CSPvpUseItemReq;
class CSPvpUseItemResp;
class CSPvpUseSkillReq;
class PvpAssistantInfo;
class CSPvpAssistantInfoResp;
class CSPvpUseSkillResp;
class CSPvpRankingGetListReq;
class CSPvpRankingPlayerInfo;
class CSPvpRankingGetListResp;
class CSPvpRankingPlayerInfoReq;
class CSPvpRankingPlayerInfoResp;
class CSPvpResultReq;
class CSPvpResultResp;
class CSPvpSelfRankListReq;
class CSPvpSelfRankListResp;
class CSPvpChatReq;
class CSPvpChatResp;
class CSPvpRecoverItemReq;
class CSPvpRecoverItemResp;

// ===================================================================

class CSPvpMatchReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpMatchReq();
  virtual ~CSPvpMatchReq();

  CSPvpMatchReq(const CSPvpMatchReq& from);

  inline CSPvpMatchReq& operator=(const CSPvpMatchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpMatchReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpMatchReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpMatchReq* other);

  // implements Message ----------------------------------------------

  CSPvpMatchReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpMatchReq& from);
  void MergeFrom(const CSPvpMatchReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 Mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpMatchReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 mode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpMatchReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPropData : public ::google::protobuf::MessageLite {
 public:
  CSPropData();
  virtual ~CSPropData();

  CSPropData(const CSPropData& from);

  inline CSPropData& operator=(const CSPropData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPropData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPropData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPropData* other);

  // implements Message ----------------------------------------------

  CSPropData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPropData& from);
  void MergeFrom(const CSPropData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ItemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // required int32 Count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPropData)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_count();
  inline void clear_has_count();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 count_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPropData* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayInfo : public ::google::protobuf::MessageLite {
 public:
  CSPlayInfo();
  virtual ~CSPlayInfo();

  CSPlayInfo(const CSPlayInfo& from);

  inline CSPlayInfo& operator=(const CSPlayInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPlayInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayInfo* other);

  // implements Message ----------------------------------------------

  CSPlayInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayInfo& from);
  void MergeFrom(const CSPlayInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::int64 uin() const;
  inline void set_uin(::google::protobuf::int64 value);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .fgame.CSPropData PropData = 3;
  inline int propdata_size() const;
  inline void clear_propdata();
  static const int kPropDataFieldNumber = 3;
  inline const ::fgame::CSPropData& propdata(int index) const;
  inline ::fgame::CSPropData* mutable_propdata(int index);
  inline ::fgame::CSPropData* add_propdata();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPropData >&
      propdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPropData >*
      mutable_propdata();

  // @@protoc_insertion_point(class_scope:fgame.CSPlayInfo)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 uin_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSPropData > propdata_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPlayInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpMatchResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpMatchResp();
  virtual ~CSPvpMatchResp();

  CSPvpMatchResp(const CSPvpMatchResp& from);

  inline CSPvpMatchResp& operator=(const CSPvpMatchResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpMatchResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpMatchResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpMatchResp* other);

  // implements Message ----------------------------------------------

  CSPvpMatchResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpMatchResp& from);
  void MergeFrom(const CSPvpMatchResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Match_Ret = 1;
  inline bool has_match_ret() const;
  inline void clear_match_ret();
  static const int kMatchRetFieldNumber = 1;
  inline ::google::protobuf::uint32 match_ret() const;
  inline void set_match_ret(::google::protobuf::uint32 value);

  // repeated .fgame.CSPlayInfo PlayInfo = 2;
  inline int playinfo_size() const;
  inline void clear_playinfo();
  static const int kPlayInfoFieldNumber = 2;
  inline const ::fgame::CSPlayInfo& playinfo(int index) const;
  inline ::fgame::CSPlayInfo* mutable_playinfo(int index);
  inline ::fgame::CSPlayInfo* add_playinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPlayInfo >&
      playinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPlayInfo >*
      mutable_playinfo();

  // required uint32 Type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 Flag = 4;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 4;
  inline ::google::protobuf::uint32 flag() const;
  inline void set_flag(::google::protobuf::uint32 value);

  // optional uint32 RoomId = 5;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 5;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // optional uint32 Opener = 6;
  inline bool has_opener() const;
  inline void clear_opener();
  static const int kOpenerFieldNumber = 6;
  inline ::google::protobuf::uint32 opener() const;
  inline void set_opener(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpMatchResp)
 private:
  inline void set_has_match_ret();
  inline void clear_has_match_ret();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_opener();
  inline void clear_has_opener();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSPlayInfo > playinfo_;
  ::google::protobuf::uint32 match_ret_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 flag_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 opener_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpMatchResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpStopMatchReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpStopMatchReq();
  virtual ~CSPvpStopMatchReq();

  CSPvpStopMatchReq(const CSPvpStopMatchReq& from);

  inline CSPvpStopMatchReq& operator=(const CSPvpStopMatchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpStopMatchReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpStopMatchReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpStopMatchReq* other);

  // implements Message ----------------------------------------------

  CSPvpStopMatchReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpStopMatchReq& from);
  void MergeFrom(const CSPvpStopMatchReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 Mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpStopMatchReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 mode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpStopMatchReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpStopMatchResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpStopMatchResp();
  virtual ~CSPvpStopMatchResp();

  CSPvpStopMatchResp(const CSPvpStopMatchResp& from);

  inline CSPvpStopMatchResp& operator=(const CSPvpStopMatchResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpStopMatchResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpStopMatchResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpStopMatchResp* other);

  // implements Message ----------------------------------------------

  CSPvpStopMatchResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpStopMatchResp& from);
  void MergeFrom(const CSPvpStopMatchResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSPvpStopMatchResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpStopMatchResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpAppearCreepReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpAppearCreepReq();
  virtual ~CSPvpAppearCreepReq();

  CSPvpAppearCreepReq(const CSPvpAppearCreepReq& from);

  inline CSPvpAppearCreepReq& operator=(const CSPvpAppearCreepReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpAppearCreepReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpAppearCreepReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpAppearCreepReq* other);

  // implements Message ----------------------------------------------

  CSPvpAppearCreepReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpAppearCreepReq& from);
  void MergeFrom(const CSPvpAppearCreepReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 CreepId = 1;
  inline bool has_creepid() const;
  inline void clear_creepid();
  static const int kCreepIdFieldNumber = 1;
  inline ::google::protobuf::uint32 creepid() const;
  inline void set_creepid(::google::protobuf::uint32 value);

  // required double Ts = 2;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 2;
  inline double ts() const;
  inline void set_ts(double value);

  // required uint32 DataId = 3;
  inline bool has_dataid() const;
  inline void clear_dataid();
  static const int kDataIdFieldNumber = 3;
  inline ::google::protobuf::uint32 dataid() const;
  inline void set_dataid(::google::protobuf::uint32 value);

  // optional uint32 RoomId = 4;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 4;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // optional uint32 MsgNo = 5;
  inline bool has_msgno() const;
  inline void clear_msgno();
  static const int kMsgNoFieldNumber = 5;
  inline ::google::protobuf::uint32 msgno() const;
  inline void set_msgno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpAppearCreepReq)
 private:
  inline void set_has_creepid();
  inline void clear_has_creepid();
  inline void set_has_ts();
  inline void clear_has_ts();
  inline void set_has_dataid();
  inline void clear_has_dataid();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_msgno();
  inline void clear_has_msgno();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double ts_;
  ::google::protobuf::uint32 creepid_;
  ::google::protobuf::uint32 dataid_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 msgno_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpAppearCreepReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpAppearCreepResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpAppearCreepResp();
  virtual ~CSPvpAppearCreepResp();

  CSPvpAppearCreepResp(const CSPvpAppearCreepResp& from);

  inline CSPvpAppearCreepResp& operator=(const CSPvpAppearCreepResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpAppearCreepResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpAppearCreepResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpAppearCreepResp* other);

  // implements Message ----------------------------------------------

  CSPvpAppearCreepResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpAppearCreepResp& from);
  void MergeFrom(const CSPvpAppearCreepResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 CreepId = 1;
  inline bool has_creepid() const;
  inline void clear_creepid();
  static const int kCreepIdFieldNumber = 1;
  inline ::google::protobuf::uint32 creepid() const;
  inline void set_creepid(::google::protobuf::uint32 value);

  // required double Ts = 2;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 2;
  inline double ts() const;
  inline void set_ts(double value);

  // required uint32 DataId = 3;
  inline bool has_dataid() const;
  inline void clear_dataid();
  static const int kDataIdFieldNumber = 3;
  inline ::google::protobuf::uint32 dataid() const;
  inline void set_dataid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpAppearCreepResp)
 private:
  inline void set_has_creepid();
  inline void clear_has_creepid();
  inline void set_has_ts();
  inline void clear_has_ts();
  inline void set_has_dataid();
  inline void clear_has_dataid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double ts_;
  ::google::protobuf::uint32 creepid_;
  ::google::protobuf::uint32 dataid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpAppearCreepResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpObserverReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpObserverReq();
  virtual ~CSPvpObserverReq();

  CSPvpObserverReq(const CSPvpObserverReq& from);

  inline CSPvpObserverReq& operator=(const CSPvpObserverReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpObserverReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpObserverReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpObserverReq* other);

  // implements Message ----------------------------------------------

  CSPvpObserverReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpObserverReq& from);
  void MergeFrom(const CSPvpObserverReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 RoomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // optional uint32 MsgNo = 2;
  inline bool has_msgno() const;
  inline void clear_msgno();
  static const int kMsgNoFieldNumber = 2;
  inline ::google::protobuf::uint32 msgno() const;
  inline void set_msgno(::google::protobuf::uint32 value);

  // optional int64 Uin = 3;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 3;
  inline ::google::protobuf::int64 uin() const;
  inline void set_uin(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpObserverReq)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_msgno();
  inline void clear_has_msgno();
  inline void set_has_uin();
  inline void clear_has_uin();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 msgno_;
  ::google::protobuf::int64 uin_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpObserverReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpObserverResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpObserverResp();
  virtual ~CSPvpObserverResp();

  CSPvpObserverResp(const CSPvpObserverResp& from);

  inline CSPvpObserverResp& operator=(const CSPvpObserverResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpObserverResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpObserverResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpObserverResp* other);

  // implements Message ----------------------------------------------

  CSPvpObserverResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpObserverResp& from);
  void MergeFrom(const CSPvpObserverResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::int64 uin() const;
  inline void set_uin(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpObserverResp)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 uin_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpObserverResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpStartReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpStartReq();
  virtual ~CSPvpStartReq();

  CSPvpStartReq(const CSPvpStartReq& from);

  inline CSPvpStartReq& operator=(const CSPvpStartReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpStartReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpStartReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpStartReq* other);

  // implements Message ----------------------------------------------

  CSPvpStartReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpStartReq& from);
  void MergeFrom(const CSPvpStartReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 RoomId = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 2;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // optional uint32 MsgNo = 3;
  inline bool has_msgno() const;
  inline void clear_msgno();
  static const int kMsgNoFieldNumber = 3;
  inline ::google::protobuf::uint32 msgno() const;
  inline void set_msgno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpStartReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_msgno();
  inline void clear_has_msgno();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 msgno_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpStartReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerPoint : public ::google::protobuf::MessageLite {
 public:
  CSPlayerPoint();
  virtual ~CSPlayerPoint();

  CSPlayerPoint(const CSPlayerPoint& from);

  inline CSPlayerPoint& operator=(const CSPlayerPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPlayerPoint& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerPoint* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerPoint* other);

  // implements Message ----------------------------------------------

  CSPlayerPoint* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerPoint& from);
  void MergeFrom(const CSPlayerPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::int64 uin() const;
  inline void set_uin(::google::protobuf::int64 value);

  // required uint32 Camp = 2;
  inline bool has_camp() const;
  inline void clear_camp();
  static const int kCampFieldNumber = 2;
  inline ::google::protobuf::uint32 camp() const;
  inline void set_camp(::google::protobuf::uint32 value);

  // optional string Name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string Icon = 4;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 4;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // optional uint32 Point = 5;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 5;
  inline ::google::protobuf::uint32 point() const;
  inline void set_point(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPlayerPoint)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_camp();
  inline void clear_has_camp();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_point();
  inline void clear_has_point();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 uin_;
  ::std::string* name_;
  ::google::protobuf::uint32 camp_;
  ::google::protobuf::uint32 point_;
  ::std::string* icon_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerPoint* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpStartResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpStartResp();
  virtual ~CSPvpStartResp();

  CSPvpStartResp(const CSPvpStartResp& from);

  inline CSPvpStartResp& operator=(const CSPvpStartResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpStartResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpStartResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpStartResp* other);

  // implements Message ----------------------------------------------

  CSPvpStartResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpStartResp& from);
  void MergeFrom(const CSPvpStartResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 MapId = 1;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 mapid() const;
  inline void set_mapid(::google::protobuf::uint32 value);

  // required uint32 Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required double Ts = 3;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 3;
  inline double ts() const;
  inline void set_ts(double value);

  // repeated .fgame.CSPlayerPoint Points = 4;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 4;
  inline const ::fgame::CSPlayerPoint& points(int index) const;
  inline ::fgame::CSPlayerPoint* mutable_points(int index);
  inline ::fgame::CSPlayerPoint* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPlayerPoint >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPlayerPoint >*
      mutable_points();

  // @@protoc_insertion_point(class_scope:fgame.CSPvpStartResp)
 private:
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ts();
  inline void clear_has_ts();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 mapid_;
  ::google::protobuf::uint32 type_;
  double ts_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSPlayerPoint > points_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpStartResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpFightReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpFightReq();
  virtual ~CSPvpFightReq();

  CSPvpFightReq(const CSPvpFightReq& from);

  inline CSPvpFightReq& operator=(const CSPvpFightReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpFightReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpFightReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpFightReq* other);

  // implements Message ----------------------------------------------

  CSPvpFightReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpFightReq& from);
  void MergeFrom(const CSPvpFightReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::int64 uin() const;
  inline void set_uin(::google::protobuf::int64 value);

  // required uint32 Src = 2;
  inline bool has_src() const;
  inline void clear_src();
  static const int kSrcFieldNumber = 2;
  inline ::google::protobuf::uint32 src() const;
  inline void set_src(::google::protobuf::uint32 value);

  // required uint32 Dest = 3;
  inline bool has_dest() const;
  inline void clear_dest();
  static const int kDestFieldNumber = 3;
  inline ::google::protobuf::uint32 dest() const;
  inline void set_dest(::google::protobuf::uint32 value);

  // required uint32 Num = 4;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 4;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // required double Ts = 5;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 5;
  inline double ts() const;
  inline void set_ts(double value);

  // required uint32 FormationId = 6;
  inline bool has_formationid() const;
  inline void clear_formationid();
  static const int kFormationIdFieldNumber = 6;
  inline ::google::protobuf::uint32 formationid() const;
  inline void set_formationid(::google::protobuf::uint32 value);

  // optional uint32 RoomId = 7;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 7;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // optional uint32 MsgNo = 8;
  inline bool has_msgno() const;
  inline void clear_msgno();
  static const int kMsgNoFieldNumber = 8;
  inline ::google::protobuf::uint32 msgno() const;
  inline void set_msgno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpFightReq)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_src();
  inline void clear_has_src();
  inline void set_has_dest();
  inline void clear_has_dest();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_ts();
  inline void clear_has_ts();
  inline void set_has_formationid();
  inline void clear_has_formationid();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_msgno();
  inline void clear_has_msgno();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 uin_;
  ::google::protobuf::uint32 src_;
  ::google::protobuf::uint32 dest_;
  double ts_;
  ::google::protobuf::uint32 num_;
  ::google::protobuf::uint32 formationid_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 msgno_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpFightReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpFightResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpFightResp();
  virtual ~CSPvpFightResp();

  CSPvpFightResp(const CSPvpFightResp& from);

  inline CSPvpFightResp& operator=(const CSPvpFightResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpFightResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpFightResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpFightResp* other);

  // implements Message ----------------------------------------------

  CSPvpFightResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpFightResp& from);
  void MergeFrom(const CSPvpFightResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::int64 uin() const;
  inline void set_uin(::google::protobuf::int64 value);

  // required uint32 Src = 2;
  inline bool has_src() const;
  inline void clear_src();
  static const int kSrcFieldNumber = 2;
  inline ::google::protobuf::uint32 src() const;
  inline void set_src(::google::protobuf::uint32 value);

  // required uint32 Dest = 3;
  inline bool has_dest() const;
  inline void clear_dest();
  static const int kDestFieldNumber = 3;
  inline ::google::protobuf::uint32 dest() const;
  inline void set_dest(::google::protobuf::uint32 value);

  // required uint32 Num = 4;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 4;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // required double Ts = 5;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 5;
  inline double ts() const;
  inline void set_ts(double value);

  // required uint32 FormationId = 6;
  inline bool has_formationid() const;
  inline void clear_formationid();
  static const int kFormationIdFieldNumber = 6;
  inline ::google::protobuf::uint32 formationid() const;
  inline void set_formationid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpFightResp)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_src();
  inline void clear_has_src();
  inline void set_has_dest();
  inline void clear_has_dest();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_ts();
  inline void clear_has_ts();
  inline void set_has_formationid();
  inline void clear_has_formationid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 uin_;
  ::google::protobuf::uint32 src_;
  ::google::protobuf::uint32 dest_;
  double ts_;
  ::google::protobuf::uint32 num_;
  ::google::protobuf::uint32 formationid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpFightResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpUpgradeReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpUpgradeReq();
  virtual ~CSPvpUpgradeReq();

  CSPvpUpgradeReq(const CSPvpUpgradeReq& from);

  inline CSPvpUpgradeReq& operator=(const CSPvpUpgradeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpUpgradeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpUpgradeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpUpgradeReq* other);

  // implements Message ----------------------------------------------

  CSPvpUpgradeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpUpgradeReq& from);
  void MergeFrom(const CSPvpUpgradeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::int64 uin() const;
  inline void set_uin(::google::protobuf::int64 value);

  // required uint32 BuildId = 2;
  inline bool has_buildid() const;
  inline void clear_buildid();
  static const int kBuildIdFieldNumber = 2;
  inline ::google::protobuf::uint32 buildid() const;
  inline void set_buildid(::google::protobuf::uint32 value);

  // required double Ts = 3;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 3;
  inline double ts() const;
  inline void set_ts(double value);

  // optional uint32 Level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 RoomId = 5;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 5;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // optional uint32 MsgNo = 6;
  inline bool has_msgno() const;
  inline void clear_msgno();
  static const int kMsgNoFieldNumber = 6;
  inline ::google::protobuf::uint32 msgno() const;
  inline void set_msgno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpUpgradeReq)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_buildid();
  inline void clear_has_buildid();
  inline void set_has_ts();
  inline void clear_has_ts();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_msgno();
  inline void clear_has_msgno();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 uin_;
  double ts_;
  ::google::protobuf::uint32 buildid_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 msgno_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpUpgradeReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpUpgradeResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpUpgradeResp();
  virtual ~CSPvpUpgradeResp();

  CSPvpUpgradeResp(const CSPvpUpgradeResp& from);

  inline CSPvpUpgradeResp& operator=(const CSPvpUpgradeResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpUpgradeResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpUpgradeResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpUpgradeResp* other);

  // implements Message ----------------------------------------------

  CSPvpUpgradeResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpUpgradeResp& from);
  void MergeFrom(const CSPvpUpgradeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::int64 uin() const;
  inline void set_uin(::google::protobuf::int64 value);

  // required uint32 BuildId = 2;
  inline bool has_buildid() const;
  inline void clear_buildid();
  static const int kBuildIdFieldNumber = 2;
  inline ::google::protobuf::uint32 buildid() const;
  inline void set_buildid(::google::protobuf::uint32 value);

  // required double Ts = 3;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 3;
  inline double ts() const;
  inline void set_ts(double value);

  // optional uint32 Level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpUpgradeResp)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_buildid();
  inline void clear_has_buildid();
  inline void set_has_ts();
  inline void clear_has_ts();
  inline void set_has_level();
  inline void clear_has_level();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 uin_;
  double ts_;
  ::google::protobuf::uint32 buildid_;
  ::google::protobuf::uint32 level_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpUpgradeResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpEndReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpEndReq();
  virtual ~CSPvpEndReq();

  CSPvpEndReq(const CSPvpEndReq& from);

  inline CSPvpEndReq& operator=(const CSPvpEndReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpEndReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpEndReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpEndReq* other);

  // implements Message ----------------------------------------------

  CSPvpEndReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpEndReq& from);
  void MergeFrom(const CSPvpEndReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 Win = 1;
  inline bool has_win() const;
  inline void clear_win();
  static const int kWinFieldNumber = 1;
  inline ::google::protobuf::int64 win() const;
  inline void set_win(::google::protobuf::int64 value);

  // required double Ts = 2;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 2;
  inline double ts() const;
  inline void set_ts(double value);

  // optional uint32 RoomId = 3;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 3;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // optional uint32 MsgNo = 4;
  inline bool has_msgno() const;
  inline void clear_msgno();
  static const int kMsgNoFieldNumber = 4;
  inline ::google::protobuf::uint32 msgno() const;
  inline void set_msgno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpEndReq)
 private:
  inline void set_has_win();
  inline void clear_has_win();
  inline void set_has_ts();
  inline void clear_has_ts();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_msgno();
  inline void clear_has_msgno();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 win_;
  double ts_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 msgno_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpEndReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerPvpResult : public ::google::protobuf::MessageLite {
 public:
  CSPlayerPvpResult();
  virtual ~CSPlayerPvpResult();

  CSPlayerPvpResult(const CSPlayerPvpResult& from);

  inline CSPlayerPvpResult& operator=(const CSPlayerPvpResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPlayerPvpResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerPvpResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerPvpResult* other);

  // implements Message ----------------------------------------------

  CSPlayerPvpResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerPvpResult& from);
  void MergeFrom(const CSPlayerPvpResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::int64 uin() const;
  inline void set_uin(::google::protobuf::int64 value);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 PrevScore = 3;
  inline bool has_prevscore() const;
  inline void clear_prevscore();
  static const int kPrevScoreFieldNumber = 3;
  inline ::google::protobuf::uint32 prevscore() const;
  inline void set_prevscore(::google::protobuf::uint32 value);

  // required uint32 AddScore = 4;
  inline bool has_addscore() const;
  inline void clear_addscore();
  static const int kAddScoreFieldNumber = 4;
  inline ::google::protobuf::uint32 addscore() const;
  inline void set_addscore(::google::protobuf::uint32 value);

  // required int32 WinRate = 5;
  inline bool has_winrate() const;
  inline void clear_winrate();
  static const int kWinRateFieldNumber = 5;
  inline ::google::protobuf::int32 winrate() const;
  inline void set_winrate(::google::protobuf::int32 value);

  // optional uint32 Title = 6;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 6;
  inline ::google::protobuf::uint32 title() const;
  inline void set_title(::google::protobuf::uint32 value);

  // optional uint32 NewRank = 7;
  inline bool has_newrank() const;
  inline void clear_newrank();
  static const int kNewRankFieldNumber = 7;
  inline ::google::protobuf::uint32 newrank() const;
  inline void set_newrank(::google::protobuf::uint32 value);

  // optional uint32 WinCount = 8;
  inline bool has_wincount() const;
  inline void clear_wincount();
  static const int kWinCountFieldNumber = 8;
  inline ::google::protobuf::uint32 wincount() const;
  inline void set_wincount(::google::protobuf::uint32 value);

  // optional int32 PrevPoint = 9;
  inline bool has_prevpoint() const;
  inline void clear_prevpoint();
  static const int kPrevPointFieldNumber = 9;
  inline ::google::protobuf::int32 prevpoint() const;
  inline void set_prevpoint(::google::protobuf::int32 value);

  // optional int32 AddPoint = 10;
  inline bool has_addpoint() const;
  inline void clear_addpoint();
  static const int kAddPointFieldNumber = 10;
  inline ::google::protobuf::int32 addpoint() const;
  inline void set_addpoint(::google::protobuf::int32 value);

  // optional uint32 ExtraScore = 11;
  inline bool has_extrascore() const;
  inline void clear_extrascore();
  static const int kExtraScoreFieldNumber = 11;
  inline ::google::protobuf::uint32 extrascore() const;
  inline void set_extrascore(::google::protobuf::uint32 value);

  // optional uint32 VipLevel = 12;
  inline bool has_viplevel() const;
  inline void clear_viplevel();
  static const int kVipLevelFieldNumber = 12;
  inline ::google::protobuf::uint32 viplevel() const;
  inline void set_viplevel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPlayerPvpResult)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_prevscore();
  inline void clear_has_prevscore();
  inline void set_has_addscore();
  inline void clear_has_addscore();
  inline void set_has_winrate();
  inline void clear_has_winrate();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_newrank();
  inline void clear_has_newrank();
  inline void set_has_wincount();
  inline void clear_has_wincount();
  inline void set_has_prevpoint();
  inline void clear_has_prevpoint();
  inline void set_has_addpoint();
  inline void clear_has_addpoint();
  inline void set_has_extrascore();
  inline void clear_has_extrascore();
  inline void set_has_viplevel();
  inline void clear_has_viplevel();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 uin_;
  ::std::string* name_;
  ::google::protobuf::uint32 prevscore_;
  ::google::protobuf::uint32 addscore_;
  ::google::protobuf::int32 winrate_;
  ::google::protobuf::uint32 title_;
  ::google::protobuf::uint32 newrank_;
  ::google::protobuf::uint32 wincount_;
  ::google::protobuf::int32 prevpoint_;
  ::google::protobuf::int32 addpoint_;
  ::google::protobuf::uint32 extrascore_;
  ::google::protobuf::uint32 viplevel_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerPvpResult* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpEndResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpEndResp();
  virtual ~CSPvpEndResp();

  CSPvpEndResp(const CSPvpEndResp& from);

  inline CSPvpEndResp& operator=(const CSPvpEndResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpEndResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpEndResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpEndResp* other);

  // implements Message ----------------------------------------------

  CSPvpEndResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpEndResp& from);
  void MergeFrom(const CSPvpEndResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 Win = 1;
  inline bool has_win() const;
  inline void clear_win();
  static const int kWinFieldNumber = 1;
  inline ::google::protobuf::int64 win() const;
  inline void set_win(::google::protobuf::int64 value);

  // required double Ts = 2;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 2;
  inline double ts() const;
  inline void set_ts(double value);

  // repeated .fgame.CSPlayerPvpResult Result = 3;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline const ::fgame::CSPlayerPvpResult& result(int index) const;
  inline ::fgame::CSPlayerPvpResult* mutable_result(int index);
  inline ::fgame::CSPlayerPvpResult* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPlayerPvpResult >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPlayerPvpResult >*
      mutable_result();

  // repeated .fgame.PropertyUpdateData UpdateData = 4;
  inline int updatedata_size() const;
  inline void clear_updatedata();
  static const int kUpdateDataFieldNumber = 4;
  inline const ::fgame::PropertyUpdateData& updatedata(int index) const;
  inline ::fgame::PropertyUpdateData* mutable_updatedata(int index);
  inline ::fgame::PropertyUpdateData* add_updatedata();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >&
      updatedata() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >*
      mutable_updatedata();

  // optional uint32 ShareId = 5;
  inline bool has_shareid() const;
  inline void clear_shareid();
  static const int kShareIdFieldNumber = 5;
  inline ::google::protobuf::uint32 shareid() const;
  inline void set_shareid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpEndResp)
 private:
  inline void set_has_win();
  inline void clear_has_win();
  inline void set_has_ts();
  inline void clear_has_ts();
  inline void set_has_shareid();
  inline void clear_has_shareid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 win_;
  double ts_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSPlayerPvpResult > result_;
  ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData > updatedata_;
  ::google::protobuf::uint32 shareid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpEndResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpLeaveReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpLeaveReq();
  virtual ~CSPvpLeaveReq();

  CSPvpLeaveReq(const CSPvpLeaveReq& from);

  inline CSPvpLeaveReq& operator=(const CSPvpLeaveReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpLeaveReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpLeaveReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpLeaveReq* other);

  // implements Message ----------------------------------------------

  CSPvpLeaveReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpLeaveReq& from);
  void MergeFrom(const CSPvpLeaveReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 RoomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // optional uint32 MsgNo = 2;
  inline bool has_msgno() const;
  inline void clear_msgno();
  static const int kMsgNoFieldNumber = 2;
  inline ::google::protobuf::uint32 msgno() const;
  inline void set_msgno(::google::protobuf::uint32 value);

  // optional uint32 Mode = 3;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 3;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpLeaveReq)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_msgno();
  inline void clear_has_msgno();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 msgno_;
  ::google::protobuf::uint32 mode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpLeaveReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpLeaveResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpLeaveResp();
  virtual ~CSPvpLeaveResp();

  CSPvpLeaveResp(const CSPvpLeaveResp& from);

  inline CSPvpLeaveResp& operator=(const CSPvpLeaveResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpLeaveResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpLeaveResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpLeaveResp* other);

  // implements Message ----------------------------------------------

  CSPvpLeaveResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpLeaveResp& from);
  void MergeFrom(const CSPvpLeaveResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::int64 uin() const;
  inline void set_uin(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpLeaveResp)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 uin_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpLeaveResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpGetAwardResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpGetAwardResp();
  virtual ~CSPvpGetAwardResp();

  CSPvpGetAwardResp(const CSPvpGetAwardResp& from);

  inline CSPvpGetAwardResp& operator=(const CSPvpGetAwardResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpGetAwardResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpGetAwardResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpGetAwardResp* other);

  // implements Message ----------------------------------------------

  CSPvpGetAwardResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpGetAwardResp& from);
  void MergeFrom(const CSPvpGetAwardResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 AwardType = 1;
  inline bool has_awardtype() const;
  inline void clear_awardtype();
  static const int kAwardTypeFieldNumber = 1;
  inline ::google::protobuf::int32 awardtype() const;
  inline void set_awardtype(::google::protobuf::int32 value);

  // repeated .fgame.PropertyUpdateData UpdateData = 2;
  inline int updatedata_size() const;
  inline void clear_updatedata();
  static const int kUpdateDataFieldNumber = 2;
  inline const ::fgame::PropertyUpdateData& updatedata(int index) const;
  inline ::fgame::PropertyUpdateData* mutable_updatedata(int index);
  inline ::fgame::PropertyUpdateData* add_updatedata();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >&
      updatedata() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >*
      mutable_updatedata();

  // @@protoc_insertion_point(class_scope:fgame.CSPvpGetAwardResp)
 private:
  inline void set_has_awardtype();
  inline void clear_has_awardtype();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData > updatedata_;
  ::google::protobuf::int32 awardtype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpGetAwardResp* default_instance_;
};
// -------------------------------------------------------------------

class CSFormationList : public ::google::protobuf::MessageLite {
 public:
  CSFormationList();
  virtual ~CSFormationList();

  CSFormationList(const CSFormationList& from);

  inline CSFormationList& operator=(const CSFormationList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSFormationList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSFormationList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSFormationList* other);

  // implements Message ----------------------------------------------

  CSFormationList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSFormationList& from);
  void MergeFrom(const CSFormationList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSFormationList)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSFormationList* default_instance_;
};
// -------------------------------------------------------------------

class CSMapData : public ::google::protobuf::MessageLite {
 public:
  CSMapData();
  virtual ~CSMapData();

  CSMapData(const CSMapData& from);

  inline CSMapData& operator=(const CSMapData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSMapData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMapData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMapData* other);

  // implements Message ----------------------------------------------

  CSMapData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMapData& from);
  void MergeFrom(const CSMapData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 BuildId = 1;
  inline bool has_buildid() const;
  inline void clear_buildid();
  static const int kBuildIdFieldNumber = 1;
  inline ::google::protobuf::uint32 buildid() const;
  inline void set_buildid(::google::protobuf::uint32 value);

  // required uint32 Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 Level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint32 Camp = 4;
  inline bool has_camp() const;
  inline void clear_camp();
  static const int kCampFieldNumber = 4;
  inline ::google::protobuf::uint32 camp() const;
  inline void set_camp(::google::protobuf::uint32 value);

  // required uint32 Num = 5;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 5;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // repeated .fgame.CSFormationList List = 6;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 6;
  inline const ::fgame::CSFormationList& list(int index) const;
  inline ::fgame::CSFormationList* mutable_list(int index);
  inline ::fgame::CSFormationList* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSFormationList >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSFormationList >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:fgame.CSMapData)
 private:
  inline void set_has_buildid();
  inline void clear_has_buildid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_camp();
  inline void clear_has_camp();
  inline void set_has_num();
  inline void clear_has_num();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 buildid_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 camp_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSFormationList > list_;
  ::google::protobuf::uint32 num_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSMapData* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpMapReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpMapReq();
  virtual ~CSPvpMapReq();

  CSPvpMapReq(const CSPvpMapReq& from);

  inline CSPvpMapReq& operator=(const CSPvpMapReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpMapReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpMapReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpMapReq* other);

  // implements Message ----------------------------------------------

  CSPvpMapReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpMapReq& from);
  void MergeFrom(const CSPvpMapReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.CSMapData Data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::fgame::CSMapData& data(int index) const;
  inline ::fgame::CSMapData* mutable_data(int index);
  inline ::fgame::CSMapData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSMapData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSMapData >*
      mutable_data();

  // required double Ts = 2;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 2;
  inline double ts() const;
  inline void set_ts(double value);

  // optional uint32 RoomId = 3;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 3;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // optional uint32 MsgNo = 4;
  inline bool has_msgno() const;
  inline void clear_msgno();
  static const int kMsgNoFieldNumber = 4;
  inline ::google::protobuf::uint32 msgno() const;
  inline void set_msgno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpMapReq)
 private:
  inline void set_has_ts();
  inline void clear_has_ts();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_msgno();
  inline void clear_has_msgno();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSMapData > data_;
  double ts_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 msgno_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpMapReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpMapResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpMapResp();
  virtual ~CSPvpMapResp();

  CSPvpMapResp(const CSPvpMapResp& from);

  inline CSPvpMapResp& operator=(const CSPvpMapResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpMapResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpMapResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpMapResp* other);

  // implements Message ----------------------------------------------

  CSPvpMapResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpMapResp& from);
  void MergeFrom(const CSPvpMapResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.CSMapData Data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::fgame::CSMapData& data(int index) const;
  inline ::fgame::CSMapData* mutable_data(int index);
  inline ::fgame::CSMapData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSMapData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSMapData >*
      mutable_data();

  // required double Ts = 2;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 2;
  inline double ts() const;
  inline void set_ts(double value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpMapResp)
 private:
  inline void set_has_ts();
  inline void clear_has_ts();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSMapData > data_;
  double ts_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpMapResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpPingReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpPingReq();
  virtual ~CSPvpPingReq();

  CSPvpPingReq(const CSPvpPingReq& from);

  inline CSPvpPingReq& operator=(const CSPvpPingReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpPingReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpPingReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpPingReq* other);

  // implements Message ----------------------------------------------

  CSPvpPingReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpPingReq& from);
  void MergeFrom(const CSPvpPingReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double Ts = 1;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 1;
  inline double ts() const;
  inline void set_ts(double value);

  // optional uint32 RoomId = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 2;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // optional uint32 MsgNo = 3;
  inline bool has_msgno() const;
  inline void clear_msgno();
  static const int kMsgNoFieldNumber = 3;
  inline ::google::protobuf::uint32 msgno() const;
  inline void set_msgno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpPingReq)
 private:
  inline void set_has_ts();
  inline void clear_has_ts();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_msgno();
  inline void clear_has_msgno();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double ts_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 msgno_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpPingReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpPingResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpPingResp();
  virtual ~CSPvpPingResp();

  CSPvpPingResp(const CSPvpPingResp& from);

  inline CSPvpPingResp& operator=(const CSPvpPingResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpPingResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpPingResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpPingResp* other);

  // implements Message ----------------------------------------------

  CSPvpPingResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpPingResp& from);
  void MergeFrom(const CSPvpPingResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 Host = 1;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 1;
  inline ::google::protobuf::int64 host() const;
  inline void set_host(::google::protobuf::int64 value);

  // required double Ts = 2;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 2;
  inline double ts() const;
  inline void set_ts(double value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpPingResp)
 private:
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_ts();
  inline void clear_has_ts();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 host_;
  double ts_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpPingResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpUseItemReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpUseItemReq();
  virtual ~CSPvpUseItemReq();

  CSPvpUseItemReq(const CSPvpUseItemReq& from);

  inline CSPvpUseItemReq& operator=(const CSPvpUseItemReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpUseItemReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpUseItemReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpUseItemReq* other);

  // implements Message ----------------------------------------------

  CSPvpUseItemReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpUseItemReq& from);
  void MergeFrom(const CSPvpUseItemReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ItemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // required double Ts = 2;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 2;
  inline double ts() const;
  inline void set_ts(double value);

  // optional uint32 X = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // optional uint32 Y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // optional uint32 BuildId = 5;
  inline bool has_buildid() const;
  inline void clear_buildid();
  static const int kBuildIdFieldNumber = 5;
  inline ::google::protobuf::uint32 buildid() const;
  inline void set_buildid(::google::protobuf::uint32 value);

  // optional uint32 RoomId = 6;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 6;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // optional uint32 MsgNo = 7;
  inline bool has_msgno() const;
  inline void clear_msgno();
  static const int kMsgNoFieldNumber = 7;
  inline ::google::protobuf::uint32 msgno() const;
  inline void set_msgno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpUseItemReq)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_ts();
  inline void clear_has_ts();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_buildid();
  inline void clear_has_buildid();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_msgno();
  inline void clear_has_msgno();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double ts_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 buildid_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 msgno_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpUseItemReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpUseItemResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpUseItemResp();
  virtual ~CSPvpUseItemResp();

  CSPvpUseItemResp(const CSPvpUseItemResp& from);

  inline CSPvpUseItemResp& operator=(const CSPvpUseItemResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpUseItemResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpUseItemResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpUseItemResp* other);

  // implements Message ----------------------------------------------

  CSPvpUseItemResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpUseItemResp& from);
  void MergeFrom(const CSPvpUseItemResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::int64 uin() const;
  inline void set_uin(::google::protobuf::int64 value);

  // required int32 ItemId = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // required double Ts = 3;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 3;
  inline double ts() const;
  inline void set_ts(double value);

  // optional uint32 X = 4;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 4;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // optional uint32 Y = 5;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 5;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // optional uint32 BuildId = 6;
  inline bool has_buildid() const;
  inline void clear_buildid();
  static const int kBuildIdFieldNumber = 6;
  inline ::google::protobuf::uint32 buildid() const;
  inline void set_buildid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpUseItemResp)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_ts();
  inline void clear_has_ts();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_buildid();
  inline void clear_has_buildid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 uin_;
  double ts_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 buildid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpUseItemResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpUseSkillReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpUseSkillReq();
  virtual ~CSPvpUseSkillReq();

  CSPvpUseSkillReq(const CSPvpUseSkillReq& from);

  inline CSPvpUseSkillReq& operator=(const CSPvpUseSkillReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpUseSkillReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpUseSkillReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpUseSkillReq* other);

  // implements Message ----------------------------------------------

  CSPvpUseSkillReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpUseSkillReq& from);
  void MergeFrom(const CSPvpUseSkillReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 CampID = 1;
  inline bool has_campid() const;
  inline void clear_campid();
  static const int kCampIDFieldNumber = 1;
  inline ::google::protobuf::uint32 campid() const;
  inline void set_campid(::google::protobuf::uint32 value);

  // required uint32 SkillID = 2;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillIDFieldNumber = 2;
  inline ::google::protobuf::uint32 skillid() const;
  inline void set_skillid(::google::protobuf::uint32 value);

  // required uint32 RollNum = 3;
  inline bool has_rollnum() const;
  inline void clear_rollnum();
  static const int kRollNumFieldNumber = 3;
  inline ::google::protobuf::uint32 rollnum() const;
  inline void set_rollnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpUseSkillReq)
 private:
  inline void set_has_campid();
  inline void clear_has_campid();
  inline void set_has_skillid();
  inline void clear_has_skillid();
  inline void set_has_rollnum();
  inline void clear_has_rollnum();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 campid_;
  ::google::protobuf::uint32 skillid_;
  ::google::protobuf::uint32 rollnum_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpUseSkillReq* default_instance_;
};
// -------------------------------------------------------------------

class PvpAssistantInfo : public ::google::protobuf::MessageLite {
 public:
  PvpAssistantInfo();
  virtual ~PvpAssistantInfo();

  PvpAssistantInfo(const PvpAssistantInfo& from);

  inline PvpAssistantInfo& operator=(const PvpAssistantInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PvpAssistantInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PvpAssistantInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PvpAssistantInfo* other);

  // implements Message ----------------------------------------------

  PvpAssistantInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PvpAssistantInfo& from);
  void MergeFrom(const PvpAssistantInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 AssistantId = 1;
  inline bool has_assistantid() const;
  inline void clear_assistantid();
  static const int kAssistantIdFieldNumber = 1;
  inline ::google::protobuf::uint32 assistantid() const;
  inline void set_assistantid(::google::protobuf::uint32 value);

  // required uint32 Level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint32 Quality = 3;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 3;
  inline ::google::protobuf::uint32 quality() const;
  inline void set_quality(::google::protobuf::uint32 value);

  // repeated uint32 ActiveSkills = 4;
  inline int activeskills_size() const;
  inline void clear_activeskills();
  static const int kActiveSkillsFieldNumber = 4;
  inline ::google::protobuf::uint32 activeskills(int index) const;
  inline void set_activeskills(int index, ::google::protobuf::uint32 value);
  inline void add_activeskills(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      activeskills() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_activeskills();

  // repeated uint32 PassiveSkills = 5;
  inline int passiveskills_size() const;
  inline void clear_passiveskills();
  static const int kPassiveSkillsFieldNumber = 5;
  inline ::google::protobuf::uint32 passiveskills(int index) const;
  inline void set_passiveskills(int index, ::google::protobuf::uint32 value);
  inline void add_passiveskills(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      passiveskills() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_passiveskills();

  // required uint32 CampID = 6;
  inline bool has_campid() const;
  inline void clear_campid();
  static const int kCampIDFieldNumber = 6;
  inline ::google::protobuf::uint32 campid() const;
  inline void set_campid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.PvpAssistantInfo)
 private:
  inline void set_has_assistantid();
  inline void clear_has_assistantid();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_campid();
  inline void clear_has_campid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 assistantid_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > activeskills_;
  ::google::protobuf::uint32 quality_;
  ::google::protobuf::uint32 campid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > passiveskills_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static PvpAssistantInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpAssistantInfoResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpAssistantInfoResp();
  virtual ~CSPvpAssistantInfoResp();

  CSPvpAssistantInfoResp(const CSPvpAssistantInfoResp& from);

  inline CSPvpAssistantInfoResp& operator=(const CSPvpAssistantInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpAssistantInfoResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpAssistantInfoResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpAssistantInfoResp* other);

  // implements Message ----------------------------------------------

  CSPvpAssistantInfoResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpAssistantInfoResp& from);
  void MergeFrom(const CSPvpAssistantInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.PvpAssistantInfo Info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::fgame::PvpAssistantInfo& info(int index) const;
  inline ::fgame::PvpAssistantInfo* mutable_info(int index);
  inline ::fgame::PvpAssistantInfo* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::PvpAssistantInfo >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::PvpAssistantInfo >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:fgame.CSPvpAssistantInfoResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::PvpAssistantInfo > info_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpAssistantInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpUseSkillResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpUseSkillResp();
  virtual ~CSPvpUseSkillResp();

  CSPvpUseSkillResp(const CSPvpUseSkillResp& from);

  inline CSPvpUseSkillResp& operator=(const CSPvpUseSkillResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpUseSkillResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpUseSkillResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpUseSkillResp* other);

  // implements Message ----------------------------------------------

  CSPvpUseSkillResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpUseSkillResp& from);
  void MergeFrom(const CSPvpUseSkillResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool Ok = 1;
  inline bool has_ok() const;
  inline void clear_ok();
  static const int kOkFieldNumber = 1;
  inline bool ok() const;
  inline void set_ok(bool value);

  // required uint32 CampID = 2;
  inline bool has_campid() const;
  inline void clear_campid();
  static const int kCampIDFieldNumber = 2;
  inline ::google::protobuf::uint32 campid() const;
  inline void set_campid(::google::protobuf::uint32 value);

  // required uint32 SkillID = 3;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillIDFieldNumber = 3;
  inline ::google::protobuf::uint32 skillid() const;
  inline void set_skillid(::google::protobuf::uint32 value);

  // repeated uint32 RandomNumbers = 4;
  inline int randomnumbers_size() const;
  inline void clear_randomnumbers();
  static const int kRandomNumbersFieldNumber = 4;
  inline ::google::protobuf::uint32 randomnumbers(int index) const;
  inline void set_randomnumbers(int index, ::google::protobuf::uint32 value);
  inline void add_randomnumbers(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      randomnumbers() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_randomnumbers();

  // @@protoc_insertion_point(class_scope:fgame.CSPvpUseSkillResp)
 private:
  inline void set_has_ok();
  inline void clear_has_ok();
  inline void set_has_campid();
  inline void clear_has_campid();
  inline void set_has_skillid();
  inline void clear_has_skillid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool ok_;
  ::google::protobuf::uint32 campid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > randomnumbers_;
  ::google::protobuf::uint32 skillid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpUseSkillResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpRankingGetListReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpRankingGetListReq();
  virtual ~CSPvpRankingGetListReq();

  CSPvpRankingGetListReq(const CSPvpRankingGetListReq& from);

  inline CSPvpRankingGetListReq& operator=(const CSPvpRankingGetListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpRankingGetListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpRankingGetListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpRankingGetListReq* other);

  // implements Message ----------------------------------------------

  CSPvpRankingGetListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpRankingGetListReq& from);
  void MergeFrom(const CSPvpRankingGetListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 GroundID = 1;
  inline bool has_groundid() const;
  inline void clear_groundid();
  static const int kGroundIDFieldNumber = 1;
  inline ::google::protobuf::uint32 groundid() const;
  inline void set_groundid(::google::protobuf::uint32 value);

  // optional uint32 TopNSize = 2;
  inline bool has_topnsize() const;
  inline void clear_topnsize();
  static const int kTopNSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 topnsize() const;
  inline void set_topnsize(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpRankingGetListReq)
 private:
  inline void set_has_groundid();
  inline void clear_has_groundid();
  inline void set_has_topnsize();
  inline void clear_has_topnsize();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 groundid_;
  ::google::protobuf::uint32 topnsize_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpRankingGetListReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpRankingPlayerInfo : public ::google::protobuf::MessageLite {
 public:
  CSPvpRankingPlayerInfo();
  virtual ~CSPvpRankingPlayerInfo();

  CSPvpRankingPlayerInfo(const CSPvpRankingPlayerInfo& from);

  inline CSPvpRankingPlayerInfo& operator=(const CSPvpRankingPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpRankingPlayerInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpRankingPlayerInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpRankingPlayerInfo* other);

  // implements Message ----------------------------------------------

  CSPvpRankingPlayerInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpRankingPlayerInfo& from);
  void MergeFrom(const CSPvpRankingPlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Order = 1;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 1;
  inline ::google::protobuf::uint32 order() const;
  inline void set_order(::google::protobuf::uint32 value);

  // required uint64 Id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string Name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 Point = 4;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 4;
  inline ::google::protobuf::uint32 point() const;
  inline void set_point(::google::protobuf::uint32 value);

  // optional float WinRate = 5;
  inline bool has_winrate() const;
  inline void clear_winrate();
  static const int kWinRateFieldNumber = 5;
  inline float winrate() const;
  inline void set_winrate(float value);

  // optional uint32 Group = 6;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 6;
  inline ::google::protobuf::uint32 group() const;
  inline void set_group(::google::protobuf::uint32 value);

  // optional uint32 Score = 7;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 7;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // optional uint32 VipLevel = 8;
  inline bool has_viplevel() const;
  inline void clear_viplevel();
  static const int kVipLevelFieldNumber = 8;
  inline ::google::protobuf::uint32 viplevel() const;
  inline void set_viplevel(::google::protobuf::uint32 value);

  // optional uint32 Area = 9;
  inline bool has_area() const;
  inline void clear_area();
  static const int kAreaFieldNumber = 9;
  inline ::google::protobuf::uint32 area() const;
  inline void set_area(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpRankingPlayerInfo)
 private:
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_winrate();
  inline void clear_has_winrate();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_viplevel();
  inline void clear_has_viplevel();
  inline void set_has_area();
  inline void clear_has_area();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint32 order_;
  ::google::protobuf::uint32 point_;
  ::std::string* name_;
  float winrate_;
  ::google::protobuf::uint32 group_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 viplevel_;
  ::google::protobuf::uint32 area_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpRankingPlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpRankingGetListResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpRankingGetListResp();
  virtual ~CSPvpRankingGetListResp();

  CSPvpRankingGetListResp(const CSPvpRankingGetListResp& from);

  inline CSPvpRankingGetListResp& operator=(const CSPvpRankingGetListResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpRankingGetListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpRankingGetListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpRankingGetListResp* other);

  // implements Message ----------------------------------------------

  CSPvpRankingGetListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpRankingGetListResp& from);
  void MergeFrom(const CSPvpRankingGetListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 GroundID = 1;
  inline bool has_groundid() const;
  inline void clear_groundid();
  static const int kGroundIDFieldNumber = 1;
  inline ::google::protobuf::uint32 groundid() const;
  inline void set_groundid(::google::protobuf::uint32 value);

  // repeated .fgame.CSPvpRankingPlayerInfo PlayerList = 2;
  inline int playerlist_size() const;
  inline void clear_playerlist();
  static const int kPlayerListFieldNumber = 2;
  inline const ::fgame::CSPvpRankingPlayerInfo& playerlist(int index) const;
  inline ::fgame::CSPvpRankingPlayerInfo* mutable_playerlist(int index);
  inline ::fgame::CSPvpRankingPlayerInfo* add_playerlist();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPvpRankingPlayerInfo >&
      playerlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPvpRankingPlayerInfo >*
      mutable_playerlist();

  // @@protoc_insertion_point(class_scope:fgame.CSPvpRankingGetListResp)
 private:
  inline void set_has_groundid();
  inline void clear_has_groundid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSPvpRankingPlayerInfo > playerlist_;
  ::google::protobuf::uint32 groundid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpRankingGetListResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpRankingPlayerInfoReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpRankingPlayerInfoReq();
  virtual ~CSPvpRankingPlayerInfoReq();

  CSPvpRankingPlayerInfoReq(const CSPvpRankingPlayerInfoReq& from);

  inline CSPvpRankingPlayerInfoReq& operator=(const CSPvpRankingPlayerInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpRankingPlayerInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpRankingPlayerInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpRankingPlayerInfoReq* other);

  // implements Message ----------------------------------------------

  CSPvpRankingPlayerInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpRankingPlayerInfoReq& from);
  void MergeFrom(const CSPvpRankingPlayerInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpRankingPlayerInfoReq)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpRankingPlayerInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpRankingPlayerInfoResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpRankingPlayerInfoResp();
  virtual ~CSPvpRankingPlayerInfoResp();

  CSPvpRankingPlayerInfoResp(const CSPvpRankingPlayerInfoResp& from);

  inline CSPvpRankingPlayerInfoResp& operator=(const CSPvpRankingPlayerInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpRankingPlayerInfoResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpRankingPlayerInfoResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpRankingPlayerInfoResp* other);

  // implements Message ----------------------------------------------

  CSPvpRankingPlayerInfoResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpRankingPlayerInfoResp& from);
  void MergeFrom(const CSPvpRankingPlayerInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .fgame.CSPvpRankingPlayerInfo RankInfo = 1;
  inline bool has_rankinfo() const;
  inline void clear_rankinfo();
  static const int kRankInfoFieldNumber = 1;
  inline const ::fgame::CSPvpRankingPlayerInfo& rankinfo() const;
  inline ::fgame::CSPvpRankingPlayerInfo* mutable_rankinfo();
  inline ::fgame::CSPvpRankingPlayerInfo* release_rankinfo();
  inline void set_allocated_rankinfo(::fgame::CSPvpRankingPlayerInfo* rankinfo);

  // optional uint32 TotalRound = 2;
  inline bool has_totalround() const;
  inline void clear_totalround();
  static const int kTotalRoundFieldNumber = 2;
  inline ::google::protobuf::uint32 totalround() const;
  inline void set_totalround(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpRankingPlayerInfoResp)
 private:
  inline void set_has_rankinfo();
  inline void clear_has_rankinfo();
  inline void set_has_totalround();
  inline void clear_has_totalround();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::fgame::CSPvpRankingPlayerInfo* rankinfo_;
  ::google::protobuf::uint32 totalround_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpRankingPlayerInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpResultReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpResultReq();
  virtual ~CSPvpResultReq();

  CSPvpResultReq(const CSPvpResultReq& from);

  inline CSPvpResultReq& operator=(const CSPvpResultReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpResultReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpResultReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpResultReq* other);

  // implements Message ----------------------------------------------

  CSPvpResultReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpResultReq& from);
  void MergeFrom(const CSPvpResultReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSPvpResultReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpResultReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpResultResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpResultResp();
  virtual ~CSPvpResultResp();

  CSPvpResultResp(const CSPvpResultResp& from);

  inline CSPvpResultResp& operator=(const CSPvpResultResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpResultResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpResultResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpResultResp* other);

  // implements Message ----------------------------------------------

  CSPvpResultResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpResultResp& from);
  void MergeFrom(const CSPvpResultResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.CSPvpEndResp Result = 1;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::fgame::CSPvpEndResp& result(int index) const;
  inline ::fgame::CSPvpEndResp* mutable_result(int index);
  inline ::fgame::CSPvpEndResp* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPvpEndResp >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPvpEndResp >*
      mutable_result();

  // @@protoc_insertion_point(class_scope:fgame.CSPvpResultResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSPvpEndResp > result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpResultResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpSelfRankListReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpSelfRankListReq();
  virtual ~CSPvpSelfRankListReq();

  CSPvpSelfRankListReq(const CSPvpSelfRankListReq& from);

  inline CSPvpSelfRankListReq& operator=(const CSPvpSelfRankListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpSelfRankListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpSelfRankListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpSelfRankListReq* other);

  // implements Message ----------------------------------------------

  CSPvpSelfRankListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpSelfRankListReq& from);
  void MergeFrom(const CSPvpSelfRankListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSPvpSelfRankListReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpSelfRankListReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpSelfRankListResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpSelfRankListResp();
  virtual ~CSPvpSelfRankListResp();

  CSPvpSelfRankListResp(const CSPvpSelfRankListResp& from);

  inline CSPvpSelfRankListResp& operator=(const CSPvpSelfRankListResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpSelfRankListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpSelfRankListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpSelfRankListResp* other);

  // implements Message ----------------------------------------------

  CSPvpSelfRankListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpSelfRankListResp& from);
  void MergeFrom(const CSPvpSelfRankListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fgame.CSPvpRankingPlayerInfo PlayerList = 1;
  inline int playerlist_size() const;
  inline void clear_playerlist();
  static const int kPlayerListFieldNumber = 1;
  inline const ::fgame::CSPvpRankingPlayerInfo& playerlist(int index) const;
  inline ::fgame::CSPvpRankingPlayerInfo* mutable_playerlist(int index);
  inline ::fgame::CSPvpRankingPlayerInfo* add_playerlist();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPvpRankingPlayerInfo >&
      playerlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPvpRankingPlayerInfo >*
      mutable_playerlist();

  // @@protoc_insertion_point(class_scope:fgame.CSPvpSelfRankListResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSPvpRankingPlayerInfo > playerlist_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpSelfRankListResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpChatReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpChatReq();
  virtual ~CSPvpChatReq();

  CSPvpChatReq(const CSPvpChatReq& from);

  inline CSPvpChatReq& operator=(const CSPvpChatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpChatReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpChatReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpChatReq* other);

  // implements Message ----------------------------------------------

  CSPvpChatReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpChatReq& from);
  void MergeFrom(const CSPvpChatReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Channel = 1;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 1;
  inline ::google::protobuf::uint32 channel() const;
  inline void set_channel(::google::protobuf::uint32 value);

  // optional string Content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional uint32 Id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 isBuy = 4;
  inline bool has_isbuy() const;
  inline void clear_isbuy();
  static const int kIsBuyFieldNumber = 4;
  inline ::google::protobuf::uint32 isbuy() const;
  inline void set_isbuy(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpChatReq)
 private:
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_isbuy();
  inline void clear_has_isbuy();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* content_;
  ::google::protobuf::uint32 channel_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 isbuy_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpChatReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpChatResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpChatResp();
  virtual ~CSPvpChatResp();

  CSPvpChatResp(const CSPvpChatResp& from);

  inline CSPvpChatResp& operator=(const CSPvpChatResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpChatResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpChatResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpChatResp* other);

  // implements Message ----------------------------------------------

  CSPvpChatResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpChatResp& from);
  void MergeFrom(const CSPvpChatResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Channel = 1;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 1;
  inline ::google::protobuf::uint32 channel() const;
  inline void set_channel(::google::protobuf::uint32 value);

  // required uint64 Uin = 2;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 2;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // optional string Name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 Title = 4;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 4;
  inline ::google::protobuf::uint32 title() const;
  inline void set_title(::google::protobuf::uint32 value);

  // optional string Content = 5;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 5;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional uint32 Id = 6;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 6;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string Icon = 7;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 7;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // optional uint32 VipLevel = 8;
  inline bool has_viplevel() const;
  inline void clear_viplevel();
  static const int kVipLevelFieldNumber = 8;
  inline ::google::protobuf::uint32 viplevel() const;
  inline void set_viplevel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpChatResp)
 private:
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_viplevel();
  inline void clear_has_viplevel();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  ::google::protobuf::uint32 channel_;
  ::google::protobuf::uint32 title_;
  ::std::string* name_;
  ::std::string* content_;
  ::std::string* icon_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 viplevel_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpChatResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpRecoverItemReq : public ::google::protobuf::MessageLite {
 public:
  CSPvpRecoverItemReq();
  virtual ~CSPvpRecoverItemReq();

  CSPvpRecoverItemReq(const CSPvpRecoverItemReq& from);

  inline CSPvpRecoverItemReq& operator=(const CSPvpRecoverItemReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpRecoverItemReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpRecoverItemReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpRecoverItemReq* other);

  // implements Message ----------------------------------------------

  CSPvpRecoverItemReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpRecoverItemReq& from);
  void MergeFrom(const CSPvpRecoverItemReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required uint32 ItemId = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpRecoverItemReq)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_itemid();
  inline void clear_has_itemid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  ::google::protobuf::uint32 itemid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpRecoverItemReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPvpRecoverItemResp : public ::google::protobuf::MessageLite {
 public:
  CSPvpRecoverItemResp();
  virtual ~CSPvpRecoverItemResp();

  CSPvpRecoverItemResp(const CSPvpRecoverItemResp& from);

  inline CSPvpRecoverItemResp& operator=(const CSPvpRecoverItemResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPvpRecoverItemResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPvpRecoverItemResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPvpRecoverItemResp* other);

  // implements Message ----------------------------------------------

  CSPvpRecoverItemResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPvpRecoverItemResp& from);
  void MergeFrom(const CSPvpRecoverItemResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required uint32 ItemId = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // required uint32 Num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPvpRecoverItemResp)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_num();
  inline void clear_has_num();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint32 num_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Pvp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Pvp_2eproto();
  #endif
  friend void protobuf_AssignDesc_Pvp_2eproto();
  friend void protobuf_ShutdownFile_Pvp_2eproto();

  void InitAsDefaultInstance();
  static CSPvpRecoverItemResp* default_instance_;
};
// ===================================================================


// ===================================================================

// CSPvpMatchReq

// required uint32 Type = 1;
inline bool CSPvpMatchReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpMatchReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpMatchReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpMatchReq::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSPvpMatchReq::type() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpMatchReq.Type)
  return type_;
}
inline void CSPvpMatchReq::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpMatchReq.Type)
}

// optional uint32 Mode = 2;
inline bool CSPvpMatchReq::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpMatchReq::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpMatchReq::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpMatchReq::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
inline ::google::protobuf::uint32 CSPvpMatchReq::mode() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpMatchReq.Mode)
  return mode_;
}
inline void CSPvpMatchReq::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpMatchReq.Mode)
}

// -------------------------------------------------------------------

// CSPropData

// required int32 ItemId = 1;
inline bool CSPropData::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPropData::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPropData::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPropData::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 CSPropData::itemid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPropData.ItemId)
  return itemid_;
}
inline void CSPropData::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPropData.ItemId)
}

// required int32 Count = 2;
inline bool CSPropData::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPropData::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPropData::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPropData::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 CSPropData::count() const {
  // @@protoc_insertion_point(field_get:fgame.CSPropData.Count)
  return count_;
}
inline void CSPropData::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPropData.Count)
}

// -------------------------------------------------------------------

// CSPlayInfo

// required int64 Uin = 1;
inline bool CSPlayInfo::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayInfo::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayInfo::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayInfo::clear_uin() {
  uin_ = GOOGLE_LONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::int64 CSPlayInfo::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayInfo.Uin)
  return uin_;
}
inline void CSPlayInfo::set_uin(::google::protobuf::int64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPlayInfo.Uin)
}

// required string Name = 2;
inline bool CSPlayInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSPlayInfo::name() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayInfo.Name)
  return *name_;
}
inline void CSPlayInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPlayInfo.Name)
}
inline void CSPlayInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPlayInfo.Name)
}
inline void CSPlayInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPlayInfo.Name)
}
inline ::std::string* CSPlayInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPlayInfo.Name)
  return name_;
}
inline ::std::string* CSPlayInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPlayInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPlayInfo.Name)
}

// repeated .fgame.CSPropData PropData = 3;
inline int CSPlayInfo::propdata_size() const {
  return propdata_.size();
}
inline void CSPlayInfo::clear_propdata() {
  propdata_.Clear();
}
inline const ::fgame::CSPropData& CSPlayInfo::propdata(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayInfo.PropData)
  return propdata_.Get(index);
}
inline ::fgame::CSPropData* CSPlayInfo::mutable_propdata(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSPlayInfo.PropData)
  return propdata_.Mutable(index);
}
inline ::fgame::CSPropData* CSPlayInfo::add_propdata() {
  // @@protoc_insertion_point(field_add:fgame.CSPlayInfo.PropData)
  return propdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPropData >&
CSPlayInfo::propdata() const {
  // @@protoc_insertion_point(field_list:fgame.CSPlayInfo.PropData)
  return propdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPropData >*
CSPlayInfo::mutable_propdata() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSPlayInfo.PropData)
  return &propdata_;
}

// -------------------------------------------------------------------

// CSPvpMatchResp

// required uint32 Match_Ret = 1;
inline bool CSPvpMatchResp::has_match_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpMatchResp::set_has_match_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpMatchResp::clear_has_match_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpMatchResp::clear_match_ret() {
  match_ret_ = 0u;
  clear_has_match_ret();
}
inline ::google::protobuf::uint32 CSPvpMatchResp::match_ret() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpMatchResp.Match_Ret)
  return match_ret_;
}
inline void CSPvpMatchResp::set_match_ret(::google::protobuf::uint32 value) {
  set_has_match_ret();
  match_ret_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpMatchResp.Match_Ret)
}

// repeated .fgame.CSPlayInfo PlayInfo = 2;
inline int CSPvpMatchResp::playinfo_size() const {
  return playinfo_.size();
}
inline void CSPvpMatchResp::clear_playinfo() {
  playinfo_.Clear();
}
inline const ::fgame::CSPlayInfo& CSPvpMatchResp::playinfo(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpMatchResp.PlayInfo)
  return playinfo_.Get(index);
}
inline ::fgame::CSPlayInfo* CSPvpMatchResp::mutable_playinfo(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSPvpMatchResp.PlayInfo)
  return playinfo_.Mutable(index);
}
inline ::fgame::CSPlayInfo* CSPvpMatchResp::add_playinfo() {
  // @@protoc_insertion_point(field_add:fgame.CSPvpMatchResp.PlayInfo)
  return playinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPlayInfo >&
CSPvpMatchResp::playinfo() const {
  // @@protoc_insertion_point(field_list:fgame.CSPvpMatchResp.PlayInfo)
  return playinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPlayInfo >*
CSPvpMatchResp::mutable_playinfo() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSPvpMatchResp.PlayInfo)
  return &playinfo_;
}

// required uint32 Type = 3;
inline bool CSPvpMatchResp::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpMatchResp::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpMatchResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpMatchResp::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSPvpMatchResp::type() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpMatchResp.Type)
  return type_;
}
inline void CSPvpMatchResp::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpMatchResp.Type)
}

// optional uint32 Flag = 4;
inline bool CSPvpMatchResp::has_flag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPvpMatchResp::set_has_flag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPvpMatchResp::clear_has_flag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPvpMatchResp::clear_flag() {
  flag_ = 0u;
  clear_has_flag();
}
inline ::google::protobuf::uint32 CSPvpMatchResp::flag() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpMatchResp.Flag)
  return flag_;
}
inline void CSPvpMatchResp::set_flag(::google::protobuf::uint32 value) {
  set_has_flag();
  flag_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpMatchResp.Flag)
}

// optional uint32 RoomId = 5;
inline bool CSPvpMatchResp::has_roomid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPvpMatchResp::set_has_roomid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPvpMatchResp::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPvpMatchResp::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPvpMatchResp::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpMatchResp.RoomId)
  return roomid_;
}
inline void CSPvpMatchResp::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpMatchResp.RoomId)
}

// optional uint32 Opener = 6;
inline bool CSPvpMatchResp::has_opener() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPvpMatchResp::set_has_opener() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPvpMatchResp::clear_has_opener() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPvpMatchResp::clear_opener() {
  opener_ = 0u;
  clear_has_opener();
}
inline ::google::protobuf::uint32 CSPvpMatchResp::opener() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpMatchResp.Opener)
  return opener_;
}
inline void CSPvpMatchResp::set_opener(::google::protobuf::uint32 value) {
  set_has_opener();
  opener_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpMatchResp.Opener)
}

// -------------------------------------------------------------------

// CSPvpStopMatchReq

// required uint32 Type = 1;
inline bool CSPvpStopMatchReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpStopMatchReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpStopMatchReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpStopMatchReq::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSPvpStopMatchReq::type() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpStopMatchReq.Type)
  return type_;
}
inline void CSPvpStopMatchReq::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpStopMatchReq.Type)
}

// optional uint32 Mode = 2;
inline bool CSPvpStopMatchReq::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpStopMatchReq::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpStopMatchReq::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpStopMatchReq::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
inline ::google::protobuf::uint32 CSPvpStopMatchReq::mode() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpStopMatchReq.Mode)
  return mode_;
}
inline void CSPvpStopMatchReq::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpStopMatchReq.Mode)
}

// -------------------------------------------------------------------

// CSPvpStopMatchResp

// -------------------------------------------------------------------

// CSPvpAppearCreepReq

// required uint32 CreepId = 1;
inline bool CSPvpAppearCreepReq::has_creepid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpAppearCreepReq::set_has_creepid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpAppearCreepReq::clear_has_creepid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpAppearCreepReq::clear_creepid() {
  creepid_ = 0u;
  clear_has_creepid();
}
inline ::google::protobuf::uint32 CSPvpAppearCreepReq::creepid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpAppearCreepReq.CreepId)
  return creepid_;
}
inline void CSPvpAppearCreepReq::set_creepid(::google::protobuf::uint32 value) {
  set_has_creepid();
  creepid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpAppearCreepReq.CreepId)
}

// required double Ts = 2;
inline bool CSPvpAppearCreepReq::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpAppearCreepReq::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpAppearCreepReq::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpAppearCreepReq::clear_ts() {
  ts_ = 0;
  clear_has_ts();
}
inline double CSPvpAppearCreepReq::ts() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpAppearCreepReq.Ts)
  return ts_;
}
inline void CSPvpAppearCreepReq::set_ts(double value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpAppearCreepReq.Ts)
}

// required uint32 DataId = 3;
inline bool CSPvpAppearCreepReq::has_dataid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpAppearCreepReq::set_has_dataid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpAppearCreepReq::clear_has_dataid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpAppearCreepReq::clear_dataid() {
  dataid_ = 0u;
  clear_has_dataid();
}
inline ::google::protobuf::uint32 CSPvpAppearCreepReq::dataid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpAppearCreepReq.DataId)
  return dataid_;
}
inline void CSPvpAppearCreepReq::set_dataid(::google::protobuf::uint32 value) {
  set_has_dataid();
  dataid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpAppearCreepReq.DataId)
}

// optional uint32 RoomId = 4;
inline bool CSPvpAppearCreepReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPvpAppearCreepReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPvpAppearCreepReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPvpAppearCreepReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPvpAppearCreepReq::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpAppearCreepReq.RoomId)
  return roomid_;
}
inline void CSPvpAppearCreepReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpAppearCreepReq.RoomId)
}

// optional uint32 MsgNo = 5;
inline bool CSPvpAppearCreepReq::has_msgno() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPvpAppearCreepReq::set_has_msgno() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPvpAppearCreepReq::clear_has_msgno() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPvpAppearCreepReq::clear_msgno() {
  msgno_ = 0u;
  clear_has_msgno();
}
inline ::google::protobuf::uint32 CSPvpAppearCreepReq::msgno() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpAppearCreepReq.MsgNo)
  return msgno_;
}
inline void CSPvpAppearCreepReq::set_msgno(::google::protobuf::uint32 value) {
  set_has_msgno();
  msgno_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpAppearCreepReq.MsgNo)
}

// -------------------------------------------------------------------

// CSPvpAppearCreepResp

// required uint32 CreepId = 1;
inline bool CSPvpAppearCreepResp::has_creepid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpAppearCreepResp::set_has_creepid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpAppearCreepResp::clear_has_creepid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpAppearCreepResp::clear_creepid() {
  creepid_ = 0u;
  clear_has_creepid();
}
inline ::google::protobuf::uint32 CSPvpAppearCreepResp::creepid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpAppearCreepResp.CreepId)
  return creepid_;
}
inline void CSPvpAppearCreepResp::set_creepid(::google::protobuf::uint32 value) {
  set_has_creepid();
  creepid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpAppearCreepResp.CreepId)
}

// required double Ts = 2;
inline bool CSPvpAppearCreepResp::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpAppearCreepResp::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpAppearCreepResp::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpAppearCreepResp::clear_ts() {
  ts_ = 0;
  clear_has_ts();
}
inline double CSPvpAppearCreepResp::ts() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpAppearCreepResp.Ts)
  return ts_;
}
inline void CSPvpAppearCreepResp::set_ts(double value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpAppearCreepResp.Ts)
}

// required uint32 DataId = 3;
inline bool CSPvpAppearCreepResp::has_dataid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpAppearCreepResp::set_has_dataid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpAppearCreepResp::clear_has_dataid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpAppearCreepResp::clear_dataid() {
  dataid_ = 0u;
  clear_has_dataid();
}
inline ::google::protobuf::uint32 CSPvpAppearCreepResp::dataid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpAppearCreepResp.DataId)
  return dataid_;
}
inline void CSPvpAppearCreepResp::set_dataid(::google::protobuf::uint32 value) {
  set_has_dataid();
  dataid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpAppearCreepResp.DataId)
}

// -------------------------------------------------------------------

// CSPvpObserverReq

// optional uint32 RoomId = 1;
inline bool CSPvpObserverReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpObserverReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpObserverReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpObserverReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPvpObserverReq::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpObserverReq.RoomId)
  return roomid_;
}
inline void CSPvpObserverReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpObserverReq.RoomId)
}

// optional uint32 MsgNo = 2;
inline bool CSPvpObserverReq::has_msgno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpObserverReq::set_has_msgno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpObserverReq::clear_has_msgno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpObserverReq::clear_msgno() {
  msgno_ = 0u;
  clear_has_msgno();
}
inline ::google::protobuf::uint32 CSPvpObserverReq::msgno() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpObserverReq.MsgNo)
  return msgno_;
}
inline void CSPvpObserverReq::set_msgno(::google::protobuf::uint32 value) {
  set_has_msgno();
  msgno_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpObserverReq.MsgNo)
}

// optional int64 Uin = 3;
inline bool CSPvpObserverReq::has_uin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpObserverReq::set_has_uin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpObserverReq::clear_has_uin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpObserverReq::clear_uin() {
  uin_ = GOOGLE_LONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::int64 CSPvpObserverReq::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpObserverReq.Uin)
  return uin_;
}
inline void CSPvpObserverReq::set_uin(::google::protobuf::int64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpObserverReq.Uin)
}

// -------------------------------------------------------------------

// CSPvpObserverResp

// optional int64 Uin = 1;
inline bool CSPvpObserverResp::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpObserverResp::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpObserverResp::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpObserverResp::clear_uin() {
  uin_ = GOOGLE_LONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::int64 CSPvpObserverResp::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpObserverResp.Uin)
  return uin_;
}
inline void CSPvpObserverResp::set_uin(::google::protobuf::int64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpObserverResp.Uin)
}

// -------------------------------------------------------------------

// CSPvpStartReq

// required uint32 Type = 1;
inline bool CSPvpStartReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpStartReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpStartReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpStartReq::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSPvpStartReq::type() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpStartReq.Type)
  return type_;
}
inline void CSPvpStartReq::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpStartReq.Type)
}

// optional uint32 RoomId = 2;
inline bool CSPvpStartReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpStartReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpStartReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpStartReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPvpStartReq::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpStartReq.RoomId)
  return roomid_;
}
inline void CSPvpStartReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpStartReq.RoomId)
}

// optional uint32 MsgNo = 3;
inline bool CSPvpStartReq::has_msgno() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpStartReq::set_has_msgno() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpStartReq::clear_has_msgno() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpStartReq::clear_msgno() {
  msgno_ = 0u;
  clear_has_msgno();
}
inline ::google::protobuf::uint32 CSPvpStartReq::msgno() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpStartReq.MsgNo)
  return msgno_;
}
inline void CSPvpStartReq::set_msgno(::google::protobuf::uint32 value) {
  set_has_msgno();
  msgno_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpStartReq.MsgNo)
}

// -------------------------------------------------------------------

// CSPlayerPoint

// required int64 Uin = 1;
inline bool CSPlayerPoint::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerPoint::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerPoint::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerPoint::clear_uin() {
  uin_ = GOOGLE_LONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::int64 CSPlayerPoint::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayerPoint.Uin)
  return uin_;
}
inline void CSPlayerPoint::set_uin(::google::protobuf::int64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPlayerPoint.Uin)
}

// required uint32 Camp = 2;
inline bool CSPlayerPoint::has_camp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerPoint::set_has_camp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerPoint::clear_has_camp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerPoint::clear_camp() {
  camp_ = 0u;
  clear_has_camp();
}
inline ::google::protobuf::uint32 CSPlayerPoint::camp() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayerPoint.Camp)
  return camp_;
}
inline void CSPlayerPoint::set_camp(::google::protobuf::uint32 value) {
  set_has_camp();
  camp_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPlayerPoint.Camp)
}

// optional string Name = 3;
inline bool CSPlayerPoint::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerPoint::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerPoint::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerPoint::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSPlayerPoint::name() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayerPoint.Name)
  return *name_;
}
inline void CSPlayerPoint::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPlayerPoint.Name)
}
inline void CSPlayerPoint::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPlayerPoint.Name)
}
inline void CSPlayerPoint::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPlayerPoint.Name)
}
inline ::std::string* CSPlayerPoint::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPlayerPoint.Name)
  return name_;
}
inline ::std::string* CSPlayerPoint::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPlayerPoint::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPlayerPoint.Name)
}

// optional string Icon = 4;
inline bool CSPlayerPoint::has_icon() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPlayerPoint::set_has_icon() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPlayerPoint::clear_has_icon() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPlayerPoint::clear_icon() {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& CSPlayerPoint::icon() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayerPoint.Icon)
  return *icon_;
}
inline void CSPlayerPoint::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPlayerPoint.Icon)
}
inline void CSPlayerPoint::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPlayerPoint.Icon)
}
inline void CSPlayerPoint::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPlayerPoint.Icon)
}
inline ::std::string* CSPlayerPoint::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPlayerPoint.Icon)
  return icon_;
}
inline ::std::string* CSPlayerPoint::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPlayerPoint::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPlayerPoint.Icon)
}

// optional uint32 Point = 5;
inline bool CSPlayerPoint::has_point() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPlayerPoint::set_has_point() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPlayerPoint::clear_has_point() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPlayerPoint::clear_point() {
  point_ = 0u;
  clear_has_point();
}
inline ::google::protobuf::uint32 CSPlayerPoint::point() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayerPoint.Point)
  return point_;
}
inline void CSPlayerPoint::set_point(::google::protobuf::uint32 value) {
  set_has_point();
  point_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPlayerPoint.Point)
}

// -------------------------------------------------------------------

// CSPvpStartResp

// required uint32 MapId = 1;
inline bool CSPvpStartResp::has_mapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpStartResp::set_has_mapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpStartResp::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpStartResp::clear_mapid() {
  mapid_ = 0u;
  clear_has_mapid();
}
inline ::google::protobuf::uint32 CSPvpStartResp::mapid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpStartResp.MapId)
  return mapid_;
}
inline void CSPvpStartResp::set_mapid(::google::protobuf::uint32 value) {
  set_has_mapid();
  mapid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpStartResp.MapId)
}

// required uint32 Type = 2;
inline bool CSPvpStartResp::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpStartResp::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpStartResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpStartResp::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSPvpStartResp::type() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpStartResp.Type)
  return type_;
}
inline void CSPvpStartResp::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpStartResp.Type)
}

// required double Ts = 3;
inline bool CSPvpStartResp::has_ts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpStartResp::set_has_ts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpStartResp::clear_has_ts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpStartResp::clear_ts() {
  ts_ = 0;
  clear_has_ts();
}
inline double CSPvpStartResp::ts() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpStartResp.Ts)
  return ts_;
}
inline void CSPvpStartResp::set_ts(double value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpStartResp.Ts)
}

// repeated .fgame.CSPlayerPoint Points = 4;
inline int CSPvpStartResp::points_size() const {
  return points_.size();
}
inline void CSPvpStartResp::clear_points() {
  points_.Clear();
}
inline const ::fgame::CSPlayerPoint& CSPvpStartResp::points(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpStartResp.Points)
  return points_.Get(index);
}
inline ::fgame::CSPlayerPoint* CSPvpStartResp::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSPvpStartResp.Points)
  return points_.Mutable(index);
}
inline ::fgame::CSPlayerPoint* CSPvpStartResp::add_points() {
  // @@protoc_insertion_point(field_add:fgame.CSPvpStartResp.Points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPlayerPoint >&
CSPvpStartResp::points() const {
  // @@protoc_insertion_point(field_list:fgame.CSPvpStartResp.Points)
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPlayerPoint >*
CSPvpStartResp::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSPvpStartResp.Points)
  return &points_;
}

// -------------------------------------------------------------------

// CSPvpFightReq

// required int64 Uin = 1;
inline bool CSPvpFightReq::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpFightReq::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpFightReq::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpFightReq::clear_uin() {
  uin_ = GOOGLE_LONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::int64 CSPvpFightReq::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpFightReq.Uin)
  return uin_;
}
inline void CSPvpFightReq::set_uin(::google::protobuf::int64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpFightReq.Uin)
}

// required uint32 Src = 2;
inline bool CSPvpFightReq::has_src() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpFightReq::set_has_src() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpFightReq::clear_has_src() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpFightReq::clear_src() {
  src_ = 0u;
  clear_has_src();
}
inline ::google::protobuf::uint32 CSPvpFightReq::src() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpFightReq.Src)
  return src_;
}
inline void CSPvpFightReq::set_src(::google::protobuf::uint32 value) {
  set_has_src();
  src_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpFightReq.Src)
}

// required uint32 Dest = 3;
inline bool CSPvpFightReq::has_dest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpFightReq::set_has_dest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpFightReq::clear_has_dest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpFightReq::clear_dest() {
  dest_ = 0u;
  clear_has_dest();
}
inline ::google::protobuf::uint32 CSPvpFightReq::dest() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpFightReq.Dest)
  return dest_;
}
inline void CSPvpFightReq::set_dest(::google::protobuf::uint32 value) {
  set_has_dest();
  dest_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpFightReq.Dest)
}

// required uint32 Num = 4;
inline bool CSPvpFightReq::has_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPvpFightReq::set_has_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPvpFightReq::clear_has_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPvpFightReq::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 CSPvpFightReq::num() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpFightReq.Num)
  return num_;
}
inline void CSPvpFightReq::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpFightReq.Num)
}

// required double Ts = 5;
inline bool CSPvpFightReq::has_ts() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPvpFightReq::set_has_ts() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPvpFightReq::clear_has_ts() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPvpFightReq::clear_ts() {
  ts_ = 0;
  clear_has_ts();
}
inline double CSPvpFightReq::ts() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpFightReq.Ts)
  return ts_;
}
inline void CSPvpFightReq::set_ts(double value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpFightReq.Ts)
}

// required uint32 FormationId = 6;
inline bool CSPvpFightReq::has_formationid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPvpFightReq::set_has_formationid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPvpFightReq::clear_has_formationid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPvpFightReq::clear_formationid() {
  formationid_ = 0u;
  clear_has_formationid();
}
inline ::google::protobuf::uint32 CSPvpFightReq::formationid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpFightReq.FormationId)
  return formationid_;
}
inline void CSPvpFightReq::set_formationid(::google::protobuf::uint32 value) {
  set_has_formationid();
  formationid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpFightReq.FormationId)
}

// optional uint32 RoomId = 7;
inline bool CSPvpFightReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSPvpFightReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSPvpFightReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSPvpFightReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPvpFightReq::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpFightReq.RoomId)
  return roomid_;
}
inline void CSPvpFightReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpFightReq.RoomId)
}

// optional uint32 MsgNo = 8;
inline bool CSPvpFightReq::has_msgno() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSPvpFightReq::set_has_msgno() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSPvpFightReq::clear_has_msgno() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSPvpFightReq::clear_msgno() {
  msgno_ = 0u;
  clear_has_msgno();
}
inline ::google::protobuf::uint32 CSPvpFightReq::msgno() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpFightReq.MsgNo)
  return msgno_;
}
inline void CSPvpFightReq::set_msgno(::google::protobuf::uint32 value) {
  set_has_msgno();
  msgno_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpFightReq.MsgNo)
}

// -------------------------------------------------------------------

// CSPvpFightResp

// required int64 Uin = 1;
inline bool CSPvpFightResp::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpFightResp::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpFightResp::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpFightResp::clear_uin() {
  uin_ = GOOGLE_LONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::int64 CSPvpFightResp::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpFightResp.Uin)
  return uin_;
}
inline void CSPvpFightResp::set_uin(::google::protobuf::int64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpFightResp.Uin)
}

// required uint32 Src = 2;
inline bool CSPvpFightResp::has_src() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpFightResp::set_has_src() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpFightResp::clear_has_src() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpFightResp::clear_src() {
  src_ = 0u;
  clear_has_src();
}
inline ::google::protobuf::uint32 CSPvpFightResp::src() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpFightResp.Src)
  return src_;
}
inline void CSPvpFightResp::set_src(::google::protobuf::uint32 value) {
  set_has_src();
  src_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpFightResp.Src)
}

// required uint32 Dest = 3;
inline bool CSPvpFightResp::has_dest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpFightResp::set_has_dest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpFightResp::clear_has_dest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpFightResp::clear_dest() {
  dest_ = 0u;
  clear_has_dest();
}
inline ::google::protobuf::uint32 CSPvpFightResp::dest() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpFightResp.Dest)
  return dest_;
}
inline void CSPvpFightResp::set_dest(::google::protobuf::uint32 value) {
  set_has_dest();
  dest_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpFightResp.Dest)
}

// required uint32 Num = 4;
inline bool CSPvpFightResp::has_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPvpFightResp::set_has_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPvpFightResp::clear_has_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPvpFightResp::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 CSPvpFightResp::num() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpFightResp.Num)
  return num_;
}
inline void CSPvpFightResp::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpFightResp.Num)
}

// required double Ts = 5;
inline bool CSPvpFightResp::has_ts() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPvpFightResp::set_has_ts() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPvpFightResp::clear_has_ts() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPvpFightResp::clear_ts() {
  ts_ = 0;
  clear_has_ts();
}
inline double CSPvpFightResp::ts() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpFightResp.Ts)
  return ts_;
}
inline void CSPvpFightResp::set_ts(double value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpFightResp.Ts)
}

// required uint32 FormationId = 6;
inline bool CSPvpFightResp::has_formationid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPvpFightResp::set_has_formationid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPvpFightResp::clear_has_formationid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPvpFightResp::clear_formationid() {
  formationid_ = 0u;
  clear_has_formationid();
}
inline ::google::protobuf::uint32 CSPvpFightResp::formationid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpFightResp.FormationId)
  return formationid_;
}
inline void CSPvpFightResp::set_formationid(::google::protobuf::uint32 value) {
  set_has_formationid();
  formationid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpFightResp.FormationId)
}

// -------------------------------------------------------------------

// CSPvpUpgradeReq

// required int64 Uin = 1;
inline bool CSPvpUpgradeReq::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpUpgradeReq::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpUpgradeReq::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpUpgradeReq::clear_uin() {
  uin_ = GOOGLE_LONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::int64 CSPvpUpgradeReq::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUpgradeReq.Uin)
  return uin_;
}
inline void CSPvpUpgradeReq::set_uin(::google::protobuf::int64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUpgradeReq.Uin)
}

// required uint32 BuildId = 2;
inline bool CSPvpUpgradeReq::has_buildid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpUpgradeReq::set_has_buildid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpUpgradeReq::clear_has_buildid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpUpgradeReq::clear_buildid() {
  buildid_ = 0u;
  clear_has_buildid();
}
inline ::google::protobuf::uint32 CSPvpUpgradeReq::buildid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUpgradeReq.BuildId)
  return buildid_;
}
inline void CSPvpUpgradeReq::set_buildid(::google::protobuf::uint32 value) {
  set_has_buildid();
  buildid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUpgradeReq.BuildId)
}

// required double Ts = 3;
inline bool CSPvpUpgradeReq::has_ts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpUpgradeReq::set_has_ts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpUpgradeReq::clear_has_ts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpUpgradeReq::clear_ts() {
  ts_ = 0;
  clear_has_ts();
}
inline double CSPvpUpgradeReq::ts() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUpgradeReq.Ts)
  return ts_;
}
inline void CSPvpUpgradeReq::set_ts(double value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUpgradeReq.Ts)
}

// optional uint32 Level = 4;
inline bool CSPvpUpgradeReq::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPvpUpgradeReq::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPvpUpgradeReq::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPvpUpgradeReq::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 CSPvpUpgradeReq::level() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUpgradeReq.Level)
  return level_;
}
inline void CSPvpUpgradeReq::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUpgradeReq.Level)
}

// optional uint32 RoomId = 5;
inline bool CSPvpUpgradeReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPvpUpgradeReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPvpUpgradeReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPvpUpgradeReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPvpUpgradeReq::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUpgradeReq.RoomId)
  return roomid_;
}
inline void CSPvpUpgradeReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUpgradeReq.RoomId)
}

// optional uint32 MsgNo = 6;
inline bool CSPvpUpgradeReq::has_msgno() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPvpUpgradeReq::set_has_msgno() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPvpUpgradeReq::clear_has_msgno() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPvpUpgradeReq::clear_msgno() {
  msgno_ = 0u;
  clear_has_msgno();
}
inline ::google::protobuf::uint32 CSPvpUpgradeReq::msgno() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUpgradeReq.MsgNo)
  return msgno_;
}
inline void CSPvpUpgradeReq::set_msgno(::google::protobuf::uint32 value) {
  set_has_msgno();
  msgno_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUpgradeReq.MsgNo)
}

// -------------------------------------------------------------------

// CSPvpUpgradeResp

// required int64 Uin = 1;
inline bool CSPvpUpgradeResp::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpUpgradeResp::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpUpgradeResp::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpUpgradeResp::clear_uin() {
  uin_ = GOOGLE_LONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::int64 CSPvpUpgradeResp::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUpgradeResp.Uin)
  return uin_;
}
inline void CSPvpUpgradeResp::set_uin(::google::protobuf::int64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUpgradeResp.Uin)
}

// required uint32 BuildId = 2;
inline bool CSPvpUpgradeResp::has_buildid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpUpgradeResp::set_has_buildid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpUpgradeResp::clear_has_buildid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpUpgradeResp::clear_buildid() {
  buildid_ = 0u;
  clear_has_buildid();
}
inline ::google::protobuf::uint32 CSPvpUpgradeResp::buildid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUpgradeResp.BuildId)
  return buildid_;
}
inline void CSPvpUpgradeResp::set_buildid(::google::protobuf::uint32 value) {
  set_has_buildid();
  buildid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUpgradeResp.BuildId)
}

// required double Ts = 3;
inline bool CSPvpUpgradeResp::has_ts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpUpgradeResp::set_has_ts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpUpgradeResp::clear_has_ts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpUpgradeResp::clear_ts() {
  ts_ = 0;
  clear_has_ts();
}
inline double CSPvpUpgradeResp::ts() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUpgradeResp.Ts)
  return ts_;
}
inline void CSPvpUpgradeResp::set_ts(double value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUpgradeResp.Ts)
}

// optional uint32 Level = 4;
inline bool CSPvpUpgradeResp::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPvpUpgradeResp::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPvpUpgradeResp::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPvpUpgradeResp::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 CSPvpUpgradeResp::level() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUpgradeResp.Level)
  return level_;
}
inline void CSPvpUpgradeResp::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUpgradeResp.Level)
}

// -------------------------------------------------------------------

// CSPvpEndReq

// required int64 Win = 1;
inline bool CSPvpEndReq::has_win() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpEndReq::set_has_win() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpEndReq::clear_has_win() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpEndReq::clear_win() {
  win_ = GOOGLE_LONGLONG(0);
  clear_has_win();
}
inline ::google::protobuf::int64 CSPvpEndReq::win() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpEndReq.Win)
  return win_;
}
inline void CSPvpEndReq::set_win(::google::protobuf::int64 value) {
  set_has_win();
  win_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpEndReq.Win)
}

// required double Ts = 2;
inline bool CSPvpEndReq::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpEndReq::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpEndReq::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpEndReq::clear_ts() {
  ts_ = 0;
  clear_has_ts();
}
inline double CSPvpEndReq::ts() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpEndReq.Ts)
  return ts_;
}
inline void CSPvpEndReq::set_ts(double value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpEndReq.Ts)
}

// optional uint32 RoomId = 3;
inline bool CSPvpEndReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpEndReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpEndReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpEndReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPvpEndReq::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpEndReq.RoomId)
  return roomid_;
}
inline void CSPvpEndReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpEndReq.RoomId)
}

// optional uint32 MsgNo = 4;
inline bool CSPvpEndReq::has_msgno() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPvpEndReq::set_has_msgno() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPvpEndReq::clear_has_msgno() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPvpEndReq::clear_msgno() {
  msgno_ = 0u;
  clear_has_msgno();
}
inline ::google::protobuf::uint32 CSPvpEndReq::msgno() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpEndReq.MsgNo)
  return msgno_;
}
inline void CSPvpEndReq::set_msgno(::google::protobuf::uint32 value) {
  set_has_msgno();
  msgno_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpEndReq.MsgNo)
}

// -------------------------------------------------------------------

// CSPlayerPvpResult

// required int64 Uin = 1;
inline bool CSPlayerPvpResult::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerPvpResult::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerPvpResult::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerPvpResult::clear_uin() {
  uin_ = GOOGLE_LONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::int64 CSPlayerPvpResult::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayerPvpResult.Uin)
  return uin_;
}
inline void CSPlayerPvpResult::set_uin(::google::protobuf::int64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPlayerPvpResult.Uin)
}

// required string Name = 2;
inline bool CSPlayerPvpResult::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerPvpResult::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerPvpResult::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerPvpResult::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSPlayerPvpResult::name() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayerPvpResult.Name)
  return *name_;
}
inline void CSPlayerPvpResult::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPlayerPvpResult.Name)
}
inline void CSPlayerPvpResult::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPlayerPvpResult.Name)
}
inline void CSPlayerPvpResult::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPlayerPvpResult.Name)
}
inline ::std::string* CSPlayerPvpResult::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPlayerPvpResult.Name)
  return name_;
}
inline ::std::string* CSPlayerPvpResult::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPlayerPvpResult::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPlayerPvpResult.Name)
}

// required uint32 PrevScore = 3;
inline bool CSPlayerPvpResult::has_prevscore() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerPvpResult::set_has_prevscore() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerPvpResult::clear_has_prevscore() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerPvpResult::clear_prevscore() {
  prevscore_ = 0u;
  clear_has_prevscore();
}
inline ::google::protobuf::uint32 CSPlayerPvpResult::prevscore() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayerPvpResult.PrevScore)
  return prevscore_;
}
inline void CSPlayerPvpResult::set_prevscore(::google::protobuf::uint32 value) {
  set_has_prevscore();
  prevscore_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPlayerPvpResult.PrevScore)
}

// required uint32 AddScore = 4;
inline bool CSPlayerPvpResult::has_addscore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPlayerPvpResult::set_has_addscore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPlayerPvpResult::clear_has_addscore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPlayerPvpResult::clear_addscore() {
  addscore_ = 0u;
  clear_has_addscore();
}
inline ::google::protobuf::uint32 CSPlayerPvpResult::addscore() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayerPvpResult.AddScore)
  return addscore_;
}
inline void CSPlayerPvpResult::set_addscore(::google::protobuf::uint32 value) {
  set_has_addscore();
  addscore_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPlayerPvpResult.AddScore)
}

// required int32 WinRate = 5;
inline bool CSPlayerPvpResult::has_winrate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPlayerPvpResult::set_has_winrate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPlayerPvpResult::clear_has_winrate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPlayerPvpResult::clear_winrate() {
  winrate_ = 0;
  clear_has_winrate();
}
inline ::google::protobuf::int32 CSPlayerPvpResult::winrate() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayerPvpResult.WinRate)
  return winrate_;
}
inline void CSPlayerPvpResult::set_winrate(::google::protobuf::int32 value) {
  set_has_winrate();
  winrate_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPlayerPvpResult.WinRate)
}

// optional uint32 Title = 6;
inline bool CSPlayerPvpResult::has_title() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPlayerPvpResult::set_has_title() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPlayerPvpResult::clear_has_title() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPlayerPvpResult::clear_title() {
  title_ = 0u;
  clear_has_title();
}
inline ::google::protobuf::uint32 CSPlayerPvpResult::title() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayerPvpResult.Title)
  return title_;
}
inline void CSPlayerPvpResult::set_title(::google::protobuf::uint32 value) {
  set_has_title();
  title_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPlayerPvpResult.Title)
}

// optional uint32 NewRank = 7;
inline bool CSPlayerPvpResult::has_newrank() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSPlayerPvpResult::set_has_newrank() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSPlayerPvpResult::clear_has_newrank() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSPlayerPvpResult::clear_newrank() {
  newrank_ = 0u;
  clear_has_newrank();
}
inline ::google::protobuf::uint32 CSPlayerPvpResult::newrank() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayerPvpResult.NewRank)
  return newrank_;
}
inline void CSPlayerPvpResult::set_newrank(::google::protobuf::uint32 value) {
  set_has_newrank();
  newrank_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPlayerPvpResult.NewRank)
}

// optional uint32 WinCount = 8;
inline bool CSPlayerPvpResult::has_wincount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSPlayerPvpResult::set_has_wincount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSPlayerPvpResult::clear_has_wincount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSPlayerPvpResult::clear_wincount() {
  wincount_ = 0u;
  clear_has_wincount();
}
inline ::google::protobuf::uint32 CSPlayerPvpResult::wincount() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayerPvpResult.WinCount)
  return wincount_;
}
inline void CSPlayerPvpResult::set_wincount(::google::protobuf::uint32 value) {
  set_has_wincount();
  wincount_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPlayerPvpResult.WinCount)
}

// optional int32 PrevPoint = 9;
inline bool CSPlayerPvpResult::has_prevpoint() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSPlayerPvpResult::set_has_prevpoint() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSPlayerPvpResult::clear_has_prevpoint() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSPlayerPvpResult::clear_prevpoint() {
  prevpoint_ = 0;
  clear_has_prevpoint();
}
inline ::google::protobuf::int32 CSPlayerPvpResult::prevpoint() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayerPvpResult.PrevPoint)
  return prevpoint_;
}
inline void CSPlayerPvpResult::set_prevpoint(::google::protobuf::int32 value) {
  set_has_prevpoint();
  prevpoint_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPlayerPvpResult.PrevPoint)
}

// optional int32 AddPoint = 10;
inline bool CSPlayerPvpResult::has_addpoint() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSPlayerPvpResult::set_has_addpoint() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSPlayerPvpResult::clear_has_addpoint() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSPlayerPvpResult::clear_addpoint() {
  addpoint_ = 0;
  clear_has_addpoint();
}
inline ::google::protobuf::int32 CSPlayerPvpResult::addpoint() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayerPvpResult.AddPoint)
  return addpoint_;
}
inline void CSPlayerPvpResult::set_addpoint(::google::protobuf::int32 value) {
  set_has_addpoint();
  addpoint_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPlayerPvpResult.AddPoint)
}

// optional uint32 ExtraScore = 11;
inline bool CSPlayerPvpResult::has_extrascore() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CSPlayerPvpResult::set_has_extrascore() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CSPlayerPvpResult::clear_has_extrascore() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CSPlayerPvpResult::clear_extrascore() {
  extrascore_ = 0u;
  clear_has_extrascore();
}
inline ::google::protobuf::uint32 CSPlayerPvpResult::extrascore() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayerPvpResult.ExtraScore)
  return extrascore_;
}
inline void CSPlayerPvpResult::set_extrascore(::google::protobuf::uint32 value) {
  set_has_extrascore();
  extrascore_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPlayerPvpResult.ExtraScore)
}

// optional uint32 VipLevel = 12;
inline bool CSPlayerPvpResult::has_viplevel() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CSPlayerPvpResult::set_has_viplevel() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CSPlayerPvpResult::clear_has_viplevel() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CSPlayerPvpResult::clear_viplevel() {
  viplevel_ = 0u;
  clear_has_viplevel();
}
inline ::google::protobuf::uint32 CSPlayerPvpResult::viplevel() const {
  // @@protoc_insertion_point(field_get:fgame.CSPlayerPvpResult.VipLevel)
  return viplevel_;
}
inline void CSPlayerPvpResult::set_viplevel(::google::protobuf::uint32 value) {
  set_has_viplevel();
  viplevel_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPlayerPvpResult.VipLevel)
}

// -------------------------------------------------------------------

// CSPvpEndResp

// required int64 Win = 1;
inline bool CSPvpEndResp::has_win() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpEndResp::set_has_win() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpEndResp::clear_has_win() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpEndResp::clear_win() {
  win_ = GOOGLE_LONGLONG(0);
  clear_has_win();
}
inline ::google::protobuf::int64 CSPvpEndResp::win() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpEndResp.Win)
  return win_;
}
inline void CSPvpEndResp::set_win(::google::protobuf::int64 value) {
  set_has_win();
  win_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpEndResp.Win)
}

// required double Ts = 2;
inline bool CSPvpEndResp::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpEndResp::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpEndResp::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpEndResp::clear_ts() {
  ts_ = 0;
  clear_has_ts();
}
inline double CSPvpEndResp::ts() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpEndResp.Ts)
  return ts_;
}
inline void CSPvpEndResp::set_ts(double value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpEndResp.Ts)
}

// repeated .fgame.CSPlayerPvpResult Result = 3;
inline int CSPvpEndResp::result_size() const {
  return result_.size();
}
inline void CSPvpEndResp::clear_result() {
  result_.Clear();
}
inline const ::fgame::CSPlayerPvpResult& CSPvpEndResp::result(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpEndResp.Result)
  return result_.Get(index);
}
inline ::fgame::CSPlayerPvpResult* CSPvpEndResp::mutable_result(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSPvpEndResp.Result)
  return result_.Mutable(index);
}
inline ::fgame::CSPlayerPvpResult* CSPvpEndResp::add_result() {
  // @@protoc_insertion_point(field_add:fgame.CSPvpEndResp.Result)
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPlayerPvpResult >&
CSPvpEndResp::result() const {
  // @@protoc_insertion_point(field_list:fgame.CSPvpEndResp.Result)
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPlayerPvpResult >*
CSPvpEndResp::mutable_result() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSPvpEndResp.Result)
  return &result_;
}

// repeated .fgame.PropertyUpdateData UpdateData = 4;
inline int CSPvpEndResp::updatedata_size() const {
  return updatedata_.size();
}
inline void CSPvpEndResp::clear_updatedata() {
  updatedata_.Clear();
}
inline const ::fgame::PropertyUpdateData& CSPvpEndResp::updatedata(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpEndResp.UpdateData)
  return updatedata_.Get(index);
}
inline ::fgame::PropertyUpdateData* CSPvpEndResp::mutable_updatedata(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSPvpEndResp.UpdateData)
  return updatedata_.Mutable(index);
}
inline ::fgame::PropertyUpdateData* CSPvpEndResp::add_updatedata() {
  // @@protoc_insertion_point(field_add:fgame.CSPvpEndResp.UpdateData)
  return updatedata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >&
CSPvpEndResp::updatedata() const {
  // @@protoc_insertion_point(field_list:fgame.CSPvpEndResp.UpdateData)
  return updatedata_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >*
CSPvpEndResp::mutable_updatedata() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSPvpEndResp.UpdateData)
  return &updatedata_;
}

// optional uint32 ShareId = 5;
inline bool CSPvpEndResp::has_shareid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPvpEndResp::set_has_shareid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPvpEndResp::clear_has_shareid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPvpEndResp::clear_shareid() {
  shareid_ = 0u;
  clear_has_shareid();
}
inline ::google::protobuf::uint32 CSPvpEndResp::shareid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpEndResp.ShareId)
  return shareid_;
}
inline void CSPvpEndResp::set_shareid(::google::protobuf::uint32 value) {
  set_has_shareid();
  shareid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpEndResp.ShareId)
}

// -------------------------------------------------------------------

// CSPvpLeaveReq

// optional uint32 RoomId = 1;
inline bool CSPvpLeaveReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpLeaveReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpLeaveReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpLeaveReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPvpLeaveReq::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpLeaveReq.RoomId)
  return roomid_;
}
inline void CSPvpLeaveReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpLeaveReq.RoomId)
}

// optional uint32 MsgNo = 2;
inline bool CSPvpLeaveReq::has_msgno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpLeaveReq::set_has_msgno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpLeaveReq::clear_has_msgno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpLeaveReq::clear_msgno() {
  msgno_ = 0u;
  clear_has_msgno();
}
inline ::google::protobuf::uint32 CSPvpLeaveReq::msgno() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpLeaveReq.MsgNo)
  return msgno_;
}
inline void CSPvpLeaveReq::set_msgno(::google::protobuf::uint32 value) {
  set_has_msgno();
  msgno_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpLeaveReq.MsgNo)
}

// optional uint32 Mode = 3;
inline bool CSPvpLeaveReq::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpLeaveReq::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpLeaveReq::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpLeaveReq::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
inline ::google::protobuf::uint32 CSPvpLeaveReq::mode() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpLeaveReq.Mode)
  return mode_;
}
inline void CSPvpLeaveReq::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpLeaveReq.Mode)
}

// -------------------------------------------------------------------

// CSPvpLeaveResp

// required int64 Uin = 1;
inline bool CSPvpLeaveResp::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpLeaveResp::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpLeaveResp::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpLeaveResp::clear_uin() {
  uin_ = GOOGLE_LONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::int64 CSPvpLeaveResp::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpLeaveResp.Uin)
  return uin_;
}
inline void CSPvpLeaveResp::set_uin(::google::protobuf::int64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpLeaveResp.Uin)
}

// -------------------------------------------------------------------

// CSPvpGetAwardResp

// required int32 AwardType = 1;
inline bool CSPvpGetAwardResp::has_awardtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpGetAwardResp::set_has_awardtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpGetAwardResp::clear_has_awardtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpGetAwardResp::clear_awardtype() {
  awardtype_ = 0;
  clear_has_awardtype();
}
inline ::google::protobuf::int32 CSPvpGetAwardResp::awardtype() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpGetAwardResp.AwardType)
  return awardtype_;
}
inline void CSPvpGetAwardResp::set_awardtype(::google::protobuf::int32 value) {
  set_has_awardtype();
  awardtype_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpGetAwardResp.AwardType)
}

// repeated .fgame.PropertyUpdateData UpdateData = 2;
inline int CSPvpGetAwardResp::updatedata_size() const {
  return updatedata_.size();
}
inline void CSPvpGetAwardResp::clear_updatedata() {
  updatedata_.Clear();
}
inline const ::fgame::PropertyUpdateData& CSPvpGetAwardResp::updatedata(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpGetAwardResp.UpdateData)
  return updatedata_.Get(index);
}
inline ::fgame::PropertyUpdateData* CSPvpGetAwardResp::mutable_updatedata(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSPvpGetAwardResp.UpdateData)
  return updatedata_.Mutable(index);
}
inline ::fgame::PropertyUpdateData* CSPvpGetAwardResp::add_updatedata() {
  // @@protoc_insertion_point(field_add:fgame.CSPvpGetAwardResp.UpdateData)
  return updatedata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >&
CSPvpGetAwardResp::updatedata() const {
  // @@protoc_insertion_point(field_list:fgame.CSPvpGetAwardResp.UpdateData)
  return updatedata_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::PropertyUpdateData >*
CSPvpGetAwardResp::mutable_updatedata() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSPvpGetAwardResp.UpdateData)
  return &updatedata_;
}

// -------------------------------------------------------------------

// CSFormationList

// required uint32 id = 1;
inline bool CSFormationList::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSFormationList::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSFormationList::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSFormationList::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSFormationList::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSFormationList.id)
  return id_;
}
inline void CSFormationList::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSFormationList.id)
}

// -------------------------------------------------------------------

// CSMapData

// required uint32 BuildId = 1;
inline bool CSMapData::has_buildid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMapData::set_has_buildid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMapData::clear_has_buildid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMapData::clear_buildid() {
  buildid_ = 0u;
  clear_has_buildid();
}
inline ::google::protobuf::uint32 CSMapData::buildid() const {
  // @@protoc_insertion_point(field_get:fgame.CSMapData.BuildId)
  return buildid_;
}
inline void CSMapData::set_buildid(::google::protobuf::uint32 value) {
  set_has_buildid();
  buildid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSMapData.BuildId)
}

// required uint32 Type = 2;
inline bool CSMapData::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMapData::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMapData::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMapData::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSMapData::type() const {
  // @@protoc_insertion_point(field_get:fgame.CSMapData.Type)
  return type_;
}
inline void CSMapData::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSMapData.Type)
}

// required uint32 Level = 3;
inline bool CSMapData::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMapData::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMapData::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMapData::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 CSMapData::level() const {
  // @@protoc_insertion_point(field_get:fgame.CSMapData.Level)
  return level_;
}
inline void CSMapData::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSMapData.Level)
}

// required uint32 Camp = 4;
inline bool CSMapData::has_camp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSMapData::set_has_camp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSMapData::clear_has_camp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSMapData::clear_camp() {
  camp_ = 0u;
  clear_has_camp();
}
inline ::google::protobuf::uint32 CSMapData::camp() const {
  // @@protoc_insertion_point(field_get:fgame.CSMapData.Camp)
  return camp_;
}
inline void CSMapData::set_camp(::google::protobuf::uint32 value) {
  set_has_camp();
  camp_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSMapData.Camp)
}

// required uint32 Num = 5;
inline bool CSMapData::has_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSMapData::set_has_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSMapData::clear_has_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSMapData::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 CSMapData::num() const {
  // @@protoc_insertion_point(field_get:fgame.CSMapData.Num)
  return num_;
}
inline void CSMapData::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSMapData.Num)
}

// repeated .fgame.CSFormationList List = 6;
inline int CSMapData::list_size() const {
  return list_.size();
}
inline void CSMapData::clear_list() {
  list_.Clear();
}
inline const ::fgame::CSFormationList& CSMapData::list(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSMapData.List)
  return list_.Get(index);
}
inline ::fgame::CSFormationList* CSMapData::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSMapData.List)
  return list_.Mutable(index);
}
inline ::fgame::CSFormationList* CSMapData::add_list() {
  // @@protoc_insertion_point(field_add:fgame.CSMapData.List)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSFormationList >&
CSMapData::list() const {
  // @@protoc_insertion_point(field_list:fgame.CSMapData.List)
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSFormationList >*
CSMapData::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSMapData.List)
  return &list_;
}

// -------------------------------------------------------------------

// CSPvpMapReq

// repeated .fgame.CSMapData Data = 1;
inline int CSPvpMapReq::data_size() const {
  return data_.size();
}
inline void CSPvpMapReq::clear_data() {
  data_.Clear();
}
inline const ::fgame::CSMapData& CSPvpMapReq::data(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpMapReq.Data)
  return data_.Get(index);
}
inline ::fgame::CSMapData* CSPvpMapReq::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSPvpMapReq.Data)
  return data_.Mutable(index);
}
inline ::fgame::CSMapData* CSPvpMapReq::add_data() {
  // @@protoc_insertion_point(field_add:fgame.CSPvpMapReq.Data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSMapData >&
CSPvpMapReq::data() const {
  // @@protoc_insertion_point(field_list:fgame.CSPvpMapReq.Data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSMapData >*
CSPvpMapReq::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSPvpMapReq.Data)
  return &data_;
}

// required double Ts = 2;
inline bool CSPvpMapReq::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpMapReq::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpMapReq::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpMapReq::clear_ts() {
  ts_ = 0;
  clear_has_ts();
}
inline double CSPvpMapReq::ts() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpMapReq.Ts)
  return ts_;
}
inline void CSPvpMapReq::set_ts(double value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpMapReq.Ts)
}

// optional uint32 RoomId = 3;
inline bool CSPvpMapReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpMapReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpMapReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpMapReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPvpMapReq::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpMapReq.RoomId)
  return roomid_;
}
inline void CSPvpMapReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpMapReq.RoomId)
}

// optional uint32 MsgNo = 4;
inline bool CSPvpMapReq::has_msgno() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPvpMapReq::set_has_msgno() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPvpMapReq::clear_has_msgno() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPvpMapReq::clear_msgno() {
  msgno_ = 0u;
  clear_has_msgno();
}
inline ::google::protobuf::uint32 CSPvpMapReq::msgno() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpMapReq.MsgNo)
  return msgno_;
}
inline void CSPvpMapReq::set_msgno(::google::protobuf::uint32 value) {
  set_has_msgno();
  msgno_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpMapReq.MsgNo)
}

// -------------------------------------------------------------------

// CSPvpMapResp

// repeated .fgame.CSMapData Data = 1;
inline int CSPvpMapResp::data_size() const {
  return data_.size();
}
inline void CSPvpMapResp::clear_data() {
  data_.Clear();
}
inline const ::fgame::CSMapData& CSPvpMapResp::data(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpMapResp.Data)
  return data_.Get(index);
}
inline ::fgame::CSMapData* CSPvpMapResp::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSPvpMapResp.Data)
  return data_.Mutable(index);
}
inline ::fgame::CSMapData* CSPvpMapResp::add_data() {
  // @@protoc_insertion_point(field_add:fgame.CSPvpMapResp.Data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSMapData >&
CSPvpMapResp::data() const {
  // @@protoc_insertion_point(field_list:fgame.CSPvpMapResp.Data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSMapData >*
CSPvpMapResp::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSPvpMapResp.Data)
  return &data_;
}

// required double Ts = 2;
inline bool CSPvpMapResp::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpMapResp::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpMapResp::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpMapResp::clear_ts() {
  ts_ = 0;
  clear_has_ts();
}
inline double CSPvpMapResp::ts() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpMapResp.Ts)
  return ts_;
}
inline void CSPvpMapResp::set_ts(double value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpMapResp.Ts)
}

// -------------------------------------------------------------------

// CSPvpPingReq

// required double Ts = 1;
inline bool CSPvpPingReq::has_ts() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpPingReq::set_has_ts() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpPingReq::clear_has_ts() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpPingReq::clear_ts() {
  ts_ = 0;
  clear_has_ts();
}
inline double CSPvpPingReq::ts() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpPingReq.Ts)
  return ts_;
}
inline void CSPvpPingReq::set_ts(double value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpPingReq.Ts)
}

// optional uint32 RoomId = 2;
inline bool CSPvpPingReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpPingReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpPingReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpPingReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPvpPingReq::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpPingReq.RoomId)
  return roomid_;
}
inline void CSPvpPingReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpPingReq.RoomId)
}

// optional uint32 MsgNo = 3;
inline bool CSPvpPingReq::has_msgno() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpPingReq::set_has_msgno() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpPingReq::clear_has_msgno() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpPingReq::clear_msgno() {
  msgno_ = 0u;
  clear_has_msgno();
}
inline ::google::protobuf::uint32 CSPvpPingReq::msgno() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpPingReq.MsgNo)
  return msgno_;
}
inline void CSPvpPingReq::set_msgno(::google::protobuf::uint32 value) {
  set_has_msgno();
  msgno_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpPingReq.MsgNo)
}

// -------------------------------------------------------------------

// CSPvpPingResp

// required int64 Host = 1;
inline bool CSPvpPingResp::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpPingResp::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpPingResp::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpPingResp::clear_host() {
  host_ = GOOGLE_LONGLONG(0);
  clear_has_host();
}
inline ::google::protobuf::int64 CSPvpPingResp::host() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpPingResp.Host)
  return host_;
}
inline void CSPvpPingResp::set_host(::google::protobuf::int64 value) {
  set_has_host();
  host_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpPingResp.Host)
}

// required double Ts = 2;
inline bool CSPvpPingResp::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpPingResp::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpPingResp::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpPingResp::clear_ts() {
  ts_ = 0;
  clear_has_ts();
}
inline double CSPvpPingResp::ts() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpPingResp.Ts)
  return ts_;
}
inline void CSPvpPingResp::set_ts(double value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpPingResp.Ts)
}

// -------------------------------------------------------------------

// CSPvpUseItemReq

// required int32 ItemId = 1;
inline bool CSPvpUseItemReq::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpUseItemReq::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpUseItemReq::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpUseItemReq::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 CSPvpUseItemReq::itemid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseItemReq.ItemId)
  return itemid_;
}
inline void CSPvpUseItemReq::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseItemReq.ItemId)
}

// required double Ts = 2;
inline bool CSPvpUseItemReq::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpUseItemReq::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpUseItemReq::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpUseItemReq::clear_ts() {
  ts_ = 0;
  clear_has_ts();
}
inline double CSPvpUseItemReq::ts() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseItemReq.Ts)
  return ts_;
}
inline void CSPvpUseItemReq::set_ts(double value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseItemReq.Ts)
}

// optional uint32 X = 3;
inline bool CSPvpUseItemReq::has_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpUseItemReq::set_has_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpUseItemReq::clear_has_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpUseItemReq::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 CSPvpUseItemReq::x() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseItemReq.X)
  return x_;
}
inline void CSPvpUseItemReq::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseItemReq.X)
}

// optional uint32 Y = 4;
inline bool CSPvpUseItemReq::has_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPvpUseItemReq::set_has_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPvpUseItemReq::clear_has_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPvpUseItemReq::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 CSPvpUseItemReq::y() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseItemReq.Y)
  return y_;
}
inline void CSPvpUseItemReq::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseItemReq.Y)
}

// optional uint32 BuildId = 5;
inline bool CSPvpUseItemReq::has_buildid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPvpUseItemReq::set_has_buildid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPvpUseItemReq::clear_has_buildid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPvpUseItemReq::clear_buildid() {
  buildid_ = 0u;
  clear_has_buildid();
}
inline ::google::protobuf::uint32 CSPvpUseItemReq::buildid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseItemReq.BuildId)
  return buildid_;
}
inline void CSPvpUseItemReq::set_buildid(::google::protobuf::uint32 value) {
  set_has_buildid();
  buildid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseItemReq.BuildId)
}

// optional uint32 RoomId = 6;
inline bool CSPvpUseItemReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPvpUseItemReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPvpUseItemReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPvpUseItemReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPvpUseItemReq::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseItemReq.RoomId)
  return roomid_;
}
inline void CSPvpUseItemReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseItemReq.RoomId)
}

// optional uint32 MsgNo = 7;
inline bool CSPvpUseItemReq::has_msgno() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSPvpUseItemReq::set_has_msgno() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSPvpUseItemReq::clear_has_msgno() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSPvpUseItemReq::clear_msgno() {
  msgno_ = 0u;
  clear_has_msgno();
}
inline ::google::protobuf::uint32 CSPvpUseItemReq::msgno() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseItemReq.MsgNo)
  return msgno_;
}
inline void CSPvpUseItemReq::set_msgno(::google::protobuf::uint32 value) {
  set_has_msgno();
  msgno_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseItemReq.MsgNo)
}

// -------------------------------------------------------------------

// CSPvpUseItemResp

// required int64 Uin = 1;
inline bool CSPvpUseItemResp::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpUseItemResp::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpUseItemResp::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpUseItemResp::clear_uin() {
  uin_ = GOOGLE_LONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::int64 CSPvpUseItemResp::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseItemResp.Uin)
  return uin_;
}
inline void CSPvpUseItemResp::set_uin(::google::protobuf::int64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseItemResp.Uin)
}

// required int32 ItemId = 2;
inline bool CSPvpUseItemResp::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpUseItemResp::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpUseItemResp::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpUseItemResp::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 CSPvpUseItemResp::itemid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseItemResp.ItemId)
  return itemid_;
}
inline void CSPvpUseItemResp::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseItemResp.ItemId)
}

// required double Ts = 3;
inline bool CSPvpUseItemResp::has_ts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpUseItemResp::set_has_ts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpUseItemResp::clear_has_ts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpUseItemResp::clear_ts() {
  ts_ = 0;
  clear_has_ts();
}
inline double CSPvpUseItemResp::ts() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseItemResp.Ts)
  return ts_;
}
inline void CSPvpUseItemResp::set_ts(double value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseItemResp.Ts)
}

// optional uint32 X = 4;
inline bool CSPvpUseItemResp::has_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPvpUseItemResp::set_has_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPvpUseItemResp::clear_has_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPvpUseItemResp::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 CSPvpUseItemResp::x() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseItemResp.X)
  return x_;
}
inline void CSPvpUseItemResp::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseItemResp.X)
}

// optional uint32 Y = 5;
inline bool CSPvpUseItemResp::has_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPvpUseItemResp::set_has_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPvpUseItemResp::clear_has_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPvpUseItemResp::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 CSPvpUseItemResp::y() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseItemResp.Y)
  return y_;
}
inline void CSPvpUseItemResp::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseItemResp.Y)
}

// optional uint32 BuildId = 6;
inline bool CSPvpUseItemResp::has_buildid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPvpUseItemResp::set_has_buildid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPvpUseItemResp::clear_has_buildid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPvpUseItemResp::clear_buildid() {
  buildid_ = 0u;
  clear_has_buildid();
}
inline ::google::protobuf::uint32 CSPvpUseItemResp::buildid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseItemResp.BuildId)
  return buildid_;
}
inline void CSPvpUseItemResp::set_buildid(::google::protobuf::uint32 value) {
  set_has_buildid();
  buildid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseItemResp.BuildId)
}

// -------------------------------------------------------------------

// CSPvpUseSkillReq

// required uint32 CampID = 1;
inline bool CSPvpUseSkillReq::has_campid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpUseSkillReq::set_has_campid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpUseSkillReq::clear_has_campid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpUseSkillReq::clear_campid() {
  campid_ = 0u;
  clear_has_campid();
}
inline ::google::protobuf::uint32 CSPvpUseSkillReq::campid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseSkillReq.CampID)
  return campid_;
}
inline void CSPvpUseSkillReq::set_campid(::google::protobuf::uint32 value) {
  set_has_campid();
  campid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseSkillReq.CampID)
}

// required uint32 SkillID = 2;
inline bool CSPvpUseSkillReq::has_skillid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpUseSkillReq::set_has_skillid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpUseSkillReq::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpUseSkillReq::clear_skillid() {
  skillid_ = 0u;
  clear_has_skillid();
}
inline ::google::protobuf::uint32 CSPvpUseSkillReq::skillid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseSkillReq.SkillID)
  return skillid_;
}
inline void CSPvpUseSkillReq::set_skillid(::google::protobuf::uint32 value) {
  set_has_skillid();
  skillid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseSkillReq.SkillID)
}

// required uint32 RollNum = 3;
inline bool CSPvpUseSkillReq::has_rollnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpUseSkillReq::set_has_rollnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpUseSkillReq::clear_has_rollnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpUseSkillReq::clear_rollnum() {
  rollnum_ = 0u;
  clear_has_rollnum();
}
inline ::google::protobuf::uint32 CSPvpUseSkillReq::rollnum() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseSkillReq.RollNum)
  return rollnum_;
}
inline void CSPvpUseSkillReq::set_rollnum(::google::protobuf::uint32 value) {
  set_has_rollnum();
  rollnum_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseSkillReq.RollNum)
}

// -------------------------------------------------------------------

// PvpAssistantInfo

// required uint32 AssistantId = 1;
inline bool PvpAssistantInfo::has_assistantid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpAssistantInfo::set_has_assistantid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpAssistantInfo::clear_has_assistantid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpAssistantInfo::clear_assistantid() {
  assistantid_ = 0u;
  clear_has_assistantid();
}
inline ::google::protobuf::uint32 PvpAssistantInfo::assistantid() const {
  // @@protoc_insertion_point(field_get:fgame.PvpAssistantInfo.AssistantId)
  return assistantid_;
}
inline void PvpAssistantInfo::set_assistantid(::google::protobuf::uint32 value) {
  set_has_assistantid();
  assistantid_ = value;
  // @@protoc_insertion_point(field_set:fgame.PvpAssistantInfo.AssistantId)
}

// required uint32 Level = 2;
inline bool PvpAssistantInfo::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpAssistantInfo::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpAssistantInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpAssistantInfo::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 PvpAssistantInfo::level() const {
  // @@protoc_insertion_point(field_get:fgame.PvpAssistantInfo.Level)
  return level_;
}
inline void PvpAssistantInfo::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:fgame.PvpAssistantInfo.Level)
}

// required uint32 Quality = 3;
inline bool PvpAssistantInfo::has_quality() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PvpAssistantInfo::set_has_quality() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PvpAssistantInfo::clear_has_quality() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PvpAssistantInfo::clear_quality() {
  quality_ = 0u;
  clear_has_quality();
}
inline ::google::protobuf::uint32 PvpAssistantInfo::quality() const {
  // @@protoc_insertion_point(field_get:fgame.PvpAssistantInfo.Quality)
  return quality_;
}
inline void PvpAssistantInfo::set_quality(::google::protobuf::uint32 value) {
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:fgame.PvpAssistantInfo.Quality)
}

// repeated uint32 ActiveSkills = 4;
inline int PvpAssistantInfo::activeskills_size() const {
  return activeskills_.size();
}
inline void PvpAssistantInfo::clear_activeskills() {
  activeskills_.Clear();
}
inline ::google::protobuf::uint32 PvpAssistantInfo::activeskills(int index) const {
  // @@protoc_insertion_point(field_get:fgame.PvpAssistantInfo.ActiveSkills)
  return activeskills_.Get(index);
}
inline void PvpAssistantInfo::set_activeskills(int index, ::google::protobuf::uint32 value) {
  activeskills_.Set(index, value);
  // @@protoc_insertion_point(field_set:fgame.PvpAssistantInfo.ActiveSkills)
}
inline void PvpAssistantInfo::add_activeskills(::google::protobuf::uint32 value) {
  activeskills_.Add(value);
  // @@protoc_insertion_point(field_add:fgame.PvpAssistantInfo.ActiveSkills)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
PvpAssistantInfo::activeskills() const {
  // @@protoc_insertion_point(field_list:fgame.PvpAssistantInfo.ActiveSkills)
  return activeskills_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
PvpAssistantInfo::mutable_activeskills() {
  // @@protoc_insertion_point(field_mutable_list:fgame.PvpAssistantInfo.ActiveSkills)
  return &activeskills_;
}

// repeated uint32 PassiveSkills = 5;
inline int PvpAssistantInfo::passiveskills_size() const {
  return passiveskills_.size();
}
inline void PvpAssistantInfo::clear_passiveskills() {
  passiveskills_.Clear();
}
inline ::google::protobuf::uint32 PvpAssistantInfo::passiveskills(int index) const {
  // @@protoc_insertion_point(field_get:fgame.PvpAssistantInfo.PassiveSkills)
  return passiveskills_.Get(index);
}
inline void PvpAssistantInfo::set_passiveskills(int index, ::google::protobuf::uint32 value) {
  passiveskills_.Set(index, value);
  // @@protoc_insertion_point(field_set:fgame.PvpAssistantInfo.PassiveSkills)
}
inline void PvpAssistantInfo::add_passiveskills(::google::protobuf::uint32 value) {
  passiveskills_.Add(value);
  // @@protoc_insertion_point(field_add:fgame.PvpAssistantInfo.PassiveSkills)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
PvpAssistantInfo::passiveskills() const {
  // @@protoc_insertion_point(field_list:fgame.PvpAssistantInfo.PassiveSkills)
  return passiveskills_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
PvpAssistantInfo::mutable_passiveskills() {
  // @@protoc_insertion_point(field_mutable_list:fgame.PvpAssistantInfo.PassiveSkills)
  return &passiveskills_;
}

// required uint32 CampID = 6;
inline bool PvpAssistantInfo::has_campid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PvpAssistantInfo::set_has_campid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PvpAssistantInfo::clear_has_campid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PvpAssistantInfo::clear_campid() {
  campid_ = 0u;
  clear_has_campid();
}
inline ::google::protobuf::uint32 PvpAssistantInfo::campid() const {
  // @@protoc_insertion_point(field_get:fgame.PvpAssistantInfo.CampID)
  return campid_;
}
inline void PvpAssistantInfo::set_campid(::google::protobuf::uint32 value) {
  set_has_campid();
  campid_ = value;
  // @@protoc_insertion_point(field_set:fgame.PvpAssistantInfo.CampID)
}

// -------------------------------------------------------------------

// CSPvpAssistantInfoResp

// repeated .fgame.PvpAssistantInfo Info = 1;
inline int CSPvpAssistantInfoResp::info_size() const {
  return info_.size();
}
inline void CSPvpAssistantInfoResp::clear_info() {
  info_.Clear();
}
inline const ::fgame::PvpAssistantInfo& CSPvpAssistantInfoResp::info(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpAssistantInfoResp.Info)
  return info_.Get(index);
}
inline ::fgame::PvpAssistantInfo* CSPvpAssistantInfoResp::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSPvpAssistantInfoResp.Info)
  return info_.Mutable(index);
}
inline ::fgame::PvpAssistantInfo* CSPvpAssistantInfoResp::add_info() {
  // @@protoc_insertion_point(field_add:fgame.CSPvpAssistantInfoResp.Info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::PvpAssistantInfo >&
CSPvpAssistantInfoResp::info() const {
  // @@protoc_insertion_point(field_list:fgame.CSPvpAssistantInfoResp.Info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::PvpAssistantInfo >*
CSPvpAssistantInfoResp::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSPvpAssistantInfoResp.Info)
  return &info_;
}

// -------------------------------------------------------------------

// CSPvpUseSkillResp

// required bool Ok = 1;
inline bool CSPvpUseSkillResp::has_ok() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpUseSkillResp::set_has_ok() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpUseSkillResp::clear_has_ok() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpUseSkillResp::clear_ok() {
  ok_ = false;
  clear_has_ok();
}
inline bool CSPvpUseSkillResp::ok() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseSkillResp.Ok)
  return ok_;
}
inline void CSPvpUseSkillResp::set_ok(bool value) {
  set_has_ok();
  ok_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseSkillResp.Ok)
}

// required uint32 CampID = 2;
inline bool CSPvpUseSkillResp::has_campid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpUseSkillResp::set_has_campid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpUseSkillResp::clear_has_campid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpUseSkillResp::clear_campid() {
  campid_ = 0u;
  clear_has_campid();
}
inline ::google::protobuf::uint32 CSPvpUseSkillResp::campid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseSkillResp.CampID)
  return campid_;
}
inline void CSPvpUseSkillResp::set_campid(::google::protobuf::uint32 value) {
  set_has_campid();
  campid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseSkillResp.CampID)
}

// required uint32 SkillID = 3;
inline bool CSPvpUseSkillResp::has_skillid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpUseSkillResp::set_has_skillid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpUseSkillResp::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpUseSkillResp::clear_skillid() {
  skillid_ = 0u;
  clear_has_skillid();
}
inline ::google::protobuf::uint32 CSPvpUseSkillResp::skillid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseSkillResp.SkillID)
  return skillid_;
}
inline void CSPvpUseSkillResp::set_skillid(::google::protobuf::uint32 value) {
  set_has_skillid();
  skillid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseSkillResp.SkillID)
}

// repeated uint32 RandomNumbers = 4;
inline int CSPvpUseSkillResp::randomnumbers_size() const {
  return randomnumbers_.size();
}
inline void CSPvpUseSkillResp::clear_randomnumbers() {
  randomnumbers_.Clear();
}
inline ::google::protobuf::uint32 CSPvpUseSkillResp::randomnumbers(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpUseSkillResp.RandomNumbers)
  return randomnumbers_.Get(index);
}
inline void CSPvpUseSkillResp::set_randomnumbers(int index, ::google::protobuf::uint32 value) {
  randomnumbers_.Set(index, value);
  // @@protoc_insertion_point(field_set:fgame.CSPvpUseSkillResp.RandomNumbers)
}
inline void CSPvpUseSkillResp::add_randomnumbers(::google::protobuf::uint32 value) {
  randomnumbers_.Add(value);
  // @@protoc_insertion_point(field_add:fgame.CSPvpUseSkillResp.RandomNumbers)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSPvpUseSkillResp::randomnumbers() const {
  // @@protoc_insertion_point(field_list:fgame.CSPvpUseSkillResp.RandomNumbers)
  return randomnumbers_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSPvpUseSkillResp::mutable_randomnumbers() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSPvpUseSkillResp.RandomNumbers)
  return &randomnumbers_;
}

// -------------------------------------------------------------------

// CSPvpRankingGetListReq

// required uint32 GroundID = 1;
inline bool CSPvpRankingGetListReq::has_groundid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpRankingGetListReq::set_has_groundid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpRankingGetListReq::clear_has_groundid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpRankingGetListReq::clear_groundid() {
  groundid_ = 0u;
  clear_has_groundid();
}
inline ::google::protobuf::uint32 CSPvpRankingGetListReq::groundid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRankingGetListReq.GroundID)
  return groundid_;
}
inline void CSPvpRankingGetListReq::set_groundid(::google::protobuf::uint32 value) {
  set_has_groundid();
  groundid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpRankingGetListReq.GroundID)
}

// optional uint32 TopNSize = 2;
inline bool CSPvpRankingGetListReq::has_topnsize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpRankingGetListReq::set_has_topnsize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpRankingGetListReq::clear_has_topnsize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpRankingGetListReq::clear_topnsize() {
  topnsize_ = 0u;
  clear_has_topnsize();
}
inline ::google::protobuf::uint32 CSPvpRankingGetListReq::topnsize() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRankingGetListReq.TopNSize)
  return topnsize_;
}
inline void CSPvpRankingGetListReq::set_topnsize(::google::protobuf::uint32 value) {
  set_has_topnsize();
  topnsize_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpRankingGetListReq.TopNSize)
}

// -------------------------------------------------------------------

// CSPvpRankingPlayerInfo

// required uint32 Order = 1;
inline bool CSPvpRankingPlayerInfo::has_order() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpRankingPlayerInfo::set_has_order() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpRankingPlayerInfo::clear_has_order() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpRankingPlayerInfo::clear_order() {
  order_ = 0u;
  clear_has_order();
}
inline ::google::protobuf::uint32 CSPvpRankingPlayerInfo::order() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRankingPlayerInfo.Order)
  return order_;
}
inline void CSPvpRankingPlayerInfo::set_order(::google::protobuf::uint32 value) {
  set_has_order();
  order_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpRankingPlayerInfo.Order)
}

// required uint64 Id = 2;
inline bool CSPvpRankingPlayerInfo::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpRankingPlayerInfo::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpRankingPlayerInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpRankingPlayerInfo::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 CSPvpRankingPlayerInfo::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRankingPlayerInfo.Id)
  return id_;
}
inline void CSPvpRankingPlayerInfo::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpRankingPlayerInfo.Id)
}

// optional string Name = 3;
inline bool CSPvpRankingPlayerInfo::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpRankingPlayerInfo::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpRankingPlayerInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpRankingPlayerInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSPvpRankingPlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRankingPlayerInfo.Name)
  return *name_;
}
inline void CSPvpRankingPlayerInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPvpRankingPlayerInfo.Name)
}
inline void CSPvpRankingPlayerInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPvpRankingPlayerInfo.Name)
}
inline void CSPvpRankingPlayerInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPvpRankingPlayerInfo.Name)
}
inline ::std::string* CSPvpRankingPlayerInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPvpRankingPlayerInfo.Name)
  return name_;
}
inline ::std::string* CSPvpRankingPlayerInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPvpRankingPlayerInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPvpRankingPlayerInfo.Name)
}

// optional uint32 Point = 4;
inline bool CSPvpRankingPlayerInfo::has_point() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPvpRankingPlayerInfo::set_has_point() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPvpRankingPlayerInfo::clear_has_point() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPvpRankingPlayerInfo::clear_point() {
  point_ = 0u;
  clear_has_point();
}
inline ::google::protobuf::uint32 CSPvpRankingPlayerInfo::point() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRankingPlayerInfo.Point)
  return point_;
}
inline void CSPvpRankingPlayerInfo::set_point(::google::protobuf::uint32 value) {
  set_has_point();
  point_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpRankingPlayerInfo.Point)
}

// optional float WinRate = 5;
inline bool CSPvpRankingPlayerInfo::has_winrate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPvpRankingPlayerInfo::set_has_winrate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPvpRankingPlayerInfo::clear_has_winrate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPvpRankingPlayerInfo::clear_winrate() {
  winrate_ = 0;
  clear_has_winrate();
}
inline float CSPvpRankingPlayerInfo::winrate() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRankingPlayerInfo.WinRate)
  return winrate_;
}
inline void CSPvpRankingPlayerInfo::set_winrate(float value) {
  set_has_winrate();
  winrate_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpRankingPlayerInfo.WinRate)
}

// optional uint32 Group = 6;
inline bool CSPvpRankingPlayerInfo::has_group() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPvpRankingPlayerInfo::set_has_group() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPvpRankingPlayerInfo::clear_has_group() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPvpRankingPlayerInfo::clear_group() {
  group_ = 0u;
  clear_has_group();
}
inline ::google::protobuf::uint32 CSPvpRankingPlayerInfo::group() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRankingPlayerInfo.Group)
  return group_;
}
inline void CSPvpRankingPlayerInfo::set_group(::google::protobuf::uint32 value) {
  set_has_group();
  group_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpRankingPlayerInfo.Group)
}

// optional uint32 Score = 7;
inline bool CSPvpRankingPlayerInfo::has_score() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSPvpRankingPlayerInfo::set_has_score() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSPvpRankingPlayerInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSPvpRankingPlayerInfo::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 CSPvpRankingPlayerInfo::score() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRankingPlayerInfo.Score)
  return score_;
}
inline void CSPvpRankingPlayerInfo::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpRankingPlayerInfo.Score)
}

// optional uint32 VipLevel = 8;
inline bool CSPvpRankingPlayerInfo::has_viplevel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSPvpRankingPlayerInfo::set_has_viplevel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSPvpRankingPlayerInfo::clear_has_viplevel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSPvpRankingPlayerInfo::clear_viplevel() {
  viplevel_ = 0u;
  clear_has_viplevel();
}
inline ::google::protobuf::uint32 CSPvpRankingPlayerInfo::viplevel() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRankingPlayerInfo.VipLevel)
  return viplevel_;
}
inline void CSPvpRankingPlayerInfo::set_viplevel(::google::protobuf::uint32 value) {
  set_has_viplevel();
  viplevel_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpRankingPlayerInfo.VipLevel)
}

// optional uint32 Area = 9;
inline bool CSPvpRankingPlayerInfo::has_area() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSPvpRankingPlayerInfo::set_has_area() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSPvpRankingPlayerInfo::clear_has_area() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSPvpRankingPlayerInfo::clear_area() {
  area_ = 0u;
  clear_has_area();
}
inline ::google::protobuf::uint32 CSPvpRankingPlayerInfo::area() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRankingPlayerInfo.Area)
  return area_;
}
inline void CSPvpRankingPlayerInfo::set_area(::google::protobuf::uint32 value) {
  set_has_area();
  area_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpRankingPlayerInfo.Area)
}

// -------------------------------------------------------------------

// CSPvpRankingGetListResp

// required uint32 GroundID = 1;
inline bool CSPvpRankingGetListResp::has_groundid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpRankingGetListResp::set_has_groundid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpRankingGetListResp::clear_has_groundid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpRankingGetListResp::clear_groundid() {
  groundid_ = 0u;
  clear_has_groundid();
}
inline ::google::protobuf::uint32 CSPvpRankingGetListResp::groundid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRankingGetListResp.GroundID)
  return groundid_;
}
inline void CSPvpRankingGetListResp::set_groundid(::google::protobuf::uint32 value) {
  set_has_groundid();
  groundid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpRankingGetListResp.GroundID)
}

// repeated .fgame.CSPvpRankingPlayerInfo PlayerList = 2;
inline int CSPvpRankingGetListResp::playerlist_size() const {
  return playerlist_.size();
}
inline void CSPvpRankingGetListResp::clear_playerlist() {
  playerlist_.Clear();
}
inline const ::fgame::CSPvpRankingPlayerInfo& CSPvpRankingGetListResp::playerlist(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRankingGetListResp.PlayerList)
  return playerlist_.Get(index);
}
inline ::fgame::CSPvpRankingPlayerInfo* CSPvpRankingGetListResp::mutable_playerlist(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSPvpRankingGetListResp.PlayerList)
  return playerlist_.Mutable(index);
}
inline ::fgame::CSPvpRankingPlayerInfo* CSPvpRankingGetListResp::add_playerlist() {
  // @@protoc_insertion_point(field_add:fgame.CSPvpRankingGetListResp.PlayerList)
  return playerlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPvpRankingPlayerInfo >&
CSPvpRankingGetListResp::playerlist() const {
  // @@protoc_insertion_point(field_list:fgame.CSPvpRankingGetListResp.PlayerList)
  return playerlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPvpRankingPlayerInfo >*
CSPvpRankingGetListResp::mutable_playerlist() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSPvpRankingGetListResp.PlayerList)
  return &playerlist_;
}

// -------------------------------------------------------------------

// CSPvpRankingPlayerInfoReq

// required uint64 Uin = 1;
inline bool CSPvpRankingPlayerInfoReq::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpRankingPlayerInfoReq::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpRankingPlayerInfoReq::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpRankingPlayerInfoReq::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPvpRankingPlayerInfoReq::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRankingPlayerInfoReq.Uin)
  return uin_;
}
inline void CSPvpRankingPlayerInfoReq::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpRankingPlayerInfoReq.Uin)
}

// -------------------------------------------------------------------

// CSPvpRankingPlayerInfoResp

// required .fgame.CSPvpRankingPlayerInfo RankInfo = 1;
inline bool CSPvpRankingPlayerInfoResp::has_rankinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpRankingPlayerInfoResp::set_has_rankinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpRankingPlayerInfoResp::clear_has_rankinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpRankingPlayerInfoResp::clear_rankinfo() {
  if (rankinfo_ != NULL) rankinfo_->::fgame::CSPvpRankingPlayerInfo::Clear();
  clear_has_rankinfo();
}
inline const ::fgame::CSPvpRankingPlayerInfo& CSPvpRankingPlayerInfoResp::rankinfo() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRankingPlayerInfoResp.RankInfo)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rankinfo_ != NULL ? *rankinfo_ : *default_instance().rankinfo_;
#else
  return rankinfo_ != NULL ? *rankinfo_ : *default_instance_->rankinfo_;
#endif
}
inline ::fgame::CSPvpRankingPlayerInfo* CSPvpRankingPlayerInfoResp::mutable_rankinfo() {
  set_has_rankinfo();
  if (rankinfo_ == NULL) rankinfo_ = new ::fgame::CSPvpRankingPlayerInfo;
  // @@protoc_insertion_point(field_mutable:fgame.CSPvpRankingPlayerInfoResp.RankInfo)
  return rankinfo_;
}
inline ::fgame::CSPvpRankingPlayerInfo* CSPvpRankingPlayerInfoResp::release_rankinfo() {
  clear_has_rankinfo();
  ::fgame::CSPvpRankingPlayerInfo* temp = rankinfo_;
  rankinfo_ = NULL;
  return temp;
}
inline void CSPvpRankingPlayerInfoResp::set_allocated_rankinfo(::fgame::CSPvpRankingPlayerInfo* rankinfo) {
  delete rankinfo_;
  rankinfo_ = rankinfo;
  if (rankinfo) {
    set_has_rankinfo();
  } else {
    clear_has_rankinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPvpRankingPlayerInfoResp.RankInfo)
}

// optional uint32 TotalRound = 2;
inline bool CSPvpRankingPlayerInfoResp::has_totalround() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpRankingPlayerInfoResp::set_has_totalround() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpRankingPlayerInfoResp::clear_has_totalround() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpRankingPlayerInfoResp::clear_totalround() {
  totalround_ = 0u;
  clear_has_totalround();
}
inline ::google::protobuf::uint32 CSPvpRankingPlayerInfoResp::totalround() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRankingPlayerInfoResp.TotalRound)
  return totalround_;
}
inline void CSPvpRankingPlayerInfoResp::set_totalround(::google::protobuf::uint32 value) {
  set_has_totalround();
  totalround_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpRankingPlayerInfoResp.TotalRound)
}

// -------------------------------------------------------------------

// CSPvpResultReq

// -------------------------------------------------------------------

// CSPvpResultResp

// repeated .fgame.CSPvpEndResp Result = 1;
inline int CSPvpResultResp::result_size() const {
  return result_.size();
}
inline void CSPvpResultResp::clear_result() {
  result_.Clear();
}
inline const ::fgame::CSPvpEndResp& CSPvpResultResp::result(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpResultResp.Result)
  return result_.Get(index);
}
inline ::fgame::CSPvpEndResp* CSPvpResultResp::mutable_result(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSPvpResultResp.Result)
  return result_.Mutable(index);
}
inline ::fgame::CSPvpEndResp* CSPvpResultResp::add_result() {
  // @@protoc_insertion_point(field_add:fgame.CSPvpResultResp.Result)
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPvpEndResp >&
CSPvpResultResp::result() const {
  // @@protoc_insertion_point(field_list:fgame.CSPvpResultResp.Result)
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPvpEndResp >*
CSPvpResultResp::mutable_result() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSPvpResultResp.Result)
  return &result_;
}

// -------------------------------------------------------------------

// CSPvpSelfRankListReq

// -------------------------------------------------------------------

// CSPvpSelfRankListResp

// repeated .fgame.CSPvpRankingPlayerInfo PlayerList = 1;
inline int CSPvpSelfRankListResp::playerlist_size() const {
  return playerlist_.size();
}
inline void CSPvpSelfRankListResp::clear_playerlist() {
  playerlist_.Clear();
}
inline const ::fgame::CSPvpRankingPlayerInfo& CSPvpSelfRankListResp::playerlist(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpSelfRankListResp.PlayerList)
  return playerlist_.Get(index);
}
inline ::fgame::CSPvpRankingPlayerInfo* CSPvpSelfRankListResp::mutable_playerlist(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSPvpSelfRankListResp.PlayerList)
  return playerlist_.Mutable(index);
}
inline ::fgame::CSPvpRankingPlayerInfo* CSPvpSelfRankListResp::add_playerlist() {
  // @@protoc_insertion_point(field_add:fgame.CSPvpSelfRankListResp.PlayerList)
  return playerlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPvpRankingPlayerInfo >&
CSPvpSelfRankListResp::playerlist() const {
  // @@protoc_insertion_point(field_list:fgame.CSPvpSelfRankListResp.PlayerList)
  return playerlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPvpRankingPlayerInfo >*
CSPvpSelfRankListResp::mutable_playerlist() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSPvpSelfRankListResp.PlayerList)
  return &playerlist_;
}

// -------------------------------------------------------------------

// CSPvpChatReq

// required uint32 Channel = 1;
inline bool CSPvpChatReq::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpChatReq::set_has_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpChatReq::clear_has_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpChatReq::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 CSPvpChatReq::channel() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpChatReq.Channel)
  return channel_;
}
inline void CSPvpChatReq::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpChatReq.Channel)
}

// optional string Content = 2;
inline bool CSPvpChatReq::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpChatReq::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpChatReq::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpChatReq::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& CSPvpChatReq::content() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpChatReq.Content)
  return *content_;
}
inline void CSPvpChatReq::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPvpChatReq.Content)
}
inline void CSPvpChatReq::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPvpChatReq.Content)
}
inline void CSPvpChatReq::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPvpChatReq.Content)
}
inline ::std::string* CSPvpChatReq::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPvpChatReq.Content)
  return content_;
}
inline ::std::string* CSPvpChatReq::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPvpChatReq::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPvpChatReq.Content)
}

// optional uint32 Id = 3;
inline bool CSPvpChatReq::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpChatReq::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpChatReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpChatReq::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSPvpChatReq::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpChatReq.Id)
  return id_;
}
inline void CSPvpChatReq::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpChatReq.Id)
}

// optional uint32 isBuy = 4;
inline bool CSPvpChatReq::has_isbuy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPvpChatReq::set_has_isbuy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPvpChatReq::clear_has_isbuy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPvpChatReq::clear_isbuy() {
  isbuy_ = 0u;
  clear_has_isbuy();
}
inline ::google::protobuf::uint32 CSPvpChatReq::isbuy() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpChatReq.isBuy)
  return isbuy_;
}
inline void CSPvpChatReq::set_isbuy(::google::protobuf::uint32 value) {
  set_has_isbuy();
  isbuy_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpChatReq.isBuy)
}

// -------------------------------------------------------------------

// CSPvpChatResp

// required uint32 Channel = 1;
inline bool CSPvpChatResp::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpChatResp::set_has_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpChatResp::clear_has_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpChatResp::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 CSPvpChatResp::channel() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpChatResp.Channel)
  return channel_;
}
inline void CSPvpChatResp::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpChatResp.Channel)
}

// required uint64 Uin = 2;
inline bool CSPvpChatResp::has_uin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpChatResp::set_has_uin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpChatResp::clear_has_uin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpChatResp::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPvpChatResp::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpChatResp.Uin)
  return uin_;
}
inline void CSPvpChatResp::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpChatResp.Uin)
}

// optional string Name = 3;
inline bool CSPvpChatResp::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpChatResp::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpChatResp::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpChatResp::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSPvpChatResp::name() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpChatResp.Name)
  return *name_;
}
inline void CSPvpChatResp::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPvpChatResp.Name)
}
inline void CSPvpChatResp::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPvpChatResp.Name)
}
inline void CSPvpChatResp::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPvpChatResp.Name)
}
inline ::std::string* CSPvpChatResp::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPvpChatResp.Name)
  return name_;
}
inline ::std::string* CSPvpChatResp::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPvpChatResp::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPvpChatResp.Name)
}

// optional uint32 Title = 4;
inline bool CSPvpChatResp::has_title() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPvpChatResp::set_has_title() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPvpChatResp::clear_has_title() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPvpChatResp::clear_title() {
  title_ = 0u;
  clear_has_title();
}
inline ::google::protobuf::uint32 CSPvpChatResp::title() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpChatResp.Title)
  return title_;
}
inline void CSPvpChatResp::set_title(::google::protobuf::uint32 value) {
  set_has_title();
  title_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpChatResp.Title)
}

// optional string Content = 5;
inline bool CSPvpChatResp::has_content() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPvpChatResp::set_has_content() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPvpChatResp::clear_has_content() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPvpChatResp::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& CSPvpChatResp::content() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpChatResp.Content)
  return *content_;
}
inline void CSPvpChatResp::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPvpChatResp.Content)
}
inline void CSPvpChatResp::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPvpChatResp.Content)
}
inline void CSPvpChatResp::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPvpChatResp.Content)
}
inline ::std::string* CSPvpChatResp::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPvpChatResp.Content)
  return content_;
}
inline ::std::string* CSPvpChatResp::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPvpChatResp::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPvpChatResp.Content)
}

// optional uint32 Id = 6;
inline bool CSPvpChatResp::has_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPvpChatResp::set_has_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPvpChatResp::clear_has_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPvpChatResp::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSPvpChatResp::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpChatResp.Id)
  return id_;
}
inline void CSPvpChatResp::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpChatResp.Id)
}

// optional string Icon = 7;
inline bool CSPvpChatResp::has_icon() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSPvpChatResp::set_has_icon() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSPvpChatResp::clear_has_icon() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSPvpChatResp::clear_icon() {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& CSPvpChatResp::icon() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpChatResp.Icon)
  return *icon_;
}
inline void CSPvpChatResp::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPvpChatResp.Icon)
}
inline void CSPvpChatResp::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPvpChatResp.Icon)
}
inline void CSPvpChatResp::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPvpChatResp.Icon)
}
inline ::std::string* CSPvpChatResp::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPvpChatResp.Icon)
  return icon_;
}
inline ::std::string* CSPvpChatResp::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPvpChatResp::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPvpChatResp.Icon)
}

// optional uint32 VipLevel = 8;
inline bool CSPvpChatResp::has_viplevel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSPvpChatResp::set_has_viplevel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSPvpChatResp::clear_has_viplevel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSPvpChatResp::clear_viplevel() {
  viplevel_ = 0u;
  clear_has_viplevel();
}
inline ::google::protobuf::uint32 CSPvpChatResp::viplevel() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpChatResp.VipLevel)
  return viplevel_;
}
inline void CSPvpChatResp::set_viplevel(::google::protobuf::uint32 value) {
  set_has_viplevel();
  viplevel_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpChatResp.VipLevel)
}

// -------------------------------------------------------------------

// CSPvpRecoverItemReq

// required uint64 Uin = 1;
inline bool CSPvpRecoverItemReq::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpRecoverItemReq::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpRecoverItemReq::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpRecoverItemReq::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPvpRecoverItemReq::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRecoverItemReq.Uin)
  return uin_;
}
inline void CSPvpRecoverItemReq::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpRecoverItemReq.Uin)
}

// required uint32 ItemId = 2;
inline bool CSPvpRecoverItemReq::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpRecoverItemReq::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpRecoverItemReq::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpRecoverItemReq::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 CSPvpRecoverItemReq::itemid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRecoverItemReq.ItemId)
  return itemid_;
}
inline void CSPvpRecoverItemReq::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpRecoverItemReq.ItemId)
}

// -------------------------------------------------------------------

// CSPvpRecoverItemResp

// required uint64 Uin = 1;
inline bool CSPvpRecoverItemResp::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPvpRecoverItemResp::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPvpRecoverItemResp::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPvpRecoverItemResp::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPvpRecoverItemResp::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRecoverItemResp.Uin)
  return uin_;
}
inline void CSPvpRecoverItemResp::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpRecoverItemResp.Uin)
}

// required uint32 ItemId = 2;
inline bool CSPvpRecoverItemResp::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPvpRecoverItemResp::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPvpRecoverItemResp::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPvpRecoverItemResp::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 CSPvpRecoverItemResp::itemid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRecoverItemResp.ItemId)
  return itemid_;
}
inline void CSPvpRecoverItemResp::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpRecoverItemResp.ItemId)
}

// required uint32 Num = 3;
inline bool CSPvpRecoverItemResp::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPvpRecoverItemResp::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPvpRecoverItemResp::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPvpRecoverItemResp::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 CSPvpRecoverItemResp::num() const {
  // @@protoc_insertion_point(field_get:fgame.CSPvpRecoverItemResp.Num)
  return num_;
}
inline void CSPvpRecoverItemResp::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPvpRecoverItemResp.Num)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fgame

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Pvp_2eproto__INCLUDED
