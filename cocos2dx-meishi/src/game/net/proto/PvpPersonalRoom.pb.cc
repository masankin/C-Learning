// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PvpPersonalRoom.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "PvpPersonalRoom.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace fgame {

void protobuf_ShutdownFile_PvpPersonalRoom_2eproto() {
  delete CSPersonalRoomCreateReq::default_instance_;
  delete CSPersonalRoomCreateResp::default_instance_;
  delete CSPersonalRoomPlayerInfo::default_instance_;
  delete CSPersonalRoomEnterReq::default_instance_;
  delete CSPersonalRoomEnterResp::default_instance_;
  delete CSPersonalRoomLeaveReq::default_instance_;
  delete CSPersonalRoomLeaveResp::default_instance_;
  delete CSPersonalRoomKickReq::default_instance_;
  delete CSPersonalRoomKickResp::default_instance_;
  delete CSPersonalRoomInviteReq::default_instance_;
  delete CSPersonalRoomInviteResp::default_instance_;
  delete CSPersonalRoomBroadcastReq::default_instance_;
  delete CSPersonalRoomBroadcastResp::default_instance_;
  delete CSPersonalRoomChatReq::default_instance_;
  delete CSPersonalRoomChatResp::default_instance_;
  delete CSPersonalRoomModeReq::default_instance_;
  delete CSPersonalRoomModeResp::default_instance_;
  delete CSPersonalRoomBeginFightReq::default_instance_;
  delete CSPersonalRoomBeginFightResp::default_instance_;
  delete CSPersonalRoomApplyOrRefuseInviteReq::default_instance_;
  delete CSPersonalRoomApplyOrRefuseInviteResp::default_instance_;
  delete CSPersonalRoomCountDownReq::default_instance_;
  delete CSPersonalRoomCountDownResp::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_PvpPersonalRoom_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_PvpPersonalRoom_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::fgame::protobuf_AddDesc_Friend_2eproto();
  ::fgame::protobuf_AddDesc_Player_2eproto();
  CSPersonalRoomCreateReq::default_instance_ = new CSPersonalRoomCreateReq();
  CSPersonalRoomCreateResp::default_instance_ = new CSPersonalRoomCreateResp();
  CSPersonalRoomPlayerInfo::default_instance_ = new CSPersonalRoomPlayerInfo();
  CSPersonalRoomEnterReq::default_instance_ = new CSPersonalRoomEnterReq();
  CSPersonalRoomEnterResp::default_instance_ = new CSPersonalRoomEnterResp();
  CSPersonalRoomLeaveReq::default_instance_ = new CSPersonalRoomLeaveReq();
  CSPersonalRoomLeaveResp::default_instance_ = new CSPersonalRoomLeaveResp();
  CSPersonalRoomKickReq::default_instance_ = new CSPersonalRoomKickReq();
  CSPersonalRoomKickResp::default_instance_ = new CSPersonalRoomKickResp();
  CSPersonalRoomInviteReq::default_instance_ = new CSPersonalRoomInviteReq();
  CSPersonalRoomInviteResp::default_instance_ = new CSPersonalRoomInviteResp();
  CSPersonalRoomBroadcastReq::default_instance_ = new CSPersonalRoomBroadcastReq();
  CSPersonalRoomBroadcastResp::default_instance_ = new CSPersonalRoomBroadcastResp();
  CSPersonalRoomChatReq::default_instance_ = new CSPersonalRoomChatReq();
  CSPersonalRoomChatResp::default_instance_ = new CSPersonalRoomChatResp();
  CSPersonalRoomModeReq::default_instance_ = new CSPersonalRoomModeReq();
  CSPersonalRoomModeResp::default_instance_ = new CSPersonalRoomModeResp();
  CSPersonalRoomBeginFightReq::default_instance_ = new CSPersonalRoomBeginFightReq();
  CSPersonalRoomBeginFightResp::default_instance_ = new CSPersonalRoomBeginFightResp();
  CSPersonalRoomApplyOrRefuseInviteReq::default_instance_ = new CSPersonalRoomApplyOrRefuseInviteReq();
  CSPersonalRoomApplyOrRefuseInviteResp::default_instance_ = new CSPersonalRoomApplyOrRefuseInviteResp();
  CSPersonalRoomCountDownReq::default_instance_ = new CSPersonalRoomCountDownReq();
  CSPersonalRoomCountDownResp::default_instance_ = new CSPersonalRoomCountDownResp();
  CSPersonalRoomCreateReq::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomCreateResp::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomPlayerInfo::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomEnterReq::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomEnterResp::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomLeaveReq::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomLeaveResp::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomKickReq::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomKickResp::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomInviteReq::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomInviteResp::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomBroadcastReq::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomBroadcastResp::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomChatReq::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomChatResp::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomModeReq::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomModeResp::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomBeginFightReq::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomBeginFightResp::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomApplyOrRefuseInviteReq::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomApplyOrRefuseInviteResp::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomCountDownReq::default_instance_->InitAsDefaultInstance();
  CSPersonalRoomCountDownResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_PvpPersonalRoom_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_PvpPersonalRoom_2eproto_once_);
void protobuf_AddDesc_PvpPersonalRoom_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_PvpPersonalRoom_2eproto_once_,
                 &protobuf_AddDesc_PvpPersonalRoom_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_PvpPersonalRoom_2eproto {
  StaticDescriptorInitializer_PvpPersonalRoom_2eproto() {
    protobuf_AddDesc_PvpPersonalRoom_2eproto();
  }
} static_descriptor_initializer_PvpPersonalRoom_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSPersonalRoomCreateReq::CSPersonalRoomCreateReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomCreateReq)
}

void CSPersonalRoomCreateReq::InitAsDefaultInstance() {
}

CSPersonalRoomCreateReq::CSPersonalRoomCreateReq(const CSPersonalRoomCreateReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomCreateReq)
}

void CSPersonalRoomCreateReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomCreateReq::~CSPersonalRoomCreateReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomCreateReq)
  SharedDtor();
}

void CSPersonalRoomCreateReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomCreateReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomCreateReq& CSPersonalRoomCreateReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomCreateReq* CSPersonalRoomCreateReq::default_instance_ = NULL;

CSPersonalRoomCreateReq* CSPersonalRoomCreateReq::New() const {
  return new CSPersonalRoomCreateReq;
}

void CSPersonalRoomCreateReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomCreateReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomCreateReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomCreateReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomCreateReq)
  return false;
#undef DO_
}

void CSPersonalRoomCreateReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomCreateReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomCreateReq)
}

int CSPersonalRoomCreateReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomCreateReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomCreateReq*>(&from));
}

void CSPersonalRoomCreateReq::MergeFrom(const CSPersonalRoomCreateReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomCreateReq::CopyFrom(const CSPersonalRoomCreateReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomCreateReq::IsInitialized() const {

  return true;
}

void CSPersonalRoomCreateReq::Swap(CSPersonalRoomCreateReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomCreateReq::GetTypeName() const {
  return "fgame.CSPersonalRoomCreateReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomCreateResp::kRoomIDFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomCreateResp::CSPersonalRoomCreateResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomCreateResp)
}

void CSPersonalRoomCreateResp::InitAsDefaultInstance() {
}

CSPersonalRoomCreateResp::CSPersonalRoomCreateResp(const CSPersonalRoomCreateResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomCreateResp)
}

void CSPersonalRoomCreateResp::SharedCtor() {
  _cached_size_ = 0;
  roomid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomCreateResp::~CSPersonalRoomCreateResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomCreateResp)
  SharedDtor();
}

void CSPersonalRoomCreateResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomCreateResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomCreateResp& CSPersonalRoomCreateResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomCreateResp* CSPersonalRoomCreateResp::default_instance_ = NULL;

CSPersonalRoomCreateResp* CSPersonalRoomCreateResp::New() const {
  return new CSPersonalRoomCreateResp;
}

void CSPersonalRoomCreateResp::Clear() {
  roomid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomCreateResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomCreateResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 RoomID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomCreateResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomCreateResp)
  return false;
#undef DO_
}

void CSPersonalRoomCreateResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomCreateResp)
  // required uint32 RoomID = 1;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->roomid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomCreateResp)
}

int CSPersonalRoomCreateResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 RoomID = 1;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomCreateResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomCreateResp*>(&from));
}

void CSPersonalRoomCreateResp::MergeFrom(const CSPersonalRoomCreateResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomCreateResp::CopyFrom(const CSPersonalRoomCreateResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomCreateResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPersonalRoomCreateResp::Swap(CSPersonalRoomCreateResp* other) {
  if (other != this) {
    std::swap(roomid_, other->roomid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomCreateResp::GetTypeName() const {
  return "fgame.CSPersonalRoomCreateResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomPlayerInfo::kUinFieldNumber;
const int CSPersonalRoomPlayerInfo::kNameFieldNumber;
const int CSPersonalRoomPlayerInfo::kIconFieldNumber;
const int CSPersonalRoomPlayerInfo::kGroupFieldNumber;
const int CSPersonalRoomPlayerInfo::kRankFieldNumber;
const int CSPersonalRoomPlayerInfo::kWinRateFieldNumber;
const int CSPersonalRoomPlayerInfo::kIndexFieldNumber;
const int CSPersonalRoomPlayerInfo::kScoreFieldNumber;
const int CSPersonalRoomPlayerInfo::kTitleFieldNumber;
const int CSPersonalRoomPlayerInfo::kLevelFieldNumber;
const int CSPersonalRoomPlayerInfo::kVipLevelFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomPlayerInfo::CSPersonalRoomPlayerInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomPlayerInfo)
}

void CSPersonalRoomPlayerInfo::InitAsDefaultInstance() {
}

CSPersonalRoomPlayerInfo::CSPersonalRoomPlayerInfo(const CSPersonalRoomPlayerInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomPlayerInfo)
}

void CSPersonalRoomPlayerInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  group_ = 0u;
  rank_ = 0u;
  winrate_ = 0u;
  index_ = 0u;
  score_ = 0u;
  title_ = GOOGLE_ULONGLONG(0);
  level_ = 0u;
  viplevel_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomPlayerInfo::~CSPersonalRoomPlayerInfo() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomPlayerInfo)
  SharedDtor();
}

void CSPersonalRoomPlayerInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomPlayerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomPlayerInfo& CSPersonalRoomPlayerInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomPlayerInfo* CSPersonalRoomPlayerInfo::default_instance_ = NULL;

CSPersonalRoomPlayerInfo* CSPersonalRoomPlayerInfo::New() const {
  return new CSPersonalRoomPlayerInfo;
}

void CSPersonalRoomPlayerInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPersonalRoomPlayerInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(group_, index_);
    uin_ = GOOGLE_ULONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_icon()) {
      if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        icon_->clear();
      }
    }
    score_ = 0u;
  }
  if (_has_bits_[8 / 32] & 1792) {
    ZR_(level_, viplevel_);
    title_ = GOOGLE_ULONGLONG(0);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomPlayerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomPlayerInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Name;
        break;
      }

      // required string Name = 2;
      case 2: {
        if (tag == 18) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_Icon;
        break;
      }

      // required string Icon = 3;
      case 3: {
        if (tag == 26) {
         parse_Icon:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_icon()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Group;
        break;
      }

      // required uint32 Group = 4;
      case 4: {
        if (tag == 32) {
         parse_Group:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_)));
          set_has_group();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_Rank;
        break;
      }

      // required uint32 Rank = 5;
      case 5: {
        if (tag == 40) {
         parse_Rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_)));
          set_has_rank();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_WinRate;
        break;
      }

      // required uint32 WinRate = 6;
      case 6: {
        if (tag == 48) {
         parse_WinRate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &winrate_)));
          set_has_winrate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_Index;
        break;
      }

      // required uint32 Index = 7;
      case 7: {
        if (tag == 56) {
         parse_Index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_Score;
        break;
      }

      // optional uint32 Score = 8;
      case 8: {
        if (tag == 64) {
         parse_Score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_Title;
        break;
      }

      // optional uint64 Title = 9;
      case 9: {
        if (tag == 72) {
         parse_Title:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &title_)));
          set_has_title();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_Level;
        break;
      }

      // optional uint32 Level = 10;
      case 10: {
        if (tag == 80) {
         parse_Level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_VipLevel;
        break;
      }

      // optional uint32 VipLevel = 11;
      case 11: {
        if (tag == 88) {
         parse_VipLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &viplevel_)));
          set_has_viplevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomPlayerInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomPlayerInfo)
  return false;
#undef DO_
}

void CSPersonalRoomPlayerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomPlayerInfo)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  // required string Name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // required string Icon = 3;
  if (has_icon()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->icon(), output);
  }

  // required uint32 Group = 4;
  if (has_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->group(), output);
  }

  // required uint32 Rank = 5;
  if (has_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->rank(), output);
  }

  // required uint32 WinRate = 6;
  if (has_winrate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->winrate(), output);
  }

  // required uint32 Index = 7;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->index(), output);
  }

  // optional uint32 Score = 8;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->score(), output);
  }

  // optional uint64 Title = 9;
  if (has_title()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(9, this->title(), output);
  }

  // optional uint32 Level = 10;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->level(), output);
  }

  // optional uint32 VipLevel = 11;
  if (has_viplevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->viplevel(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomPlayerInfo)
}

int CSPersonalRoomPlayerInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

    // required string Name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required string Icon = 3;
    if (has_icon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->icon());
    }

    // required uint32 Group = 4;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group());
    }

    // required uint32 Rank = 5;
    if (has_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank());
    }

    // required uint32 WinRate = 6;
    if (has_winrate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->winrate());
    }

    // required uint32 Index = 7;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

    // optional uint32 Score = 8;
    if (has_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->score());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint64 Title = 9;
    if (has_title()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->title());
    }

    // optional uint32 Level = 10;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->level());
    }

    // optional uint32 VipLevel = 11;
    if (has_viplevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->viplevel());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomPlayerInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomPlayerInfo*>(&from));
}

void CSPersonalRoomPlayerInfo::MergeFrom(const CSPersonalRoomPlayerInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_icon()) {
      set_icon(from.icon());
    }
    if (from.has_group()) {
      set_group(from.group());
    }
    if (from.has_rank()) {
      set_rank(from.rank());
    }
    if (from.has_winrate()) {
      set_winrate(from.winrate());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_title()) {
      set_title(from.title());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_viplevel()) {
      set_viplevel(from.viplevel());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomPlayerInfo::CopyFrom(const CSPersonalRoomPlayerInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomPlayerInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void CSPersonalRoomPlayerInfo::Swap(CSPersonalRoomPlayerInfo* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(name_, other->name_);
    std::swap(icon_, other->icon_);
    std::swap(group_, other->group_);
    std::swap(rank_, other->rank_);
    std::swap(winrate_, other->winrate_);
    std::swap(index_, other->index_);
    std::swap(score_, other->score_);
    std::swap(title_, other->title_);
    std::swap(level_, other->level_);
    std::swap(viplevel_, other->viplevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomPlayerInfo::GetTypeName() const {
  return "fgame.CSPersonalRoomPlayerInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomEnterReq::kRoomIDFieldNumber;
const int CSPersonalRoomEnterReq::kServerNodeFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomEnterReq::CSPersonalRoomEnterReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomEnterReq)
}

void CSPersonalRoomEnterReq::InitAsDefaultInstance() {
}

CSPersonalRoomEnterReq::CSPersonalRoomEnterReq(const CSPersonalRoomEnterReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomEnterReq)
}

void CSPersonalRoomEnterReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  roomid_ = 0u;
  servernode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomEnterReq::~CSPersonalRoomEnterReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomEnterReq)
  SharedDtor();
}

void CSPersonalRoomEnterReq::SharedDtor() {
  if (servernode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete servernode_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomEnterReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomEnterReq& CSPersonalRoomEnterReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomEnterReq* CSPersonalRoomEnterReq::default_instance_ = NULL;

CSPersonalRoomEnterReq* CSPersonalRoomEnterReq::New() const {
  return new CSPersonalRoomEnterReq;
}

void CSPersonalRoomEnterReq::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    roomid_ = 0u;
    if (has_servernode()) {
      if (servernode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        servernode_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomEnterReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomEnterReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 RoomID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_ServerNode;
        break;
      }

      // optional string ServerNode = 2;
      case 2: {
        if (tag == 18) {
         parse_ServerNode:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_servernode()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomEnterReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomEnterReq)
  return false;
#undef DO_
}

void CSPersonalRoomEnterReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomEnterReq)
  // required uint32 RoomID = 1;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->roomid(), output);
  }

  // optional string ServerNode = 2;
  if (has_servernode()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->servernode(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomEnterReq)
}

int CSPersonalRoomEnterReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 RoomID = 1;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

    // optional string ServerNode = 2;
    if (has_servernode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->servernode());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomEnterReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomEnterReq*>(&from));
}

void CSPersonalRoomEnterReq::MergeFrom(const CSPersonalRoomEnterReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_servernode()) {
      set_servernode(from.servernode());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomEnterReq::CopyFrom(const CSPersonalRoomEnterReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomEnterReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPersonalRoomEnterReq::Swap(CSPersonalRoomEnterReq* other) {
  if (other != this) {
    std::swap(roomid_, other->roomid_);
    std::swap(servernode_, other->servernode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomEnterReq::GetTypeName() const {
  return "fgame.CSPersonalRoomEnterReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomEnterResp::kRoomIDFieldNumber;
const int CSPersonalRoomEnterResp::kPlayersFieldNumber;
const int CSPersonalRoomEnterResp::kLeftSecondsFieldNumber;
const int CSPersonalRoomEnterResp::kRoomTypeFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomEnterResp::CSPersonalRoomEnterResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomEnterResp)
}

void CSPersonalRoomEnterResp::InitAsDefaultInstance() {
}

CSPersonalRoomEnterResp::CSPersonalRoomEnterResp(const CSPersonalRoomEnterResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomEnterResp)
}

void CSPersonalRoomEnterResp::SharedCtor() {
  _cached_size_ = 0;
  roomid_ = 0u;
  leftseconds_ = GOOGLE_ULONGLONG(0);
  roomtype_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomEnterResp::~CSPersonalRoomEnterResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomEnterResp)
  SharedDtor();
}

void CSPersonalRoomEnterResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomEnterResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomEnterResp& CSPersonalRoomEnterResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomEnterResp* CSPersonalRoomEnterResp::default_instance_ = NULL;

CSPersonalRoomEnterResp* CSPersonalRoomEnterResp::New() const {
  return new CSPersonalRoomEnterResp;
}

void CSPersonalRoomEnterResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPersonalRoomEnterResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(roomid_, leftseconds_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  players_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomEnterResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomEnterResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 RoomID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Players;
        break;
      }

      // repeated .fgame.CSPersonalRoomPlayerInfo Players = 2;
      case 2: {
        if (tag == 18) {
         parse_Players:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_players()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Players;
        if (input->ExpectTag(24)) goto parse_LeftSeconds;
        break;
      }

      // optional uint64 LeftSeconds = 3;
      case 3: {
        if (tag == 24) {
         parse_LeftSeconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &leftseconds_)));
          set_has_leftseconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_RoomType;
        break;
      }

      // optional uint32 RoomType = 4;
      case 4: {
        if (tag == 32) {
         parse_RoomType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomtype_)));
          set_has_roomtype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomEnterResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomEnterResp)
  return false;
#undef DO_
}

void CSPersonalRoomEnterResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomEnterResp)
  // required uint32 RoomID = 1;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->roomid(), output);
  }

  // repeated .fgame.CSPersonalRoomPlayerInfo Players = 2;
  for (int i = 0; i < this->players_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->players(i), output);
  }

  // optional uint64 LeftSeconds = 3;
  if (has_leftseconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->leftseconds(), output);
  }

  // optional uint32 RoomType = 4;
  if (has_roomtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->roomtype(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomEnterResp)
}

int CSPersonalRoomEnterResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 RoomID = 1;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

    // optional uint64 LeftSeconds = 3;
    if (has_leftseconds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->leftseconds());
    }

    // optional uint32 RoomType = 4;
    if (has_roomtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomtype());
    }

  }
  // repeated .fgame.CSPersonalRoomPlayerInfo Players = 2;
  total_size += 1 * this->players_size();
  for (int i = 0; i < this->players_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->players(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomEnterResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomEnterResp*>(&from));
}

void CSPersonalRoomEnterResp::MergeFrom(const CSPersonalRoomEnterResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  players_.MergeFrom(from.players_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_leftseconds()) {
      set_leftseconds(from.leftseconds());
    }
    if (from.has_roomtype()) {
      set_roomtype(from.roomtype());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomEnterResp::CopyFrom(const CSPersonalRoomEnterResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomEnterResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->players())) return false;
  return true;
}

void CSPersonalRoomEnterResp::Swap(CSPersonalRoomEnterResp* other) {
  if (other != this) {
    std::swap(roomid_, other->roomid_);
    players_.Swap(&other->players_);
    std::swap(leftseconds_, other->leftseconds_);
    std::swap(roomtype_, other->roomtype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomEnterResp::GetTypeName() const {
  return "fgame.CSPersonalRoomEnterResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomLeaveReq::kRoomIDFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomLeaveReq::CSPersonalRoomLeaveReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomLeaveReq)
}

void CSPersonalRoomLeaveReq::InitAsDefaultInstance() {
}

CSPersonalRoomLeaveReq::CSPersonalRoomLeaveReq(const CSPersonalRoomLeaveReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomLeaveReq)
}

void CSPersonalRoomLeaveReq::SharedCtor() {
  _cached_size_ = 0;
  roomid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomLeaveReq::~CSPersonalRoomLeaveReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomLeaveReq)
  SharedDtor();
}

void CSPersonalRoomLeaveReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomLeaveReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomLeaveReq& CSPersonalRoomLeaveReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomLeaveReq* CSPersonalRoomLeaveReq::default_instance_ = NULL;

CSPersonalRoomLeaveReq* CSPersonalRoomLeaveReq::New() const {
  return new CSPersonalRoomLeaveReq;
}

void CSPersonalRoomLeaveReq::Clear() {
  roomid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomLeaveReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomLeaveReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 RoomID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomLeaveReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomLeaveReq)
  return false;
#undef DO_
}

void CSPersonalRoomLeaveReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomLeaveReq)
  // required uint32 RoomID = 1;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->roomid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomLeaveReq)
}

int CSPersonalRoomLeaveReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 RoomID = 1;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomLeaveReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomLeaveReq*>(&from));
}

void CSPersonalRoomLeaveReq::MergeFrom(const CSPersonalRoomLeaveReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomLeaveReq::CopyFrom(const CSPersonalRoomLeaveReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomLeaveReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPersonalRoomLeaveReq::Swap(CSPersonalRoomLeaveReq* other) {
  if (other != this) {
    std::swap(roomid_, other->roomid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomLeaveReq::GetTypeName() const {
  return "fgame.CSPersonalRoomLeaveReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomLeaveResp::kUinFieldNumber;
const int CSPersonalRoomLeaveResp::kRoomIDFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomLeaveResp::CSPersonalRoomLeaveResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomLeaveResp)
}

void CSPersonalRoomLeaveResp::InitAsDefaultInstance() {
}

CSPersonalRoomLeaveResp::CSPersonalRoomLeaveResp(const CSPersonalRoomLeaveResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomLeaveResp)
}

void CSPersonalRoomLeaveResp::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  roomid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomLeaveResp::~CSPersonalRoomLeaveResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomLeaveResp)
  SharedDtor();
}

void CSPersonalRoomLeaveResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomLeaveResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomLeaveResp& CSPersonalRoomLeaveResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomLeaveResp* CSPersonalRoomLeaveResp::default_instance_ = NULL;

CSPersonalRoomLeaveResp* CSPersonalRoomLeaveResp::New() const {
  return new CSPersonalRoomLeaveResp;
}

void CSPersonalRoomLeaveResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPersonalRoomLeaveResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(uin_, roomid_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomLeaveResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomLeaveResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_RoomID;
        break;
      }

      // optional uint32 RoomID = 2;
      case 2: {
        if (tag == 16) {
         parse_RoomID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomLeaveResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomLeaveResp)
  return false;
#undef DO_
}

void CSPersonalRoomLeaveResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomLeaveResp)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  // optional uint32 RoomID = 2;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->roomid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomLeaveResp)
}

int CSPersonalRoomLeaveResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

    // optional uint32 RoomID = 2;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomLeaveResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomLeaveResp*>(&from));
}

void CSPersonalRoomLeaveResp::MergeFrom(const CSPersonalRoomLeaveResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomLeaveResp::CopyFrom(const CSPersonalRoomLeaveResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomLeaveResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPersonalRoomLeaveResp::Swap(CSPersonalRoomLeaveResp* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(roomid_, other->roomid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomLeaveResp::GetTypeName() const {
  return "fgame.CSPersonalRoomLeaveResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomKickReq::kUinFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomKickReq::CSPersonalRoomKickReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomKickReq)
}

void CSPersonalRoomKickReq::InitAsDefaultInstance() {
}

CSPersonalRoomKickReq::CSPersonalRoomKickReq(const CSPersonalRoomKickReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomKickReq)
}

void CSPersonalRoomKickReq::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomKickReq::~CSPersonalRoomKickReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomKickReq)
  SharedDtor();
}

void CSPersonalRoomKickReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomKickReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomKickReq& CSPersonalRoomKickReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomKickReq* CSPersonalRoomKickReq::default_instance_ = NULL;

CSPersonalRoomKickReq* CSPersonalRoomKickReq::New() const {
  return new CSPersonalRoomKickReq;
}

void CSPersonalRoomKickReq::Clear() {
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomKickReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomKickReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomKickReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomKickReq)
  return false;
#undef DO_
}

void CSPersonalRoomKickReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomKickReq)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomKickReq)
}

int CSPersonalRoomKickReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomKickReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomKickReq*>(&from));
}

void CSPersonalRoomKickReq::MergeFrom(const CSPersonalRoomKickReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomKickReq::CopyFrom(const CSPersonalRoomKickReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomKickReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPersonalRoomKickReq::Swap(CSPersonalRoomKickReq* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomKickReq::GetTypeName() const {
  return "fgame.CSPersonalRoomKickReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomKickResp::kUinFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomKickResp::CSPersonalRoomKickResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomKickResp)
}

void CSPersonalRoomKickResp::InitAsDefaultInstance() {
}

CSPersonalRoomKickResp::CSPersonalRoomKickResp(const CSPersonalRoomKickResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomKickResp)
}

void CSPersonalRoomKickResp::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomKickResp::~CSPersonalRoomKickResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomKickResp)
  SharedDtor();
}

void CSPersonalRoomKickResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomKickResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomKickResp& CSPersonalRoomKickResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomKickResp* CSPersonalRoomKickResp::default_instance_ = NULL;

CSPersonalRoomKickResp* CSPersonalRoomKickResp::New() const {
  return new CSPersonalRoomKickResp;
}

void CSPersonalRoomKickResp::Clear() {
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomKickResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomKickResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomKickResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomKickResp)
  return false;
#undef DO_
}

void CSPersonalRoomKickResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomKickResp)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomKickResp)
}

int CSPersonalRoomKickResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomKickResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomKickResp*>(&from));
}

void CSPersonalRoomKickResp::MergeFrom(const CSPersonalRoomKickResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomKickResp::CopyFrom(const CSPersonalRoomKickResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomKickResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPersonalRoomKickResp::Swap(CSPersonalRoomKickResp* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomKickResp::GetTypeName() const {
  return "fgame.CSPersonalRoomKickResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomInviteReq::kUinFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomInviteReq::CSPersonalRoomInviteReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomInviteReq)
}

void CSPersonalRoomInviteReq::InitAsDefaultInstance() {
}

CSPersonalRoomInviteReq::CSPersonalRoomInviteReq(const CSPersonalRoomInviteReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomInviteReq)
}

void CSPersonalRoomInviteReq::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomInviteReq::~CSPersonalRoomInviteReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomInviteReq)
  SharedDtor();
}

void CSPersonalRoomInviteReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomInviteReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomInviteReq& CSPersonalRoomInviteReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomInviteReq* CSPersonalRoomInviteReq::default_instance_ = NULL;

CSPersonalRoomInviteReq* CSPersonalRoomInviteReq::New() const {
  return new CSPersonalRoomInviteReq;
}

void CSPersonalRoomInviteReq::Clear() {
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomInviteReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomInviteReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomInviteReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomInviteReq)
  return false;
#undef DO_
}

void CSPersonalRoomInviteReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomInviteReq)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomInviteReq)
}

int CSPersonalRoomInviteReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomInviteReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomInviteReq*>(&from));
}

void CSPersonalRoomInviteReq::MergeFrom(const CSPersonalRoomInviteReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomInviteReq::CopyFrom(const CSPersonalRoomInviteReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomInviteReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPersonalRoomInviteReq::Swap(CSPersonalRoomInviteReq* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomInviteReq::GetTypeName() const {
  return "fgame.CSPersonalRoomInviteReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomInviteResp::kUinFieldNumber;
const int CSPersonalRoomInviteResp::kInfoFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomInviteResp::CSPersonalRoomInviteResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomInviteResp)
}

void CSPersonalRoomInviteResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  info_ = const_cast< ::fgame::FriendPkRequestInfo*>(
      ::fgame::FriendPkRequestInfo::internal_default_instance());
#else
  info_ = const_cast< ::fgame::FriendPkRequestInfo*>(&::fgame::FriendPkRequestInfo::default_instance());
#endif
}

CSPersonalRoomInviteResp::CSPersonalRoomInviteResp(const CSPersonalRoomInviteResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomInviteResp)
}

void CSPersonalRoomInviteResp::SharedCtor() {
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomInviteResp::~CSPersonalRoomInviteResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomInviteResp)
  SharedDtor();
}

void CSPersonalRoomInviteResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete info_;
  }
}

void CSPersonalRoomInviteResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomInviteResp& CSPersonalRoomInviteResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomInviteResp* CSPersonalRoomInviteResp::default_instance_ = NULL;

CSPersonalRoomInviteResp* CSPersonalRoomInviteResp::New() const {
  return new CSPersonalRoomInviteResp;
}

void CSPersonalRoomInviteResp::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    uin_ = GOOGLE_ULONGLONG(0);
    if (has_info()) {
      if (info_ != NULL) info_->::fgame::FriendPkRequestInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomInviteResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomInviteResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Info;
        break;
      }

      // optional .fgame.FriendPkRequestInfo Info = 2;
      case 2: {
        if (tag == 18) {
         parse_Info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomInviteResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomInviteResp)
  return false;
#undef DO_
}

void CSPersonalRoomInviteResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomInviteResp)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  // optional .fgame.FriendPkRequestInfo Info = 2;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->info(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomInviteResp)
}

int CSPersonalRoomInviteResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

    // optional .fgame.FriendPkRequestInfo Info = 2;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomInviteResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomInviteResp*>(&from));
}

void CSPersonalRoomInviteResp::MergeFrom(const CSPersonalRoomInviteResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_info()) {
      mutable_info()->::fgame::FriendPkRequestInfo::MergeFrom(from.info());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomInviteResp::CopyFrom(const CSPersonalRoomInviteResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomInviteResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_info()) {
    if (!this->info().IsInitialized()) return false;
  }
  return true;
}

void CSPersonalRoomInviteResp::Swap(CSPersonalRoomInviteResp* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(info_, other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomInviteResp::GetTypeName() const {
  return "fgame.CSPersonalRoomInviteResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSPersonalRoomBroadcastReq::CSPersonalRoomBroadcastReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomBroadcastReq)
}

void CSPersonalRoomBroadcastReq::InitAsDefaultInstance() {
}

CSPersonalRoomBroadcastReq::CSPersonalRoomBroadcastReq(const CSPersonalRoomBroadcastReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomBroadcastReq)
}

void CSPersonalRoomBroadcastReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomBroadcastReq::~CSPersonalRoomBroadcastReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomBroadcastReq)
  SharedDtor();
}

void CSPersonalRoomBroadcastReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomBroadcastReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomBroadcastReq& CSPersonalRoomBroadcastReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomBroadcastReq* CSPersonalRoomBroadcastReq::default_instance_ = NULL;

CSPersonalRoomBroadcastReq* CSPersonalRoomBroadcastReq::New() const {
  return new CSPersonalRoomBroadcastReq;
}

void CSPersonalRoomBroadcastReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomBroadcastReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomBroadcastReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomBroadcastReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomBroadcastReq)
  return false;
#undef DO_
}

void CSPersonalRoomBroadcastReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomBroadcastReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomBroadcastReq)
}

int CSPersonalRoomBroadcastReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomBroadcastReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomBroadcastReq*>(&from));
}

void CSPersonalRoomBroadcastReq::MergeFrom(const CSPersonalRoomBroadcastReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomBroadcastReq::CopyFrom(const CSPersonalRoomBroadcastReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomBroadcastReq::IsInitialized() const {

  return true;
}

void CSPersonalRoomBroadcastReq::Swap(CSPersonalRoomBroadcastReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomBroadcastReq::GetTypeName() const {
  return "fgame.CSPersonalRoomBroadcastReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomBroadcastResp::kUinFieldNumber;
const int CSPersonalRoomBroadcastResp::kNameFieldNumber;
const int CSPersonalRoomBroadcastResp::kRoomIDFieldNumber;
const int CSPersonalRoomBroadcastResp::kTimeFieldNumber;
const int CSPersonalRoomBroadcastResp::kIconFieldNumber;
const int CSPersonalRoomBroadcastResp::kServerNodeFieldNumber;
const int CSPersonalRoomBroadcastResp::kTitleFieldNumber;
const int CSPersonalRoomBroadcastResp::kVipLevelFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomBroadcastResp::CSPersonalRoomBroadcastResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomBroadcastResp)
}

void CSPersonalRoomBroadcastResp::InitAsDefaultInstance() {
}

CSPersonalRoomBroadcastResp::CSPersonalRoomBroadcastResp(const CSPersonalRoomBroadcastResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomBroadcastResp)
}

void CSPersonalRoomBroadcastResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  roomid_ = 0u;
  time_ = GOOGLE_ULONGLONG(0);
  icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  servernode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  title_ = 0u;
  viplevel_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomBroadcastResp::~CSPersonalRoomBroadcastResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomBroadcastResp)
  SharedDtor();
}

void CSPersonalRoomBroadcastResp::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_;
  }
  if (servernode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete servernode_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomBroadcastResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomBroadcastResp& CSPersonalRoomBroadcastResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomBroadcastResp* CSPersonalRoomBroadcastResp::default_instance_ = NULL;

CSPersonalRoomBroadcastResp* CSPersonalRoomBroadcastResp::New() const {
  return new CSPersonalRoomBroadcastResp;
}

void CSPersonalRoomBroadcastResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPersonalRoomBroadcastResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(roomid_, title_);
    uin_ = GOOGLE_ULONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    time_ = GOOGLE_ULONGLONG(0);
    if (has_icon()) {
      if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        icon_->clear();
      }
    }
    if (has_servernode()) {
      if (servernode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        servernode_->clear();
      }
    }
    viplevel_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomBroadcastResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomBroadcastResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Name;
        break;
      }

      // required string Name = 2;
      case 2: {
        if (tag == 18) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_RoomID;
        break;
      }

      // required uint32 RoomID = 3;
      case 3: {
        if (tag == 24) {
         parse_RoomID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Time;
        break;
      }

      // required uint64 Time = 4;
      case 4: {
        if (tag == 32) {
         parse_Time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_Icon;
        break;
      }

      // optional string Icon = 5;
      case 5: {
        if (tag == 42) {
         parse_Icon:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_icon()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_ServerNode;
        break;
      }

      // optional string ServerNode = 6;
      case 6: {
        if (tag == 50) {
         parse_ServerNode:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_servernode()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_Title;
        break;
      }

      // optional uint32 Title = 7;
      case 7: {
        if (tag == 56) {
         parse_Title:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &title_)));
          set_has_title();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_VipLevel;
        break;
      }

      // optional uint32 VipLevel = 8;
      case 8: {
        if (tag == 64) {
         parse_VipLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &viplevel_)));
          set_has_viplevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomBroadcastResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomBroadcastResp)
  return false;
#undef DO_
}

void CSPersonalRoomBroadcastResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomBroadcastResp)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  // required string Name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // required uint32 RoomID = 3;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->roomid(), output);
  }

  // required uint64 Time = 4;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->time(), output);
  }

  // optional string Icon = 5;
  if (has_icon()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->icon(), output);
  }

  // optional string ServerNode = 6;
  if (has_servernode()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->servernode(), output);
  }

  // optional uint32 Title = 7;
  if (has_title()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->title(), output);
  }

  // optional uint32 VipLevel = 8;
  if (has_viplevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->viplevel(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomBroadcastResp)
}

int CSPersonalRoomBroadcastResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

    // required string Name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required uint32 RoomID = 3;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

    // required uint64 Time = 4;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->time());
    }

    // optional string Icon = 5;
    if (has_icon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->icon());
    }

    // optional string ServerNode = 6;
    if (has_servernode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->servernode());
    }

    // optional uint32 Title = 7;
    if (has_title()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->title());
    }

    // optional uint32 VipLevel = 8;
    if (has_viplevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->viplevel());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomBroadcastResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomBroadcastResp*>(&from));
}

void CSPersonalRoomBroadcastResp::MergeFrom(const CSPersonalRoomBroadcastResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_icon()) {
      set_icon(from.icon());
    }
    if (from.has_servernode()) {
      set_servernode(from.servernode());
    }
    if (from.has_title()) {
      set_title(from.title());
    }
    if (from.has_viplevel()) {
      set_viplevel(from.viplevel());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomBroadcastResp::CopyFrom(const CSPersonalRoomBroadcastResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomBroadcastResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void CSPersonalRoomBroadcastResp::Swap(CSPersonalRoomBroadcastResp* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(name_, other->name_);
    std::swap(roomid_, other->roomid_);
    std::swap(time_, other->time_);
    std::swap(icon_, other->icon_);
    std::swap(servernode_, other->servernode_);
    std::swap(title_, other->title_);
    std::swap(viplevel_, other->viplevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomBroadcastResp::GetTypeName() const {
  return "fgame.CSPersonalRoomBroadcastResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomChatReq::kIDFieldNumber;
const int CSPersonalRoomChatReq::kWordsFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomChatReq::CSPersonalRoomChatReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomChatReq)
}

void CSPersonalRoomChatReq::InitAsDefaultInstance() {
}

CSPersonalRoomChatReq::CSPersonalRoomChatReq(const CSPersonalRoomChatReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomChatReq)
}

void CSPersonalRoomChatReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_ = 0u;
  words_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomChatReq::~CSPersonalRoomChatReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomChatReq)
  SharedDtor();
}

void CSPersonalRoomChatReq::SharedDtor() {
  if (words_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete words_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomChatReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomChatReq& CSPersonalRoomChatReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomChatReq* CSPersonalRoomChatReq::default_instance_ = NULL;

CSPersonalRoomChatReq* CSPersonalRoomChatReq::New() const {
  return new CSPersonalRoomChatReq;
}

void CSPersonalRoomChatReq::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    id_ = 0u;
    if (has_words()) {
      if (words_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        words_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomChatReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomChatReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Words;
        break;
      }

      // optional string Words = 2;
      case 2: {
        if (tag == 18) {
         parse_Words:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_words()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomChatReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomChatReq)
  return false;
#undef DO_
}

void CSPersonalRoomChatReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomChatReq)
  // required uint32 ID = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional string Words = 2;
  if (has_words()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->words(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomChatReq)
}

int CSPersonalRoomChatReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ID = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional string Words = 2;
    if (has_words()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->words());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomChatReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomChatReq*>(&from));
}

void CSPersonalRoomChatReq::MergeFrom(const CSPersonalRoomChatReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_words()) {
      set_words(from.words());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomChatReq::CopyFrom(const CSPersonalRoomChatReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomChatReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPersonalRoomChatReq::Swap(CSPersonalRoomChatReq* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(words_, other->words_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomChatReq::GetTypeName() const {
  return "fgame.CSPersonalRoomChatReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomChatResp::kUinFieldNumber;
const int CSPersonalRoomChatResp::kIDFieldNumber;
const int CSPersonalRoomChatResp::kWordsFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomChatResp::CSPersonalRoomChatResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomChatResp)
}

void CSPersonalRoomChatResp::InitAsDefaultInstance() {
}

CSPersonalRoomChatResp::CSPersonalRoomChatResp(const CSPersonalRoomChatResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomChatResp)
}

void CSPersonalRoomChatResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  uin_ = GOOGLE_ULONGLONG(0);
  id_ = 0u;
  words_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomChatResp::~CSPersonalRoomChatResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomChatResp)
  SharedDtor();
}

void CSPersonalRoomChatResp::SharedDtor() {
  if (words_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete words_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomChatResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomChatResp& CSPersonalRoomChatResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomChatResp* CSPersonalRoomChatResp::default_instance_ = NULL;

CSPersonalRoomChatResp* CSPersonalRoomChatResp::New() const {
  return new CSPersonalRoomChatResp;
}

void CSPersonalRoomChatResp::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    uin_ = GOOGLE_ULONGLONG(0);
    id_ = 0u;
    if (has_words()) {
      if (words_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        words_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomChatResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomChatResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ID;
        break;
      }

      // required uint32 ID = 2;
      case 2: {
        if (tag == 16) {
         parse_ID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_Words;
        break;
      }

      // required string Words = 3;
      case 3: {
        if (tag == 26) {
         parse_Words:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_words()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomChatResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomChatResp)
  return false;
#undef DO_
}

void CSPersonalRoomChatResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomChatResp)
  // required uint64 Uin = 1;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uin(), output);
  }

  // required uint32 ID = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->id(), output);
  }

  // required string Words = 3;
  if (has_words()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->words(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomChatResp)
}

int CSPersonalRoomChatResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uin = 1;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

    // required uint32 ID = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required string Words = 3;
    if (has_words()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->words());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomChatResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomChatResp*>(&from));
}

void CSPersonalRoomChatResp::MergeFrom(const CSPersonalRoomChatResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uin()) {
      set_uin(from.uin());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_words()) {
      set_words(from.words());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomChatResp::CopyFrom(const CSPersonalRoomChatResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomChatResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSPersonalRoomChatResp::Swap(CSPersonalRoomChatResp* other) {
  if (other != this) {
    std::swap(uin_, other->uin_);
    std::swap(id_, other->id_);
    std::swap(words_, other->words_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomChatResp::GetTypeName() const {
  return "fgame.CSPersonalRoomChatResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomModeReq::kModeFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomModeReq::CSPersonalRoomModeReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomModeReq)
}

void CSPersonalRoomModeReq::InitAsDefaultInstance() {
}

CSPersonalRoomModeReq::CSPersonalRoomModeReq(const CSPersonalRoomModeReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomModeReq)
}

void CSPersonalRoomModeReq::SharedCtor() {
  _cached_size_ = 0;
  mode_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomModeReq::~CSPersonalRoomModeReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomModeReq)
  SharedDtor();
}

void CSPersonalRoomModeReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomModeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomModeReq& CSPersonalRoomModeReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomModeReq* CSPersonalRoomModeReq::default_instance_ = NULL;

CSPersonalRoomModeReq* CSPersonalRoomModeReq::New() const {
  return new CSPersonalRoomModeReq;
}

void CSPersonalRoomModeReq::Clear() {
  mode_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomModeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomModeReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Mode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mode_)));
          set_has_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomModeReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomModeReq)
  return false;
#undef DO_
}

void CSPersonalRoomModeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomModeReq)
  // required uint32 Mode = 1;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->mode(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomModeReq)
}

int CSPersonalRoomModeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Mode = 1;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mode());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomModeReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomModeReq*>(&from));
}

void CSPersonalRoomModeReq::MergeFrom(const CSPersonalRoomModeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mode()) {
      set_mode(from.mode());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomModeReq::CopyFrom(const CSPersonalRoomModeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomModeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPersonalRoomModeReq::Swap(CSPersonalRoomModeReq* other) {
  if (other != this) {
    std::swap(mode_, other->mode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomModeReq::GetTypeName() const {
  return "fgame.CSPersonalRoomModeReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomModeResp::kModeFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomModeResp::CSPersonalRoomModeResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomModeResp)
}

void CSPersonalRoomModeResp::InitAsDefaultInstance() {
}

CSPersonalRoomModeResp::CSPersonalRoomModeResp(const CSPersonalRoomModeResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomModeResp)
}

void CSPersonalRoomModeResp::SharedCtor() {
  _cached_size_ = 0;
  mode_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomModeResp::~CSPersonalRoomModeResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomModeResp)
  SharedDtor();
}

void CSPersonalRoomModeResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomModeResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomModeResp& CSPersonalRoomModeResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomModeResp* CSPersonalRoomModeResp::default_instance_ = NULL;

CSPersonalRoomModeResp* CSPersonalRoomModeResp::New() const {
  return new CSPersonalRoomModeResp;
}

void CSPersonalRoomModeResp::Clear() {
  mode_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomModeResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomModeResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Mode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mode_)));
          set_has_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomModeResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomModeResp)
  return false;
#undef DO_
}

void CSPersonalRoomModeResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomModeResp)
  // required uint32 Mode = 1;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->mode(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomModeResp)
}

int CSPersonalRoomModeResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Mode = 1;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mode());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomModeResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomModeResp*>(&from));
}

void CSPersonalRoomModeResp::MergeFrom(const CSPersonalRoomModeResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mode()) {
      set_mode(from.mode());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomModeResp::CopyFrom(const CSPersonalRoomModeResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomModeResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPersonalRoomModeResp::Swap(CSPersonalRoomModeResp* other) {
  if (other != this) {
    std::swap(mode_, other->mode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomModeResp::GetTypeName() const {
  return "fgame.CSPersonalRoomModeResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSPersonalRoomBeginFightReq::CSPersonalRoomBeginFightReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomBeginFightReq)
}

void CSPersonalRoomBeginFightReq::InitAsDefaultInstance() {
}

CSPersonalRoomBeginFightReq::CSPersonalRoomBeginFightReq(const CSPersonalRoomBeginFightReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomBeginFightReq)
}

void CSPersonalRoomBeginFightReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomBeginFightReq::~CSPersonalRoomBeginFightReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomBeginFightReq)
  SharedDtor();
}

void CSPersonalRoomBeginFightReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomBeginFightReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomBeginFightReq& CSPersonalRoomBeginFightReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomBeginFightReq* CSPersonalRoomBeginFightReq::default_instance_ = NULL;

CSPersonalRoomBeginFightReq* CSPersonalRoomBeginFightReq::New() const {
  return new CSPersonalRoomBeginFightReq;
}

void CSPersonalRoomBeginFightReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomBeginFightReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomBeginFightReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomBeginFightReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomBeginFightReq)
  return false;
#undef DO_
}

void CSPersonalRoomBeginFightReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomBeginFightReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomBeginFightReq)
}

int CSPersonalRoomBeginFightReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomBeginFightReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomBeginFightReq*>(&from));
}

void CSPersonalRoomBeginFightReq::MergeFrom(const CSPersonalRoomBeginFightReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomBeginFightReq::CopyFrom(const CSPersonalRoomBeginFightReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomBeginFightReq::IsInitialized() const {

  return true;
}

void CSPersonalRoomBeginFightReq::Swap(CSPersonalRoomBeginFightReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomBeginFightReq::GetTypeName() const {
  return "fgame.CSPersonalRoomBeginFightReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomBeginFightResp::kRoomIDFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomBeginFightResp::CSPersonalRoomBeginFightResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomBeginFightResp)
}

void CSPersonalRoomBeginFightResp::InitAsDefaultInstance() {
}

CSPersonalRoomBeginFightResp::CSPersonalRoomBeginFightResp(const CSPersonalRoomBeginFightResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomBeginFightResp)
}

void CSPersonalRoomBeginFightResp::SharedCtor() {
  _cached_size_ = 0;
  roomid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomBeginFightResp::~CSPersonalRoomBeginFightResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomBeginFightResp)
  SharedDtor();
}

void CSPersonalRoomBeginFightResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomBeginFightResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomBeginFightResp& CSPersonalRoomBeginFightResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomBeginFightResp* CSPersonalRoomBeginFightResp::default_instance_ = NULL;

CSPersonalRoomBeginFightResp* CSPersonalRoomBeginFightResp::New() const {
  return new CSPersonalRoomBeginFightResp;
}

void CSPersonalRoomBeginFightResp::Clear() {
  roomid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomBeginFightResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomBeginFightResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 RoomID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomBeginFightResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomBeginFightResp)
  return false;
#undef DO_
}

void CSPersonalRoomBeginFightResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomBeginFightResp)
  // required uint32 RoomID = 1;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->roomid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomBeginFightResp)
}

int CSPersonalRoomBeginFightResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 RoomID = 1;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomBeginFightResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomBeginFightResp*>(&from));
}

void CSPersonalRoomBeginFightResp::MergeFrom(const CSPersonalRoomBeginFightResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomBeginFightResp::CopyFrom(const CSPersonalRoomBeginFightResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomBeginFightResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPersonalRoomBeginFightResp::Swap(CSPersonalRoomBeginFightResp* other) {
  if (other != this) {
    std::swap(roomid_, other->roomid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomBeginFightResp::GetTypeName() const {
  return "fgame.CSPersonalRoomBeginFightResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomApplyOrRefuseInviteReq::kIsApplyFieldNumber;
const int CSPersonalRoomApplyOrRefuseInviteReq::kRoomIDFieldNumber;
const int CSPersonalRoomApplyOrRefuseInviteReq::kUinFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomApplyOrRefuseInviteReq::CSPersonalRoomApplyOrRefuseInviteReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomApplyOrRefuseInviteReq)
}

void CSPersonalRoomApplyOrRefuseInviteReq::InitAsDefaultInstance() {
}

CSPersonalRoomApplyOrRefuseInviteReq::CSPersonalRoomApplyOrRefuseInviteReq(const CSPersonalRoomApplyOrRefuseInviteReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomApplyOrRefuseInviteReq)
}

void CSPersonalRoomApplyOrRefuseInviteReq::SharedCtor() {
  _cached_size_ = 0;
  isapply_ = false;
  roomid_ = 0u;
  uin_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomApplyOrRefuseInviteReq::~CSPersonalRoomApplyOrRefuseInviteReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomApplyOrRefuseInviteReq)
  SharedDtor();
}

void CSPersonalRoomApplyOrRefuseInviteReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomApplyOrRefuseInviteReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomApplyOrRefuseInviteReq& CSPersonalRoomApplyOrRefuseInviteReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomApplyOrRefuseInviteReq* CSPersonalRoomApplyOrRefuseInviteReq::default_instance_ = NULL;

CSPersonalRoomApplyOrRefuseInviteReq* CSPersonalRoomApplyOrRefuseInviteReq::New() const {
  return new CSPersonalRoomApplyOrRefuseInviteReq;
}

void CSPersonalRoomApplyOrRefuseInviteReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPersonalRoomApplyOrRefuseInviteReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(isapply_, uin_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomApplyOrRefuseInviteReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomApplyOrRefuseInviteReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool IsApply = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isapply_)));
          set_has_isapply();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_RoomID;
        break;
      }

      // required uint32 RoomID = 2;
      case 2: {
        if (tag == 16) {
         parse_RoomID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Uin;
        break;
      }

      // required uint64 Uin = 3;
      case 3: {
        if (tag == 24) {
         parse_Uin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uin_)));
          set_has_uin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomApplyOrRefuseInviteReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomApplyOrRefuseInviteReq)
  return false;
#undef DO_
}

void CSPersonalRoomApplyOrRefuseInviteReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomApplyOrRefuseInviteReq)
  // required bool IsApply = 1;
  if (has_isapply()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->isapply(), output);
  }

  // required uint32 RoomID = 2;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->roomid(), output);
  }

  // required uint64 Uin = 3;
  if (has_uin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->uin(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomApplyOrRefuseInviteReq)
}

int CSPersonalRoomApplyOrRefuseInviteReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool IsApply = 1;
    if (has_isapply()) {
      total_size += 1 + 1;
    }

    // required uint32 RoomID = 2;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

    // required uint64 Uin = 3;
    if (has_uin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uin());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomApplyOrRefuseInviteReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomApplyOrRefuseInviteReq*>(&from));
}

void CSPersonalRoomApplyOrRefuseInviteReq::MergeFrom(const CSPersonalRoomApplyOrRefuseInviteReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_isapply()) {
      set_isapply(from.isapply());
    }
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_uin()) {
      set_uin(from.uin());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomApplyOrRefuseInviteReq::CopyFrom(const CSPersonalRoomApplyOrRefuseInviteReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomApplyOrRefuseInviteReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSPersonalRoomApplyOrRefuseInviteReq::Swap(CSPersonalRoomApplyOrRefuseInviteReq* other) {
  if (other != this) {
    std::swap(isapply_, other->isapply_);
    std::swap(roomid_, other->roomid_);
    std::swap(uin_, other->uin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomApplyOrRefuseInviteReq::GetTypeName() const {
  return "fgame.CSPersonalRoomApplyOrRefuseInviteReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomApplyOrRefuseInviteResp::kIsApplyFieldNumber;
const int CSPersonalRoomApplyOrRefuseInviteResp::kRoomIDFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomApplyOrRefuseInviteResp::CSPersonalRoomApplyOrRefuseInviteResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomApplyOrRefuseInviteResp)
}

void CSPersonalRoomApplyOrRefuseInviteResp::InitAsDefaultInstance() {
}

CSPersonalRoomApplyOrRefuseInviteResp::CSPersonalRoomApplyOrRefuseInviteResp(const CSPersonalRoomApplyOrRefuseInviteResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomApplyOrRefuseInviteResp)
}

void CSPersonalRoomApplyOrRefuseInviteResp::SharedCtor() {
  _cached_size_ = 0;
  isapply_ = false;
  roomid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomApplyOrRefuseInviteResp::~CSPersonalRoomApplyOrRefuseInviteResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomApplyOrRefuseInviteResp)
  SharedDtor();
}

void CSPersonalRoomApplyOrRefuseInviteResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomApplyOrRefuseInviteResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomApplyOrRefuseInviteResp& CSPersonalRoomApplyOrRefuseInviteResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomApplyOrRefuseInviteResp* CSPersonalRoomApplyOrRefuseInviteResp::default_instance_ = NULL;

CSPersonalRoomApplyOrRefuseInviteResp* CSPersonalRoomApplyOrRefuseInviteResp::New() const {
  return new CSPersonalRoomApplyOrRefuseInviteResp;
}

void CSPersonalRoomApplyOrRefuseInviteResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPersonalRoomApplyOrRefuseInviteResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(isapply_, roomid_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomApplyOrRefuseInviteResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomApplyOrRefuseInviteResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool IsApply = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isapply_)));
          set_has_isapply();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_RoomID;
        break;
      }

      // optional uint32 RoomID = 2;
      case 2: {
        if (tag == 16) {
         parse_RoomID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomApplyOrRefuseInviteResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomApplyOrRefuseInviteResp)
  return false;
#undef DO_
}

void CSPersonalRoomApplyOrRefuseInviteResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomApplyOrRefuseInviteResp)
  // required bool IsApply = 1;
  if (has_isapply()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->isapply(), output);
  }

  // optional uint32 RoomID = 2;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->roomid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomApplyOrRefuseInviteResp)
}

int CSPersonalRoomApplyOrRefuseInviteResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool IsApply = 1;
    if (has_isapply()) {
      total_size += 1 + 1;
    }

    // optional uint32 RoomID = 2;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomApplyOrRefuseInviteResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomApplyOrRefuseInviteResp*>(&from));
}

void CSPersonalRoomApplyOrRefuseInviteResp::MergeFrom(const CSPersonalRoomApplyOrRefuseInviteResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_isapply()) {
      set_isapply(from.isapply());
    }
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomApplyOrRefuseInviteResp::CopyFrom(const CSPersonalRoomApplyOrRefuseInviteResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomApplyOrRefuseInviteResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPersonalRoomApplyOrRefuseInviteResp::Swap(CSPersonalRoomApplyOrRefuseInviteResp* other) {
  if (other != this) {
    std::swap(isapply_, other->isapply_);
    std::swap(roomid_, other->roomid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomApplyOrRefuseInviteResp::GetTypeName() const {
  return "fgame.CSPersonalRoomApplyOrRefuseInviteResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomCountDownReq::kRoomIDFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomCountDownReq::CSPersonalRoomCountDownReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomCountDownReq)
}

void CSPersonalRoomCountDownReq::InitAsDefaultInstance() {
}

CSPersonalRoomCountDownReq::CSPersonalRoomCountDownReq(const CSPersonalRoomCountDownReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomCountDownReq)
}

void CSPersonalRoomCountDownReq::SharedCtor() {
  _cached_size_ = 0;
  roomid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomCountDownReq::~CSPersonalRoomCountDownReq() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomCountDownReq)
  SharedDtor();
}

void CSPersonalRoomCountDownReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomCountDownReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomCountDownReq& CSPersonalRoomCountDownReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomCountDownReq* CSPersonalRoomCountDownReq::default_instance_ = NULL;

CSPersonalRoomCountDownReq* CSPersonalRoomCountDownReq::New() const {
  return new CSPersonalRoomCountDownReq;
}

void CSPersonalRoomCountDownReq::Clear() {
  roomid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomCountDownReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomCountDownReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 RoomID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomCountDownReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomCountDownReq)
  return false;
#undef DO_
}

void CSPersonalRoomCountDownReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomCountDownReq)
  // required uint32 RoomID = 1;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->roomid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomCountDownReq)
}

int CSPersonalRoomCountDownReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 RoomID = 1;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomCountDownReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomCountDownReq*>(&from));
}

void CSPersonalRoomCountDownReq::MergeFrom(const CSPersonalRoomCountDownReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomCountDownReq::CopyFrom(const CSPersonalRoomCountDownReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomCountDownReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPersonalRoomCountDownReq::Swap(CSPersonalRoomCountDownReq* other) {
  if (other != this) {
    std::swap(roomid_, other->roomid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomCountDownReq::GetTypeName() const {
  return "fgame.CSPersonalRoomCountDownReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPersonalRoomCountDownResp::kRoomIDFieldNumber;
const int CSPersonalRoomCountDownResp::kSecondsFieldNumber;
#endif  // !_MSC_VER

CSPersonalRoomCountDownResp::CSPersonalRoomCountDownResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CSPersonalRoomCountDownResp)
}

void CSPersonalRoomCountDownResp::InitAsDefaultInstance() {
}

CSPersonalRoomCountDownResp::CSPersonalRoomCountDownResp(const CSPersonalRoomCountDownResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CSPersonalRoomCountDownResp)
}

void CSPersonalRoomCountDownResp::SharedCtor() {
  _cached_size_ = 0;
  roomid_ = 0u;
  seconds_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPersonalRoomCountDownResp::~CSPersonalRoomCountDownResp() {
  // @@protoc_insertion_point(destructor:fgame.CSPersonalRoomCountDownResp)
  SharedDtor();
}

void CSPersonalRoomCountDownResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPersonalRoomCountDownResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPersonalRoomCountDownResp& CSPersonalRoomCountDownResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_PvpPersonalRoom_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_PvpPersonalRoom_2eproto();
#endif
  return *default_instance_;
}

CSPersonalRoomCountDownResp* CSPersonalRoomCountDownResp::default_instance_ = NULL;

CSPersonalRoomCountDownResp* CSPersonalRoomCountDownResp::New() const {
  return new CSPersonalRoomCountDownResp;
}

void CSPersonalRoomCountDownResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CSPersonalRoomCountDownResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(roomid_, seconds_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CSPersonalRoomCountDownResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CSPersonalRoomCountDownResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 RoomID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Seconds;
        break;
      }

      // required uint32 Seconds = 2;
      case 2: {
        if (tag == 16) {
         parse_Seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &seconds_)));
          set_has_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CSPersonalRoomCountDownResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CSPersonalRoomCountDownResp)
  return false;
#undef DO_
}

void CSPersonalRoomCountDownResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CSPersonalRoomCountDownResp)
  // required uint32 RoomID = 1;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->roomid(), output);
  }

  // required uint32 Seconds = 2;
  if (has_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->seconds(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CSPersonalRoomCountDownResp)
}

int CSPersonalRoomCountDownResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 RoomID = 1;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

    // required uint32 Seconds = 2;
    if (has_seconds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->seconds());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPersonalRoomCountDownResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPersonalRoomCountDownResp*>(&from));
}

void CSPersonalRoomCountDownResp::MergeFrom(const CSPersonalRoomCountDownResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_seconds()) {
      set_seconds(from.seconds());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CSPersonalRoomCountDownResp::CopyFrom(const CSPersonalRoomCountDownResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPersonalRoomCountDownResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSPersonalRoomCountDownResp::Swap(CSPersonalRoomCountDownResp* other) {
  if (other != this) {
    std::swap(roomid_, other->roomid_);
    std::swap(seconds_, other->seconds_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPersonalRoomCountDownResp::GetTypeName() const {
  return "fgame.CSPersonalRoomCountDownResp";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fgame

// @@protoc_insertion_point(global_scope)
