// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PvpPersonalRoom.proto

#ifndef PROTOBUF_PvpPersonalRoom_2eproto__INCLUDED
#define PROTOBUF_PvpPersonalRoom_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "Friend.pb.h"
#include "Player.pb.h"
// @@protoc_insertion_point(includes)

namespace fgame {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

class CSPersonalRoomCreateReq;
class CSPersonalRoomCreateResp;
class CSPersonalRoomPlayerInfo;
class CSPersonalRoomEnterReq;
class CSPersonalRoomEnterResp;
class CSPersonalRoomLeaveReq;
class CSPersonalRoomLeaveResp;
class CSPersonalRoomKickReq;
class CSPersonalRoomKickResp;
class CSPersonalRoomInviteReq;
class CSPersonalRoomInviteResp;
class CSPersonalRoomBroadcastReq;
class CSPersonalRoomBroadcastResp;
class CSPersonalRoomChatReq;
class CSPersonalRoomChatResp;
class CSPersonalRoomModeReq;
class CSPersonalRoomModeResp;
class CSPersonalRoomBeginFightReq;
class CSPersonalRoomBeginFightResp;
class CSPersonalRoomApplyOrRefuseInviteReq;
class CSPersonalRoomApplyOrRefuseInviteResp;
class CSPersonalRoomCountDownReq;
class CSPersonalRoomCountDownResp;

// ===================================================================

class CSPersonalRoomCreateReq : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomCreateReq();
  virtual ~CSPersonalRoomCreateReq();

  CSPersonalRoomCreateReq(const CSPersonalRoomCreateReq& from);

  inline CSPersonalRoomCreateReq& operator=(const CSPersonalRoomCreateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomCreateReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomCreateReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomCreateReq* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomCreateReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomCreateReq& from);
  void MergeFrom(const CSPersonalRoomCreateReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomCreateReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomCreateReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomCreateResp : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomCreateResp();
  virtual ~CSPersonalRoomCreateResp();

  CSPersonalRoomCreateResp(const CSPersonalRoomCreateResp& from);

  inline CSPersonalRoomCreateResp& operator=(const CSPersonalRoomCreateResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomCreateResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomCreateResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomCreateResp* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomCreateResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomCreateResp& from);
  void MergeFrom(const CSPersonalRoomCreateResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 RoomID = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 1;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomCreateResp)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 roomid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomCreateResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomPlayerInfo : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomPlayerInfo();
  virtual ~CSPersonalRoomPlayerInfo();

  CSPersonalRoomPlayerInfo(const CSPersonalRoomPlayerInfo& from);

  inline CSPersonalRoomPlayerInfo& operator=(const CSPersonalRoomPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomPlayerInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomPlayerInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomPlayerInfo* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomPlayerInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomPlayerInfo& from);
  void MergeFrom(const CSPersonalRoomPlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string Icon = 3;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 3;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // required uint32 Group = 4;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 4;
  inline ::google::protobuf::uint32 group() const;
  inline void set_group(::google::protobuf::uint32 value);

  // required uint32 Rank = 5;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 5;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // required uint32 WinRate = 6;
  inline bool has_winrate() const;
  inline void clear_winrate();
  static const int kWinRateFieldNumber = 6;
  inline ::google::protobuf::uint32 winrate() const;
  inline void set_winrate(::google::protobuf::uint32 value);

  // required uint32 Index = 7;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 7;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 Score = 8;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 8;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // optional uint64 Title = 9;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 9;
  inline ::google::protobuf::uint64 title() const;
  inline void set_title(::google::protobuf::uint64 value);

  // optional uint32 Level = 10;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 10;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 VipLevel = 11;
  inline bool has_viplevel() const;
  inline void clear_viplevel();
  static const int kVipLevelFieldNumber = 11;
  inline ::google::protobuf::uint32 viplevel() const;
  inline void set_viplevel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomPlayerInfo)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_winrate();
  inline void clear_has_winrate();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_viplevel();
  inline void clear_has_viplevel();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  ::std::string* name_;
  ::std::string* icon_;
  ::google::protobuf::uint32 group_;
  ::google::protobuf::uint32 rank_;
  ::google::protobuf::uint32 winrate_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint64 title_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 viplevel_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomPlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomEnterReq : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomEnterReq();
  virtual ~CSPersonalRoomEnterReq();

  CSPersonalRoomEnterReq(const CSPersonalRoomEnterReq& from);

  inline CSPersonalRoomEnterReq& operator=(const CSPersonalRoomEnterReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomEnterReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomEnterReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomEnterReq* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomEnterReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomEnterReq& from);
  void MergeFrom(const CSPersonalRoomEnterReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 RoomID = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 1;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // optional string ServerNode = 2;
  inline bool has_servernode() const;
  inline void clear_servernode();
  static const int kServerNodeFieldNumber = 2;
  inline const ::std::string& servernode() const;
  inline void set_servernode(const ::std::string& value);
  inline void set_servernode(const char* value);
  inline void set_servernode(const char* value, size_t size);
  inline ::std::string* mutable_servernode();
  inline ::std::string* release_servernode();
  inline void set_allocated_servernode(::std::string* servernode);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomEnterReq)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_servernode();
  inline void clear_has_servernode();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* servernode_;
  ::google::protobuf::uint32 roomid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomEnterReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomEnterResp : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomEnterResp();
  virtual ~CSPersonalRoomEnterResp();

  CSPersonalRoomEnterResp(const CSPersonalRoomEnterResp& from);

  inline CSPersonalRoomEnterResp& operator=(const CSPersonalRoomEnterResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomEnterResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomEnterResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomEnterResp* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomEnterResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomEnterResp& from);
  void MergeFrom(const CSPersonalRoomEnterResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 RoomID = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 1;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // repeated .fgame.CSPersonalRoomPlayerInfo Players = 2;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 2;
  inline const ::fgame::CSPersonalRoomPlayerInfo& players(int index) const;
  inline ::fgame::CSPersonalRoomPlayerInfo* mutable_players(int index);
  inline ::fgame::CSPersonalRoomPlayerInfo* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPersonalRoomPlayerInfo >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPersonalRoomPlayerInfo >*
      mutable_players();

  // optional uint64 LeftSeconds = 3;
  inline bool has_leftseconds() const;
  inline void clear_leftseconds();
  static const int kLeftSecondsFieldNumber = 3;
  inline ::google::protobuf::uint64 leftseconds() const;
  inline void set_leftseconds(::google::protobuf::uint64 value);

  // optional uint32 RoomType = 4;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 roomtype() const;
  inline void set_roomtype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomEnterResp)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_leftseconds();
  inline void clear_has_leftseconds();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fgame::CSPersonalRoomPlayerInfo > players_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 roomtype_;
  ::google::protobuf::uint64 leftseconds_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomEnterResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomLeaveReq : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomLeaveReq();
  virtual ~CSPersonalRoomLeaveReq();

  CSPersonalRoomLeaveReq(const CSPersonalRoomLeaveReq& from);

  inline CSPersonalRoomLeaveReq& operator=(const CSPersonalRoomLeaveReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomLeaveReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomLeaveReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomLeaveReq* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomLeaveReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomLeaveReq& from);
  void MergeFrom(const CSPersonalRoomLeaveReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 RoomID = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 1;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomLeaveReq)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 roomid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomLeaveReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomLeaveResp : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomLeaveResp();
  virtual ~CSPersonalRoomLeaveResp();

  CSPersonalRoomLeaveResp(const CSPersonalRoomLeaveResp& from);

  inline CSPersonalRoomLeaveResp& operator=(const CSPersonalRoomLeaveResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomLeaveResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomLeaveResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomLeaveResp* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomLeaveResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomLeaveResp& from);
  void MergeFrom(const CSPersonalRoomLeaveResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // optional uint32 RoomID = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 2;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomLeaveResp)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  ::google::protobuf::uint32 roomid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomLeaveResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomKickReq : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomKickReq();
  virtual ~CSPersonalRoomKickReq();

  CSPersonalRoomKickReq(const CSPersonalRoomKickReq& from);

  inline CSPersonalRoomKickReq& operator=(const CSPersonalRoomKickReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomKickReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomKickReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomKickReq* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomKickReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomKickReq& from);
  void MergeFrom(const CSPersonalRoomKickReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomKickReq)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomKickReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomKickResp : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomKickResp();
  virtual ~CSPersonalRoomKickResp();

  CSPersonalRoomKickResp(const CSPersonalRoomKickResp& from);

  inline CSPersonalRoomKickResp& operator=(const CSPersonalRoomKickResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomKickResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomKickResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomKickResp* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomKickResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomKickResp& from);
  void MergeFrom(const CSPersonalRoomKickResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomKickResp)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomKickResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomInviteReq : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomInviteReq();
  virtual ~CSPersonalRoomInviteReq();

  CSPersonalRoomInviteReq(const CSPersonalRoomInviteReq& from);

  inline CSPersonalRoomInviteReq& operator=(const CSPersonalRoomInviteReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomInviteReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomInviteReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomInviteReq* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomInviteReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomInviteReq& from);
  void MergeFrom(const CSPersonalRoomInviteReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomInviteReq)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomInviteReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomInviteResp : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomInviteResp();
  virtual ~CSPersonalRoomInviteResp();

  CSPersonalRoomInviteResp(const CSPersonalRoomInviteResp& from);

  inline CSPersonalRoomInviteResp& operator=(const CSPersonalRoomInviteResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomInviteResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomInviteResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomInviteResp* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomInviteResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomInviteResp& from);
  void MergeFrom(const CSPersonalRoomInviteResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // optional .fgame.FriendPkRequestInfo Info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::fgame::FriendPkRequestInfo& info() const;
  inline ::fgame::FriendPkRequestInfo* mutable_info();
  inline ::fgame::FriendPkRequestInfo* release_info();
  inline void set_allocated_info(::fgame::FriendPkRequestInfo* info);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomInviteResp)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_info();
  inline void clear_has_info();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  ::fgame::FriendPkRequestInfo* info_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomInviteResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomBroadcastReq : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomBroadcastReq();
  virtual ~CSPersonalRoomBroadcastReq();

  CSPersonalRoomBroadcastReq(const CSPersonalRoomBroadcastReq& from);

  inline CSPersonalRoomBroadcastReq& operator=(const CSPersonalRoomBroadcastReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomBroadcastReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomBroadcastReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomBroadcastReq* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomBroadcastReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomBroadcastReq& from);
  void MergeFrom(const CSPersonalRoomBroadcastReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomBroadcastReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomBroadcastReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomBroadcastResp : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomBroadcastResp();
  virtual ~CSPersonalRoomBroadcastResp();

  CSPersonalRoomBroadcastResp(const CSPersonalRoomBroadcastResp& from);

  inline CSPersonalRoomBroadcastResp& operator=(const CSPersonalRoomBroadcastResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomBroadcastResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomBroadcastResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomBroadcastResp* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomBroadcastResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomBroadcastResp& from);
  void MergeFrom(const CSPersonalRoomBroadcastResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 RoomID = 3;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 3;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // required uint64 Time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // optional string Icon = 5;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 5;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // optional string ServerNode = 6;
  inline bool has_servernode() const;
  inline void clear_servernode();
  static const int kServerNodeFieldNumber = 6;
  inline const ::std::string& servernode() const;
  inline void set_servernode(const ::std::string& value);
  inline void set_servernode(const char* value);
  inline void set_servernode(const char* value, size_t size);
  inline ::std::string* mutable_servernode();
  inline ::std::string* release_servernode();
  inline void set_allocated_servernode(::std::string* servernode);

  // optional uint32 Title = 7;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 7;
  inline ::google::protobuf::uint32 title() const;
  inline void set_title(::google::protobuf::uint32 value);

  // optional uint32 VipLevel = 8;
  inline bool has_viplevel() const;
  inline void clear_viplevel();
  static const int kVipLevelFieldNumber = 8;
  inline ::google::protobuf::uint32 viplevel() const;
  inline void set_viplevel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomBroadcastResp)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_servernode();
  inline void clear_has_servernode();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_viplevel();
  inline void clear_has_viplevel();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  ::std::string* name_;
  ::google::protobuf::uint64 time_;
  ::std::string* icon_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 title_;
  ::std::string* servernode_;
  ::google::protobuf::uint32 viplevel_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomBroadcastResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomChatReq : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomChatReq();
  virtual ~CSPersonalRoomChatReq();

  CSPersonalRoomChatReq(const CSPersonalRoomChatReq& from);

  inline CSPersonalRoomChatReq& operator=(const CSPersonalRoomChatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomChatReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomChatReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomChatReq* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomChatReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomChatReq& from);
  void MergeFrom(const CSPersonalRoomChatReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string Words = 2;
  inline bool has_words() const;
  inline void clear_words();
  static const int kWordsFieldNumber = 2;
  inline const ::std::string& words() const;
  inline void set_words(const ::std::string& value);
  inline void set_words(const char* value);
  inline void set_words(const char* value, size_t size);
  inline ::std::string* mutable_words();
  inline ::std::string* release_words();
  inline void set_allocated_words(::std::string* words);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomChatReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_words();
  inline void clear_has_words();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* words_;
  ::google::protobuf::uint32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomChatReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomChatResp : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomChatResp();
  virtual ~CSPersonalRoomChatResp();

  CSPersonalRoomChatResp(const CSPersonalRoomChatResp& from);

  inline CSPersonalRoomChatResp& operator=(const CSPersonalRoomChatResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomChatResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomChatResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomChatResp* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomChatResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomChatResp& from);
  void MergeFrom(const CSPersonalRoomChatResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required uint32 ID = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required string Words = 3;
  inline bool has_words() const;
  inline void clear_words();
  static const int kWordsFieldNumber = 3;
  inline const ::std::string& words() const;
  inline void set_words(const ::std::string& value);
  inline void set_words(const char* value);
  inline void set_words(const char* value, size_t size);
  inline ::std::string* mutable_words();
  inline ::std::string* release_words();
  inline void set_allocated_words(::std::string* words);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomChatResp)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_words();
  inline void clear_has_words();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uin_;
  ::std::string* words_;
  ::google::protobuf::uint32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomChatResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomModeReq : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomModeReq();
  virtual ~CSPersonalRoomModeReq();

  CSPersonalRoomModeReq(const CSPersonalRoomModeReq& from);

  inline CSPersonalRoomModeReq& operator=(const CSPersonalRoomModeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomModeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomModeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomModeReq* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomModeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomModeReq& from);
  void MergeFrom(const CSPersonalRoomModeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomModeReq)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 mode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomModeReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomModeResp : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomModeResp();
  virtual ~CSPersonalRoomModeResp();

  CSPersonalRoomModeResp(const CSPersonalRoomModeResp& from);

  inline CSPersonalRoomModeResp& operator=(const CSPersonalRoomModeResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomModeResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomModeResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomModeResp* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomModeResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomModeResp& from);
  void MergeFrom(const CSPersonalRoomModeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomModeResp)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 mode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomModeResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomBeginFightReq : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomBeginFightReq();
  virtual ~CSPersonalRoomBeginFightReq();

  CSPersonalRoomBeginFightReq(const CSPersonalRoomBeginFightReq& from);

  inline CSPersonalRoomBeginFightReq& operator=(const CSPersonalRoomBeginFightReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomBeginFightReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomBeginFightReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomBeginFightReq* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomBeginFightReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomBeginFightReq& from);
  void MergeFrom(const CSPersonalRoomBeginFightReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomBeginFightReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomBeginFightReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomBeginFightResp : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomBeginFightResp();
  virtual ~CSPersonalRoomBeginFightResp();

  CSPersonalRoomBeginFightResp(const CSPersonalRoomBeginFightResp& from);

  inline CSPersonalRoomBeginFightResp& operator=(const CSPersonalRoomBeginFightResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomBeginFightResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomBeginFightResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomBeginFightResp* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomBeginFightResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomBeginFightResp& from);
  void MergeFrom(const CSPersonalRoomBeginFightResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 RoomID = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 1;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomBeginFightResp)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 roomid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomBeginFightResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomApplyOrRefuseInviteReq : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomApplyOrRefuseInviteReq();
  virtual ~CSPersonalRoomApplyOrRefuseInviteReq();

  CSPersonalRoomApplyOrRefuseInviteReq(const CSPersonalRoomApplyOrRefuseInviteReq& from);

  inline CSPersonalRoomApplyOrRefuseInviteReq& operator=(const CSPersonalRoomApplyOrRefuseInviteReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomApplyOrRefuseInviteReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomApplyOrRefuseInviteReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomApplyOrRefuseInviteReq* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomApplyOrRefuseInviteReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomApplyOrRefuseInviteReq& from);
  void MergeFrom(const CSPersonalRoomApplyOrRefuseInviteReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool IsApply = 1;
  inline bool has_isapply() const;
  inline void clear_isapply();
  static const int kIsApplyFieldNumber = 1;
  inline bool isapply() const;
  inline void set_isapply(bool value);

  // required uint32 RoomID = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 2;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // required uint64 Uin = 3;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 3;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomApplyOrRefuseInviteReq)
 private:
  inline void set_has_isapply();
  inline void clear_has_isapply();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_uin();
  inline void clear_has_uin();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool isapply_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint64 uin_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomApplyOrRefuseInviteReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomApplyOrRefuseInviteResp : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomApplyOrRefuseInviteResp();
  virtual ~CSPersonalRoomApplyOrRefuseInviteResp();

  CSPersonalRoomApplyOrRefuseInviteResp(const CSPersonalRoomApplyOrRefuseInviteResp& from);

  inline CSPersonalRoomApplyOrRefuseInviteResp& operator=(const CSPersonalRoomApplyOrRefuseInviteResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomApplyOrRefuseInviteResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomApplyOrRefuseInviteResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomApplyOrRefuseInviteResp* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomApplyOrRefuseInviteResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomApplyOrRefuseInviteResp& from);
  void MergeFrom(const CSPersonalRoomApplyOrRefuseInviteResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool IsApply = 1;
  inline bool has_isapply() const;
  inline void clear_isapply();
  static const int kIsApplyFieldNumber = 1;
  inline bool isapply() const;
  inline void set_isapply(bool value);

  // optional uint32 RoomID = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 2;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomApplyOrRefuseInviteResp)
 private:
  inline void set_has_isapply();
  inline void clear_has_isapply();
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool isapply_;
  ::google::protobuf::uint32 roomid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomApplyOrRefuseInviteResp* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomCountDownReq : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomCountDownReq();
  virtual ~CSPersonalRoomCountDownReq();

  CSPersonalRoomCountDownReq(const CSPersonalRoomCountDownReq& from);

  inline CSPersonalRoomCountDownReq& operator=(const CSPersonalRoomCountDownReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomCountDownReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomCountDownReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomCountDownReq* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomCountDownReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomCountDownReq& from);
  void MergeFrom(const CSPersonalRoomCountDownReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 RoomID = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 1;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomCountDownReq)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 roomid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomCountDownReq* default_instance_;
};
// -------------------------------------------------------------------

class CSPersonalRoomCountDownResp : public ::google::protobuf::MessageLite {
 public:
  CSPersonalRoomCountDownResp();
  virtual ~CSPersonalRoomCountDownResp();

  CSPersonalRoomCountDownResp(const CSPersonalRoomCountDownResp& from);

  inline CSPersonalRoomCountDownResp& operator=(const CSPersonalRoomCountDownResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CSPersonalRoomCountDownResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPersonalRoomCountDownResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPersonalRoomCountDownResp* other);

  // implements Message ----------------------------------------------

  CSPersonalRoomCountDownResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPersonalRoomCountDownResp& from);
  void MergeFrom(const CSPersonalRoomCountDownResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 RoomID = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 1;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // required uint32 Seconds = 2;
  inline bool has_seconds() const;
  inline void clear_seconds();
  static const int kSecondsFieldNumber = 2;
  inline ::google::protobuf::uint32 seconds() const;
  inline void set_seconds(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fgame.CSPersonalRoomCountDownResp)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_seconds();
  inline void clear_has_seconds();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 seconds_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PvpPersonalRoom_2eproto();
  #endif
  friend void protobuf_AssignDesc_PvpPersonalRoom_2eproto();
  friend void protobuf_ShutdownFile_PvpPersonalRoom_2eproto();

  void InitAsDefaultInstance();
  static CSPersonalRoomCountDownResp* default_instance_;
};
// ===================================================================


// ===================================================================

// CSPersonalRoomCreateReq

// -------------------------------------------------------------------

// CSPersonalRoomCreateResp

// required uint32 RoomID = 1;
inline bool CSPersonalRoomCreateResp::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomCreateResp::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomCreateResp::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomCreateResp::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPersonalRoomCreateResp::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomCreateResp.RoomID)
  return roomid_;
}
inline void CSPersonalRoomCreateResp::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomCreateResp.RoomID)
}

// -------------------------------------------------------------------

// CSPersonalRoomPlayerInfo

// required uint64 Uin = 1;
inline bool CSPersonalRoomPlayerInfo::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomPlayerInfo::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomPlayerInfo::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomPlayerInfo::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPersonalRoomPlayerInfo::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomPlayerInfo.Uin)
  return uin_;
}
inline void CSPersonalRoomPlayerInfo::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomPlayerInfo.Uin)
}

// required string Name = 2;
inline bool CSPersonalRoomPlayerInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPersonalRoomPlayerInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPersonalRoomPlayerInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPersonalRoomPlayerInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSPersonalRoomPlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomPlayerInfo.Name)
  return *name_;
}
inline void CSPersonalRoomPlayerInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomPlayerInfo.Name)
}
inline void CSPersonalRoomPlayerInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPersonalRoomPlayerInfo.Name)
}
inline void CSPersonalRoomPlayerInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPersonalRoomPlayerInfo.Name)
}
inline ::std::string* CSPersonalRoomPlayerInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPersonalRoomPlayerInfo.Name)
  return name_;
}
inline ::std::string* CSPersonalRoomPlayerInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPersonalRoomPlayerInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPersonalRoomPlayerInfo.Name)
}

// required string Icon = 3;
inline bool CSPersonalRoomPlayerInfo::has_icon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPersonalRoomPlayerInfo::set_has_icon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPersonalRoomPlayerInfo::clear_has_icon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPersonalRoomPlayerInfo::clear_icon() {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& CSPersonalRoomPlayerInfo::icon() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomPlayerInfo.Icon)
  return *icon_;
}
inline void CSPersonalRoomPlayerInfo::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomPlayerInfo.Icon)
}
inline void CSPersonalRoomPlayerInfo::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPersonalRoomPlayerInfo.Icon)
}
inline void CSPersonalRoomPlayerInfo::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPersonalRoomPlayerInfo.Icon)
}
inline ::std::string* CSPersonalRoomPlayerInfo::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPersonalRoomPlayerInfo.Icon)
  return icon_;
}
inline ::std::string* CSPersonalRoomPlayerInfo::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPersonalRoomPlayerInfo::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPersonalRoomPlayerInfo.Icon)
}

// required uint32 Group = 4;
inline bool CSPersonalRoomPlayerInfo::has_group() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPersonalRoomPlayerInfo::set_has_group() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPersonalRoomPlayerInfo::clear_has_group() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPersonalRoomPlayerInfo::clear_group() {
  group_ = 0u;
  clear_has_group();
}
inline ::google::protobuf::uint32 CSPersonalRoomPlayerInfo::group() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomPlayerInfo.Group)
  return group_;
}
inline void CSPersonalRoomPlayerInfo::set_group(::google::protobuf::uint32 value) {
  set_has_group();
  group_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomPlayerInfo.Group)
}

// required uint32 Rank = 5;
inline bool CSPersonalRoomPlayerInfo::has_rank() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPersonalRoomPlayerInfo::set_has_rank() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPersonalRoomPlayerInfo::clear_has_rank() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPersonalRoomPlayerInfo::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 CSPersonalRoomPlayerInfo::rank() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomPlayerInfo.Rank)
  return rank_;
}
inline void CSPersonalRoomPlayerInfo::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomPlayerInfo.Rank)
}

// required uint32 WinRate = 6;
inline bool CSPersonalRoomPlayerInfo::has_winrate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPersonalRoomPlayerInfo::set_has_winrate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPersonalRoomPlayerInfo::clear_has_winrate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPersonalRoomPlayerInfo::clear_winrate() {
  winrate_ = 0u;
  clear_has_winrate();
}
inline ::google::protobuf::uint32 CSPersonalRoomPlayerInfo::winrate() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomPlayerInfo.WinRate)
  return winrate_;
}
inline void CSPersonalRoomPlayerInfo::set_winrate(::google::protobuf::uint32 value) {
  set_has_winrate();
  winrate_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomPlayerInfo.WinRate)
}

// required uint32 Index = 7;
inline bool CSPersonalRoomPlayerInfo::has_index() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSPersonalRoomPlayerInfo::set_has_index() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSPersonalRoomPlayerInfo::clear_has_index() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSPersonalRoomPlayerInfo::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CSPersonalRoomPlayerInfo::index() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomPlayerInfo.Index)
  return index_;
}
inline void CSPersonalRoomPlayerInfo::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomPlayerInfo.Index)
}

// optional uint32 Score = 8;
inline bool CSPersonalRoomPlayerInfo::has_score() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSPersonalRoomPlayerInfo::set_has_score() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSPersonalRoomPlayerInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSPersonalRoomPlayerInfo::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 CSPersonalRoomPlayerInfo::score() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomPlayerInfo.Score)
  return score_;
}
inline void CSPersonalRoomPlayerInfo::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomPlayerInfo.Score)
}

// optional uint64 Title = 9;
inline bool CSPersonalRoomPlayerInfo::has_title() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSPersonalRoomPlayerInfo::set_has_title() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSPersonalRoomPlayerInfo::clear_has_title() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSPersonalRoomPlayerInfo::clear_title() {
  title_ = GOOGLE_ULONGLONG(0);
  clear_has_title();
}
inline ::google::protobuf::uint64 CSPersonalRoomPlayerInfo::title() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomPlayerInfo.Title)
  return title_;
}
inline void CSPersonalRoomPlayerInfo::set_title(::google::protobuf::uint64 value) {
  set_has_title();
  title_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomPlayerInfo.Title)
}

// optional uint32 Level = 10;
inline bool CSPersonalRoomPlayerInfo::has_level() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSPersonalRoomPlayerInfo::set_has_level() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSPersonalRoomPlayerInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSPersonalRoomPlayerInfo::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 CSPersonalRoomPlayerInfo::level() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomPlayerInfo.Level)
  return level_;
}
inline void CSPersonalRoomPlayerInfo::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomPlayerInfo.Level)
}

// optional uint32 VipLevel = 11;
inline bool CSPersonalRoomPlayerInfo::has_viplevel() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CSPersonalRoomPlayerInfo::set_has_viplevel() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CSPersonalRoomPlayerInfo::clear_has_viplevel() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CSPersonalRoomPlayerInfo::clear_viplevel() {
  viplevel_ = 0u;
  clear_has_viplevel();
}
inline ::google::protobuf::uint32 CSPersonalRoomPlayerInfo::viplevel() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomPlayerInfo.VipLevel)
  return viplevel_;
}
inline void CSPersonalRoomPlayerInfo::set_viplevel(::google::protobuf::uint32 value) {
  set_has_viplevel();
  viplevel_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomPlayerInfo.VipLevel)
}

// -------------------------------------------------------------------

// CSPersonalRoomEnterReq

// required uint32 RoomID = 1;
inline bool CSPersonalRoomEnterReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomEnterReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomEnterReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomEnterReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPersonalRoomEnterReq::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomEnterReq.RoomID)
  return roomid_;
}
inline void CSPersonalRoomEnterReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomEnterReq.RoomID)
}

// optional string ServerNode = 2;
inline bool CSPersonalRoomEnterReq::has_servernode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPersonalRoomEnterReq::set_has_servernode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPersonalRoomEnterReq::clear_has_servernode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPersonalRoomEnterReq::clear_servernode() {
  if (servernode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servernode_->clear();
  }
  clear_has_servernode();
}
inline const ::std::string& CSPersonalRoomEnterReq::servernode() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomEnterReq.ServerNode)
  return *servernode_;
}
inline void CSPersonalRoomEnterReq::set_servernode(const ::std::string& value) {
  set_has_servernode();
  if (servernode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servernode_ = new ::std::string;
  }
  servernode_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomEnterReq.ServerNode)
}
inline void CSPersonalRoomEnterReq::set_servernode(const char* value) {
  set_has_servernode();
  if (servernode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servernode_ = new ::std::string;
  }
  servernode_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPersonalRoomEnterReq.ServerNode)
}
inline void CSPersonalRoomEnterReq::set_servernode(const char* value, size_t size) {
  set_has_servernode();
  if (servernode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servernode_ = new ::std::string;
  }
  servernode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPersonalRoomEnterReq.ServerNode)
}
inline ::std::string* CSPersonalRoomEnterReq::mutable_servernode() {
  set_has_servernode();
  if (servernode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servernode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPersonalRoomEnterReq.ServerNode)
  return servernode_;
}
inline ::std::string* CSPersonalRoomEnterReq::release_servernode() {
  clear_has_servernode();
  if (servernode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = servernode_;
    servernode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPersonalRoomEnterReq::set_allocated_servernode(::std::string* servernode) {
  if (servernode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete servernode_;
  }
  if (servernode) {
    set_has_servernode();
    servernode_ = servernode;
  } else {
    clear_has_servernode();
    servernode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPersonalRoomEnterReq.ServerNode)
}

// -------------------------------------------------------------------

// CSPersonalRoomEnterResp

// required uint32 RoomID = 1;
inline bool CSPersonalRoomEnterResp::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomEnterResp::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomEnterResp::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomEnterResp::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPersonalRoomEnterResp::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomEnterResp.RoomID)
  return roomid_;
}
inline void CSPersonalRoomEnterResp::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomEnterResp.RoomID)
}

// repeated .fgame.CSPersonalRoomPlayerInfo Players = 2;
inline int CSPersonalRoomEnterResp::players_size() const {
  return players_.size();
}
inline void CSPersonalRoomEnterResp::clear_players() {
  players_.Clear();
}
inline const ::fgame::CSPersonalRoomPlayerInfo& CSPersonalRoomEnterResp::players(int index) const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomEnterResp.Players)
  return players_.Get(index);
}
inline ::fgame::CSPersonalRoomPlayerInfo* CSPersonalRoomEnterResp::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:fgame.CSPersonalRoomEnterResp.Players)
  return players_.Mutable(index);
}
inline ::fgame::CSPersonalRoomPlayerInfo* CSPersonalRoomEnterResp::add_players() {
  // @@protoc_insertion_point(field_add:fgame.CSPersonalRoomEnterResp.Players)
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fgame::CSPersonalRoomPlayerInfo >&
CSPersonalRoomEnterResp::players() const {
  // @@protoc_insertion_point(field_list:fgame.CSPersonalRoomEnterResp.Players)
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::fgame::CSPersonalRoomPlayerInfo >*
CSPersonalRoomEnterResp::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:fgame.CSPersonalRoomEnterResp.Players)
  return &players_;
}

// optional uint64 LeftSeconds = 3;
inline bool CSPersonalRoomEnterResp::has_leftseconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPersonalRoomEnterResp::set_has_leftseconds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPersonalRoomEnterResp::clear_has_leftseconds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPersonalRoomEnterResp::clear_leftseconds() {
  leftseconds_ = GOOGLE_ULONGLONG(0);
  clear_has_leftseconds();
}
inline ::google::protobuf::uint64 CSPersonalRoomEnterResp::leftseconds() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomEnterResp.LeftSeconds)
  return leftseconds_;
}
inline void CSPersonalRoomEnterResp::set_leftseconds(::google::protobuf::uint64 value) {
  set_has_leftseconds();
  leftseconds_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomEnterResp.LeftSeconds)
}

// optional uint32 RoomType = 4;
inline bool CSPersonalRoomEnterResp::has_roomtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPersonalRoomEnterResp::set_has_roomtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPersonalRoomEnterResp::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPersonalRoomEnterResp::clear_roomtype() {
  roomtype_ = 0u;
  clear_has_roomtype();
}
inline ::google::protobuf::uint32 CSPersonalRoomEnterResp::roomtype() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomEnterResp.RoomType)
  return roomtype_;
}
inline void CSPersonalRoomEnterResp::set_roomtype(::google::protobuf::uint32 value) {
  set_has_roomtype();
  roomtype_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomEnterResp.RoomType)
}

// -------------------------------------------------------------------

// CSPersonalRoomLeaveReq

// required uint32 RoomID = 1;
inline bool CSPersonalRoomLeaveReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomLeaveReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomLeaveReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomLeaveReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPersonalRoomLeaveReq::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomLeaveReq.RoomID)
  return roomid_;
}
inline void CSPersonalRoomLeaveReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomLeaveReq.RoomID)
}

// -------------------------------------------------------------------

// CSPersonalRoomLeaveResp

// required uint64 Uin = 1;
inline bool CSPersonalRoomLeaveResp::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomLeaveResp::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomLeaveResp::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomLeaveResp::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPersonalRoomLeaveResp::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomLeaveResp.Uin)
  return uin_;
}
inline void CSPersonalRoomLeaveResp::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomLeaveResp.Uin)
}

// optional uint32 RoomID = 2;
inline bool CSPersonalRoomLeaveResp::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPersonalRoomLeaveResp::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPersonalRoomLeaveResp::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPersonalRoomLeaveResp::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPersonalRoomLeaveResp::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomLeaveResp.RoomID)
  return roomid_;
}
inline void CSPersonalRoomLeaveResp::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomLeaveResp.RoomID)
}

// -------------------------------------------------------------------

// CSPersonalRoomKickReq

// required uint64 Uin = 1;
inline bool CSPersonalRoomKickReq::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomKickReq::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomKickReq::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomKickReq::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPersonalRoomKickReq::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomKickReq.Uin)
  return uin_;
}
inline void CSPersonalRoomKickReq::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomKickReq.Uin)
}

// -------------------------------------------------------------------

// CSPersonalRoomKickResp

// required uint64 Uin = 1;
inline bool CSPersonalRoomKickResp::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomKickResp::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomKickResp::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomKickResp::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPersonalRoomKickResp::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomKickResp.Uin)
  return uin_;
}
inline void CSPersonalRoomKickResp::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomKickResp.Uin)
}

// -------------------------------------------------------------------

// CSPersonalRoomInviteReq

// required uint64 Uin = 1;
inline bool CSPersonalRoomInviteReq::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomInviteReq::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomInviteReq::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomInviteReq::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPersonalRoomInviteReq::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomInviteReq.Uin)
  return uin_;
}
inline void CSPersonalRoomInviteReq::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomInviteReq.Uin)
}

// -------------------------------------------------------------------

// CSPersonalRoomInviteResp

// required uint64 Uin = 1;
inline bool CSPersonalRoomInviteResp::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomInviteResp::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomInviteResp::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomInviteResp::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPersonalRoomInviteResp::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomInviteResp.Uin)
  return uin_;
}
inline void CSPersonalRoomInviteResp::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomInviteResp.Uin)
}

// optional .fgame.FriendPkRequestInfo Info = 2;
inline bool CSPersonalRoomInviteResp::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPersonalRoomInviteResp::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPersonalRoomInviteResp::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPersonalRoomInviteResp::clear_info() {
  if (info_ != NULL) info_->::fgame::FriendPkRequestInfo::Clear();
  clear_has_info();
}
inline const ::fgame::FriendPkRequestInfo& CSPersonalRoomInviteResp::info() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomInviteResp.Info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return info_ != NULL ? *info_ : *default_instance().info_;
#else
  return info_ != NULL ? *info_ : *default_instance_->info_;
#endif
}
inline ::fgame::FriendPkRequestInfo* CSPersonalRoomInviteResp::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::fgame::FriendPkRequestInfo;
  // @@protoc_insertion_point(field_mutable:fgame.CSPersonalRoomInviteResp.Info)
  return info_;
}
inline ::fgame::FriendPkRequestInfo* CSPersonalRoomInviteResp::release_info() {
  clear_has_info();
  ::fgame::FriendPkRequestInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void CSPersonalRoomInviteResp::set_allocated_info(::fgame::FriendPkRequestInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPersonalRoomInviteResp.Info)
}

// -------------------------------------------------------------------

// CSPersonalRoomBroadcastReq

// -------------------------------------------------------------------

// CSPersonalRoomBroadcastResp

// required uint64 Uin = 1;
inline bool CSPersonalRoomBroadcastResp::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomBroadcastResp::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomBroadcastResp::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomBroadcastResp::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPersonalRoomBroadcastResp::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomBroadcastResp.Uin)
  return uin_;
}
inline void CSPersonalRoomBroadcastResp::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomBroadcastResp.Uin)
}

// required string Name = 2;
inline bool CSPersonalRoomBroadcastResp::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPersonalRoomBroadcastResp::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPersonalRoomBroadcastResp::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPersonalRoomBroadcastResp::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSPersonalRoomBroadcastResp::name() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomBroadcastResp.Name)
  return *name_;
}
inline void CSPersonalRoomBroadcastResp::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomBroadcastResp.Name)
}
inline void CSPersonalRoomBroadcastResp::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPersonalRoomBroadcastResp.Name)
}
inline void CSPersonalRoomBroadcastResp::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPersonalRoomBroadcastResp.Name)
}
inline ::std::string* CSPersonalRoomBroadcastResp::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPersonalRoomBroadcastResp.Name)
  return name_;
}
inline ::std::string* CSPersonalRoomBroadcastResp::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPersonalRoomBroadcastResp::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPersonalRoomBroadcastResp.Name)
}

// required uint32 RoomID = 3;
inline bool CSPersonalRoomBroadcastResp::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPersonalRoomBroadcastResp::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPersonalRoomBroadcastResp::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPersonalRoomBroadcastResp::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPersonalRoomBroadcastResp::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomBroadcastResp.RoomID)
  return roomid_;
}
inline void CSPersonalRoomBroadcastResp::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomBroadcastResp.RoomID)
}

// required uint64 Time = 4;
inline bool CSPersonalRoomBroadcastResp::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPersonalRoomBroadcastResp::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPersonalRoomBroadcastResp::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPersonalRoomBroadcastResp::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 CSPersonalRoomBroadcastResp::time() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomBroadcastResp.Time)
  return time_;
}
inline void CSPersonalRoomBroadcastResp::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomBroadcastResp.Time)
}

// optional string Icon = 5;
inline bool CSPersonalRoomBroadcastResp::has_icon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPersonalRoomBroadcastResp::set_has_icon() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPersonalRoomBroadcastResp::clear_has_icon() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPersonalRoomBroadcastResp::clear_icon() {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& CSPersonalRoomBroadcastResp::icon() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomBroadcastResp.Icon)
  return *icon_;
}
inline void CSPersonalRoomBroadcastResp::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomBroadcastResp.Icon)
}
inline void CSPersonalRoomBroadcastResp::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPersonalRoomBroadcastResp.Icon)
}
inline void CSPersonalRoomBroadcastResp::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPersonalRoomBroadcastResp.Icon)
}
inline ::std::string* CSPersonalRoomBroadcastResp::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPersonalRoomBroadcastResp.Icon)
  return icon_;
}
inline ::std::string* CSPersonalRoomBroadcastResp::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPersonalRoomBroadcastResp::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPersonalRoomBroadcastResp.Icon)
}

// optional string ServerNode = 6;
inline bool CSPersonalRoomBroadcastResp::has_servernode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPersonalRoomBroadcastResp::set_has_servernode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPersonalRoomBroadcastResp::clear_has_servernode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPersonalRoomBroadcastResp::clear_servernode() {
  if (servernode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servernode_->clear();
  }
  clear_has_servernode();
}
inline const ::std::string& CSPersonalRoomBroadcastResp::servernode() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomBroadcastResp.ServerNode)
  return *servernode_;
}
inline void CSPersonalRoomBroadcastResp::set_servernode(const ::std::string& value) {
  set_has_servernode();
  if (servernode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servernode_ = new ::std::string;
  }
  servernode_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomBroadcastResp.ServerNode)
}
inline void CSPersonalRoomBroadcastResp::set_servernode(const char* value) {
  set_has_servernode();
  if (servernode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servernode_ = new ::std::string;
  }
  servernode_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPersonalRoomBroadcastResp.ServerNode)
}
inline void CSPersonalRoomBroadcastResp::set_servernode(const char* value, size_t size) {
  set_has_servernode();
  if (servernode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servernode_ = new ::std::string;
  }
  servernode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPersonalRoomBroadcastResp.ServerNode)
}
inline ::std::string* CSPersonalRoomBroadcastResp::mutable_servernode() {
  set_has_servernode();
  if (servernode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servernode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPersonalRoomBroadcastResp.ServerNode)
  return servernode_;
}
inline ::std::string* CSPersonalRoomBroadcastResp::release_servernode() {
  clear_has_servernode();
  if (servernode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = servernode_;
    servernode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPersonalRoomBroadcastResp::set_allocated_servernode(::std::string* servernode) {
  if (servernode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete servernode_;
  }
  if (servernode) {
    set_has_servernode();
    servernode_ = servernode;
  } else {
    clear_has_servernode();
    servernode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPersonalRoomBroadcastResp.ServerNode)
}

// optional uint32 Title = 7;
inline bool CSPersonalRoomBroadcastResp::has_title() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSPersonalRoomBroadcastResp::set_has_title() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSPersonalRoomBroadcastResp::clear_has_title() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSPersonalRoomBroadcastResp::clear_title() {
  title_ = 0u;
  clear_has_title();
}
inline ::google::protobuf::uint32 CSPersonalRoomBroadcastResp::title() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomBroadcastResp.Title)
  return title_;
}
inline void CSPersonalRoomBroadcastResp::set_title(::google::protobuf::uint32 value) {
  set_has_title();
  title_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomBroadcastResp.Title)
}

// optional uint32 VipLevel = 8;
inline bool CSPersonalRoomBroadcastResp::has_viplevel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSPersonalRoomBroadcastResp::set_has_viplevel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSPersonalRoomBroadcastResp::clear_has_viplevel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSPersonalRoomBroadcastResp::clear_viplevel() {
  viplevel_ = 0u;
  clear_has_viplevel();
}
inline ::google::protobuf::uint32 CSPersonalRoomBroadcastResp::viplevel() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomBroadcastResp.VipLevel)
  return viplevel_;
}
inline void CSPersonalRoomBroadcastResp::set_viplevel(::google::protobuf::uint32 value) {
  set_has_viplevel();
  viplevel_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomBroadcastResp.VipLevel)
}

// -------------------------------------------------------------------

// CSPersonalRoomChatReq

// required uint32 ID = 1;
inline bool CSPersonalRoomChatReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomChatReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomChatReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomChatReq::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSPersonalRoomChatReq::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomChatReq.ID)
  return id_;
}
inline void CSPersonalRoomChatReq::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomChatReq.ID)
}

// optional string Words = 2;
inline bool CSPersonalRoomChatReq::has_words() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPersonalRoomChatReq::set_has_words() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPersonalRoomChatReq::clear_has_words() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPersonalRoomChatReq::clear_words() {
  if (words_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    words_->clear();
  }
  clear_has_words();
}
inline const ::std::string& CSPersonalRoomChatReq::words() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomChatReq.Words)
  return *words_;
}
inline void CSPersonalRoomChatReq::set_words(const ::std::string& value) {
  set_has_words();
  if (words_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    words_ = new ::std::string;
  }
  words_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomChatReq.Words)
}
inline void CSPersonalRoomChatReq::set_words(const char* value) {
  set_has_words();
  if (words_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    words_ = new ::std::string;
  }
  words_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPersonalRoomChatReq.Words)
}
inline void CSPersonalRoomChatReq::set_words(const char* value, size_t size) {
  set_has_words();
  if (words_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    words_ = new ::std::string;
  }
  words_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPersonalRoomChatReq.Words)
}
inline ::std::string* CSPersonalRoomChatReq::mutable_words() {
  set_has_words();
  if (words_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    words_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPersonalRoomChatReq.Words)
  return words_;
}
inline ::std::string* CSPersonalRoomChatReq::release_words() {
  clear_has_words();
  if (words_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = words_;
    words_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPersonalRoomChatReq::set_allocated_words(::std::string* words) {
  if (words_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete words_;
  }
  if (words) {
    set_has_words();
    words_ = words;
  } else {
    clear_has_words();
    words_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPersonalRoomChatReq.Words)
}

// -------------------------------------------------------------------

// CSPersonalRoomChatResp

// required uint64 Uin = 1;
inline bool CSPersonalRoomChatResp::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomChatResp::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomChatResp::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomChatResp::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPersonalRoomChatResp::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomChatResp.Uin)
  return uin_;
}
inline void CSPersonalRoomChatResp::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomChatResp.Uin)
}

// required uint32 ID = 2;
inline bool CSPersonalRoomChatResp::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPersonalRoomChatResp::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPersonalRoomChatResp::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPersonalRoomChatResp::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSPersonalRoomChatResp::id() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomChatResp.ID)
  return id_;
}
inline void CSPersonalRoomChatResp::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomChatResp.ID)
}

// required string Words = 3;
inline bool CSPersonalRoomChatResp::has_words() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPersonalRoomChatResp::set_has_words() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPersonalRoomChatResp::clear_has_words() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPersonalRoomChatResp::clear_words() {
  if (words_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    words_->clear();
  }
  clear_has_words();
}
inline const ::std::string& CSPersonalRoomChatResp::words() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomChatResp.Words)
  return *words_;
}
inline void CSPersonalRoomChatResp::set_words(const ::std::string& value) {
  set_has_words();
  if (words_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    words_ = new ::std::string;
  }
  words_->assign(value);
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomChatResp.Words)
}
inline void CSPersonalRoomChatResp::set_words(const char* value) {
  set_has_words();
  if (words_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    words_ = new ::std::string;
  }
  words_->assign(value);
  // @@protoc_insertion_point(field_set_char:fgame.CSPersonalRoomChatResp.Words)
}
inline void CSPersonalRoomChatResp::set_words(const char* value, size_t size) {
  set_has_words();
  if (words_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    words_ = new ::std::string;
  }
  words_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fgame.CSPersonalRoomChatResp.Words)
}
inline ::std::string* CSPersonalRoomChatResp::mutable_words() {
  set_has_words();
  if (words_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    words_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fgame.CSPersonalRoomChatResp.Words)
  return words_;
}
inline ::std::string* CSPersonalRoomChatResp::release_words() {
  clear_has_words();
  if (words_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = words_;
    words_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CSPersonalRoomChatResp::set_allocated_words(::std::string* words) {
  if (words_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete words_;
  }
  if (words) {
    set_has_words();
    words_ = words;
  } else {
    clear_has_words();
    words_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fgame.CSPersonalRoomChatResp.Words)
}

// -------------------------------------------------------------------

// CSPersonalRoomModeReq

// required uint32 Mode = 1;
inline bool CSPersonalRoomModeReq::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomModeReq::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomModeReq::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomModeReq::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
inline ::google::protobuf::uint32 CSPersonalRoomModeReq::mode() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomModeReq.Mode)
  return mode_;
}
inline void CSPersonalRoomModeReq::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomModeReq.Mode)
}

// -------------------------------------------------------------------

// CSPersonalRoomModeResp

// required uint32 Mode = 1;
inline bool CSPersonalRoomModeResp::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomModeResp::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomModeResp::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomModeResp::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
inline ::google::protobuf::uint32 CSPersonalRoomModeResp::mode() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomModeResp.Mode)
  return mode_;
}
inline void CSPersonalRoomModeResp::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomModeResp.Mode)
}

// -------------------------------------------------------------------

// CSPersonalRoomBeginFightReq

// -------------------------------------------------------------------

// CSPersonalRoomBeginFightResp

// required uint32 RoomID = 1;
inline bool CSPersonalRoomBeginFightResp::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomBeginFightResp::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomBeginFightResp::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomBeginFightResp::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPersonalRoomBeginFightResp::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomBeginFightResp.RoomID)
  return roomid_;
}
inline void CSPersonalRoomBeginFightResp::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomBeginFightResp.RoomID)
}

// -------------------------------------------------------------------

// CSPersonalRoomApplyOrRefuseInviteReq

// required bool IsApply = 1;
inline bool CSPersonalRoomApplyOrRefuseInviteReq::has_isapply() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomApplyOrRefuseInviteReq::set_has_isapply() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomApplyOrRefuseInviteReq::clear_has_isapply() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomApplyOrRefuseInviteReq::clear_isapply() {
  isapply_ = false;
  clear_has_isapply();
}
inline bool CSPersonalRoomApplyOrRefuseInviteReq::isapply() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomApplyOrRefuseInviteReq.IsApply)
  return isapply_;
}
inline void CSPersonalRoomApplyOrRefuseInviteReq::set_isapply(bool value) {
  set_has_isapply();
  isapply_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomApplyOrRefuseInviteReq.IsApply)
}

// required uint32 RoomID = 2;
inline bool CSPersonalRoomApplyOrRefuseInviteReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPersonalRoomApplyOrRefuseInviteReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPersonalRoomApplyOrRefuseInviteReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPersonalRoomApplyOrRefuseInviteReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPersonalRoomApplyOrRefuseInviteReq::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomApplyOrRefuseInviteReq.RoomID)
  return roomid_;
}
inline void CSPersonalRoomApplyOrRefuseInviteReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomApplyOrRefuseInviteReq.RoomID)
}

// required uint64 Uin = 3;
inline bool CSPersonalRoomApplyOrRefuseInviteReq::has_uin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPersonalRoomApplyOrRefuseInviteReq::set_has_uin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPersonalRoomApplyOrRefuseInviteReq::clear_has_uin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPersonalRoomApplyOrRefuseInviteReq::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPersonalRoomApplyOrRefuseInviteReq::uin() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomApplyOrRefuseInviteReq.Uin)
  return uin_;
}
inline void CSPersonalRoomApplyOrRefuseInviteReq::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomApplyOrRefuseInviteReq.Uin)
}

// -------------------------------------------------------------------

// CSPersonalRoomApplyOrRefuseInviteResp

// required bool IsApply = 1;
inline bool CSPersonalRoomApplyOrRefuseInviteResp::has_isapply() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomApplyOrRefuseInviteResp::set_has_isapply() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomApplyOrRefuseInviteResp::clear_has_isapply() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomApplyOrRefuseInviteResp::clear_isapply() {
  isapply_ = false;
  clear_has_isapply();
}
inline bool CSPersonalRoomApplyOrRefuseInviteResp::isapply() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomApplyOrRefuseInviteResp.IsApply)
  return isapply_;
}
inline void CSPersonalRoomApplyOrRefuseInviteResp::set_isapply(bool value) {
  set_has_isapply();
  isapply_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomApplyOrRefuseInviteResp.IsApply)
}

// optional uint32 RoomID = 2;
inline bool CSPersonalRoomApplyOrRefuseInviteResp::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPersonalRoomApplyOrRefuseInviteResp::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPersonalRoomApplyOrRefuseInviteResp::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPersonalRoomApplyOrRefuseInviteResp::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPersonalRoomApplyOrRefuseInviteResp::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomApplyOrRefuseInviteResp.RoomID)
  return roomid_;
}
inline void CSPersonalRoomApplyOrRefuseInviteResp::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomApplyOrRefuseInviteResp.RoomID)
}

// -------------------------------------------------------------------

// CSPersonalRoomCountDownReq

// required uint32 RoomID = 1;
inline bool CSPersonalRoomCountDownReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomCountDownReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomCountDownReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomCountDownReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPersonalRoomCountDownReq::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomCountDownReq.RoomID)
  return roomid_;
}
inline void CSPersonalRoomCountDownReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomCountDownReq.RoomID)
}

// -------------------------------------------------------------------

// CSPersonalRoomCountDownResp

// required uint32 RoomID = 1;
inline bool CSPersonalRoomCountDownResp::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPersonalRoomCountDownResp::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPersonalRoomCountDownResp::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPersonalRoomCountDownResp::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CSPersonalRoomCountDownResp::roomid() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomCountDownResp.RoomID)
  return roomid_;
}
inline void CSPersonalRoomCountDownResp::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomCountDownResp.RoomID)
}

// required uint32 Seconds = 2;
inline bool CSPersonalRoomCountDownResp::has_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPersonalRoomCountDownResp::set_has_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPersonalRoomCountDownResp::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPersonalRoomCountDownResp::clear_seconds() {
  seconds_ = 0u;
  clear_has_seconds();
}
inline ::google::protobuf::uint32 CSPersonalRoomCountDownResp::seconds() const {
  // @@protoc_insertion_point(field_get:fgame.CSPersonalRoomCountDownResp.Seconds)
  return seconds_;
}
inline void CSPersonalRoomCountDownResp::set_seconds(::google::protobuf::uint32 value) {
  set_has_seconds();
  seconds_ = value;
  // @@protoc_insertion_point(field_set:fgame.CSPersonalRoomCountDownResp.Seconds)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fgame

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_PvpPersonalRoom_2eproto__INCLUDED
