// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SaveData.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "SaveData.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace fgame {

void protobuf_ShutdownFile_SaveData_2eproto() {
  delete PropItmeSaveData::default_instance_;
  delete LostPointData::default_instance_;
  delete AchieveData::default_instance_;
  delete LoginSrvInfo::default_instance_;
  delete LoginData::default_instance_;
  delete CostData::default_instance_;
  delete ActNoticeDataList::default_instance_;
  delete NewsBibleData::default_instance_;
  delete UserData::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_SaveData_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_SaveData_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  PropItmeSaveData::default_instance_ = new PropItmeSaveData();
  LostPointData::default_instance_ = new LostPointData();
  AchieveData::default_instance_ = new AchieveData();
  LoginSrvInfo::default_instance_ = new LoginSrvInfo();
  LoginData::default_instance_ = new LoginData();
  CostData::default_instance_ = new CostData();
  ActNoticeDataList::default_instance_ = new ActNoticeDataList();
  NewsBibleData::default_instance_ = new NewsBibleData();
  UserData::default_instance_ = new UserData();
  PropItmeSaveData::default_instance_->InitAsDefaultInstance();
  LostPointData::default_instance_->InitAsDefaultInstance();
  AchieveData::default_instance_->InitAsDefaultInstance();
  LoginSrvInfo::default_instance_->InitAsDefaultInstance();
  LoginData::default_instance_->InitAsDefaultInstance();
  CostData::default_instance_->InitAsDefaultInstance();
  ActNoticeDataList::default_instance_->InitAsDefaultInstance();
  NewsBibleData::default_instance_->InitAsDefaultInstance();
  UserData::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_SaveData_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_SaveData_2eproto_once_);
void protobuf_AddDesc_SaveData_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_SaveData_2eproto_once_,
                 &protobuf_AddDesc_SaveData_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_SaveData_2eproto {
  StaticDescriptorInitializer_SaveData_2eproto() {
    protobuf_AddDesc_SaveData_2eproto();
  }
} static_descriptor_initializer_SaveData_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int PropItmeSaveData::kIdFieldNumber;
const int PropItmeSaveData::kPosFieldNumber;
#endif  // !_MSC_VER

PropItmeSaveData::PropItmeSaveData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.PropItmeSaveData)
}

void PropItmeSaveData::InitAsDefaultInstance() {
}

PropItmeSaveData::PropItmeSaveData(const PropItmeSaveData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.PropItmeSaveData)
}

void PropItmeSaveData::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  pos_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PropItmeSaveData::~PropItmeSaveData() {
  // @@protoc_insertion_point(destructor:fgame.PropItmeSaveData)
  SharedDtor();
}

void PropItmeSaveData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PropItmeSaveData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PropItmeSaveData& PropItmeSaveData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_SaveData_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_SaveData_2eproto();
#endif
  return *default_instance_;
}

PropItmeSaveData* PropItmeSaveData::default_instance_ = NULL;

PropItmeSaveData* PropItmeSaveData::New() const {
  return new PropItmeSaveData;
}

void PropItmeSaveData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PropItmeSaveData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, pos_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PropItmeSaveData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.PropItmeSaveData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_pos;
        break;
      }

      // optional uint32 pos = 2;
      case 2: {
        if (tag == 16) {
         parse_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pos_)));
          set_has_pos();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.PropItmeSaveData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.PropItmeSaveData)
  return false;
#undef DO_
}

void PropItmeSaveData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.PropItmeSaveData)
  // optional uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional uint32 pos = 2;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->pos(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.PropItmeSaveData)
}

int PropItmeSaveData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional uint32 pos = 2;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pos());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PropItmeSaveData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PropItmeSaveData*>(&from));
}

void PropItmeSaveData::MergeFrom(const PropItmeSaveData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_pos()) {
      set_pos(from.pos());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PropItmeSaveData::CopyFrom(const PropItmeSaveData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PropItmeSaveData::IsInitialized() const {

  return true;
}

void PropItmeSaveData::Swap(PropItmeSaveData* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(pos_, other->pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PropItmeSaveData::GetTypeName() const {
  return "fgame.PropItmeSaveData";
}


// ===================================================================

#ifndef _MSC_VER
const int LostPointData::kIdFieldNumber;
const int LostPointData::kPassFieldNumber;
#endif  // !_MSC_VER

LostPointData::LostPointData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.LostPointData)
}

void LostPointData::InitAsDefaultInstance() {
}

LostPointData::LostPointData(const LostPointData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.LostPointData)
}

void LostPointData::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  pass_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LostPointData::~LostPointData() {
  // @@protoc_insertion_point(destructor:fgame.LostPointData)
  SharedDtor();
}

void LostPointData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LostPointData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LostPointData& LostPointData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_SaveData_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_SaveData_2eproto();
#endif
  return *default_instance_;
}

LostPointData* LostPointData::default_instance_ = NULL;

LostPointData* LostPointData::New() const {
  return new LostPointData;
}

void LostPointData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<LostPointData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, pass_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool LostPointData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.LostPointData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_pass;
        break;
      }

      // optional int32 pass = 2;
      case 2: {
        if (tag == 16) {
         parse_pass:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pass_)));
          set_has_pass();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.LostPointData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.LostPointData)
  return false;
#undef DO_
}

void LostPointData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.LostPointData)
  // optional uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional int32 pass = 2;
  if (has_pass()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->pass(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.LostPointData)
}

int LostPointData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional int32 pass = 2;
    if (has_pass()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pass());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LostPointData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LostPointData*>(&from));
}

void LostPointData::MergeFrom(const LostPointData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_pass()) {
      set_pass(from.pass());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void LostPointData::CopyFrom(const LostPointData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LostPointData::IsInitialized() const {

  return true;
}

void LostPointData::Swap(LostPointData* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(pass_, other->pass_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LostPointData::GetTypeName() const {
  return "fgame.LostPointData";
}


// ===================================================================

#ifndef _MSC_VER
const int AchieveData::kTipIdFieldNumber;
#endif  // !_MSC_VER

AchieveData::AchieveData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.AchieveData)
}

void AchieveData::InitAsDefaultInstance() {
}

AchieveData::AchieveData(const AchieveData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.AchieveData)
}

void AchieveData::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AchieveData::~AchieveData() {
  // @@protoc_insertion_point(destructor:fgame.AchieveData)
  SharedDtor();
}

void AchieveData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AchieveData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AchieveData& AchieveData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_SaveData_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_SaveData_2eproto();
#endif
  return *default_instance_;
}

AchieveData* AchieveData::default_instance_ = NULL;

AchieveData* AchieveData::New() const {
  return new AchieveData;
}

void AchieveData::Clear() {
  tipid_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool AchieveData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.AchieveData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 TipId = 1;
      case 1: {
        if (tag == 8) {
         parse_TipId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_tipid())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_tipid())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_TipId;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.AchieveData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.AchieveData)
  return false;
#undef DO_
}

void AchieveData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.AchieveData)
  // repeated uint32 TipId = 1;
  for (int i = 0; i < this->tipid_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->tipid(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.AchieveData)
}

int AchieveData::ByteSize() const {
  int total_size = 0;

  // repeated uint32 TipId = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->tipid_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->tipid(i));
    }
    total_size += 1 * this->tipid_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AchieveData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AchieveData*>(&from));
}

void AchieveData::MergeFrom(const AchieveData& from) {
  GOOGLE_CHECK_NE(&from, this);
  tipid_.MergeFrom(from.tipid_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void AchieveData::CopyFrom(const AchieveData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AchieveData::IsInitialized() const {

  return true;
}

void AchieveData::Swap(AchieveData* other) {
  if (other != this) {
    tipid_.Swap(&other->tipid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AchieveData::GetTypeName() const {
  return "fgame.AchieveData";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginSrvInfo::kChannelIdFieldNumber;
const int LoginSrvInfo::kAddressFieldNumber;
#endif  // !_MSC_VER

LoginSrvInfo::LoginSrvInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.LoginSrvInfo)
}

void LoginSrvInfo::InitAsDefaultInstance() {
}

LoginSrvInfo::LoginSrvInfo(const LoginSrvInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.LoginSrvInfo)
}

void LoginSrvInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  channelid_ = 0;
  address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginSrvInfo::~LoginSrvInfo() {
  // @@protoc_insertion_point(destructor:fgame.LoginSrvInfo)
  SharedDtor();
}

void LoginSrvInfo::SharedDtor() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginSrvInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginSrvInfo& LoginSrvInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_SaveData_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_SaveData_2eproto();
#endif
  return *default_instance_;
}

LoginSrvInfo* LoginSrvInfo::default_instance_ = NULL;

LoginSrvInfo* LoginSrvInfo::New() const {
  return new LoginSrvInfo;
}

void LoginSrvInfo::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    channelid_ = 0;
    if (has_address()) {
      if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        address_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool LoginSrvInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.LoginSrvInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ChannelId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &channelid_)));
          set_has_channelid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Address;
        break;
      }

      // required string Address = 2;
      case 2: {
        if (tag == 18) {
         parse_Address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.LoginSrvInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.LoginSrvInfo)
  return false;
#undef DO_
}

void LoginSrvInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.LoginSrvInfo)
  // required int32 ChannelId = 1;
  if (has_channelid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->channelid(), output);
  }

  // required string Address = 2;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->address(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.LoginSrvInfo)
}

int LoginSrvInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ChannelId = 1;
    if (has_channelid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->channelid());
    }

    // required string Address = 2;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginSrvInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginSrvInfo*>(&from));
}

void LoginSrvInfo::MergeFrom(const LoginSrvInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_channelid()) {
      set_channelid(from.channelid());
    }
    if (from.has_address()) {
      set_address(from.address());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void LoginSrvInfo::CopyFrom(const LoginSrvInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginSrvInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void LoginSrvInfo::Swap(LoginSrvInfo* other) {
  if (other != this) {
    std::swap(channelid_, other->channelid_);
    std::swap(address_, other->address_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginSrvInfo::GetTypeName() const {
  return "fgame.LoginSrvInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginData::kLastServerTimeFieldNumber;
const int LoginData::kGameServerNameFieldNumber;
const int LoginData::kLoginServerDirFieldNumber;
const int LoginData::kGameServerDirFieldNumber;
const int LoginData::kLoginListFieldNumber;
const int LoginData::kLoginSrvListFieldNumber;
#endif  // !_MSC_VER

LoginData::LoginData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.LoginData)
}

void LoginData::InitAsDefaultInstance() {
}

LoginData::LoginData(const LoginData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.LoginData)
}

void LoginData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  lastservertime_ = GOOGLE_ULONGLONG(0);
  gameservername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  loginserverdir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gameserverdir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginData::~LoginData() {
  // @@protoc_insertion_point(destructor:fgame.LoginData)
  SharedDtor();
}

void LoginData::SharedDtor() {
  if (gameservername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gameservername_;
  }
  if (loginserverdir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete loginserverdir_;
  }
  if (gameserverdir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gameserverdir_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginData& LoginData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_SaveData_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_SaveData_2eproto();
#endif
  return *default_instance_;
}

LoginData* LoginData::default_instance_ = NULL;

LoginData* LoginData::New() const {
  return new LoginData;
}

void LoginData::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    lastservertime_ = GOOGLE_ULONGLONG(0);
    if (has_gameservername()) {
      if (gameservername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        gameservername_->clear();
      }
    }
    if (has_loginserverdir()) {
      if (loginserverdir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        loginserverdir_->clear();
      }
    }
    if (has_gameserverdir()) {
      if (gameserverdir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        gameserverdir_->clear();
      }
    }
  }
  loginlist_.Clear();
  loginsrvlist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool LoginData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.LoginData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 LastServerTime = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &lastservertime_)));
          set_has_lastservertime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_GameServerName;
        break;
      }

      // required string GameServerName = 2;
      case 2: {
        if (tag == 18) {
         parse_GameServerName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gameservername()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_LoginServerDir;
        break;
      }

      // required string LoginServerDir = 3;
      case 3: {
        if (tag == 26) {
         parse_LoginServerDir:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_loginserverdir()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_GameServerDir;
        break;
      }

      // optional string GameServerDir = 4;
      case 4: {
        if (tag == 34) {
         parse_GameServerDir:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gameserverdir()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_LoginList;
        break;
      }

      // repeated string LoginList = 5;
      case 5: {
        if (tag == 42) {
         parse_LoginList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_loginlist()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_LoginList;
        if (input->ExpectTag(50)) goto parse_LoginSrvList;
        break;
      }

      // repeated .fgame.LoginSrvInfo LoginSrvList = 6;
      case 6: {
        if (tag == 50) {
         parse_LoginSrvList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_loginsrvlist()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_LoginSrvList;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.LoginData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.LoginData)
  return false;
#undef DO_
}

void LoginData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.LoginData)
  // required uint64 LastServerTime = 1;
  if (has_lastservertime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->lastservertime(), output);
  }

  // required string GameServerName = 2;
  if (has_gameservername()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->gameservername(), output);
  }

  // required string LoginServerDir = 3;
  if (has_loginserverdir()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->loginserverdir(), output);
  }

  // optional string GameServerDir = 4;
  if (has_gameserverdir()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->gameserverdir(), output);
  }

  // repeated string LoginList = 5;
  for (int i = 0; i < this->loginlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->loginlist(i), output);
  }

  // repeated .fgame.LoginSrvInfo LoginSrvList = 6;
  for (int i = 0; i < this->loginsrvlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->loginsrvlist(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.LoginData)
}

int LoginData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 LastServerTime = 1;
    if (has_lastservertime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->lastservertime());
    }

    // required string GameServerName = 2;
    if (has_gameservername()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->gameservername());
    }

    // required string LoginServerDir = 3;
    if (has_loginserverdir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->loginserverdir());
    }

    // optional string GameServerDir = 4;
    if (has_gameserverdir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->gameserverdir());
    }

  }
  // repeated string LoginList = 5;
  total_size += 1 * this->loginlist_size();
  for (int i = 0; i < this->loginlist_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->loginlist(i));
  }

  // repeated .fgame.LoginSrvInfo LoginSrvList = 6;
  total_size += 1 * this->loginsrvlist_size();
  for (int i = 0; i < this->loginsrvlist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->loginsrvlist(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginData*>(&from));
}

void LoginData::MergeFrom(const LoginData& from) {
  GOOGLE_CHECK_NE(&from, this);
  loginlist_.MergeFrom(from.loginlist_);
  loginsrvlist_.MergeFrom(from.loginsrvlist_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_lastservertime()) {
      set_lastservertime(from.lastservertime());
    }
    if (from.has_gameservername()) {
      set_gameservername(from.gameservername());
    }
    if (from.has_loginserverdir()) {
      set_loginserverdir(from.loginserverdir());
    }
    if (from.has_gameserverdir()) {
      set_gameserverdir(from.gameserverdir());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void LoginData::CopyFrom(const LoginData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->loginsrvlist())) return false;
  return true;
}

void LoginData::Swap(LoginData* other) {
  if (other != this) {
    std::swap(lastservertime_, other->lastservertime_);
    std::swap(gameservername_, other->gameservername_);
    std::swap(loginserverdir_, other->loginserverdir_);
    std::swap(gameserverdir_, other->gameserverdir_);
    loginlist_.Swap(&other->loginlist_);
    loginsrvlist_.Swap(&other->loginsrvlist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginData::GetTypeName() const {
  return "fgame.LoginData";
}


// ===================================================================

#ifndef _MSC_VER
const int CostData::kCostDayFieldNumber;
const int CostData::kCostMoneyFieldNumber;
const int CostData::kCostMonthFieldNumber;
const int CostData::kCostMonthMoneyFieldNumber;
#endif  // !_MSC_VER

CostData::CostData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.CostData)
}

void CostData::InitAsDefaultInstance() {
}

CostData::CostData(const CostData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.CostData)
}

void CostData::SharedCtor() {
  _cached_size_ = 0;
  costday_ = GOOGLE_ULONGLONG(0);
  costmoney_ = 0u;
  costmonth_ = GOOGLE_ULONGLONG(0);
  costmonthmoney_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CostData::~CostData() {
  // @@protoc_insertion_point(destructor:fgame.CostData)
  SharedDtor();
}

void CostData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CostData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CostData& CostData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_SaveData_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_SaveData_2eproto();
#endif
  return *default_instance_;
}

CostData* CostData::default_instance_ = NULL;

CostData* CostData::New() const {
  return new CostData;
}

void CostData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CostData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(costday_, costmonthmoney_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CostData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.CostData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 costDay = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &costday_)));
          set_has_costday();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_costMoney;
        break;
      }

      // optional uint32 costMoney = 2;
      case 2: {
        if (tag == 16) {
         parse_costMoney:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &costmoney_)));
          set_has_costmoney();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_costMonth;
        break;
      }

      // optional uint64 costMonth = 3;
      case 3: {
        if (tag == 24) {
         parse_costMonth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &costmonth_)));
          set_has_costmonth();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_costMonthMoney;
        break;
      }

      // optional uint32 costMonthMoney = 4;
      case 4: {
        if (tag == 32) {
         parse_costMonthMoney:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &costmonthmoney_)));
          set_has_costmonthmoney();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.CostData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.CostData)
  return false;
#undef DO_
}

void CostData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.CostData)
  // optional uint64 costDay = 1;
  if (has_costday()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->costday(), output);
  }

  // optional uint32 costMoney = 2;
  if (has_costmoney()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->costmoney(), output);
  }

  // optional uint64 costMonth = 3;
  if (has_costmonth()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->costmonth(), output);
  }

  // optional uint32 costMonthMoney = 4;
  if (has_costmonthmoney()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->costmonthmoney(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.CostData)
}

int CostData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 costDay = 1;
    if (has_costday()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->costday());
    }

    // optional uint32 costMoney = 2;
    if (has_costmoney()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->costmoney());
    }

    // optional uint64 costMonth = 3;
    if (has_costmonth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->costmonth());
    }

    // optional uint32 costMonthMoney = 4;
    if (has_costmonthmoney()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->costmonthmoney());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CostData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CostData*>(&from));
}

void CostData::MergeFrom(const CostData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_costday()) {
      set_costday(from.costday());
    }
    if (from.has_costmoney()) {
      set_costmoney(from.costmoney());
    }
    if (from.has_costmonth()) {
      set_costmonth(from.costmonth());
    }
    if (from.has_costmonthmoney()) {
      set_costmonthmoney(from.costmonthmoney());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CostData::CopyFrom(const CostData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CostData::IsInitialized() const {

  return true;
}

void CostData::Swap(CostData* other) {
  if (other != this) {
    std::swap(costday_, other->costday_);
    std::swap(costmoney_, other->costmoney_);
    std::swap(costmonth_, other->costmonth_);
    std::swap(costmonthmoney_, other->costmonthmoney_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CostData::GetTypeName() const {
  return "fgame.CostData";
}


// ===================================================================

#ifndef _MSC_VER
const int ActNoticeDataList::kActIdFieldNumber;
#endif  // !_MSC_VER

ActNoticeDataList::ActNoticeDataList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.ActNoticeDataList)
}

void ActNoticeDataList::InitAsDefaultInstance() {
}

ActNoticeDataList::ActNoticeDataList(const ActNoticeDataList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.ActNoticeDataList)
}

void ActNoticeDataList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ActNoticeDataList::~ActNoticeDataList() {
  // @@protoc_insertion_point(destructor:fgame.ActNoticeDataList)
  SharedDtor();
}

void ActNoticeDataList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ActNoticeDataList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ActNoticeDataList& ActNoticeDataList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_SaveData_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_SaveData_2eproto();
#endif
  return *default_instance_;
}

ActNoticeDataList* ActNoticeDataList::default_instance_ = NULL;

ActNoticeDataList* ActNoticeDataList::New() const {
  return new ActNoticeDataList;
}

void ActNoticeDataList::Clear() {
  actid_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ActNoticeDataList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.ActNoticeDataList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 ActId = 1;
      case 1: {
        if (tag == 8) {
         parse_ActId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_actid())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_actid())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_ActId;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.ActNoticeDataList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.ActNoticeDataList)
  return false;
#undef DO_
}

void ActNoticeDataList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.ActNoticeDataList)
  // repeated int32 ActId = 1;
  for (int i = 0; i < this->actid_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->actid(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.ActNoticeDataList)
}

int ActNoticeDataList::ByteSize() const {
  int total_size = 0;

  // repeated int32 ActId = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->actid_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->actid(i));
    }
    total_size += 1 * this->actid_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ActNoticeDataList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ActNoticeDataList*>(&from));
}

void ActNoticeDataList::MergeFrom(const ActNoticeDataList& from) {
  GOOGLE_CHECK_NE(&from, this);
  actid_.MergeFrom(from.actid_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ActNoticeDataList::CopyFrom(const ActNoticeDataList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActNoticeDataList::IsInitialized() const {

  return true;
}

void ActNoticeDataList::Swap(ActNoticeDataList* other) {
  if (other != this) {
    actid_.Swap(&other->actid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ActNoticeDataList::GetTypeName() const {
  return "fgame.ActNoticeDataList";
}


// ===================================================================

#ifndef _MSC_VER
const int NewsBibleData::kBibleIdFieldNumber;
const int NewsBibleData::kPassFieldNumber;
#endif  // !_MSC_VER

NewsBibleData::NewsBibleData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.NewsBibleData)
}

void NewsBibleData::InitAsDefaultInstance() {
}

NewsBibleData::NewsBibleData(const NewsBibleData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.NewsBibleData)
}

void NewsBibleData::SharedCtor() {
  _cached_size_ = 0;
  bibleid_ = 0u;
  pass_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NewsBibleData::~NewsBibleData() {
  // @@protoc_insertion_point(destructor:fgame.NewsBibleData)
  SharedDtor();
}

void NewsBibleData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NewsBibleData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NewsBibleData& NewsBibleData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_SaveData_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_SaveData_2eproto();
#endif
  return *default_instance_;
}

NewsBibleData* NewsBibleData::default_instance_ = NULL;

NewsBibleData* NewsBibleData::New() const {
  return new NewsBibleData;
}

void NewsBibleData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<NewsBibleData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(bibleid_, pass_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool NewsBibleData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.NewsBibleData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 BibleId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bibleid_)));
          set_has_bibleid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Pass;
        break;
      }

      // optional uint32 Pass = 2;
      case 2: {
        if (tag == 16) {
         parse_Pass:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pass_)));
          set_has_pass();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.NewsBibleData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.NewsBibleData)
  return false;
#undef DO_
}

void NewsBibleData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.NewsBibleData)
  // optional uint32 BibleId = 1;
  if (has_bibleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->bibleid(), output);
  }

  // optional uint32 Pass = 2;
  if (has_pass()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->pass(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.NewsBibleData)
}

int NewsBibleData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 BibleId = 1;
    if (has_bibleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bibleid());
    }

    // optional uint32 Pass = 2;
    if (has_pass()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pass());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NewsBibleData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NewsBibleData*>(&from));
}

void NewsBibleData::MergeFrom(const NewsBibleData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bibleid()) {
      set_bibleid(from.bibleid());
    }
    if (from.has_pass()) {
      set_pass(from.pass());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void NewsBibleData::CopyFrom(const NewsBibleData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewsBibleData::IsInitialized() const {

  return true;
}

void NewsBibleData::Swap(NewsBibleData* other) {
  if (other != this) {
    std::swap(bibleid_, other->bibleid_);
    std::swap(pass_, other->pass_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NewsBibleData::GetTypeName() const {
  return "fgame.NewsBibleData";
}


// ===================================================================

#ifndef _MSC_VER
const int UserData::kOpenIdFieldNumber;
const int UserData::kLastSaveFieldNumber;
const int UserData::kGoldFieldNumber;
const int UserData::kLostPointDataFieldNumber;
const int UserData::kInputIDFieldNumber;
const int UserData::kAchieveDataFieldNumber;
const int UserData::kPropItmeDataFieldNumber;
const int UserData::kLoginDataFieldNumber;
const int UserData::kMCostDataFieldNumber;
const int UserData::kVersionFieldNumber;
const int UserData::kBibleTabItemIdFieldNumber;
const int UserData::kFirstFailFieldNumber;
const int UserData::kActNoticeDataListFieldNumber;
const int UserData::kActInformTimeFieldNumber;
const int UserData::kOpenGamePassTipFieldNumber;
const int UserData::kChatBuyTipFieldNumber;
const int UserData::kChatFreeCountFieldNumber;
const int UserData::kChatTimeLeftFieldNumber;
const int UserData::kSaveLevelTipFieldNumber;
const int UserData::kBibleDataFieldNumber;
#endif  // !_MSC_VER

UserData::UserData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:fgame.UserData)
}

void UserData::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  achievedata_ = const_cast< ::fgame::AchieveData*>(
      ::fgame::AchieveData::internal_default_instance());
#else
  achievedata_ = const_cast< ::fgame::AchieveData*>(&::fgame::AchieveData::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  logindata_ = const_cast< ::fgame::LoginData*>(
      ::fgame::LoginData::internal_default_instance());
#else
  logindata_ = const_cast< ::fgame::LoginData*>(&::fgame::LoginData::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  mcostdata_ = const_cast< ::fgame::CostData*>(
      ::fgame::CostData::internal_default_instance());
#else
  mcostdata_ = const_cast< ::fgame::CostData*>(&::fgame::CostData::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  actnoticedatalist_ = const_cast< ::fgame::ActNoticeDataList*>(
      ::fgame::ActNoticeDataList::internal_default_instance());
#else
  actnoticedatalist_ = const_cast< ::fgame::ActNoticeDataList*>(&::fgame::ActNoticeDataList::default_instance());
#endif
}

UserData::UserData(const UserData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:fgame.UserData)
}

void UserData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  lastsave_ = GOOGLE_ULONGLONG(0);
  gold_ = 0u;
  inputid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  achievedata_ = NULL;
  logindata_ = NULL;
  mcostdata_ = NULL;
  version_ = 0u;
  bibletabitemid_ = 0u;
  firstfail_ = 0u;
  actnoticedatalist_ = NULL;
  actinformtime_ = GOOGLE_ULONGLONG(0);
  opengamepasstip_ = 0u;
  chatbuytip_ = 0u;
  chatfreecount_ = 0u;
  chattimeleft_ = GOOGLE_ULONGLONG(0);
  saveleveltip_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserData::~UserData() {
  // @@protoc_insertion_point(destructor:fgame.UserData)
  SharedDtor();
}

void UserData::SharedDtor() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (inputid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete inputid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete achievedata_;
    delete logindata_;
    delete mcostdata_;
    delete actnoticedatalist_;
  }
}

void UserData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserData& UserData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_SaveData_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_SaveData_2eproto();
#endif
  return *default_instance_;
}

UserData* UserData::default_instance_ = NULL;

UserData* UserData::New() const {
  return new UserData;
}

void UserData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<UserData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 183) {
    if (has_openid()) {
      if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        openid_->clear();
      }
    }
    lastsave_ = GOOGLE_ULONGLONG(0);
    gold_ = 0u;
    if (has_inputid()) {
      if (inputid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        inputid_->clear();
      }
    }
    if (has_achievedata()) {
      if (achievedata_ != NULL) achievedata_->::fgame::AchieveData::Clear();
    }
    if (has_logindata()) {
      if (logindata_ != NULL) logindata_->::fgame::LoginData::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 65280) {
    ZR_(bibletabitemid_, firstfail_);
    ZR_(actinformtime_, chatbuytip_);
    if (has_mcostdata()) {
      if (mcostdata_ != NULL) mcostdata_->::fgame::CostData::Clear();
    }
    version_ = 0u;
    if (has_actnoticedatalist()) {
      if (actnoticedatalist_ != NULL) actnoticedatalist_->::fgame::ActNoticeDataList::Clear();
    }
  }
  ZR_(chattimeleft_, saveleveltip_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  lostpointdata_.Clear();
  propitmedata_.Clear();
  bibledata_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UserData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:fgame.UserData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string OpenId = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_openid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_lastSave;
        break;
      }

      // optional uint64 lastSave = 3;
      case 3: {
        if (tag == 24) {
         parse_lastSave:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &lastsave_)));
          set_has_lastsave();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_gold;
        break;
      }

      // optional uint32 gold = 4;
      case 4: {
        if (tag == 32) {
         parse_gold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gold_)));
          set_has_gold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_lostPointData;
        break;
      }

      // repeated .fgame.LostPointData lostPointData = 13;
      case 13: {
        if (tag == 106) {
         parse_lostPointData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lostpointdata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_lostPointData;
        if (input->ExpectTag(154)) goto parse_inputID;
        break;
      }

      // optional string inputID = 19;
      case 19: {
        if (tag == 154) {
         parse_inputID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_inputid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_achieveData;
        break;
      }

      // optional .fgame.AchieveData achieveData = 20;
      case 20: {
        if (tag == 162) {
         parse_achieveData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_achievedata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(170)) goto parse_propItmeData;
        break;
      }

      // repeated .fgame.PropItmeSaveData propItmeData = 21;
      case 21: {
        if (tag == 170) {
         parse_propItmeData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_propitmedata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(170)) goto parse_propItmeData;
        if (input->ExpectTag(194)) goto parse_loginData;
        break;
      }

      // optional .fgame.LoginData loginData = 24;
      case 24: {
        if (tag == 194) {
         parse_loginData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_logindata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(202)) goto parse_mCostData;
        break;
      }

      // optional .fgame.CostData mCostData = 25;
      case 25: {
        if (tag == 202) {
         parse_mCostData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mcostdata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(216)) goto parse_version;
        break;
      }

      // optional uint32 version = 27;
      case 27: {
        if (tag == 216) {
         parse_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(224)) goto parse_bibleTabItemId;
        break;
      }

      // optional uint32 bibleTabItemId = 28;
      case 28: {
        if (tag == 224) {
         parse_bibleTabItemId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bibletabitemid_)));
          set_has_bibletabitemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(232)) goto parse_firstFail;
        break;
      }

      // optional uint32 firstFail = 29;
      case 29: {
        if (tag == 232) {
         parse_firstFail:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &firstfail_)));
          set_has_firstfail();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(242)) goto parse_actNoticeDataList;
        break;
      }

      // optional .fgame.ActNoticeDataList actNoticeDataList = 30;
      case 30: {
        if (tag == 242) {
         parse_actNoticeDataList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_actnoticedatalist()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(248)) goto parse_ActInformTime;
        break;
      }

      // optional uint64 ActInformTime = 31;
      case 31: {
        if (tag == 248) {
         parse_ActInformTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &actinformtime_)));
          set_has_actinformtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(256)) goto parse_OpenGamePassTip;
        break;
      }

      // optional uint32 OpenGamePassTip = 32;
      case 32: {
        if (tag == 256) {
         parse_OpenGamePassTip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &opengamepasstip_)));
          set_has_opengamepasstip();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(264)) goto parse_ChatBuyTip;
        break;
      }

      // optional uint32 ChatBuyTip = 33;
      case 33: {
        if (tag == 264) {
         parse_ChatBuyTip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chatbuytip_)));
          set_has_chatbuytip();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(272)) goto parse_ChatFreeCount;
        break;
      }

      // optional uint32 ChatFreeCount = 34;
      case 34: {
        if (tag == 272) {
         parse_ChatFreeCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chatfreecount_)));
          set_has_chatfreecount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(280)) goto parse_ChatTimeLeft;
        break;
      }

      // optional uint64 ChatTimeLeft = 35;
      case 35: {
        if (tag == 280) {
         parse_ChatTimeLeft:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &chattimeleft_)));
          set_has_chattimeleft();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(288)) goto parse_SaveLevelTip;
        break;
      }

      // optional uint32 SaveLevelTip = 36;
      case 36: {
        if (tag == 288) {
         parse_SaveLevelTip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &saveleveltip_)));
          set_has_saveleveltip();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(298)) goto parse_BibleData;
        break;
      }

      // repeated .fgame.NewsBibleData BibleData = 37;
      case 37: {
        if (tag == 298) {
         parse_BibleData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_bibledata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(298)) goto parse_BibleData;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fgame.UserData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fgame.UserData)
  return false;
#undef DO_
}

void UserData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fgame.UserData)
  // optional string OpenId = 1;
  if (has_openid()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->openid(), output);
  }

  // optional uint64 lastSave = 3;
  if (has_lastsave()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->lastsave(), output);
  }

  // optional uint32 gold = 4;
  if (has_gold()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->gold(), output);
  }

  // repeated .fgame.LostPointData lostPointData = 13;
  for (int i = 0; i < this->lostpointdata_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      13, this->lostpointdata(i), output);
  }

  // optional string inputID = 19;
  if (has_inputid()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      19, this->inputid(), output);
  }

  // optional .fgame.AchieveData achieveData = 20;
  if (has_achievedata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      20, this->achievedata(), output);
  }

  // repeated .fgame.PropItmeSaveData propItmeData = 21;
  for (int i = 0; i < this->propitmedata_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      21, this->propitmedata(i), output);
  }

  // optional .fgame.LoginData loginData = 24;
  if (has_logindata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      24, this->logindata(), output);
  }

  // optional .fgame.CostData mCostData = 25;
  if (has_mcostdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      25, this->mcostdata(), output);
  }

  // optional uint32 version = 27;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(27, this->version(), output);
  }

  // optional uint32 bibleTabItemId = 28;
  if (has_bibletabitemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(28, this->bibletabitemid(), output);
  }

  // optional uint32 firstFail = 29;
  if (has_firstfail()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(29, this->firstfail(), output);
  }

  // optional .fgame.ActNoticeDataList actNoticeDataList = 30;
  if (has_actnoticedatalist()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      30, this->actnoticedatalist(), output);
  }

  // optional uint64 ActInformTime = 31;
  if (has_actinformtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(31, this->actinformtime(), output);
  }

  // optional uint32 OpenGamePassTip = 32;
  if (has_opengamepasstip()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(32, this->opengamepasstip(), output);
  }

  // optional uint32 ChatBuyTip = 33;
  if (has_chatbuytip()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(33, this->chatbuytip(), output);
  }

  // optional uint32 ChatFreeCount = 34;
  if (has_chatfreecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(34, this->chatfreecount(), output);
  }

  // optional uint64 ChatTimeLeft = 35;
  if (has_chattimeleft()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(35, this->chattimeleft(), output);
  }

  // optional uint32 SaveLevelTip = 36;
  if (has_saveleveltip()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(36, this->saveleveltip(), output);
  }

  // repeated .fgame.NewsBibleData BibleData = 37;
  for (int i = 0; i < this->bibledata_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      37, this->bibledata(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:fgame.UserData)
}

int UserData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string OpenId = 1;
    if (has_openid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->openid());
    }

    // optional uint64 lastSave = 3;
    if (has_lastsave()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->lastsave());
    }

    // optional uint32 gold = 4;
    if (has_gold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gold());
    }

    // optional string inputID = 19;
    if (has_inputid()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->inputid());
    }

    // optional .fgame.AchieveData achieveData = 20;
    if (has_achievedata()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->achievedata());
    }

    // optional .fgame.LoginData loginData = 24;
    if (has_logindata()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->logindata());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .fgame.CostData mCostData = 25;
    if (has_mcostdata()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mcostdata());
    }

    // optional uint32 version = 27;
    if (has_version()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // optional uint32 bibleTabItemId = 28;
    if (has_bibletabitemid()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bibletabitemid());
    }

    // optional uint32 firstFail = 29;
    if (has_firstfail()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->firstfail());
    }

    // optional .fgame.ActNoticeDataList actNoticeDataList = 30;
    if (has_actnoticedatalist()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->actnoticedatalist());
    }

    // optional uint64 ActInformTime = 31;
    if (has_actinformtime()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->actinformtime());
    }

    // optional uint32 OpenGamePassTip = 32;
    if (has_opengamepasstip()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->opengamepasstip());
    }

    // optional uint32 ChatBuyTip = 33;
    if (has_chatbuytip()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chatbuytip());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional uint32 ChatFreeCount = 34;
    if (has_chatfreecount()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chatfreecount());
    }

    // optional uint64 ChatTimeLeft = 35;
    if (has_chattimeleft()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->chattimeleft());
    }

    // optional uint32 SaveLevelTip = 36;
    if (has_saveleveltip()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->saveleveltip());
    }

  }
  // repeated .fgame.LostPointData lostPointData = 13;
  total_size += 1 * this->lostpointdata_size();
  for (int i = 0; i < this->lostpointdata_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lostpointdata(i));
  }

  // repeated .fgame.PropItmeSaveData propItmeData = 21;
  total_size += 2 * this->propitmedata_size();
  for (int i = 0; i < this->propitmedata_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->propitmedata(i));
  }

  // repeated .fgame.NewsBibleData BibleData = 37;
  total_size += 2 * this->bibledata_size();
  for (int i = 0; i < this->bibledata_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->bibledata(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserData*>(&from));
}

void UserData::MergeFrom(const UserData& from) {
  GOOGLE_CHECK_NE(&from, this);
  lostpointdata_.MergeFrom(from.lostpointdata_);
  propitmedata_.MergeFrom(from.propitmedata_);
  bibledata_.MergeFrom(from.bibledata_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_openid()) {
      set_openid(from.openid());
    }
    if (from.has_lastsave()) {
      set_lastsave(from.lastsave());
    }
    if (from.has_gold()) {
      set_gold(from.gold());
    }
    if (from.has_inputid()) {
      set_inputid(from.inputid());
    }
    if (from.has_achievedata()) {
      mutable_achievedata()->::fgame::AchieveData::MergeFrom(from.achievedata());
    }
    if (from.has_logindata()) {
      mutable_logindata()->::fgame::LoginData::MergeFrom(from.logindata());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_mcostdata()) {
      mutable_mcostdata()->::fgame::CostData::MergeFrom(from.mcostdata());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_bibletabitemid()) {
      set_bibletabitemid(from.bibletabitemid());
    }
    if (from.has_firstfail()) {
      set_firstfail(from.firstfail());
    }
    if (from.has_actnoticedatalist()) {
      mutable_actnoticedatalist()->::fgame::ActNoticeDataList::MergeFrom(from.actnoticedatalist());
    }
    if (from.has_actinformtime()) {
      set_actinformtime(from.actinformtime());
    }
    if (from.has_opengamepasstip()) {
      set_opengamepasstip(from.opengamepasstip());
    }
    if (from.has_chatbuytip()) {
      set_chatbuytip(from.chatbuytip());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_chatfreecount()) {
      set_chatfreecount(from.chatfreecount());
    }
    if (from.has_chattimeleft()) {
      set_chattimeleft(from.chattimeleft());
    }
    if (from.has_saveleveltip()) {
      set_saveleveltip(from.saveleveltip());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UserData::CopyFrom(const UserData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserData::IsInitialized() const {

  if (has_logindata()) {
    if (!this->logindata().IsInitialized()) return false;
  }
  return true;
}

void UserData::Swap(UserData* other) {
  if (other != this) {
    std::swap(openid_, other->openid_);
    std::swap(lastsave_, other->lastsave_);
    std::swap(gold_, other->gold_);
    lostpointdata_.Swap(&other->lostpointdata_);
    std::swap(inputid_, other->inputid_);
    std::swap(achievedata_, other->achievedata_);
    propitmedata_.Swap(&other->propitmedata_);
    std::swap(logindata_, other->logindata_);
    std::swap(mcostdata_, other->mcostdata_);
    std::swap(version_, other->version_);
    std::swap(bibletabitemid_, other->bibletabitemid_);
    std::swap(firstfail_, other->firstfail_);
    std::swap(actnoticedatalist_, other->actnoticedatalist_);
    std::swap(actinformtime_, other->actinformtime_);
    std::swap(opengamepasstip_, other->opengamepasstip_);
    std::swap(chatbuytip_, other->chatbuytip_);
    std::swap(chatfreecount_, other->chatfreecount_);
    std::swap(chattimeleft_, other->chattimeleft_);
    std::swap(saveleveltip_, other->saveleveltip_);
    bibledata_.Swap(&other->bibledata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserData::GetTypeName() const {
  return "fgame.UserData";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fgame

// @@protoc_insertion_point(global_scope)
